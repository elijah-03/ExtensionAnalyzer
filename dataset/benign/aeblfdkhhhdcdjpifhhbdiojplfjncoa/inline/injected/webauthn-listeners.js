"use strict";
!function(){try{var e="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{},n=(new Error).stack;n&&(e._sentryDebugIds=e._sentryDebugIds||{},e._sentryDebugIds[n]="148e49e0-7036-5241-a040-72de6360483b")}catch(e){}}();

(() => {
var P=e=>{throw new Error("Unexpected value.")},R=()=>globalThis.crypto.getRandomValues(new Uint32Array(1))[0].toString(36),y=()=>{let e,t=new Promise(n=>{e=n});return{resolve:n=>e(n),promise:t}};var b=async e=>{if(!e)return v();if(e.aborted)return Promise.resolve({type:"aborted"});let t=y(),r=()=>{t.resolve({type:"aborted"}),e.removeEventListener("abort",r)};return e.addEventListener("abort",r),t.promise},h=e=>typeof e=="string"&&e.length>0,A=e=>e instanceof ArrayBuffer||e instanceof window.ArrayBuffer||e instanceof Int8Array||e instanceof window.Int8Array||e instanceof Uint8Array||e instanceof window.Uint8Array||e instanceof DataView||e instanceof window.DataView||e instanceof Array||e instanceof window.Array?Array.from(e instanceof ArrayBuffer||e instanceof window.ArrayBuffer?new Uint8Array(e):e):e,I=async e=>new Promise(t=>{setTimeout(()=>t({type:"timeout"}),e)}),v=async()=>new Promise(()=>{});function S(){if(typeof globalThis.exportFunction=="function")return globalThis.exportFunction}function T(){if(typeof globalThis.cloneInto=="function")return globalThis.cloneInto}function E(){if(window.wrappedJSObject)return window.wrappedJSObject}function q(e){let t=T();return t?t(e,window,{cloneFunctions:!0,wrapReflectors:!0}):e}var x=e=>({credProps:e?.credProps?{rk:e.credProps.rk}:void 0,prf:e?.prf?{enabled:e.prf.enabled,results:e.prf.results?{first:new Uint8Array(e.prf.results.first).buffer,second:e.prf.results.second?new Uint8Array(e.prf.results.second):void 0}:void 0}:void 0});function u(e){let t=T();return t?new window.Promise((r,n)=>{e.then(o=>{r(t(o,window,{cloneFunctions:!0,wrapReflectors:!0}))}).catch(o=>{n(o)})}):e}var w=class{credentials;constructor(t){this.credentials=new C(t.document,t.navigator?.credentials)}},C=class{refs;constructor(t,r){if(!r){this.refs={exists:!1};return}this.refs={browserGetRef:r.get.bind(r),browserCreateRef:r.create.bind(r),document:t,exists:!0}}isSafari(){return!1}ensureFocus(){if(!this.refs.exists||this.refs.document.hasFocus())return;let t=this.refs.document.querySelectorAll('input[autocomplete*="webauthn"]');if(t){for(let n of t)if(n.focus(),document.hasFocus())return}let r=this.refs.document.querySelectorAll('input:not([autocomplete*="webauthn"])');if(r){for(let n of r)if(n.focus(),document.hasFocus())return}console.warn("could not ensure focus")}async get(t){if(!this.refs.exists)throw new DOMException("The operation either timed out or was not allowed. See https://www.w3.org/TR/webauthn-2/#sctn-privacy-considerations-client.","NotAllowedError");return this.isSafari()&&this.ensureFocus(),this.refs.browserGetRef(t)}async create(t){if(!this.refs.exists)throw new DOMException("The operation either timed out or was not allowed. See https://www.w3.org/TR/webauthn-2/#sctn-privacy-considerations-client.","NotAllowedError");return this.isSafari()&&this.ensureFocus(),this.refs.browserCreateRef(t)}};var d=class e{source;synRequests;abortableRequests;directRequests;routes;debug;log;static opSynType="op-window-syn";static opSynAckType="op-window-syn-ack";static opAbortType="op-window-abort";static opDirectRequestType="op-window-direct-request";static opDirectResponseType="op-window-direct-response";static NoReceivingEnd="no-receiving-end";static HandlerError="uncaught-handler-error";constructor(t){this.routes=t,this.synRequests={},this.abortableRequests={},this.directRequests={},this.source=R(),this.debug=!1,this.log={error:(n,o)=>console.error(`PWM-${this.source}-${o}: ${n}`),debug:(n,o)=>{this.debug&&console.info(`PWM-${this.source}-${o}: ${n}`)}},window.addEventListener("message",n=>{if(!this.validateMessage(n.data))return;let s=n.data;if(s.source===this.source||s.destination&&s.destination!==this.source)return;let{type:i}=s,a=n.stopImmediatePropagation.bind(n);i===e.opSynType&&this.handleIncomingSyn(s,a),i===e.opSynAckType&&this.handleIncomingSynAck(s,a),i===e.opAbortType&&this.handleIncomingAbortRequest(s,a),i===e.opDirectRequestType&&this.handleIncomingDirectRequest(s,a),i===e.opDirectResponseType&&this.handleIncomingResponse(s,a)},!0)}async send(t,{body:r,signal:n}){let o=R(),s=await this.handleOutgoingSyn(o,t,n);if(s.type!=="ack")return s;let i=s.data;return(await this.handleOutgoingDirect(i.ackedById,o,t,r,n)).data}getRoutes(){return Object.keys(this.routes)}async handleOutgoingSyn(t,r,n){let o=b(n),s={msgId:t,source:this.source,type:e.opSynType,message:void 0,name:r};this.log.debug("starting request sequence",r);let i=y();this.synRequests[t]=i,window.postMessage(s),this.log.debug("starting ack race",r);let a=await Promise.race([i.promise,I(1e3),o]);if(a.type==="timeout")return this.log.debug("finished request sequence: ack timed out",r),delete this.synRequests[t],{type:e.NoReceivingEnd};if(a.type==="aborted"||n?.aborted)return this.log.debug("finished request sequence: aborted sync",r),delete this.synRequests[t],this.throwAbort(n);this.log.debug(`ack race won by: ${a.data.ackedById}`,r);let l=y();return this.directRequests[t]=l,a}handleIncomingSyn(t,r){if(!this.routes[t.name]){this.log.debug("received a request with no handler to call",t.name);return}r();let o={msgId:t.msgId,source:this.source,destination:t.source,name:t.name,type:e.opSynAckType,message:void 0};window.postMessage(o)}handleIncomingSynAck(t,r){if(typeof this.synRequests[t.msgId]>"u")return;r(),this.synRequests[t.msgId].resolve({type:"ack",data:{ackedById:t.source}}),delete this.synRequests[t.msgId]}async handleOutgoingDirect(t,r,n,o,s){let i=b(s),a=y();this.directRequests[r]=a;let l={msgId:r,source:this.source,destination:t,type:e.opDirectRequestType,message:o,name:n};this.log.debug(`sending direct request to: ${t}`,n),window.postMessage(l);let f=await Promise.race([a.promise,i]);if(delete this.directRequests[r],f.type==="aborted"){let g={...l,type:e.opAbortType};return g.reason=s?.reason,this.log.debug("notifying receiver to abort",n),window.postMessage(g),this.log.debug("finished request sequence: aborted",n),this.throwAbort(s)}return this.log.debug("finished request sequence: success",n),f}async handleIncomingDirectRequest(t,r){let n=this.routes[t.name];if(!n){this.log.error("received a request with no handler to call",t.name);return}r();let o=new AbortController;this.abortableRequests[t.msgId]=o;let s=b(o.signal),i;try{i=await Promise.race([n({body:t.message,signal:o.signal}),s])}catch(f){let g=f instanceof Error?f.message:"unknown";i={type:e.HandlerError,data:{reason:g}}}delete this.abortableRequests[t.msgId];let a=i;if(a&&a?.type==="aborted")return;let l={msgId:t.msgId,source:this.source,destination:t.source,name:t.name,type:e.opDirectResponseType,message:i};window.postMessage(l)}handleIncomingAbortRequest(t,r){if(typeof this.abortableRequests[t.msgId]>"u"){this.log.debug(`received abort ${t.msgId} for no active request - likely already completed`,t.name);return}r(),this.abortableRequests[t.msgId].abort(t.reason),delete this.abortableRequests[t.msgId]}handleIncomingResponse(t,r){if(typeof this.directRequests[t.msgId]>"u"){this.log.debug(`received response ${t.msgId} with no promise to resolve - likely already aborted`,t.name);return}r(),this.directRequests[t.msgId].resolve({type:"completed",data:t.message}),delete this.directRequests[t.msgId]}throwAbort(t){throw t?.reason?new DOMException(`${t.reason}`,"AbortError"):new DOMException("signal is aborted without reason","AbortError")}validateMessage(t){let r="validate";if(typeof t!="object"||t===null)return this.log.debug("invalid message - not an object",r),!1;let n=t;return h(n.msgId)?h(n.source)?h(n.name)?n.type!==e.opSynType&&n.type!==e.opSynAckType&&n.type!==e.opAbortType&&n.type!==e.opDirectRequestType&&n.type!==e.opDirectResponseType?(this.log.debug("invalid message: type unsupported",r),!1):!0:(this.log.debug("invalid message - missing name",r),!1):(this.log.debug("invalid message - missing source",r),!1):(this.log.debug("invalid message - missing msgId",r),!1)}};var k=window.PublicKeyCredential?.isConditionalMediationAvailable?.bind(window.PublicKeyCredential),M=window.PublicKeyCredential?.isUserVerifyingPlatformAuthenticatorAvailable?.bind(window.PublicKeyCredential),F=window.PublicKeyCredential?.getClientCapabilities?.bind(window.PublicKeyCredential),c=new w(window),B,j=new Promise(e=>{let t=()=>{B=!0,e(void 0)};window.document.prerendering?document.addEventListener("prerenderingchange",t):t()}),G=async e=>{let t={...e};delete t?.signal,t.mediation==="conditional"&&t.publicKey?.timeout&&(t.publicKey.timeout=void 0);let r={type:"get-credential-request",data:JSON.stringify(t,(o,s)=>A(s))},n=await O.send("get-credential",{body:r});if(n.type===d.NoReceivingEnd||n.type===d.HandlerError)return c.credentials.get(e);if(n.type==="get-credential-error"){if(n.data.reason==="timeout")throw new DOMException("The operation either timed out or was not allowed. See https://www.w3.org/TR/webauthn-2/#sctn-privacy-considerations-client.","NotAllowedError");if(t.mediation==="conditional"&&n.data.reason==="user-cancelled")return v();if(t.mediation==="conditional"&&n.data.reason==="fallback-requested"){let o={...e};return delete o.mediation,c.credentials.get(o)}return n.data.reason==="user-cancelled"?null:(n.data.reason==="fallback-requested"||n.data.reason==="internal-error"||n.data.reason==="invalid-request"||P(n.data.reason),c.credentials.get(e))}return V(n)},V=({data:e})=>{let t={clientDataJSON:new Uint8Array(e.response.clientDataJSON).buffer,authenticatorData:new Uint8Array(e.response.authenticatorData).buffer,signature:new Uint8Array(e.response.signature).buffer,userHandle:e.response.userHandle?new Uint8Array(e.response.userHandle).buffer:null};Object.setPrototypeOf(t,AuthenticatorAssertionResponse.prototype);let r={id:e.id,rawId:new Uint8Array(e.rawId).buffer,type:e.type,authenticatorAttachment:e.authenticatorAttachment??null,response:t,getClientExtensionResults:()=>q(x(e.clientExtensionResults))};return Object.setPrototypeOf(r,PublicKeyCredential.prototype),r},$=async e=>{let t={...e};delete t?.signal;let r={type:"create-credential-request",data:JSON.stringify(t,(o,s)=>A(s))},n=await O.send("create-credential",{body:r});if(n.type===d.NoReceivingEnd||n.type===d.HandlerError)return c.credentials.create(e);if(n.type==="create-credential-error"){if(n.data.reason==="timeout")throw new DOMException("The operation either timed out or was not allowed. See https://www.w3.org/TR/webauthn-2/#sctn-privacy-considerations-client.","NotAllowedError");if(n.data.reason==="duplicate")throw new DOMException("The user attempted to register an authenticator that contains one of the credentials already registered with the relying party.","InvalidStateError");return n.data.reason==="user-cancelled"?null:(n.data.reason==="fallback-requested"||n.data.reason==="internal-error"||n.data.reason==="invalid-request"||P(n.data.reason),c.credentials.create(e))}return J(n)},J=({data:e})=>{let t={attestationObject:new Uint8Array(e.response.attestationObject).buffer,clientDataJSON:new Uint8Array(e.response.clientDataJSON).buffer,getTransports:()=>e.response.transports??[],getAuthenticatorData:()=>new Uint8Array(e.response.authenticatorData??[]).buffer,getPublicKey:()=>e.response.publicKey?new Uint8Array(e.response.publicKey).buffer:null,getPublicKeyAlgorithm:()=>e.response.publicKeyAlgorithm};Object.setPrototypeOf(t,AuthenticatorAttestationResponse.prototype);let r={id:e.id,rawId:new Uint8Array(e.rawId).buffer,type:e.type,authenticatorAttachment:e.authenticatorAttachment??null,response:t,getClientExtensionResults:()=>q(x(e.clientExtensionResults))};return Object.setPrototypeOf(r,PublicKeyCredential.prototype),r},m,L=async()=>{let e={type:"should-intercept-webauthn-request",data:void 0},t=await O.send("should-intercept-webauthn",{body:e});return t.type===d.NoReceivingEnd||t.type===d.HandlerError||t.type==="should-intercept-webauthn-error"?!1:t.data},z=async e=>(typeof e.body.authenticatePasskeys<"u"&&(m=e.body.authenticatePasskeys),Promise.resolve()),O=new d({"update-settings":z}),p=async()=>(typeof B>"u"&&await j,typeof m>"u"&&(m=await L()),m);async function D(e){return await p()?$(e):c.credentials.create(e)}async function W(e){return await p()?G(e):c.credentials.get(e)}async function N(){return await p()?!0:k?k():!1}async function H(){return await p()?!0:M?M():!1}async function U(){return await p()?{conditionalCreate:!1,conditionalGet:!0,hybridTransport:!0,passkeyPlatformAuthenticator:!0,userVerifyingPlatformAuthenticator:!0,relatedOrigins:!0,signalAllAcceptedCredentials:!1,signalCurrentUserDetails:!1,signalUnknownCredential:!1,"extension:credProps":!0,"extension:prf":!0}:F()}var K=()=>{let e=S();e?(e(t=>u(D(t)),window.navigator.credentials,{defineAs:"create"}),e(t=>u(W(t)),window.navigator.credentials,{defineAs:"get"}),e(()=>u(N()),window.PublicKeyCredential,{defineAs:"isConditionalMediationAvailable"}),e(()=>u(H()),window.PublicKeyCredential,{defineAs:"isUserVerifyingPlatformAuthenticatorAvailable"}),e(()=>u(U()),window.PublicKeyCredential,{defineAs:"getClientCapabilities"})):(window.navigator.credentials.create=D,window.navigator.credentials.get=W,window.PublicKeyCredential.isConditionalMediationAvailable=N,window.PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable=H,window.PublicKeyCredential.getClientCapabilities=U)},Q=()=>{if(window.navigator.credentials.create.length>0&&window.navigator.credentials.get.length>0)return;let e=E();e&&e.navigator.credentials.create.length>0&&e.navigator.credentials.get.length>0||K()};function X(){window.navigator.credentials&&(p(),K(),setInterval(Q,100))}X();
})();

//# debugId=148e49e0-7036-5241-a040-72de6360483b
