/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 3587:
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * jQuery Validation Plugin v1.20.0
 *
 * https://jqueryvalidation.org/
 *
 * Copyright (c) 2023 JÃ¶rn Zaefferer
 * Released under the MIT license
 */
(function( factory ) {
	if ( true ) {
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(9755)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {}
}(function( $ ) {

$.extend( $.fn, {

	// https://jqueryvalidation.org/validate/
	validate: function( options ) {

		// If nothing is selected, return nothing; can't chain anyway
		if ( !this.length ) {
			if ( options && options.debug && window.console ) {
				console.warn( "Nothing selected, can't validate, returning nothing." );
			}
			return;
		}

		// Check if a validator for this form was already created
		var validator = $.data( this[ 0 ], "validator" );
		if ( validator ) {
			return validator;
		}

		// Add novalidate tag if HTML5.
		this.attr( "novalidate", "novalidate" );

		validator = new $.validator( options, this[ 0 ] );
		$.data( this[ 0 ], "validator", validator );

		if ( validator.settings.onsubmit ) {

			this.on( "click.validate", ":submit", function( event ) {

				// Track the used submit button to properly handle scripted
				// submits later.
				validator.submitButton = event.currentTarget;

				// Allow suppressing validation by adding a cancel class to the submit button
				if ( $( this ).hasClass( "cancel" ) ) {
					validator.cancelSubmit = true;
				}

				// Allow suppressing validation by adding the html5 formnovalidate attribute to the submit button
				if ( $( this ).attr( "formnovalidate" ) !== undefined ) {
					validator.cancelSubmit = true;
				}
			} );

			// Validate the form on submit
			this.on( "submit.validate", function( event ) {
				if ( validator.settings.debug ) {

					// Prevent form submit to be able to see console output
					event.preventDefault();
				}

				function handle() {
					var hidden, result;

					// Insert a hidden input as a replacement for the missing submit button
					// The hidden input is inserted in two cases:
					//   - A user defined a `submitHandler`
					//   - There was a pending request due to `remote` method and `stopRequest()`
					//     was called to submit the form in case it's valid
					if ( validator.submitButton && ( validator.settings.submitHandler || validator.formSubmitted ) ) {
						hidden = $( "<input type='hidden'/>" )
							.attr( "name", validator.submitButton.name )
							.val( $( validator.submitButton ).val() )
							.appendTo( validator.currentForm );
					}

					if ( validator.settings.submitHandler && !validator.settings.debug ) {
						result = validator.settings.submitHandler.call( validator, validator.currentForm, event );
						if ( hidden ) {

							// And clean up afterwards; thanks to no-block-scope, hidden can be referenced
							hidden.remove();
						}
						if ( result !== undefined ) {
							return result;
						}
						return false;
					}
					return true;
				}

				// Prevent submit for invalid forms or custom submit handlers
				if ( validator.cancelSubmit ) {
					validator.cancelSubmit = false;
					return handle();
				}
				if ( validator.form() ) {
					if ( validator.pendingRequest ) {
						validator.formSubmitted = true;
						return false;
					}
					return handle();
				} else {
					validator.focusInvalid();
					return false;
				}
			} );
		}

		return validator;
	},

	// https://jqueryvalidation.org/valid/
	valid: function() {
		var valid, validator, errorList;

		if ( $( this[ 0 ] ).is( "form" ) ) {
			valid = this.validate().form();
		} else {
			errorList = [];
			valid = true;
			validator = $( this[ 0 ].form ).validate();
			this.each( function() {
				valid = validator.element( this ) && valid;
				if ( !valid ) {
					errorList = errorList.concat( validator.errorList );
				}
			} );
			validator.errorList = errorList;
		}
		return valid;
	},

	// https://jqueryvalidation.org/rules/
	rules: function( command, argument ) {
		var element = this[ 0 ],
			isContentEditable = typeof this.attr( "contenteditable" ) !== "undefined" && this.attr( "contenteditable" ) !== "false",
			settings, staticRules, existingRules, data, param, filtered;

		// If nothing is selected, return empty object; can't chain anyway
		if ( element == null ) {
			return;
		}

		if ( !element.form && isContentEditable ) {
			element.form = this.closest( "form" )[ 0 ];
			element.name = this.attr( "name" );
		}

		if ( element.form == null ) {
			return;
		}

		if ( command ) {
			settings = $.data( element.form, "validator" ).settings;
			staticRules = settings.rules;
			existingRules = $.validator.staticRules( element );
			switch ( command ) {
			case "add":
				$.extend( existingRules, $.validator.normalizeRule( argument ) );

				// Remove messages from rules, but allow them to be set separately
				delete existingRules.messages;
				staticRules[ element.name ] = existingRules;
				if ( argument.messages ) {
					settings.messages[ element.name ] = $.extend( settings.messages[ element.name ], argument.messages );
				}
				break;
			case "remove":
				if ( !argument ) {
					delete staticRules[ element.name ];
					return existingRules;
				}
				filtered = {};
				$.each( argument.split( /\s/ ), function( index, method ) {
					filtered[ method ] = existingRules[ method ];
					delete existingRules[ method ];
				} );
				return filtered;
			}
		}

		data = $.validator.normalizeRules(
		$.extend(
			{},
			$.validator.classRules( element ),
			$.validator.attributeRules( element ),
			$.validator.dataRules( element ),
			$.validator.staticRules( element )
		), element );

		// Make sure required is at front
		if ( data.required ) {
			param = data.required;
			delete data.required;
			data = $.extend( { required: param }, data );
		}

		// Make sure remote is at back
		if ( data.remote ) {
			param = data.remote;
			delete data.remote;
			data = $.extend( data, { remote: param } );
		}

		return data;
	}
} );

// JQuery trim is deprecated, provide a trim method based on String.prototype.trim
var trim = function( str ) {

	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/trim#Polyfill
	return str.replace( /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "" );
};

// Custom selectors
$.extend( $.expr.pseudos || $.expr[ ":" ], {		// '|| $.expr[ ":" ]' here enables backwards compatibility to jQuery 1.7. Can be removed when dropping jQ 1.7.x support

	// https://jqueryvalidation.org/blank-selector/
	blank: function( a ) {
		return !trim( "" + $( a ).val() );
	},

	// https://jqueryvalidation.org/filled-selector/
	filled: function( a ) {
		var val = $( a ).val();
		return val !== null && !!trim( "" + val );
	},

	// https://jqueryvalidation.org/unchecked-selector/
	unchecked: function( a ) {
		return !$( a ).prop( "checked" );
	}
} );

// Constructor for validator
$.validator = function( options, form ) {
	this.settings = $.extend( true, {}, $.validator.defaults, options );
	this.currentForm = form;
	this.init();
};

// https://jqueryvalidation.org/jQuery.validator.format/
$.validator.format = function( source, params ) {
	if ( arguments.length === 1 ) {
		return function() {
			var args = $.makeArray( arguments );
			args.unshift( source );
			return $.validator.format.apply( this, args );
		};
	}
	if ( params === undefined ) {
		return source;
	}
	if ( arguments.length > 2 && params.constructor !== Array  ) {
		params = $.makeArray( arguments ).slice( 1 );
	}
	if ( params.constructor !== Array ) {
		params = [ params ];
	}
	$.each( params, function( i, n ) {
		source = source.replace( new RegExp( "\\{" + i + "\\}", "g" ), function() {
			return n;
		} );
	} );
	return source;
};

$.extend( $.validator, {

	defaults: {
		messages: {},
		groups: {},
		rules: {},
		errorClass: "error",
		pendingClass: "pending",
		validClass: "valid",
		errorElement: "label",
		focusCleanup: false,
		focusInvalid: true,
		errorContainer: $( [] ),
		errorLabelContainer: $( [] ),
		onsubmit: true,
		ignore: ":hidden",
		ignoreTitle: false,
		onfocusin: function( element ) {
			this.lastActive = element;

			// Hide error label and remove error class on focus if enabled
			if ( this.settings.focusCleanup ) {
				if ( this.settings.unhighlight ) {
					this.settings.unhighlight.call( this, element, this.settings.errorClass, this.settings.validClass );
				}
				this.hideThese( this.errorsFor( element ) );
			}
		},
		onfocusout: function( element ) {
			if ( !this.checkable( element ) && ( element.name in this.submitted || !this.optional( element ) ) ) {
				this.element( element );
			}
		},
		onkeyup: function( element, event ) {

			// Avoid revalidate the field when pressing one of the following keys
			// Shift       => 16
			// Ctrl        => 17
			// Alt         => 18
			// Caps lock   => 20
			// End         => 35
			// Home        => 36
			// Left arrow  => 37
			// Up arrow    => 38
			// Right arrow => 39
			// Down arrow  => 40
			// Insert      => 45
			// Num lock    => 144
			// AltGr key   => 225
			var excludedKeys = [
				16, 17, 18, 20, 35, 36, 37,
				38, 39, 40, 45, 144, 225
			];

			if ( event.which === 9 && this.elementValue( element ) === "" || $.inArray( event.keyCode, excludedKeys ) !== -1 ) {
				return;
			} else if ( element.name in this.submitted || element.name in this.invalid ) {
				this.element( element );
			}
		},
		onclick: function( element ) {

			// Click on selects, radiobuttons and checkboxes
			if ( element.name in this.submitted ) {
				this.element( element );

			// Or option elements, check parent select in that case
			} else if ( element.parentNode.name in this.submitted ) {
				this.element( element.parentNode );
			}
		},
		highlight: function( element, errorClass, validClass ) {
			if ( element.type === "radio" ) {
				this.findByName( element.name ).addClass( errorClass ).removeClass( validClass );
			} else {
				$( element ).addClass( errorClass ).removeClass( validClass );
			}
		},
		unhighlight: function( element, errorClass, validClass ) {
			if ( element.type === "radio" ) {
				this.findByName( element.name ).removeClass( errorClass ).addClass( validClass );
			} else {
				$( element ).removeClass( errorClass ).addClass( validClass );
			}
		}
	},

	// https://jqueryvalidation.org/jQuery.validator.setDefaults/
	setDefaults: function( settings ) {
		$.extend( $.validator.defaults, settings );
	},

	messages: {
		required: "This field is required.",
		remote: "Please fix this field.",
		email: "Please enter a valid email address.",
		url: "Please enter a valid URL.",
		date: "Please enter a valid date.",
		dateISO: "Please enter a valid date (ISO).",
		number: "Please enter a valid number.",
		digits: "Please enter only digits.",
		equalTo: "Please enter the same value again.",
		maxlength: $.validator.format( "Please enter no more than {0} characters." ),
		minlength: $.validator.format( "Please enter at least {0} characters." ),
		rangelength: $.validator.format( "Please enter a value between {0} and {1} characters long." ),
		range: $.validator.format( "Please enter a value between {0} and {1}." ),
		max: $.validator.format( "Please enter a value less than or equal to {0}." ),
		min: $.validator.format( "Please enter a value greater than or equal to {0}." ),
		step: $.validator.format( "Please enter a multiple of {0}." )
	},

	autoCreateRanges: false,

	prototype: {

		init: function() {
			this.labelContainer = $( this.settings.errorLabelContainer );
			this.errorContext = this.labelContainer.length && this.labelContainer || $( this.currentForm );
			this.containers = $( this.settings.errorContainer ).add( this.settings.errorLabelContainer );
			this.submitted = {};
			this.valueCache = {};
			this.pendingRequest = 0;
			this.pending = {};
			this.invalid = {};
			this.reset();

			var currentForm = this.currentForm,
				groups = ( this.groups = {} ),
				rules;
			$.each( this.settings.groups, function( key, value ) {
				if ( typeof value === "string" ) {
					value = value.split( /\s/ );
				}
				$.each( value, function( index, name ) {
					groups[ name ] = key;
				} );
			} );
			rules = this.settings.rules;
			$.each( rules, function( key, value ) {
				rules[ key ] = $.validator.normalizeRule( value );
			} );

			function delegate( event ) {
				var isContentEditable = typeof $( this ).attr( "contenteditable" ) !== "undefined" && $( this ).attr( "contenteditable" ) !== "false";

				// Set form expando on contenteditable
				if ( !this.form && isContentEditable ) {
					this.form = $( this ).closest( "form" )[ 0 ];
					this.name = $( this ).attr( "name" );
				}

				// Ignore the element if it belongs to another form. This will happen mainly
				// when setting the `form` attribute of an input to the id of another form.
				if ( currentForm !== this.form ) {
					return;
				}

				var validator = $.data( this.form, "validator" ),
					eventType = "on" + event.type.replace( /^validate/, "" ),
					settings = validator.settings;
				if ( settings[ eventType ] && !$( this ).is( settings.ignore ) ) {
					settings[ eventType ].call( validator, this, event );
				}
			}

			$( this.currentForm )
				.on( "focusin.validate focusout.validate keyup.validate",
					":text, [type='password'], [type='file'], select, textarea, [type='number'], [type='search'], " +
					"[type='tel'], [type='url'], [type='email'], [type='datetime'], [type='date'], [type='month'], " +
					"[type='week'], [type='time'], [type='datetime-local'], [type='range'], [type='color'], " +
					"[type='radio'], [type='checkbox'], [contenteditable], [type='button']", delegate )

				// Support: Chrome, oldIE
				// "select" is provided as event.target when clicking a option
				.on( "click.validate", "select, option, [type='radio'], [type='checkbox']", delegate );

			if ( this.settings.invalidHandler ) {
				$( this.currentForm ).on( "invalid-form.validate", this.settings.invalidHandler );
			}
		},

		// https://jqueryvalidation.org/Validator.form/
		form: function() {
			this.checkForm();
			$.extend( this.submitted, this.errorMap );
			this.invalid = $.extend( {}, this.errorMap );
			if ( !this.valid() ) {
				$( this.currentForm ).triggerHandler( "invalid-form", [ this ] );
			}
			this.showErrors();
			return this.valid();
		},

		checkForm: function() {
			this.prepareForm();
			for ( var i = 0, elements = ( this.currentElements = this.elements() ); elements[ i ]; i++ ) {
				this.check( elements[ i ] );
			}
			return this.valid();
		},

		// https://jqueryvalidation.org/Validator.element/
		element: function( element ) {
			var cleanElement = this.clean( element ),
				checkElement = this.validationTargetFor( cleanElement ),
				v = this,
				result = true,
				rs, group;

			if ( checkElement === undefined ) {
				delete this.invalid[ cleanElement.name ];
			} else {
				this.prepareElement( checkElement );
				this.currentElements = $( checkElement );

				// If this element is grouped, then validate all group elements already
				// containing a value
				group = this.groups[ checkElement.name ];
				if ( group ) {
					$.each( this.groups, function( name, testgroup ) {
						if ( testgroup === group && name !== checkElement.name ) {
							cleanElement = v.validationTargetFor( v.clean( v.findByName( name ) ) );
							if ( cleanElement && cleanElement.name in v.invalid ) {
								v.currentElements.push( cleanElement );
								result = v.check( cleanElement ) && result;
							}
						}
					} );
				}

				rs = this.check( checkElement ) !== false;
				result = result && rs;
				if ( rs ) {
					this.invalid[ checkElement.name ] = false;
				} else {
					this.invalid[ checkElement.name ] = true;
				}

				if ( !this.numberOfInvalids() ) {

					// Hide error containers on last error
					this.toHide = this.toHide.add( this.containers );
				}
				this.showErrors();

				// Add aria-invalid status for screen readers
				$( element ).attr( "aria-invalid", !rs );
			}

			return result;
		},

		// https://jqueryvalidation.org/Validator.showErrors/
		showErrors: function( errors ) {
			if ( errors ) {
				var validator = this;

				// Add items to error list and map
				$.extend( this.errorMap, errors );
				this.errorList = $.map( this.errorMap, function( message, name ) {
					return {
						message: message,
						element: validator.findByName( name )[ 0 ]
					};
				} );

				// Remove items from success list
				this.successList = $.grep( this.successList, function( element ) {
					return !( element.name in errors );
				} );
			}
			if ( this.settings.showErrors ) {
				this.settings.showErrors.call( this, this.errorMap, this.errorList );
			} else {
				this.defaultShowErrors();
			}
		},

		// https://jqueryvalidation.org/Validator.resetForm/
		resetForm: function() {
			if ( $.fn.resetForm ) {
				$( this.currentForm ).resetForm();
			}
			this.invalid = {};
			this.submitted = {};
			this.prepareForm();
			this.hideErrors();
			var elements = this.elements()
				.removeData( "previousValue" )
				.removeAttr( "aria-invalid" );

			this.resetElements( elements );
		},

		resetElements: function( elements ) {
			var i;

			if ( this.settings.unhighlight ) {
				for ( i = 0; elements[ i ]; i++ ) {
					this.settings.unhighlight.call( this, elements[ i ],
						this.settings.errorClass, "" );
					this.findByName( elements[ i ].name ).removeClass( this.settings.validClass );
				}
			} else {
				elements
					.removeClass( this.settings.errorClass )
					.removeClass( this.settings.validClass );
			}
		},

		numberOfInvalids: function() {
			return this.objectLength( this.invalid );
		},

		objectLength: function( obj ) {
			/* jshint unused: false */
			var count = 0,
				i;
			for ( i in obj ) {

				// This check allows counting elements with empty error
				// message as invalid elements
				if ( obj[ i ] !== undefined && obj[ i ] !== null && obj[ i ] !== false ) {
					count++;
				}
			}
			return count;
		},

		hideErrors: function() {
			this.hideThese( this.toHide );
		},

		hideThese: function( errors ) {
			errors.not( this.containers ).text( "" );
			this.addWrapper( errors ).hide();
		},

		valid: function() {
			return this.size() === 0;
		},

		size: function() {
			return this.errorList.length;
		},

		focusInvalid: function() {
			if ( this.settings.focusInvalid ) {
				try {
					$( this.findLastActive() || this.errorList.length && this.errorList[ 0 ].element || [] )
					.filter( ":visible" )
					.trigger( "focus" )

					// Manually trigger focusin event; without it, focusin handler isn't called, findLastActive won't have anything to find
					.trigger( "focusin" );
				} catch ( e ) {

					// Ignore IE throwing errors when focusing hidden elements
				}
			}
		},

		findLastActive: function() {
			var lastActive = this.lastActive;
			return lastActive && $.grep( this.errorList, function( n ) {
				return n.element.name === lastActive.name;
			} ).length === 1 && lastActive;
		},

		elements: function() {
			var validator = this,
				rulesCache = {};

			// Select all valid inputs inside the form (no submit or reset buttons)
			return $( this.currentForm )
			.find( "input, select, textarea, [contenteditable]" )
			.not( ":submit, :reset, :image, :disabled" )
			.not( this.settings.ignore )
			.filter( function() {
				var name = this.name || $( this ).attr( "name" ); // For contenteditable
				var isContentEditable = typeof $( this ).attr( "contenteditable" ) !== "undefined" && $( this ).attr( "contenteditable" ) !== "false";

				if ( !name && validator.settings.debug && window.console ) {
					console.error( "%o has no name assigned", this );
				}

				// Set form expando on contenteditable
				if ( isContentEditable ) {
					this.form = $( this ).closest( "form" )[ 0 ];
					this.name = name;
				}

				// Ignore elements that belong to other/nested forms
				if ( this.form !== validator.currentForm ) {
					return false;
				}

				// Select only the first element for each name, and only those with rules specified
				if ( name in rulesCache || !validator.objectLength( $( this ).rules() ) ) {
					return false;
				}

				rulesCache[ name ] = true;
				return true;
			} );
		},

		clean: function( selector ) {
			return $( selector )[ 0 ];
		},

		errors: function() {
			var errorClass = this.settings.errorClass.split( " " ).join( "." );
			return $( this.settings.errorElement + "." + errorClass, this.errorContext );
		},

		resetInternals: function() {
			this.successList = [];
			this.errorList = [];
			this.errorMap = {};
			this.toShow = $( [] );
			this.toHide = $( [] );
		},

		reset: function() {
			this.resetInternals();
			this.currentElements = $( [] );
		},

		prepareForm: function() {
			this.reset();
			this.toHide = this.errors().add( this.containers );
		},

		prepareElement: function( element ) {
			this.reset();
			this.toHide = this.errorsFor( element );
		},

		elementValue: function( element ) {
			var $element = $( element ),
				type = element.type,
				isContentEditable = typeof $element.attr( "contenteditable" ) !== "undefined" && $element.attr( "contenteditable" ) !== "false",
				val, idx;

			if ( type === "radio" || type === "checkbox" ) {
				return this.findByName( element.name ).filter( ":checked" ).val();
			} else if ( type === "number" && typeof element.validity !== "undefined" ) {
				return element.validity.badInput ? "NaN" : $element.val();
			}

			if ( isContentEditable ) {
				val = $element.text();
			} else {
				val = $element.val();
			}

			if ( type === "file" ) {

				// Modern browser (chrome & safari)
				if ( val.substr( 0, 12 ) === "C:\\fakepath\\" ) {
					return val.substr( 12 );
				}

				// Legacy browsers
				// Unix-based path
				idx = val.lastIndexOf( "/" );
				if ( idx >= 0 ) {
					return val.substr( idx + 1 );
				}

				// Windows-based path
				idx = val.lastIndexOf( "\\" );
				if ( idx >= 0 ) {
					return val.substr( idx + 1 );
				}

				// Just the file name
				return val;
			}

			if ( typeof val === "string" ) {
				return val.replace( /\r/g, "" );
			}
			return val;
		},

		check: function( element ) {
			element = this.validationTargetFor( this.clean( element ) );

			var rules = $( element ).rules(),
				rulesCount = $.map( rules, function( n, i ) {
					return i;
				} ).length,
				dependencyMismatch = false,
				val = this.elementValue( element ),
				result, method, rule, normalizer;

			// Abort any pending Ajax request from a previous call to this method.
			this.abortRequest( element );

			// Prioritize the local normalizer defined for this element over the global one
			// if the former exists, otherwise user the global one in case it exists.
			if ( typeof rules.normalizer === "function" ) {
				normalizer = rules.normalizer;
			} else if (	typeof this.settings.normalizer === "function" ) {
				normalizer = this.settings.normalizer;
			}

			// If normalizer is defined, then call it to retreive the changed value instead
			// of using the real one.
			// Note that `this` in the normalizer is `element`.
			if ( normalizer ) {
				val = normalizer.call( element, val );

				// Delete the normalizer from rules to avoid treating it as a pre-defined method.
				delete rules.normalizer;
			}

			for ( method in rules ) {
				rule = { method: method, parameters: rules[ method ] };
				try {
					result = $.validator.methods[ method ].call( this, val, element, rule.parameters );

					// If a method indicates that the field is optional and therefore valid,
					// don't mark it as valid when there are no other rules
					if ( result === "dependency-mismatch" && rulesCount === 1 ) {
						dependencyMismatch = true;
						continue;
					}
					dependencyMismatch = false;

					if ( result === "pending" ) {
						this.toHide = this.toHide.not( this.errorsFor( element ) );
						return;
					}

					if ( !result ) {
						this.formatAndAdd( element, rule );
						return false;
					}
				} catch ( e ) {
					if ( this.settings.debug && window.console ) {
						console.log( "Exception occurred when checking element " + element.id + ", check the '" + rule.method + "' method.", e );
					}
					if ( e instanceof TypeError ) {
						e.message += ".  Exception occurred when checking element " + element.id + ", check the '" + rule.method + "' method.";
					}

					throw e;
				}
			}
			if ( dependencyMismatch ) {
				return;
			}
			if ( this.objectLength( rules ) ) {
				this.successList.push( element );
			}
			return true;
		},

		// Return the custom message for the given element and validation method
		// specified in the element's HTML5 data attribute
		// return the generic message if present and no method specific message is present
		customDataMessage: function( element, method ) {
			return $( element ).data( "msg" + method.charAt( 0 ).toUpperCase() +
				method.substring( 1 ).toLowerCase() ) || $( element ).data( "msg" );
		},

		// Return the custom message for the given element name and validation method
		customMessage: function( name, method ) {
			var m = this.settings.messages[ name ];
			return m && ( m.constructor === String ? m : m[ method ] );
		},

		// Return the first defined argument, allowing empty strings
		findDefined: function() {
			for ( var i = 0; i < arguments.length; i++ ) {
				if ( arguments[ i ] !== undefined ) {
					return arguments[ i ];
				}
			}
			return undefined;
		},

		// The second parameter 'rule' used to be a string, and extended to an object literal
		// of the following form:
		// rule = {
		//     method: "method name",
		//     parameters: "the given method parameters"
		// }
		//
		// The old behavior still supported, kept to maintain backward compatibility with
		// old code, and will be removed in the next major release.
		defaultMessage: function( element, rule ) {
			if ( typeof rule === "string" ) {
				rule = { method: rule };
			}

			var message = this.findDefined(
					this.customMessage( element.name, rule.method ),
					this.customDataMessage( element, rule.method ),

					// 'title' is never undefined, so handle empty string as undefined
					!this.settings.ignoreTitle && element.title || undefined,
					$.validator.messages[ rule.method ],
					"<strong>Warning: No message defined for " + element.name + "</strong>"
				),
				theregex = /\$?\{(\d+)\}/g;
			if ( typeof message === "function" ) {
				message = message.call( this, rule.parameters, element );
			} else if ( theregex.test( message ) ) {
				message = $.validator.format( message.replace( theregex, "{$1}" ), rule.parameters );
			}

			return message;
		},

		formatAndAdd: function( element, rule ) {
			var message = this.defaultMessage( element, rule );

			this.errorList.push( {
				message: message,
				element: element,
				method: rule.method
			} );

			this.errorMap[ element.name ] = message;
			this.submitted[ element.name ] = message;
		},

		addWrapper: function( toToggle ) {
			if ( this.settings.wrapper ) {
				toToggle = toToggle.add( toToggle.parent( this.settings.wrapper ) );
			}
			return toToggle;
		},

		defaultShowErrors: function() {
			var i, elements, error;
			for ( i = 0; this.errorList[ i ]; i++ ) {
				error = this.errorList[ i ];
				if ( this.settings.highlight ) {
					this.settings.highlight.call( this, error.element, this.settings.errorClass, this.settings.validClass );
				}
				this.showLabel( error.element, error.message );
			}
			if ( this.errorList.length ) {
				this.toShow = this.toShow.add( this.containers );
			}
			if ( this.settings.success ) {
				for ( i = 0; this.successList[ i ]; i++ ) {
					this.showLabel( this.successList[ i ] );
				}
			}
			if ( this.settings.unhighlight ) {
				for ( i = 0, elements = this.validElements(); elements[ i ]; i++ ) {
					this.settings.unhighlight.call( this, elements[ i ], this.settings.errorClass, this.settings.validClass );
				}
			}
			this.toHide = this.toHide.not( this.toShow );
			this.hideErrors();
			this.addWrapper( this.toShow ).show();
		},

		validElements: function() {
			return this.currentElements.not( this.invalidElements() );
		},

		invalidElements: function() {
			return $( this.errorList ).map( function() {
				return this.element;
			} );
		},

		showLabel: function( element, message ) {
			var place, group, errorID, v,
				error = this.errorsFor( element ),
				elementID = this.idOrName( element ),
				describedBy = $( element ).attr( "aria-describedby" );

			if ( error.length ) {

				// Refresh error/success class
				error.removeClass( this.settings.validClass ).addClass( this.settings.errorClass );

				// Replace message on existing label
				if ( this.settings && this.settings.escapeHtml ) {
					error.text( message || "" );
				} else {
					error.html( message || "" );
				}
			} else {

				// Create error element
				error = $( "<" + this.settings.errorElement + ">" )
					.attr( "id", elementID + "-error" )
					.addClass( this.settings.errorClass );

				if ( this.settings && this.settings.escapeHtml ) {
					error.text( message || "" );
				} else {
					error.html( message || "" );
				}

				// Maintain reference to the element to be placed into the DOM
				place = error;
				if ( this.settings.wrapper ) {

					// Make sure the element is visible, even in IE
					// actually showing the wrapped element is handled elsewhere
					place = error.hide().show().wrap( "<" + this.settings.wrapper + "/>" ).parent();
				}
				if ( this.labelContainer.length ) {
					this.labelContainer.append( place );
				} else if ( this.settings.errorPlacement ) {
					this.settings.errorPlacement.call( this, place, $( element ) );
				} else {
					place.insertAfter( element );
				}

				// Link error back to the element
				if ( error.is( "label" ) ) {

					// If the error is a label, then associate using 'for'
					error.attr( "for", elementID );

					// If the element is not a child of an associated label, then it's necessary
					// to explicitly apply aria-describedby
				} else if ( error.parents( "label[for='" + this.escapeCssMeta( elementID ) + "']" ).length === 0 ) {
					errorID = error.attr( "id" );

					// Respect existing non-error aria-describedby
					if ( !describedBy ) {
						describedBy = errorID;
					} else if ( !describedBy.match( new RegExp( "\\b" + this.escapeCssMeta( errorID ) + "\\b" ) ) ) {

						// Add to end of list if not already present
						describedBy += " " + errorID;
					}
					$( element ).attr( "aria-describedby", describedBy );

					// If this element is grouped, then assign to all elements in the same group
					group = this.groups[ element.name ];
					if ( group ) {
						v = this;
						$.each( v.groups, function( name, testgroup ) {
							if ( testgroup === group ) {
								$( "[name='" + v.escapeCssMeta( name ) + "']", v.currentForm )
									.attr( "aria-describedby", error.attr( "id" ) );
							}
						} );
					}
				}
			}
			if ( !message && this.settings.success ) {
				error.text( "" );
				if ( typeof this.settings.success === "string" ) {
					error.addClass( this.settings.success );
				} else {
					this.settings.success( error, element );
				}
			}
			this.toShow = this.toShow.add( error );
		},

		errorsFor: function( element ) {
			var name = this.escapeCssMeta( this.idOrName( element ) ),
				describer = $( element ).attr( "aria-describedby" ),
				selector = "label[for='" + name + "'], label[for='" + name + "'] *";

			// 'aria-describedby' should directly reference the error element
			if ( describer ) {
				selector = selector + ", #" + this.escapeCssMeta( describer )
					.replace( /\s+/g, ", #" );
			}

			return this
				.errors()
				.filter( selector );
		},

		// See https://api.jquery.com/category/selectors/, for CSS
		// meta-characters that should be escaped in order to be used with JQuery
		// as a literal part of a name/id or any selector.
		escapeCssMeta: function( string ) {
			if ( string === undefined ) {
				return "";
			}

			return string.replace( /([\\!"#$%&'()*+,./:;<=>?@\[\]^`{|}~])/g, "\\$1" );
		},

		idOrName: function( element ) {
			return this.groups[ element.name ] || ( this.checkable( element ) ? element.name : element.id || element.name );
		},

		validationTargetFor: function( element ) {

			// If radio/checkbox, validate first element in group instead
			if ( this.checkable( element ) ) {
				element = this.findByName( element.name );
			}

			// Always apply ignore filter
			return $( element ).not( this.settings.ignore )[ 0 ];
		},

		checkable: function( element ) {
			return ( /radio|checkbox/i ).test( element.type );
		},

		findByName: function( name ) {
			return $( this.currentForm ).find( "[name='" + this.escapeCssMeta( name ) + "']" );
		},

		getLength: function( value, element ) {
			switch ( element.nodeName.toLowerCase() ) {
			case "select":
				return $( "option:selected", element ).length;
			case "input":
				if ( this.checkable( element ) ) {
					return this.findByName( element.name ).filter( ":checked" ).length;
				}
			}
			return value.length;
		},

		depend: function( param, element ) {
			return this.dependTypes[ typeof param ] ? this.dependTypes[ typeof param ]( param, element ) : true;
		},

		dependTypes: {
			"boolean": function( param ) {
				return param;
			},
			"string": function( param, element ) {
				return !!$( param, element.form ).length;
			},
			"function": function( param, element ) {
				return param( element );
			}
		},

		optional: function( element ) {
			var val = this.elementValue( element );
			return !$.validator.methods.required.call( this, val, element ) && "dependency-mismatch";
		},

		elementAjaxPort: function( element ) {
			return "validate" + element.name;
		},

		startRequest: function( element ) {
			if ( !this.pending[ element.name ] ) {
				this.pendingRequest++;
				$( element ).addClass( this.settings.pendingClass );
				this.pending[ element.name ] = true;
			}
		},

		stopRequest: function( element, valid ) {
			this.pendingRequest--;

			// Sometimes synchronization fails, make sure pendingRequest is never < 0
			if ( this.pendingRequest < 0 ) {
				this.pendingRequest = 0;
			}
			delete this.pending[ element.name ];
			$( element ).removeClass( this.settings.pendingClass );
			if ( valid && this.pendingRequest === 0 && this.formSubmitted && this.form() && this.pendingRequest === 0 ) {
				$( this.currentForm ).trigger( "submit" );

				// Remove the hidden input that was used as a replacement for the
				// missing submit button. The hidden input is added by `handle()`
				// to ensure that the value of the used submit button is passed on
				// for scripted submits triggered by this method
				if ( this.submitButton ) {
					$( "input:hidden[name='" + this.submitButton.name + "']", this.currentForm ).remove();
				}

				this.formSubmitted = false;
			} else if ( !valid && this.pendingRequest === 0 && this.formSubmitted ) {
				$( this.currentForm ).triggerHandler( "invalid-form", [ this ] );
				this.formSubmitted = false;
			}
		},

		abortRequest: function( element ) {
			var port;

			if ( this.pending[ element.name ] ) {
				port = this.elementAjaxPort( element );
				$.ajaxAbort( port );

				this.pendingRequest--;

				// Sometimes synchronization fails, make sure pendingRequest is never < 0
				if ( this.pendingRequest < 0 ) {
					this.pendingRequest = 0;
				}

				delete this.pending[ element.name ];
				$( element ).removeClass( this.settings.pendingClass );
			}
		},

		previousValue: function( element, method ) {
			method = typeof method === "string" && method || "remote";

			return $.data( element, "previousValue" ) || $.data( element, "previousValue", {
				old: null,
				valid: true,
				message: this.defaultMessage( element, { method: method } )
			} );
		},

		// Cleans up all forms and elements, removes validator-specific events
		destroy: function() {
			this.resetForm();

			$( this.currentForm )
				.off( ".validate" )
				.removeData( "validator" )
				.find( ".validate-equalTo-blur" )
					.off( ".validate-equalTo" )
					.removeClass( "validate-equalTo-blur" )
				.find( ".validate-lessThan-blur" )
					.off( ".validate-lessThan" )
					.removeClass( "validate-lessThan-blur" )
				.find( ".validate-lessThanEqual-blur" )
					.off( ".validate-lessThanEqual" )
					.removeClass( "validate-lessThanEqual-blur" )
				.find( ".validate-greaterThanEqual-blur" )
					.off( ".validate-greaterThanEqual" )
					.removeClass( "validate-greaterThanEqual-blur" )
				.find( ".validate-greaterThan-blur" )
					.off( ".validate-greaterThan" )
					.removeClass( "validate-greaterThan-blur" );
		}

	},

	classRuleSettings: {
		required: { required: true },
		email: { email: true },
		url: { url: true },
		date: { date: true },
		dateISO: { dateISO: true },
		number: { number: true },
		digits: { digits: true },
		creditcard: { creditcard: true }
	},

	addClassRules: function( className, rules ) {
		if ( className.constructor === String ) {
			this.classRuleSettings[ className ] = rules;
		} else {
			$.extend( this.classRuleSettings, className );
		}
	},

	classRules: function( element ) {
		var rules = {},
			classes = $( element ).attr( "class" );

		if ( classes ) {
			$.each( classes.split( " " ), function() {
				if ( this in $.validator.classRuleSettings ) {
					$.extend( rules, $.validator.classRuleSettings[ this ] );
				}
			} );
		}
		return rules;
	},

	normalizeAttributeRule: function( rules, type, method, value ) {

		// Convert the value to a number for number inputs, and for text for backwards compability
		// allows type="date" and others to be compared as strings
		if ( /min|max|step/.test( method ) && ( type === null || /number|range|text/.test( type ) ) ) {
			value = Number( value );

			// Support Opera Mini, which returns NaN for undefined minlength
			if ( isNaN( value ) ) {
				value = undefined;
			}
		}

		if ( value || value === 0 ) {
			rules[ method ] = value;
		} else if ( type === method && type !== "range" ) {

			// Exception: the jquery validate 'range' method
			// does not test for the html5 'range' type
			rules[ type === "date" ? "dateISO" : method ] = true;
		}
	},

	attributeRules: function( element ) {
		var rules = {},
			$element = $( element ),
			type = element.getAttribute( "type" ),
			method, value;

		for ( method in $.validator.methods ) {

			// Support for <input required> in both html5 and older browsers
			if ( method === "required" ) {
				value = element.getAttribute( method );

				// Some browsers return an empty string for the required attribute
				// and non-HTML5 browsers might have required="" markup
				if ( value === "" ) {
					value = true;
				}

				// Force non-HTML5 browsers to return bool
				value = !!value;
			} else {
				value = $element.attr( method );
			}

			this.normalizeAttributeRule( rules, type, method, value );
		}

		// 'maxlength' may be returned as -1, 2147483647 ( IE ) and 524288 ( safari ) for text inputs
		if ( rules.maxlength && /-1|2147483647|524288/.test( rules.maxlength ) ) {
			delete rules.maxlength;
		}

		return rules;
	},

	dataRules: function( element ) {
		var rules = {},
			$element = $( element ),
			type = element.getAttribute( "type" ),
			method, value;

		for ( method in $.validator.methods ) {
			value = $element.data( "rule" + method.charAt( 0 ).toUpperCase() + method.substring( 1 ).toLowerCase() );

			// Cast empty attributes like `data-rule-required` to `true`
			if ( value === "" ) {
				value = true;
			}

			this.normalizeAttributeRule( rules, type, method, value );
		}
		return rules;
	},

	staticRules: function( element ) {
		var rules = {},
			validator = $.data( element.form, "validator" );

		if ( validator.settings.rules ) {
			rules = $.validator.normalizeRule( validator.settings.rules[ element.name ] ) || {};
		}
		return rules;
	},

	normalizeRules: function( rules, element ) {

		// Handle dependency check
		$.each( rules, function( prop, val ) {

			// Ignore rule when param is explicitly false, eg. required:false
			if ( val === false ) {
				delete rules[ prop ];
				return;
			}
			if ( val.param || val.depends ) {
				var keepRule = true;
				switch ( typeof val.depends ) {
				case "string":
					keepRule = !!$( val.depends, element.form ).length;
					break;
				case "function":
					keepRule = val.depends.call( element, element );
					break;
				}
				if ( keepRule ) {
					rules[ prop ] = val.param !== undefined ? val.param : true;
				} else {
					$.data( element.form, "validator" ).resetElements( $( element ) );
					delete rules[ prop ];
				}
			}
		} );

		// Evaluate parameters
		$.each( rules, function( rule, parameter ) {
			rules[ rule ] = typeof parameter === "function" && rule !== "normalizer" ? parameter( element ) : parameter;
		} );

		// Clean number parameters
		$.each( [ "minlength", "maxlength" ], function() {
			if ( rules[ this ] ) {
				rules[ this ] = Number( rules[ this ] );
			}
		} );
		$.each( [ "rangelength", "range" ], function() {
			var parts;
			if ( rules[ this ] ) {
				if ( Array.isArray( rules[ this ] ) ) {
					rules[ this ] = [ Number( rules[ this ][ 0 ] ), Number( rules[ this ][ 1 ] ) ];
				} else if ( typeof rules[ this ] === "string" ) {
					parts = rules[ this ].replace( /[\[\]]/g, "" ).split( /[\s,]+/ );
					rules[ this ] = [ Number( parts[ 0 ] ), Number( parts[ 1 ] ) ];
				}
			}
		} );

		if ( $.validator.autoCreateRanges ) {

			// Auto-create ranges
			if ( rules.min != null && rules.max != null ) {
				rules.range = [ rules.min, rules.max ];
				delete rules.min;
				delete rules.max;
			}
			if ( rules.minlength != null && rules.maxlength != null ) {
				rules.rangelength = [ rules.minlength, rules.maxlength ];
				delete rules.minlength;
				delete rules.maxlength;
			}
		}

		return rules;
	},

	// Converts a simple string to a {string: true} rule, e.g., "required" to {required:true}
	normalizeRule: function( data ) {
		if ( typeof data === "string" ) {
			var transformed = {};
			$.each( data.split( /\s/ ), function() {
				transformed[ this ] = true;
			} );
			data = transformed;
		}
		return data;
	},

	// https://jqueryvalidation.org/jQuery.validator.addMethod/
	addMethod: function( name, method, message ) {
		$.validator.methods[ name ] = method;
		$.validator.messages[ name ] = message !== undefined ? message : $.validator.messages[ name ];
		if ( method.length < 3 ) {
			$.validator.addClassRules( name, $.validator.normalizeRule( name ) );
		}
	},

	// https://jqueryvalidation.org/jQuery.validator.methods/
	methods: {

		// https://jqueryvalidation.org/required-method/
		required: function( value, element, param ) {

			// Check if dependency is met
			if ( !this.depend( param, element ) ) {
				return "dependency-mismatch";
			}
			if ( element.nodeName.toLowerCase() === "select" ) {

				// Could be an array for select-multiple or a string, both are fine this way
				var val = $( element ).val();
				return val && val.length > 0;
			}
			if ( this.checkable( element ) ) {
				return this.getLength( value, element ) > 0;
			}
			return value !== undefined && value !== null && value.length > 0;
		},

		// https://jqueryvalidation.org/email-method/
		email: function( value, element ) {

			// From https://html.spec.whatwg.org/multipage/forms.html#valid-e-mail-address
			// Retrieved 2014-01-14
			// If you have a problem with this implementation, report a bug against the above spec
			// Or use custom methods to implement your own email validation
			return this.optional( element ) || /^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/.test( value );
		},

		// https://jqueryvalidation.org/url-method/
		url: function( value, element ) {

			// Copyright (c) 2010-2013 Diego Perini, MIT licensed
			// https://gist.github.com/dperini/729294
			// see also https://mathiasbynens.be/demo/url-regex
			// modified to allow protocol-relative URLs
			return this.optional( element ) || /^(?:(?:(?:https?|ftp):)?\/\/)(?:(?:[^\]\[?\/<~#`!@$^&*()+=}|:";',>{ ]|%[0-9A-Fa-f]{2})+(?::(?:[^\]\[?\/<~#`!@$^&*()+=}|:";',>{ ]|%[0-9A-Fa-f]{2})*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u00a1-\uffff][a-z0-9\u00a1-\uffff_-]{0,62})?[a-z0-9\u00a1-\uffff]\.)+(?:[a-z\u00a1-\uffff]{2,}\.?))(?::\d{2,5})?(?:[/?#]\S*)?$/i.test( value );
		},

		// https://jqueryvalidation.org/date-method/
		date: ( function() {
			var called = false;

			return function( value, element ) {
				if ( !called ) {
					called = true;
					if ( this.settings.debug && window.console ) {
						console.warn(
							"The `date` method is deprecated and will be removed in version '2.0.0'.\n" +
							"Please don't use it, since it relies on the Date constructor, which\n" +
							"behaves very differently across browsers and locales. Use `dateISO`\n" +
							"instead or one of the locale specific methods in `localizations/`\n" +
							"and `additional-methods.js`."
						);
					}
				}

				return this.optional( element ) || !/Invalid|NaN/.test( new Date( value ).toString() );
			};
		}() ),

		// https://jqueryvalidation.org/dateISO-method/
		dateISO: function( value, element ) {
			return this.optional( element ) || /^\d{4}[\/\-](0?[1-9]|1[012])[\/\-](0?[1-9]|[12][0-9]|3[01])$/.test( value );
		},

		// https://jqueryvalidation.org/number-method/
		number: function( value, element ) {
			return this.optional( element ) || /^(?:-?\d+|-?\d{1,3}(?:,\d{3})+)?(?:\.\d+)?$/.test( value );
		},

		// https://jqueryvalidation.org/digits-method/
		digits: function( value, element ) {
			return this.optional( element ) || /^\d+$/.test( value );
		},

		// https://jqueryvalidation.org/minlength-method/
		minlength: function( value, element, param ) {
			var length = Array.isArray( value ) ? value.length : this.getLength( value, element );
			return this.optional( element ) || length >= param;
		},

		// https://jqueryvalidation.org/maxlength-method/
		maxlength: function( value, element, param ) {
			var length = Array.isArray( value ) ? value.length : this.getLength( value, element );
			return this.optional( element ) || length <= param;
		},

		// https://jqueryvalidation.org/rangelength-method/
		rangelength: function( value, element, param ) {
			var length = Array.isArray( value ) ? value.length : this.getLength( value, element );
			return this.optional( element ) || ( length >= param[ 0 ] && length <= param[ 1 ] );
		},

		// https://jqueryvalidation.org/min-method/
		min: function( value, element, param ) {
			return this.optional( element ) || value >= param;
		},

		// https://jqueryvalidation.org/max-method/
		max: function( value, element, param ) {
			return this.optional( element ) || value <= param;
		},

		// https://jqueryvalidation.org/range-method/
		range: function( value, element, param ) {
			return this.optional( element ) || ( value >= param[ 0 ] && value <= param[ 1 ] );
		},

		// https://jqueryvalidation.org/step-method/
		step: function( value, element, param ) {
			var type = $( element ).attr( "type" ),
				errorMessage = "Step attribute on input type " + type + " is not supported.",
				supportedTypes = [ "text", "number", "range" ],
				re = new RegExp( "\\b" + type + "\\b" ),
				notSupported = type && !re.test( supportedTypes.join() ),
				decimalPlaces = function( num ) {
					var match = ( "" + num ).match( /(?:\.(\d+))?$/ );
					if ( !match ) {
						return 0;
					}

					// Number of digits right of decimal point.
					return match[ 1 ] ? match[ 1 ].length : 0;
				},
				toInt = function( num ) {
					return Math.round( num * Math.pow( 10, decimals ) );
				},
				valid = true,
				decimals;

			// Works only for text, number and range input types
			// TODO find a way to support input types date, datetime, datetime-local, month, time and week
			if ( notSupported ) {
				throw new Error( errorMessage );
			}

			decimals = decimalPlaces( param );

			// Value can't have too many decimals
			if ( decimalPlaces( value ) > decimals || toInt( value ) % toInt( param ) !== 0 ) {
				valid = false;
			}

			return this.optional( element ) || valid;
		},

		// https://jqueryvalidation.org/equalTo-method/
		equalTo: function( value, element, param ) {

			// Bind to the blur event of the target in order to revalidate whenever the target field is updated
			var target = $( param );
			if ( this.settings.onfocusout && target.not( ".validate-equalTo-blur" ).length ) {
				target.addClass( "validate-equalTo-blur" ).on( "blur.validate-equalTo", function() {
					$( element ).valid();
				} );
			}
			return value === target.val();
		},

		// https://jqueryvalidation.org/remote-method/
		remote: function( value, element, param, method ) {
			if ( this.optional( element ) ) {
				return "dependency-mismatch";
			}

			method = typeof method === "string" && method || "remote";

			var previous = this.previousValue( element, method ),
				validator, data, optionDataString;

			if ( !this.settings.messages[ element.name ] ) {
				this.settings.messages[ element.name ] = {};
			}
			previous.originalMessage = previous.originalMessage || this.settings.messages[ element.name ][ method ];
			this.settings.messages[ element.name ][ method ] = previous.message;

			param = typeof param === "string" && { url: param } || param;
			optionDataString = $.param( $.extend( { data: value }, param.data ) );
			if ( previous.old === optionDataString ) {
				return previous.valid;
			}

			previous.old = optionDataString;
			validator = this;
			this.startRequest( element );
			data = {};
			data[ element.name ] = value;
			$.ajax( $.extend( true, {
				mode: "abort",
				port: this.elementAjaxPort( element ),
				dataType: "json",
				data: data,
				context: validator.currentForm,
				success: function( response ) {
					var valid = response === true || response === "true",
						errors, message, submitted;

					validator.settings.messages[ element.name ][ method ] = previous.originalMessage;
					if ( valid ) {
						submitted = validator.formSubmitted;
						validator.toHide = validator.errorsFor( element );
						validator.formSubmitted = submitted;
						validator.successList.push( element );
						validator.invalid[ element.name ] = false;
						validator.showErrors();
					} else {
						errors = {};
						message = response || validator.defaultMessage( element, { method: method, parameters: value } );
						errors[ element.name ] = previous.message = message;
						validator.invalid[ element.name ] = true;
						validator.showErrors( errors );
					}
					previous.valid = valid;
					validator.stopRequest( element, valid );
				}
			}, param ) );
			return "pending";
		}
	}

} );

// Ajax mode: abort
// usage: $.ajax({ mode: "abort"[, port: "uniqueport"]});
//        $.ajaxAbort( port );
// if mode:"abort" is used, the previous request on that port (port can be undefined) is aborted via XMLHttpRequest.abort()

var pendingRequests = {},
	ajax;

// Use a prefilter if available (1.5+)
if ( $.ajaxPrefilter ) {
	$.ajaxPrefilter( function( settings, _, xhr ) {
		var port = settings.port;
		if ( settings.mode === "abort" ) {
			$.ajaxAbort( port );
			pendingRequests[ port ] = xhr;
		}
	} );
} else {

	// Proxy ajax
	ajax = $.ajax;
	$.ajax = function( settings ) {
		var mode = ( "mode" in settings ? settings : $.ajaxSettings ).mode,
			port = ( "port" in settings ? settings : $.ajaxSettings ).port;
		if ( mode === "abort" ) {
			$.ajaxAbort( port );
			pendingRequests[ port ] = ajax.apply( this, arguments );
			return pendingRequests[ port ];
		}
		return ajax.apply( this, arguments );
	};
}

// Abort the previous request without sending a new one
$.ajaxAbort = function( port ) {
	if ( pendingRequests[ port ] ) {
		pendingRequests[ port ].abort();
		delete pendingRequests[ port ];
	}
};
return $;
}));

/***/ }),

/***/ 9755:
/***/ (function(module, exports) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * jQuery JavaScript Library v3.7.1
 * https://jquery.com/
 *
 * Copyright OpenJS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2023-08-28T13:37Z
 */
( function( global, factory ) {

	"use strict";

	if (  true && typeof module.exports === "object" ) {

		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket trac-14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
// enough that all such attempts are guarded in a try block.
"use strict";

var arr = [];

var getProto = Object.getPrototypeOf;

var slice = arr.slice;

var flat = arr.flat ? function( array ) {
	return arr.flat.call( array );
} : function( array ) {
	return arr.concat.apply( [], array );
};


var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var fnToString = hasOwn.toString;

var ObjectFunctionString = fnToString.call( Object );

var support = {};

var isFunction = function isFunction( obj ) {

		// Support: Chrome <=57, Firefox <=52
		// In some browsers, typeof returns "function" for HTML <object> elements
		// (i.e., `typeof document.createElement( "object" ) === "function"`).
		// We don't want to classify *any* DOM node as a function.
		// Support: QtWeb <=3.8.5, WebKit <=534.34, wkhtmltopdf tool <=0.12.5
		// Plus for old WebKit, typeof returns "function" for HTML collections
		// (e.g., `typeof document.getElementsByTagName("div") === "function"`). (gh-4756)
		return typeof obj === "function" && typeof obj.nodeType !== "number" &&
			typeof obj.item !== "function";
	};


var isWindow = function isWindow( obj ) {
		return obj != null && obj === obj.window;
	};


var document = window.document;



	var preservedScriptAttributes = {
		type: true,
		src: true,
		nonce: true,
		noModule: true
	};

	function DOMEval( code, node, doc ) {
		doc = doc || document;

		var i, val,
			script = doc.createElement( "script" );

		script.text = code;
		if ( node ) {
			for ( i in preservedScriptAttributes ) {

				// Support: Firefox 64+, Edge 18+
				// Some browsers don't support the "nonce" property on scripts.
				// On the other hand, just using `getAttribute` is not enough as
				// the `nonce` attribute is reset to an empty string whenever it
				// becomes browsing-context connected.
				// See https://github.com/whatwg/html/issues/2369
				// See https://html.spec.whatwg.org/#nonce-attributes
				// The `node.getAttribute` check was added for the sake of
				// `jQuery.globalEval` so that it can fake a nonce-containing node
				// via an object.
				val = node[ i ] || node.getAttribute && node.getAttribute( i );
				if ( val ) {
					script.setAttribute( i, val );
				}
			}
		}
		doc.head.appendChild( script ).parentNode.removeChild( script );
	}


function toType( obj ) {
	if ( obj == null ) {
		return obj + "";
	}

	// Support: Android <=2.3 only (functionish RegExp)
	return typeof obj === "object" || typeof obj === "function" ?
		class2type[ toString.call( obj ) ] || "object" :
		typeof obj;
}
/* global Symbol */
// Defining this global in .eslintrc.json would create a danger of using the global
// unguarded in another place, it seems safer to define global only for this module



var version = "3.7.1",

	rhtmlSuffix = /HTML$/i,

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	};

jQuery.fn = jQuery.prototype = {

	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {

		// Return all the elements in a clean array
		if ( num == null ) {
			return slice.call( this );
		}

		// Return just the one element from the set
		return num < 0 ? this[ num + this.length ] : this[ num ];
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	each: function( callback ) {
		return jQuery.each( this, callback );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map( this, function( elem, i ) {
			return callback.call( elem, i, elem );
		} ) );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	even: function() {
		return this.pushStack( jQuery.grep( this, function( _elem, i ) {
			return ( i + 1 ) % 2;
		} ) );
	},

	odd: function() {
		return this.pushStack( jQuery.grep( this, function( _elem, i ) {
			return i % 2;
		} ) );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor();
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[ 0 ] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !isFunction( target ) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {

		// Only deal with non-null/undefined values
		if ( ( options = arguments[ i ] ) != null ) {

			// Extend the base object
			for ( name in options ) {
				copy = options[ name ];

				// Prevent Object.prototype pollution
				// Prevent never-ending loop
				if ( name === "__proto__" || target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
					( copyIsArray = Array.isArray( copy ) ) ) ) {
					src = target[ name ];

					// Ensure proper type for the source value
					if ( copyIsArray && !Array.isArray( src ) ) {
						clone = [];
					} else if ( !copyIsArray && !jQuery.isPlainObject( src ) ) {
						clone = {};
					} else {
						clone = src;
					}
					copyIsArray = false;

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend( {

	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isPlainObject: function( obj ) {
		var proto, Ctor;

		// Detect obvious negatives
		// Use toString instead of jQuery.type to catch host objects
		if ( !obj || toString.call( obj ) !== "[object Object]" ) {
			return false;
		}

		proto = getProto( obj );

		// Objects with no prototype (e.g., `Object.create( null )`) are plain
		if ( !proto ) {
			return true;
		}

		// Objects with prototype are plain iff they were constructed by a global Object function
		Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
		return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
	},

	isEmptyObject: function( obj ) {
		var name;

		for ( name in obj ) {
			return false;
		}
		return true;
	},

	// Evaluates a script in a provided context; falls back to the global one
	// if not specified.
	globalEval: function( code, options, doc ) {
		DOMEval( code, { nonce: options && options.nonce }, doc );
	},

	each: function( obj, callback ) {
		var length, i = 0;

		if ( isArrayLike( obj ) ) {
			length = obj.length;
			for ( ; i < length; i++ ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		} else {
			for ( i in obj ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		}

		return obj;
	},


	// Retrieve the text value of an array of DOM nodes
	text: function( elem ) {
		var node,
			ret = "",
			i = 0,
			nodeType = elem.nodeType;

		if ( !nodeType ) {

			// If no nodeType, this is expected to be an array
			while ( ( node = elem[ i++ ] ) ) {

				// Do not traverse comment nodes
				ret += jQuery.text( node );
			}
		}
		if ( nodeType === 1 || nodeType === 11 ) {
			return elem.textContent;
		}
		if ( nodeType === 9 ) {
			return elem.documentElement.textContent;
		}
		if ( nodeType === 3 || nodeType === 4 ) {
			return elem.nodeValue;
		}

		// Do not include comment or processing instruction nodes

		return ret;
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArrayLike( Object( arr ) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
						[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	isXMLDoc: function( elem ) {
		var namespace = elem && elem.namespaceURI,
			docElem = elem && ( elem.ownerDocument || elem ).documentElement;

		// Assume HTML when documentElement doesn't yet exist, such as inside
		// document fragments.
		return !rhtmlSuffix.test( namespace || docElem && docElem.nodeName || "HTML" );
	},

	// Support: Android <=4.0 only, PhantomJS 1 only
	// push.apply(_, arraylike) throws on ancient WebKit
	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var length, value,
			i = 0,
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArrayLike( elems ) ) {
			length = elems.length;
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return flat( ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
} );

if ( typeof Symbol === "function" ) {
	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
	function( _i, name ) {
		class2type[ "[object " + name + "]" ] = name.toLowerCase();
	} );

function isArrayLike( obj ) {

	// Support: real iOS 8.2 only (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = !!obj && "length" in obj && obj.length,
		type = toType( obj );

	if ( isFunction( obj ) || isWindow( obj ) ) {
		return false;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}


function nodeName( elem, name ) {

	return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

}
var pop = arr.pop;


var sort = arr.sort;


var splice = arr.splice;


var whitespace = "[\\x20\\t\\r\\n\\f]";


var rtrimCSS = new RegExp(
	"^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$",
	"g"
);




// Note: an element does not contain itself
jQuery.contains = function( a, b ) {
	var bup = b && b.parentNode;

	return a === bup || !!( bup && bup.nodeType === 1 && (

		// Support: IE 9 - 11+
		// IE doesn't have `contains` on SVG.
		a.contains ?
			a.contains( bup ) :
			a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
	) );
};




// CSS string/identifier serialization
// https://drafts.csswg.org/cssom/#common-serializing-idioms
var rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g;

function fcssescape( ch, asCodePoint ) {
	if ( asCodePoint ) {

		// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
		if ( ch === "\0" ) {
			return "\uFFFD";
		}

		// Control characters and (dependent upon position) numbers get escaped as code points
		return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
	}

	// Other potentially-special ASCII characters get backslash-escaped
	return "\\" + ch;
}

jQuery.escapeSelector = function( sel ) {
	return ( sel + "" ).replace( rcssescape, fcssescape );
};




var preferredDoc = document,
	pushNative = push;

( function() {

var i,
	Expr,
	outermostContext,
	sortInput,
	hasDuplicate,
	push = pushNative,

	// Local document vars
	document,
	documentElement,
	documentIsHTML,
	rbuggyQSA,
	matches,

	// Instance-specific data
	expando = jQuery.expando,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	nonnativeSelectorCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|" +
		"loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// https://www.w3.org/TR/css-syntax-3/#ident-token-diagram
	identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace +
		"?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",

	// Attribute selectors: https://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +

		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +

		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" +
		whitespace + "*\\]",

	pseudos = ":(" + identifier + ")(?:\\((" +

		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +

		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +

		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rleadingCombinator = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" +
		whitespace + "*" ),
	rdescend = new RegExp( whitespace + "|>" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		ID: new RegExp( "^#(" + identifier + ")" ),
		CLASS: new RegExp( "^\\.(" + identifier + ")" ),
		TAG: new RegExp( "^(" + identifier + "|[*])" ),
		ATTR: new RegExp( "^" + attributes ),
		PSEUDO: new RegExp( "^" + pseudos ),
		CHILD: new RegExp(
			"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" +
				whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" +
				whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		bool: new RegExp( "^(?:" + booleans + ")$", "i" ),

		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		needsContext: new RegExp( "^" + whitespace +
			"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace +
			"*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,

	// CSS escapes
	// https://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\[\\da-fA-F]{1,6}" + whitespace +
		"?|\\\\([^\\r\\n\\f])", "g" ),
	funescape = function( escape, nonHex ) {
		var high = "0x" + escape.slice( 1 ) - 0x10000;

		if ( nonHex ) {

			// Strip the backslash prefix from a non-hex escape sequence
			return nonHex;
		}

		// Replace a hexadecimal escape sequence with the encoded Unicode code point
		// Support: IE <=11+
		// For values outside the Basic Multilingual Plane (BMP), manually construct a
		// surrogate pair
		return high < 0 ?
			String.fromCharCode( high + 0x10000 ) :
			String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// Used for iframes; see `setDocument`.
	// Support: IE 9 - 11+, Edge 12 - 18+
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE/Edge.
	unloadHandler = function() {
		setDocument();
	},

	inDisabledFieldset = addCombinator(
		function( elem ) {
			return elem.disabled === true && nodeName( elem, "fieldset" );
		},
		{ dir: "parentNode", next: "legend" }
	);

// Support: IE <=9 only
// Accessing document.activeElement can throw unexpectedly
// https://bugs.jquery.com/ticket/13393
function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		( arr = slice.call( preferredDoc.childNodes ) ),
		preferredDoc.childNodes
	);

	// Support: Android <=4.0
	// Detect silently failing push.apply
	// eslint-disable-next-line no-unused-expressions
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = {
		apply: function( target, els ) {
			pushNative.apply( target, slice.call( els ) );
		},
		call: function( target ) {
			pushNative.apply( target, slice.call( arguments, 1 ) );
		}
	};
}

function find( selector, context, results, seed ) {
	var m, i, elem, nid, match, groups, newSelector,
		newContext = context && context.ownerDocument,

		// nodeType defaults to 9, since context defaults to document
		nodeType = context ? context.nodeType : 9;

	results = results || [];

	// Return early from calls with invalid selector or context
	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	// Try to shortcut find operations (as opposed to filters) in HTML documents
	if ( !seed ) {
		setDocument( context );
		context = context || document;

		if ( documentIsHTML ) {

			// If the selector is sufficiently simple, try using a "get*By*" DOM method
			// (excepting DocumentFragment context, where the methods don't exist)
			if ( nodeType !== 11 && ( match = rquickExpr.exec( selector ) ) ) {

				// ID selector
				if ( ( m = match[ 1 ] ) ) {

					// Document context
					if ( nodeType === 9 ) {
						if ( ( elem = context.getElementById( m ) ) ) {

							// Support: IE 9 only
							// getElementById can match elements by name instead of ID
							if ( elem.id === m ) {
								push.call( results, elem );
								return results;
							}
						} else {
							return results;
						}

					// Element context
					} else {

						// Support: IE 9 only
						// getElementById can match elements by name instead of ID
						if ( newContext && ( elem = newContext.getElementById( m ) ) &&
							find.contains( context, elem ) &&
							elem.id === m ) {

							push.call( results, elem );
							return results;
						}
					}

				// Type selector
				} else if ( match[ 2 ] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Class selector
				} else if ( ( m = match[ 3 ] ) && context.getElementsByClassName ) {
					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// Take advantage of querySelectorAll
			if ( !nonnativeSelectorCache[ selector + " " ] &&
				( !rbuggyQSA || !rbuggyQSA.test( selector ) ) ) {

				newSelector = selector;
				newContext = context;

				// qSA considers elements outside a scoping root when evaluating child or
				// descendant combinators, which is not what we want.
				// In such cases, we work around the behavior by prefixing every selector in the
				// list with an ID selector referencing the scope context.
				// The technique has to be used as well when a leading combinator is used
				// as such selectors are not recognized by querySelectorAll.
				// Thanks to Andrew Dupont for this technique.
				if ( nodeType === 1 &&
					( rdescend.test( selector ) || rleadingCombinator.test( selector ) ) ) {

					// Expand context for sibling selectors
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
						context;

					// We can use :scope instead of the ID hack if the browser
					// supports it & if we're not changing the context.
					// Support: IE 11+, Edge 17 - 18+
					// IE/Edge sometimes throw a "Permission denied" error when
					// strict-comparing two documents; shallow comparisons work.
					// eslint-disable-next-line eqeqeq
					if ( newContext != context || !support.scope ) {

						// Capture the context ID, setting it first if necessary
						if ( ( nid = context.getAttribute( "id" ) ) ) {
							nid = jQuery.escapeSelector( nid );
						} else {
							context.setAttribute( "id", ( nid = expando ) );
						}
					}

					// Prefix every selector in the list
					groups = tokenize( selector );
					i = groups.length;
					while ( i-- ) {
						groups[ i ] = ( nid ? "#" + nid : ":scope" ) + " " +
							toSelector( groups[ i ] );
					}
					newSelector = groups.join( "," );
				}

				try {
					push.apply( results,
						newContext.querySelectorAll( newSelector )
					);
					return results;
				} catch ( qsaError ) {
					nonnativeSelectorCache( selector, true );
				} finally {
					if ( nid === expando ) {
						context.removeAttribute( "id" );
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrimCSS, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {

		// Use (key + " ") to avoid collision with native prototype properties
		// (see https://github.com/jquery/sizzle/issues/157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {

			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return ( cache[ key + " " ] = value );
	}
	return cache;
}

/**
 * Mark a function for special use by jQuery selector module
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created element and returns a boolean result
 */
function assert( fn ) {
	var el = document.createElement( "fieldset" );

	try {
		return !!fn( el );
	} catch ( e ) {
		return false;
	} finally {

		// Remove from its parent by default
		if ( el.parentNode ) {
			el.parentNode.removeChild( el );
		}

		// release memory in IE
		el = null;
	}
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		return nodeName( elem, "input" ) && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		return ( nodeName( elem, "input" ) || nodeName( elem, "button" ) ) &&
			elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for :enabled/:disabled
 * @param {Boolean} disabled true for :disabled; false for :enabled
 */
function createDisabledPseudo( disabled ) {

	// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
	return function( elem ) {

		// Only certain elements can match :enabled or :disabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
		if ( "form" in elem ) {

			// Check for inherited disabledness on relevant non-disabled elements:
			// * listed form-associated elements in a disabled fieldset
			//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
			// * option elements in a disabled optgroup
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
			// All such elements have a "form" property.
			if ( elem.parentNode && elem.disabled === false ) {

				// Option elements defer to a parent optgroup if present
				if ( "label" in elem ) {
					if ( "label" in elem.parentNode ) {
						return elem.parentNode.disabled === disabled;
					} else {
						return elem.disabled === disabled;
					}
				}

				// Support: IE 6 - 11+
				// Use the isDisabled shortcut property to check for disabled fieldset ancestors
				return elem.isDisabled === disabled ||

					// Where there is no isDisabled, check manually
					elem.isDisabled !== !disabled &&
						inDisabledFieldset( elem ) === disabled;
			}

			return elem.disabled === disabled;

		// Try to winnow out elements that can't be disabled before trusting the disabled property.
		// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
		// even exist on them, let alone have a boolean value.
		} else if ( "label" in elem ) {
			return elem.disabled === disabled;
		}

		// Remaining elements are neither :enabled nor :disabled
		return false;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction( function( argument ) {
		argument = +argument;
		return markFunction( function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ ( j = matchIndexes[ i ] ) ] ) {
					seed[ j ] = !( matches[ j ] = seed[ j ] );
				}
			}
		} );
	} );
}

/**
 * Checks a node for validity as a jQuery selector context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [node] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
function setDocument( node ) {
	var subWindow,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( doc == document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Update global variables
	document = doc;
	documentElement = document.documentElement;
	documentIsHTML = !jQuery.isXMLDoc( document );

	// Support: iOS 7 only, IE 9 - 11+
	// Older browsers didn't support unprefixed `matches`.
	matches = documentElement.matches ||
		documentElement.webkitMatchesSelector ||
		documentElement.msMatchesSelector;

	// Support: IE 9 - 11+, Edge 12 - 18+
	// Accessing iframe documents after unload throws "permission denied" errors
	// (see trac-13936).
	// Limit the fix to IE & Edge Legacy; despite Edge 15+ implementing `matches`,
	// all IE 9+ and Edge Legacy versions implement `msMatchesSelector` as well.
	if ( documentElement.msMatchesSelector &&

		// Support: IE 11+, Edge 17 - 18+
		// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
		// two documents; shallow comparisons work.
		// eslint-disable-next-line eqeqeq
		preferredDoc != document &&
		( subWindow = document.defaultView ) && subWindow.top !== subWindow ) {

		// Support: IE 9 - 11+, Edge 12 - 18+
		subWindow.addEventListener( "unload", unloadHandler );
	}

	// Support: IE <10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programmatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert( function( el ) {
		documentElement.appendChild( el ).id = jQuery.expando;
		return !document.getElementsByName ||
			!document.getElementsByName( jQuery.expando ).length;
	} );

	// Support: IE 9 only
	// Check to see if it's possible to do matchesSelector
	// on a disconnected node.
	support.disconnectedMatch = assert( function( el ) {
		return matches.call( el, "*" );
	} );

	// Support: IE 9 - 11+, Edge 12 - 18+
	// IE/Edge don't support the :scope pseudo-class.
	support.scope = assert( function() {
		return document.querySelectorAll( ":scope" );
	} );

	// Support: Chrome 105 - 111 only, Safari 15.4 - 16.3 only
	// Make sure the `:has()` argument is parsed unforgivingly.
	// We include `*` in the test to detect buggy implementations that are
	// _selectively_ forgiving (specifically when the list includes at least
	// one valid selector).
	// Note that we treat complete lack of support for `:has()` as if it were
	// spec-compliant support, which is fine because use of `:has()` in such
	// environments will fail in the qSA path and fall back to jQuery traversal
	// anyway.
	support.cssHas = assert( function() {
		try {
			document.querySelector( ":has(*,:jqfake)" );
			return false;
		} catch ( e ) {
			return true;
		}
	} );

	// ID filter and find
	if ( support.getById ) {
		Expr.filter.ID = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute( "id" ) === attrId;
			};
		};
		Expr.find.ID = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var elem = context.getElementById( id );
				return elem ? [ elem ] : [];
			}
		};
	} else {
		Expr.filter.ID =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode( "id" );
				return node && node.value === attrId;
			};
		};

		// Support: IE 6 - 7 only
		// getElementById is not reliable as a find shortcut
		Expr.find.ID = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var node, i, elems,
					elem = context.getElementById( id );

				if ( elem ) {

					// Verify the id attribute
					node = elem.getAttributeNode( "id" );
					if ( node && node.value === id ) {
						return [ elem ];
					}

					// Fall back on getElementsByName
					elems = context.getElementsByName( id );
					i = 0;
					while ( ( elem = elems[ i++ ] ) ) {
						node = elem.getAttributeNode( "id" );
						if ( node && node.value === id ) {
							return [ elem ];
						}
					}
				}

				return [];
			}
		};
	}

	// Tag
	Expr.find.TAG = function( tag, context ) {
		if ( typeof context.getElementsByTagName !== "undefined" ) {
			return context.getElementsByTagName( tag );

		// DocumentFragment nodes don't have gEBTN
		} else {
			return context.querySelectorAll( tag );
		}
	};

	// Class
	Expr.find.CLASS = function( className, context ) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	rbuggyQSA = [];

	// Build QSA regex
	// Regex strategy adopted from Diego Perini
	assert( function( el ) {

		var input;

		documentElement.appendChild( el ).innerHTML =
			"<a id='" + expando + "' href='' disabled='disabled'></a>" +
			"<select id='" + expando + "-\r\\' disabled='disabled'>" +
			"<option selected=''></option></select>";

		// Support: iOS <=7 - 8 only
		// Boolean attributes and "value" are not treated correctly in some XML documents
		if ( !el.querySelectorAll( "[selected]" ).length ) {
			rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
		}

		// Support: iOS <=7 - 8 only
		if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
			rbuggyQSA.push( "~=" );
		}

		// Support: iOS 8 only
		// https://bugs.webkit.org/show_bug.cgi?id=136851
		// In-page `selector#id sibling-combinator selector` fails
		if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
			rbuggyQSA.push( ".#.+[+~]" );
		}

		// Support: Chrome <=105+, Firefox <=104+, Safari <=15.4+
		// In some of the document kinds, these selectors wouldn't work natively.
		// This is probably OK but for backwards compatibility we want to maintain
		// handling them through jQuery traversal in jQuery 3.x.
		if ( !el.querySelectorAll( ":checked" ).length ) {
			rbuggyQSA.push( ":checked" );
		}

		// Support: Windows 8 Native Apps
		// The type and name attributes are restricted during .innerHTML assignment
		input = document.createElement( "input" );
		input.setAttribute( "type", "hidden" );
		el.appendChild( input ).setAttribute( "name", "D" );

		// Support: IE 9 - 11+
		// IE's :disabled selector does not pick up the children of disabled fieldsets
		// Support: Chrome <=105+, Firefox <=104+, Safari <=15.4+
		// In some of the document kinds, these selectors wouldn't work natively.
		// This is probably OK but for backwards compatibility we want to maintain
		// handling them through jQuery traversal in jQuery 3.x.
		documentElement.appendChild( el ).disabled = true;
		if ( el.querySelectorAll( ":disabled" ).length !== 2 ) {
			rbuggyQSA.push( ":enabled", ":disabled" );
		}

		// Support: IE 11+, Edge 15 - 18+
		// IE 11/Edge don't find elements on a `[name='']` query in some cases.
		// Adding a temporary attribute to the document before the selection works
		// around the issue.
		// Interestingly, IE 10 & older don't seem to have the issue.
		input = document.createElement( "input" );
		input.setAttribute( "name", "" );
		el.appendChild( input );
		if ( !el.querySelectorAll( "[name='']" ).length ) {
			rbuggyQSA.push( "\\[" + whitespace + "*name" + whitespace + "*=" +
				whitespace + "*(?:''|\"\")" );
		}
	} );

	if ( !support.cssHas ) {

		// Support: Chrome 105 - 110+, Safari 15.4 - 16.3+
		// Our regular `try-catch` mechanism fails to detect natively-unsupported
		// pseudo-classes inside `:has()` (such as `:has(:contains("Foo"))`)
		// in browsers that parse the `:has()` argument as a forgiving selector list.
		// https://drafts.csswg.org/selectors/#relational now requires the argument
		// to be parsed unforgivingly, but browsers have not yet fully adjusted.
		rbuggyQSA.push( ":has" );
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join( "|" ) );

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		// Support: IE 11+, Edge 17 - 18+
		// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
		// two documents; shallow comparisons work.
		// eslint-disable-next-line eqeqeq
		compare = ( a.ownerDocument || a ) == ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			( !support.sortDetached && b.compareDocumentPosition( a ) === compare ) ) {

			// Choose the first element that is related to our preferred document
			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			// eslint-disable-next-line eqeqeq
			if ( a === document || a.ownerDocument == preferredDoc &&
				find.contains( preferredDoc, a ) ) {
				return -1;
			}

			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			// eslint-disable-next-line eqeqeq
			if ( b === document || b.ownerDocument == preferredDoc &&
				find.contains( preferredDoc, b ) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	};

	return document;
}

find.matches = function( expr, elements ) {
	return find( expr, null, null, elements );
};

find.matchesSelector = function( elem, expr ) {
	setDocument( elem );

	if ( documentIsHTML &&
		!nonnativeSelectorCache[ expr + " " ] &&
		( !rbuggyQSA || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||

					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch ( e ) {
			nonnativeSelectorCache( expr, true );
		}
	}

	return find( expr, document, null, [ elem ] ).length > 0;
};

find.contains = function( context, elem ) {

	// Set document vars if needed
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( ( context.ownerDocument || context ) != document ) {
		setDocument( context );
	}
	return jQuery.contains( context, elem );
};


find.attr = function( elem, name ) {

	// Set document vars if needed
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( ( elem.ownerDocument || elem ) != document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],

		// Don't get fooled by Object.prototype properties (see trac-13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	if ( val !== undefined ) {
		return val;
	}

	return elem.getAttribute( name );
};

find.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
jQuery.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	//
	// Support: Android <=4.0+
	// Testing for detecting duplicates is unpredictable so instead assume we can't
	// depend on duplicate detection in all browsers without a stable sort.
	hasDuplicate = !support.sortStable;
	sortInput = !support.sortStable && slice.call( results, 0 );
	sort.call( results, sortOrder );

	if ( hasDuplicate ) {
		while ( ( elem = results[ i++ ] ) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			splice.call( results, duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

jQuery.fn.uniqueSort = function() {
	return this.pushStack( jQuery.uniqueSort( slice.apply( this ) ) );
};

Expr = jQuery.expr = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		ATTR: function( match ) {
			match[ 1 ] = match[ 1 ].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[ 3 ] = ( match[ 3 ] || match[ 4 ] || match[ 5 ] || "" )
				.replace( runescape, funescape );

			if ( match[ 2 ] === "~=" ) {
				match[ 3 ] = " " + match[ 3 ] + " ";
			}

			return match.slice( 0, 4 );
		},

		CHILD: function( match ) {

			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[ 1 ] = match[ 1 ].toLowerCase();

			if ( match[ 1 ].slice( 0, 3 ) === "nth" ) {

				// nth-* requires argument
				if ( !match[ 3 ] ) {
					find.error( match[ 0 ] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[ 4 ] = +( match[ 4 ] ?
					match[ 5 ] + ( match[ 6 ] || 1 ) :
					2 * ( match[ 3 ] === "even" || match[ 3 ] === "odd" )
				);
				match[ 5 ] = +( ( match[ 7 ] + match[ 8 ] ) || match[ 3 ] === "odd" );

			// other types prohibit arguments
			} else if ( match[ 3 ] ) {
				find.error( match[ 0 ] );
			}

			return match;
		},

		PSEUDO: function( match ) {
			var excess,
				unquoted = !match[ 6 ] && match[ 2 ];

			if ( matchExpr.CHILD.test( match[ 0 ] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[ 3 ] ) {
				match[ 2 ] = match[ 4 ] || match[ 5 ] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&

				// Get excess from tokenize (recursively)
				( excess = tokenize( unquoted, true ) ) &&

				// advance to the next closing parenthesis
				( excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length ) ) {

				// excess is a negative index
				match[ 0 ] = match[ 0 ].slice( 0, excess );
				match[ 2 ] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		TAG: function( nodeNameSelector ) {
			var expectedNodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() {
					return true;
				} :
				function( elem ) {
					return nodeName( elem, expectedNodeName );
				};
		},

		CLASS: function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				( pattern = new RegExp( "(^|" + whitespace + ")" + className +
					"(" + whitespace + "|$)" ) ) &&
				classCache( className, function( elem ) {
					return pattern.test(
						typeof elem.className === "string" && elem.className ||
							typeof elem.getAttribute !== "undefined" &&
								elem.getAttribute( "class" ) ||
							""
					);
				} );
		},

		ATTR: function( name, operator, check ) {
			return function( elem ) {
				var result = find.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				if ( operator === "=" ) {
					return result === check;
				}
				if ( operator === "!=" ) {
					return result !== check;
				}
				if ( operator === "^=" ) {
					return check && result.indexOf( check ) === 0;
				}
				if ( operator === "*=" ) {
					return check && result.indexOf( check ) > -1;
				}
				if ( operator === "$=" ) {
					return check && result.slice( -check.length ) === check;
				}
				if ( operator === "~=" ) {
					return ( " " + result.replace( rwhitespace, " " ) + " " )
						.indexOf( check ) > -1;
				}
				if ( operator === "|=" ) {
					return result === check || result.slice( 0, check.length + 1 ) === check + "-";
				}

				return false;
			};
		},

		CHILD: function( type, what, _argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, _context, xml ) {
					var cache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						diff = false;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( ( node = node[ dir ] ) ) {
									if ( ofType ?
										nodeName( node, name ) :
										node.nodeType === 1 ) {

										return false;
									}
								}

								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {

							// Seek `elem` from a previously-cached index
							outerCache = parent[ expando ] || ( parent[ expando ] = {} );
							cache = outerCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
							diff = nodeIndex && cache[ 2 ];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( ( node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								( diff = nodeIndex = 0 ) || start.pop() ) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									outerCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						} else {

							// Use previously-cached element index if available
							if ( useCache ) {
								outerCache = elem[ expando ] || ( elem[ expando ] = {} );
								cache = outerCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex;
							}

							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {

								// Use the same loop as above to seek `elem` from the start
								while ( ( node = ++nodeIndex && node && node[ dir ] ||
									( diff = nodeIndex = 0 ) || start.pop() ) ) {

									if ( ( ofType ?
										nodeName( node, name ) :
										node.nodeType === 1 ) &&
										++diff ) {

										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] ||
												( node[ expando ] = {} );
											outerCache[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		PSEUDO: function( pseudo, argument ) {

			// pseudo-class names are case-insensitive
			// https://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					find.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as jQuery does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction( function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf.call( seed, matched[ i ] );
							seed[ idx ] = !( matches[ idx ] = matched[ i ] );
						}
					} ) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {

		// Potentially complex pseudos
		not: markFunction( function( selector ) {

			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrimCSS, "$1" ) );

			return matcher[ expando ] ?
				markFunction( function( seed, matches, _context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( ( elem = unmatched[ i ] ) ) {
							seed[ i ] = !( matches[ i ] = elem );
						}
					}
				} ) :
				function( elem, _context, xml ) {
					input[ 0 ] = elem;
					matcher( input, null, xml, results );

					// Don't keep the element
					// (see https://github.com/jquery/sizzle/issues/299)
					input[ 0 ] = null;
					return !results.pop();
				};
		} ),

		has: markFunction( function( selector ) {
			return function( elem ) {
				return find( selector, elem ).length > 0;
			};
		} ),

		contains: markFunction( function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || jQuery.text( elem ) ).indexOf( text ) > -1;
			};
		} ),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// https://www.w3.org/TR/selectors/#lang-pseudo
		lang: markFunction( function( lang ) {

			// lang value must be a valid identifier
			if ( !ridentifier.test( lang || "" ) ) {
				find.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( ( elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute( "xml:lang" ) || elem.getAttribute( "lang" ) ) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( ( elem = elem.parentNode ) && elem.nodeType === 1 );
				return false;
			};
		} ),

		// Miscellaneous
		target: function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		root: function( elem ) {
			return elem === documentElement;
		},

		focus: function( elem ) {
			return elem === safeActiveElement() &&
				document.hasFocus() &&
				!!( elem.type || elem.href || ~elem.tabIndex );
		},

		// Boolean properties
		enabled: createDisabledPseudo( false ),
		disabled: createDisabledPseudo( true ),

		checked: function( elem ) {

			// In CSS3, :checked should return both checked and selected elements
			// https://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			return ( nodeName( elem, "input" ) && !!elem.checked ) ||
				( nodeName( elem, "option" ) && !!elem.selected );
		},

		selected: function( elem ) {

			// Support: IE <=11+
			// Accessing the selectedIndex property
			// forces the browser to treat the default option as
			// selected when in an optgroup.
			if ( elem.parentNode ) {
				// eslint-disable-next-line no-unused-expressions
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		empty: function( elem ) {

			// https://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		parent: function( elem ) {
			return !Expr.pseudos.empty( elem );
		},

		// Element/input types
		header: function( elem ) {
			return rheader.test( elem.nodeName );
		},

		input: function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		button: function( elem ) {
			return nodeName( elem, "input" ) && elem.type === "button" ||
				nodeName( elem, "button" );
		},

		text: function( elem ) {
			var attr;
			return nodeName( elem, "input" ) && elem.type === "text" &&

				// Support: IE <10 only
				// New HTML5 attribute values (e.g., "search") appear
				// with elem.type === "text"
				( ( attr = elem.getAttribute( "type" ) ) == null ||
					attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		first: createPositionalPseudo( function() {
			return [ 0 ];
		} ),

		last: createPositionalPseudo( function( _matchIndexes, length ) {
			return [ length - 1 ];
		} ),

		eq: createPositionalPseudo( function( _matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		} ),

		even: createPositionalPseudo( function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		odd: createPositionalPseudo( function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		lt: createPositionalPseudo( function( matchIndexes, length, argument ) {
			var i;

			if ( argument < 0 ) {
				i = argument + length;
			} else if ( argument > length ) {
				i = length;
			} else {
				i = argument;
			}

			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		gt: createPositionalPseudo( function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} )
	}
};

Expr.pseudos.nth = Expr.pseudos.eq;

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

function tokenize( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || ( match = rcomma.exec( soFar ) ) ) {
			if ( match ) {

				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[ 0 ].length ) || soFar;
			}
			groups.push( ( tokens = [] ) );
		}

		matched = false;

		// Combinators
		if ( ( match = rleadingCombinator.exec( soFar ) ) ) {
			matched = match.shift();
			tokens.push( {
				value: matched,

				// Cast descendant combinators to space
				type: match[ 0 ].replace( rtrimCSS, " " )
			} );
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( ( match = matchExpr[ type ].exec( soFar ) ) && ( !preFilters[ type ] ||
				( match = preFilters[ type ]( match ) ) ) ) {
				matched = match.shift();
				tokens.push( {
					value: matched,
					type: type,
					matches: match
				} );
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	if ( parseOnly ) {
		return soFar.length;
	}

	return soFar ?
		find.error( selector ) :

		// Cache the tokens
		tokenCache( selector, groups ).slice( 0 );
}

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[ i ].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		skip = combinator.next,
		key = skip || dir,
		checkNonElements = base && key === "parentNode",
		doneName = done++;

	return combinator.first ?

		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( ( elem = elem[ dir ] ) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
			return false;
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
			if ( xml ) {
				while ( ( elem = elem[ dir ] ) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( ( elem = elem[ dir ] ) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || ( elem[ expando ] = {} );

						if ( skip && nodeName( elem, skip ) ) {
							elem = elem[ dir ] || elem;
						} else if ( ( oldCache = outerCache[ key ] ) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return ( newCache[ 2 ] = oldCache[ 2 ] );
						} else {

							// Reuse newcache so results back-propagate to previous elements
							outerCache[ key ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( ( newCache[ 2 ] = matcher( elem, context, xml ) ) ) {
								return true;
							}
						}
					}
				}
			}
			return false;
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[ i ]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[ 0 ];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		find( selector, contexts[ i ], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( ( elem = unmatched[ i ] ) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction( function( seed, results, context, xml ) {
		var temp, i, elem, matcherOut,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed ||
				multipleContexts( selector || "*",
					context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems;

		if ( matcher ) {

			// If we have a postFinder, or filtered seed, or non-seed postFilter
			// or preexisting results,
			matcherOut = postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

				// ...intermediate processing is necessary
				[] :

				// ...otherwise use results directly
				results;

			// Find primary matches
			matcher( matcherIn, matcherOut, context, xml );
		} else {
			matcherOut = matcherIn;
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( ( elem = temp[ i ] ) ) {
					matcherOut[ postMap[ i ] ] = !( matcherIn[ postMap[ i ] ] = elem );
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {

					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( ( elem = matcherOut[ i ] ) ) {

							// Restore matcherIn since elem is not yet a final match
							temp.push( ( matcherIn[ i ] = elem ) );
						}
					}
					postFinder( null, ( matcherOut = [] ), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( ( elem = matcherOut[ i ] ) &&
						( temp = postFinder ? indexOf.call( seed, elem ) : preMap[ i ] ) > -1 ) {

						seed[ temp ] = !( results[ temp ] = elem );
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	} );
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[ 0 ].type ],
		implicitRelative = leadingRelative || Expr.relative[ " " ],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf.call( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {

			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			// eslint-disable-next-line eqeqeq
			var ret = ( !leadingRelative && ( xml || context != outermostContext ) ) || (
				( checkContext = context ).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );

			// Avoid hanging onto element
			// (see https://github.com/jquery/sizzle/issues/299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( ( matcher = Expr.relative[ tokens[ i ].type ] ) ) {
			matchers = [ addCombinator( elementMatcher( matchers ), matcher ) ];
		} else {
			matcher = Expr.filter[ tokens[ i ].type ].apply( null, tokens[ i ].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {

				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[ j ].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(

						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 )
							.concat( { value: tokens[ i - 2 ].type === " " ? "*" : "" } )
					).replace( rtrimCSS, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( ( tokens = tokens.slice( j ) ) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,

				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find.TAG( "*", outermost ),

				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = ( dirruns += contextBackup == null ? 1 : Math.random() || 0.1 ),
				len = elems.length;

			if ( outermost ) {

				// Support: IE 11+, Edge 17 - 18+
				// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
				// two documents; shallow comparisons work.
				// eslint-disable-next-line eqeqeq
				outermostContext = context == document || context || outermost;
			}

			// Add elements passing elementMatchers directly to results
			// Support: iOS <=7 - 9 only
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching
			// elements by id. (see trac-14142)
			for ( ; i !== len && ( elem = elems[ i ] ) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;

					// Support: IE 11+, Edge 17 - 18+
					// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
					// two documents; shallow comparisons work.
					// eslint-disable-next-line eqeqeq
					if ( !context && elem.ownerDocument != document ) {
						setDocument( elem );
						xml = !documentIsHTML;
					}
					while ( ( matcher = elementMatchers[ j++ ] ) ) {
						if ( matcher( elem, context || document, xml ) ) {
							push.call( results, elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {

					// They will have gone through all possible matchers
					if ( ( elem = !matcher && elem ) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// `i` is now the count of elements visited above, and adding it to `matchedCount`
			// makes the latter nonnegative.
			matchedCount += i;

			// Apply set filters to unmatched elements
			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
			// no element matchers and no seed.
			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
			// numerically zero.
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( ( matcher = setMatchers[ j++ ] ) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {

					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !( unmatched[ i ] || setMatched[ i ] ) ) {
								setMatched[ i ] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					jQuery.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

function compile( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {

		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[ i ] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector,
			matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
}

/**
 * A low-level selection function that works with jQuery's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with jQuery selector compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
function select( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( ( selector = compiled.selector || selector ) );

	results = results || [];

	// Try to minimize operations if there is only one selector in the list and no seed
	// (the latter of which guarantees us context)
	if ( match.length === 1 ) {

		// Reduce context if the leading compound selector is an ID
		tokens = match[ 0 ] = match[ 0 ].slice( 0 );
		if ( tokens.length > 2 && ( token = tokens[ 0 ] ).type === "ID" &&
				context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[ 1 ].type ] ) {

			context = ( Expr.find.ID(
				token.matches[ 0 ].replace( runescape, funescape ),
				context
			) || [] )[ 0 ];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr.needsContext.test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[ i ];

			// Abort if we hit a combinator
			if ( Expr.relative[ ( type = token.type ) ] ) {
				break;
			}
			if ( ( find = Expr.find[ type ] ) ) {

				// Search, expanding context for leading sibling combinators
				if ( ( seed = find(
					token.matches[ 0 ].replace( runescape, funescape ),
					rsibling.test( tokens[ 0 ].type ) &&
						testContext( context.parentNode ) || context
				) ) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
}

// One-time assignments

// Support: Android <=4.0 - 4.1+
// Sort stability
support.sortStable = expando.split( "" ).sort( sortOrder ).join( "" ) === expando;

// Initialize against the default document
setDocument();

// Support: Android <=4.0 - 4.1+
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert( function( el ) {

	// Should return 1, but returns 4 (following)
	return el.compareDocumentPosition( document.createElement( "fieldset" ) ) & 1;
} );

jQuery.find = find;

// Deprecated
jQuery.expr[ ":" ] = jQuery.expr.pseudos;
jQuery.unique = jQuery.uniqueSort;

// These have always been private, but they used to be documented as part of
// Sizzle so let's maintain them for now for backwards compatibility purposes.
find.compile = compile;
find.select = select;
find.setDocument = setDocument;
find.tokenize = tokenize;

find.escape = jQuery.escapeSelector;
find.getText = jQuery.text;
find.isXML = jQuery.isXMLDoc;
find.selectors = jQuery.expr;
find.support = jQuery.support;
find.uniqueSort = jQuery.uniqueSort;

	/* eslint-enable */

} )();


var dir = function( elem, dir, until ) {
	var matched = [],
		truncate = until !== undefined;

	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
		if ( elem.nodeType === 1 ) {
			if ( truncate && jQuery( elem ).is( until ) ) {
				break;
			}
			matched.push( elem );
		}
	}
	return matched;
};


var siblings = function( n, elem ) {
	var matched = [];

	for ( ; n; n = n.nextSibling ) {
		if ( n.nodeType === 1 && n !== elem ) {
			matched.push( n );
		}
	}

	return matched;
};


var rneedsContext = jQuery.expr.match.needsContext;

var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			return !!qualifier.call( elem, i, elem ) !== not;
		} );
	}

	// Single element
	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		} );
	}

	// Arraylike of elements (jQuery, arguments, Array)
	if ( typeof qualifier !== "string" ) {
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
		} );
	}

	// Filtered directly for both simple and complex selectors
	return jQuery.filter( qualifier, elements, not );
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	if ( elems.length === 1 && elem.nodeType === 1 ) {
		return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
	}

	return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
		return elem.nodeType === 1;
	} ) );
};

jQuery.fn.extend( {
	find: function( selector ) {
		var i, ret,
			len = this.length,
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter( function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			} ) );
		}

		ret = this.pushStack( [] );

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		return len > 1 ? jQuery.uniqueSort( ret ) : ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow( this, selector || [], false ) );
	},
	not: function( selector ) {
		return this.pushStack( winnow( this, selector || [], true ) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
} );


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (trac-9521)
	// Strict HTML recognition (trac-11290: must start with <)
	// Shortcut simple #id case for speed
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[ 0 ] === "<" &&
				selector[ selector.length - 1 ] === ">" &&
				selector.length >= 3 ) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && ( match[ 1 ] || !context ) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[ 1 ] ) {
					context = context instanceof jQuery ? context[ 0 ] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[ 1 ],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {

							// Properties of context are called as methods if possible
							if ( isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[ 2 ] );

					if ( elem ) {

						// Inject the element directly into the jQuery object
						this[ 0 ] = elem;
						this.length = 1;
					}
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || root ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this[ 0 ] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( isFunction( selector ) ) {
			return root.ready !== undefined ?
				root.ready( selector ) :

				// Execute immediately if ready is not present
				selector( jQuery );
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,

	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend( {
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter( function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[ i ] ) ) {
					return true;
				}
			}
		} );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			targets = typeof selectors !== "string" && jQuery( selectors );

		// Positional selectors never match, since there's no _selection_ context
		if ( !rneedsContext.test( selectors ) ) {
			for ( ; i < l; i++ ) {
				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

					// Always skip document fragments
					if ( cur.nodeType < 11 && ( targets ?
						targets.index( cur ) > -1 :

						// Don't pass non-elements to jQuery#find
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector( cur, selectors ) ) ) {

						matched.push( cur );
						break;
					}
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.uniqueSort(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	}
} );

function sibling( cur, dir ) {
	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each( {
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, _i, until ) {
		return dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, _i, until ) {
		return dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, _i, until ) {
		return dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return siblings( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return siblings( elem.firstChild );
	},
	contents: function( elem ) {
		if ( elem.contentDocument != null &&

			// Support: IE 11+
			// <object> elements with no `data` attribute has an object
			// `contentDocument` with a `null` prototype.
			getProto( elem.contentDocument ) ) {

			return elem.contentDocument;
		}

		// Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
		// Treat the template element as a regular one in browsers that
		// don't support it.
		if ( nodeName( elem, "template" ) ) {
			elem = elem.content || elem;
		}

		return jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {

			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.uniqueSort( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
} );
var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



// Convert String-formatted options into Object-formatted ones
function createOptions( options ) {
	var object = {};
	jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	} );
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		createOptions( options ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,

		// Last fire value for non-forgettable lists
		memory,

		// Flag to know if list was already fired
		fired,

		// Flag to prevent firing
		locked,

		// Actual callback list
		list = [],

		// Queue of execution data for repeatable lists
		queue = [],

		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,

		// Fire callbacks
		fire = function() {

			// Enforce single-firing
			locked = locked || options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for ( ; queue.length; firingIndex = -1 ) {
				memory = queue.shift();
				while ( ++firingIndex < list.length ) {

					// Run callback and check for early termination
					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
						options.stopOnFalse ) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if ( !options.memory ) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if ( locked ) {

				// Keep an empty list if we have data for future add calls
				if ( memory ) {
					list = [];

				// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},

		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {

					// If we have memory from a past run, we should fire after adding
					if ( memory && !firing ) {
						firingIndex = list.length - 1;
						queue.push( memory );
					}

					( function add( args ) {
						jQuery.each( args, function( _, arg ) {
							if ( isFunction( arg ) ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && toType( arg ) !== "string" ) {

								// Inspect recursively
								add( arg );
							}
						} );
					} )( arguments );

					if ( memory && !firing ) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function() {
				jQuery.each( arguments, function( _, arg ) {
					var index;
					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
						list.splice( index, 1 );

						// Handle firing indexes
						if ( index <= firingIndex ) {
							firingIndex--;
						}
					}
				} );
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ?
					jQuery.inArray( fn, list ) > -1 :
					list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function() {
				if ( list ) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function() {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function() {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function() {
				locked = queue = [];
				if ( !memory && !firing ) {
					list = memory = "";
				}
				return this;
			},
			locked: function() {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( !locked ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					queue.push( args );
					if ( !firing ) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


function Identity( v ) {
	return v;
}
function Thrower( ex ) {
	throw ex;
}

function adoptValue( value, resolve, reject, noValue ) {
	var method;

	try {

		// Check for promise aspect first to privilege synchronous behavior
		if ( value && isFunction( ( method = value.promise ) ) ) {
			method.call( value ).done( resolve ).fail( reject );

		// Other thenables
		} else if ( value && isFunction( ( method = value.then ) ) ) {
			method.call( value, resolve, reject );

		// Other non-thenables
		} else {

			// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
			// * false: [ value ].slice( 0 ) => resolve( value )
			// * true: [ value ].slice( 1 ) => resolve()
			resolve.apply( undefined, [ value ].slice( noValue ) );
		}

	// For Promises/A+, convert exceptions into rejections
	// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
	// Deferred#then to conditionally suppress rejection.
	} catch ( value ) {

		// Support: Android 4.0 only
		// Strict mode functions invoked without .call/.apply get global-object context
		reject.apply( undefined, [ value ] );
	}
}

jQuery.extend( {

	Deferred: function( func ) {
		var tuples = [

				// action, add listener, callbacks,
				// ... .then handlers, argument index, [final state]
				[ "notify", "progress", jQuery.Callbacks( "memory" ),
					jQuery.Callbacks( "memory" ), 2 ],
				[ "resolve", "done", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 0, "resolved" ],
				[ "reject", "fail", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 1, "rejected" ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				"catch": function( fn ) {
					return promise.then( null, fn );
				},

				// Keep pipe for back-compat
				pipe: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;

					return jQuery.Deferred( function( newDefer ) {
						jQuery.each( tuples, function( _i, tuple ) {

							// Map tuples (progress, done, fail) to arguments (done, fail, progress)
							var fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

							// deferred.progress(function() { bind to newDefer or newDefer.notify })
							// deferred.done(function() { bind to newDefer or newDefer.resolve })
							// deferred.fail(function() { bind to newDefer or newDefer.reject })
							deferred[ tuple[ 1 ] ]( function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && isFunction( returned.promise ) ) {
									returned.promise()
										.progress( newDefer.notify )
										.done( newDefer.resolve )
										.fail( newDefer.reject );
								} else {
									newDefer[ tuple[ 0 ] + "With" ](
										this,
										fn ? [ returned ] : arguments
									);
								}
							} );
						} );
						fns = null;
					} ).promise();
				},
				then: function( onFulfilled, onRejected, onProgress ) {
					var maxDepth = 0;
					function resolve( depth, deferred, handler, special ) {
						return function() {
							var that = this,
								args = arguments,
								mightThrow = function() {
									var returned, then;

									// Support: Promises/A+ section 2.3.3.3.3
									// https://promisesaplus.com/#point-59
									// Ignore double-resolution attempts
									if ( depth < maxDepth ) {
										return;
									}

									returned = handler.apply( that, args );

									// Support: Promises/A+ section 2.3.1
									// https://promisesaplus.com/#point-48
									if ( returned === deferred.promise() ) {
										throw new TypeError( "Thenable self-resolution" );
									}

									// Support: Promises/A+ sections 2.3.3.1, 3.5
									// https://promisesaplus.com/#point-54
									// https://promisesaplus.com/#point-75
									// Retrieve `then` only once
									then = returned &&

										// Support: Promises/A+ section 2.3.4
										// https://promisesaplus.com/#point-64
										// Only check objects and functions for thenability
										( typeof returned === "object" ||
											typeof returned === "function" ) &&
										returned.then;

									// Handle a returned thenable
									if ( isFunction( then ) ) {

										// Special processors (notify) just wait for resolution
										if ( special ) {
											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special )
											);

										// Normal processors (resolve) also hook into progress
										} else {

											// ...and disregard older resolution values
											maxDepth++;

											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special ),
												resolve( maxDepth, deferred, Identity,
													deferred.notifyWith )
											);
										}

									// Handle all other returned values
									} else {

										// Only substitute handlers pass on context
										// and multiple values (non-spec behavior)
										if ( handler !== Identity ) {
											that = undefined;
											args = [ returned ];
										}

										// Process the value(s)
										// Default process is resolve
										( special || deferred.resolveWith )( that, args );
									}
								},

								// Only normal processors (resolve) catch and reject exceptions
								process = special ?
									mightThrow :
									function() {
										try {
											mightThrow();
										} catch ( e ) {

											if ( jQuery.Deferred.exceptionHook ) {
												jQuery.Deferred.exceptionHook( e,
													process.error );
											}

											// Support: Promises/A+ section 2.3.3.3.4.1
											// https://promisesaplus.com/#point-61
											// Ignore post-resolution exceptions
											if ( depth + 1 >= maxDepth ) {

												// Only substitute handlers pass on context
												// and multiple values (non-spec behavior)
												if ( handler !== Thrower ) {
													that = undefined;
													args = [ e ];
												}

												deferred.rejectWith( that, args );
											}
										}
									};

							// Support: Promises/A+ section 2.3.3.3.1
							// https://promisesaplus.com/#point-57
							// Re-resolve promises immediately to dodge false rejection from
							// subsequent errors
							if ( depth ) {
								process();
							} else {

								// Call an optional hook to record the error, in case of exception
								// since it's otherwise lost when execution goes async
								if ( jQuery.Deferred.getErrorHook ) {
									process.error = jQuery.Deferred.getErrorHook();

								// The deprecated alias of the above. While the name suggests
								// returning the stack, not an error instance, jQuery just passes
								// it directly to `console.warn` so both will work; an instance
								// just better cooperates with source maps.
								} else if ( jQuery.Deferred.getStackHook ) {
									process.error = jQuery.Deferred.getStackHook();
								}
								window.setTimeout( process );
							}
						};
					}

					return jQuery.Deferred( function( newDefer ) {

						// progress_handlers.add( ... )
						tuples[ 0 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onProgress ) ?
									onProgress :
									Identity,
								newDefer.notifyWith
							)
						);

						// fulfilled_handlers.add( ... )
						tuples[ 1 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onFulfilled ) ?
									onFulfilled :
									Identity
							)
						);

						// rejected_handlers.add( ... )
						tuples[ 2 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onRejected ) ?
									onRejected :
									Thrower
							)
						);
					} ).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 5 ];

			// promise.progress = list.add
			// promise.done = list.add
			// promise.fail = list.add
			promise[ tuple[ 1 ] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(
					function() {

						// state = "resolved" (i.e., fulfilled)
						// state = "rejected"
						state = stateString;
					},

					// rejected_callbacks.disable
					// fulfilled_callbacks.disable
					tuples[ 3 - i ][ 2 ].disable,

					// rejected_handlers.disable
					// fulfilled_handlers.disable
					tuples[ 3 - i ][ 3 ].disable,

					// progress_callbacks.lock
					tuples[ 0 ][ 2 ].lock,

					// progress_handlers.lock
					tuples[ 0 ][ 3 ].lock
				);
			}

			// progress_handlers.fire
			// fulfilled_handlers.fire
			// rejected_handlers.fire
			list.add( tuple[ 3 ].fire );

			// deferred.notify = function() { deferred.notifyWith(...) }
			// deferred.resolve = function() { deferred.resolveWith(...) }
			// deferred.reject = function() { deferred.rejectWith(...) }
			deferred[ tuple[ 0 ] ] = function() {
				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
				return this;
			};

			// deferred.notifyWith = list.fireWith
			// deferred.resolveWith = list.fireWith
			// deferred.rejectWith = list.fireWith
			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
		} );

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( singleValue ) {
		var

			// count of uncompleted subordinates
			remaining = arguments.length,

			// count of unprocessed arguments
			i = remaining,

			// subordinate fulfillment data
			resolveContexts = Array( i ),
			resolveValues = slice.call( arguments ),

			// the primary Deferred
			primary = jQuery.Deferred(),

			// subordinate callback factory
			updateFunc = function( i ) {
				return function( value ) {
					resolveContexts[ i ] = this;
					resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( !( --remaining ) ) {
						primary.resolveWith( resolveContexts, resolveValues );
					}
				};
			};

		// Single- and empty arguments are adopted like Promise.resolve
		if ( remaining <= 1 ) {
			adoptValue( singleValue, primary.done( updateFunc( i ) ).resolve, primary.reject,
				!remaining );

			// Use .then() to unwrap secondary thenables (cf. gh-3000)
			if ( primary.state() === "pending" ||
				isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

				return primary.then();
			}
		}

		// Multiple arguments are aggregated like Promise.all array elements
		while ( i-- ) {
			adoptValue( resolveValues[ i ], updateFunc( i ), primary.reject );
		}

		return primary.promise();
	}
} );


// These usually indicate a programmer mistake during development,
// warn about them ASAP rather than swallowing them by default.
var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

// If `jQuery.Deferred.getErrorHook` is defined, `asyncError` is an error
// captured before the async barrier to get the original error cause
// which may otherwise be hidden.
jQuery.Deferred.exceptionHook = function( error, asyncError ) {

	// Support: IE 8 - 9 only
	// Console exists when dev tools are open, which can happen at any time
	if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
		window.console.warn( "jQuery.Deferred exception: " + error.message,
			error.stack, asyncError );
	}
};




jQuery.readyException = function( error ) {
	window.setTimeout( function() {
		throw error;
	} );
};




// The deferred used on DOM ready
var readyList = jQuery.Deferred();

jQuery.fn.ready = function( fn ) {

	readyList
		.then( fn )

		// Wrap jQuery.readyException in a function so that the lookup
		// happens at the time of error handling instead of callback
		// registration.
		.catch( function( error ) {
			jQuery.readyException( error );
		} );

	return this;
};

jQuery.extend( {

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See trac-6781
	readyWait: 1,

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );
	}
} );

jQuery.ready.then = readyList.then;

// The ready event handler and self cleanup method
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed );
	window.removeEventListener( "load", completed );
	jQuery.ready();
}

// Catch cases where $(document).ready() is called
// after the browser event has already occurred.
// Support: IE <=9 - 10 only
// Older IE sometimes signals "interactive" too soon
if ( document.readyState === "complete" ||
	( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

	// Handle it asynchronously to allow scripts the opportunity to delay ready
	window.setTimeout( jQuery.ready );

} else {

	// Use the handy event callback
	document.addEventListener( "DOMContentLoaded", completed );

	// A fallback to window.onload, that will always work
	window.addEventListener( "load", completed );
}




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( toType( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			access( elems, fn, i, key[ i ], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {

			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, _key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn(
					elems[ i ], key, raw ?
						value :
						value.call( elems[ i ], i, fn( elems[ i ], key ) )
				);
			}
		}
	}

	if ( chainable ) {
		return elems;
	}

	// Gets
	if ( bulk ) {
		return fn.call( elems );
	}

	return len ? fn( elems[ 0 ], key ) : emptyGet;
};


// Matches dashed string for camelizing
var rmsPrefix = /^-ms-/,
	rdashAlpha = /-([a-z])/g;

// Used by camelCase as callback to replace()
function fcamelCase( _all, letter ) {
	return letter.toUpperCase();
}

// Convert dashed to camelCase; used by the css and data modules
// Support: IE <=9 - 11, Edge 12 - 15
// Microsoft forgot to hump their vendor prefix (trac-9572)
function camelCase( string ) {
	return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
}
var acceptData = function( owner ) {

	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};




function Data() {
	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;

Data.prototype = {

	cache: function( owner ) {

		// Check if the owner object already has a cache
		var value = owner[ this.expando ];

		// If not, create one
		if ( !value ) {
			value = {};

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see trac-8335.
			// Always return an empty object.
			if ( acceptData( owner ) ) {

				// If it is a node unlikely to be stringify-ed or looped over
				// use plain assignment
				if ( owner.nodeType ) {
					owner[ this.expando ] = value;

				// Otherwise secure it in a non-enumerable property
				// configurable must be true to allow the property to be
				// deleted when data is removed
				} else {
					Object.defineProperty( owner, this.expando, {
						value: value,
						configurable: true
					} );
				}
			}
		}

		return value;
	},
	set: function( owner, data, value ) {
		var prop,
			cache = this.cache( owner );

		// Handle: [ owner, key, value ] args
		// Always use camelCase key (gh-2257)
		if ( typeof data === "string" ) {
			cache[ camelCase( data ) ] = value;

		// Handle: [ owner, { properties } ] args
		} else {

			// Copy the properties one-by-one to the cache object
			for ( prop in data ) {
				cache[ camelCase( prop ) ] = data[ prop ];
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		return key === undefined ?
			this.cache( owner ) :

			// Always use camelCase key (gh-2257)
			owner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];
	},
	access: function( owner, key, value ) {

		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				( ( key && typeof key === "string" ) && value === undefined ) ) {

			return this.get( owner, key );
		}

		// When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i,
			cache = owner[ this.expando ];

		if ( cache === undefined ) {
			return;
		}

		if ( key !== undefined ) {

			// Support array or space separated string of keys
			if ( Array.isArray( key ) ) {

				// If key is an array of keys...
				// We always set camelCase keys, so remove that.
				key = key.map( camelCase );
			} else {
				key = camelCase( key );

				// If a key with the spaces exists, use it.
				// Otherwise, create an array by matching non-whitespace
				key = key in cache ?
					[ key ] :
					( key.match( rnothtmlwhite ) || [] );
			}

			i = key.length;

			while ( i-- ) {
				delete cache[ key[ i ] ];
			}
		}

		// Remove the expando if there's no more data
		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

			// Support: Chrome <=35 - 45
			// Webkit & Blink performance suffers when deleting properties
			// from DOM nodes, so set to undefined instead
			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
			if ( owner.nodeType ) {
				owner[ this.expando ] = undefined;
			} else {
				delete owner[ this.expando ];
			}
		}
	},
	hasData: function( owner ) {
		var cache = owner[ this.expando ];
		return cache !== undefined && !jQuery.isEmptyObject( cache );
	}
};
var dataPriv = new Data();

var dataUser = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /[A-Z]/g;

function getData( data ) {
	if ( data === "true" ) {
		return true;
	}

	if ( data === "false" ) {
		return false;
	}

	if ( data === "null" ) {
		return null;
	}

	// Only convert to a number if it doesn't change the string
	if ( data === +data + "" ) {
		return +data;
	}

	if ( rbrace.test( data ) ) {
		return JSON.parse( data );
	}

	return data;
}

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = getData( data );
			} catch ( e ) {}

			// Make sure we set the data so it isn't changed later
			dataUser.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend( {
	hasData: function( elem ) {
		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return dataUser.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		dataUser.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to dataPriv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return dataPriv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		dataPriv.remove( elem, name );
	}
} );

jQuery.fn.extend( {
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = dataUser.get( elem );

				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE 11 only
						// The attrs elements can be null (trac-14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = camelCase( name.slice( 5 ) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					dataPriv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each( function() {
				dataUser.set( this, key );
			} );
		}

		return access( this, function( value ) {
			var data;

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {

				// Attempt to get data from the cache
				// The key will always be camelCased in Data
				data = dataUser.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each( function() {

				// We always store the camelCased key
				dataUser.set( this, key, value );
			} );
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each( function() {
			dataUser.remove( this, key );
		} );
	}
} );


jQuery.extend( {
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = dataPriv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || Array.isArray( data ) ) {
					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
			empty: jQuery.Callbacks( "once memory" ).add( function() {
				dataPriv.remove( elem, [ type + "queue", key ] );
			} )
		} );
	}
} );

jQuery.fn.extend( {
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[ 0 ], type );
		}

		return data === undefined ?
			this :
			this.each( function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			} );
	},
	dequeue: function( type ) {
		return this.each( function() {
			jQuery.dequeue( this, type );
		} );
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},

	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
} );
var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var documentElement = document.documentElement;



	var isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem );
		},
		composed = { composed: true };

	// Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only
	// Check attachment across shadow DOM boundaries when possible (gh-3504)
	// Support: iOS 10.0-10.2 only
	// Early iOS 10 versions support `attachShadow` but not `getRootNode`,
	// leading to errors. We need to check for `getRootNode`.
	if ( documentElement.getRootNode ) {
		isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem ) ||
				elem.getRootNode( composed ) === elem.ownerDocument;
		};
	}
var isHiddenWithinTree = function( elem, el ) {

		// isHiddenWithinTree might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;

		// Inline style trumps all
		return elem.style.display === "none" ||
			elem.style.display === "" &&

			// Otherwise, check computed style
			// Support: Firefox <=43 - 45
			// Disconnected elements can have computed display: none, so first confirm that elem is
			// in the document.
			isAttached( elem ) &&

			jQuery.css( elem, "display" ) === "none";
	};



function adjustCSS( elem, prop, valueParts, tween ) {
	var adjusted, scale,
		maxIterations = 20,
		currentValue = tween ?
			function() {
				return tween.cur();
			} :
			function() {
				return jQuery.css( elem, prop, "" );
			},
		initial = currentValue(),
		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

		// Starting value computation is required for potential unit mismatches
		initialInUnit = elem.nodeType &&
			( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
			rcssNum.exec( jQuery.css( elem, prop ) );

	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

		// Support: Firefox <=54
		// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
		initial = initial / 2;

		// Trust units reported by jQuery.css
		unit = unit || initialInUnit[ 3 ];

		// Iteratively approximate from a nonzero starting point
		initialInUnit = +initial || 1;

		while ( maxIterations-- ) {

			// Evaluate and update our best guess (doubling guesses that zero out).
			// Finish if the scale equals or crosses 1 (making the old*new product non-positive).
			jQuery.style( elem, prop, initialInUnit + unit );
			if ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {
				maxIterations = 0;
			}
			initialInUnit = initialInUnit / scale;

		}

		initialInUnit = initialInUnit * 2;
		jQuery.style( elem, prop, initialInUnit + unit );

		// Make sure we update the tween properties later on
		valueParts = valueParts || [];
	}

	if ( valueParts ) {
		initialInUnit = +initialInUnit || +initial || 0;

		// Apply relative offset (+=/-=) if specified
		adjusted = valueParts[ 1 ] ?
			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
			+valueParts[ 2 ];
		if ( tween ) {
			tween.unit = unit;
			tween.start = initialInUnit;
			tween.end = adjusted;
		}
	}
	return adjusted;
}


var defaultDisplayMap = {};

function getDefaultDisplay( elem ) {
	var temp,
		doc = elem.ownerDocument,
		nodeName = elem.nodeName,
		display = defaultDisplayMap[ nodeName ];

	if ( display ) {
		return display;
	}

	temp = doc.body.appendChild( doc.createElement( nodeName ) );
	display = jQuery.css( temp, "display" );

	temp.parentNode.removeChild( temp );

	if ( display === "none" ) {
		display = "block";
	}
	defaultDisplayMap[ nodeName ] = display;

	return display;
}

function showHide( elements, show ) {
	var display, elem,
		values = [],
		index = 0,
		length = elements.length;

	// Determine new display value for elements that need to change
	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		display = elem.style.display;
		if ( show ) {

			// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
			// check is required in this first loop unless we have a nonempty display value (either
			// inline or about-to-be-restored)
			if ( display === "none" ) {
				values[ index ] = dataPriv.get( elem, "display" ) || null;
				if ( !values[ index ] ) {
					elem.style.display = "";
				}
			}
			if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
				values[ index ] = getDefaultDisplay( elem );
			}
		} else {
			if ( display !== "none" ) {
				values[ index ] = "none";

				// Remember what we're overwriting
				dataPriv.set( elem, "display", display );
			}
		}
	}

	// Set the display of the elements in a second loop to avoid constant reflow
	for ( index = 0; index < length; index++ ) {
		if ( values[ index ] != null ) {
			elements[ index ].style.display = values[ index ];
		}
	}

	return elements;
}

jQuery.fn.extend( {
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each( function() {
			if ( isHiddenWithinTree( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		} );
	}
} );
var rcheckableType = ( /^(?:checkbox|radio)$/i );

var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]*)/i );

var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );



( function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Android 4.0 - 4.3 only
	// Check state lost if the name is set (trac-11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (trac-14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Android <=4.1 only
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE <=11 only
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;

	// Support: IE <=9 only
	// IE <=9 replaces <option> tags with their contents when inserted outside of
	// the select element.
	div.innerHTML = "<option></option>";
	support.option = !!div.lastChild;
} )();


// We have to close these tags to support XHTML (trac-13200)
var wrapMap = {

	// XHTML parsers do not magically insert elements in the
	// same way that tag soup parsers do. So we cannot shorten
	// this by omitting <tbody> or other required elements.
	thead: [ 1, "<table>", "</table>" ],
	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

	_default: [ 0, "", "" ]
};

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

// Support: IE <=9 only
if ( !support.option ) {
	wrapMap.optgroup = wrapMap.option = [ 1, "<select multiple='multiple'>", "</select>" ];
}


function getAll( context, tag ) {

	// Support: IE <=9 - 11 only
	// Use typeof to avoid zero-argument method invocation on host objects (trac-15151)
	var ret;

	if ( typeof context.getElementsByTagName !== "undefined" ) {
		ret = context.getElementsByTagName( tag || "*" );

	} else if ( typeof context.querySelectorAll !== "undefined" ) {
		ret = context.querySelectorAll( tag || "*" );

	} else {
		ret = [];
	}

	if ( tag === undefined || tag && nodeName( context, tag ) ) {
		return jQuery.merge( [ context ], ret );
	}

	return ret;
}


// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		dataPriv.set(
			elems[ i ],
			"globalEval",
			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
		);
	}
}


var rhtml = /<|&#?\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
	var elem, tmp, tag, wrap, attached, j,
		fragment = context.createDocumentFragment(),
		nodes = [],
		i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		elem = elems[ i ];

		if ( elem || elem === 0 ) {

			// Add nodes directly
			if ( toType( elem ) === "object" ) {

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
				nodes.push( context.createTextNode( elem ) );

			// Convert html into DOM nodes
			} else {
				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

				// Deserialize a standard representation
				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
				wrap = wrapMap[ tag ] || wrapMap._default;
				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

				// Descend through wrappers to the right content
				j = wrap[ 0 ];
				while ( j-- ) {
					tmp = tmp.lastChild;
				}

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, tmp.childNodes );

				// Remember the top-level container
				tmp = fragment.firstChild;

				// Ensure the created nodes are orphaned (trac-12392)
				tmp.textContent = "";
			}
		}
	}

	// Remove wrapper from fragment
	fragment.textContent = "";

	i = 0;
	while ( ( elem = nodes[ i++ ] ) ) {

		// Skip elements already in the context collection (trac-4087)
		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
			if ( ignored ) {
				ignored.push( elem );
			}
			continue;
		}

		attached = isAttached( elem );

		// Append to fragment
		tmp = getAll( fragment.appendChild( elem ), "script" );

		// Preserve script evaluation history
		if ( attached ) {
			setGlobalEval( tmp );
		}

		// Capture executables
		if ( scripts ) {
			j = 0;
			while ( ( elem = tmp[ j++ ] ) ) {
				if ( rscriptType.test( elem.type || "" ) ) {
					scripts.push( elem );
				}
			}
		}
	}

	return fragment;
}


var rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

function on( elem, types, selector, data, fn, one ) {
	var origFn, type;

	// Types can be a map of types/handlers
	if ( typeof types === "object" ) {

		// ( types-Object, selector, data )
		if ( typeof selector !== "string" ) {

			// ( types-Object, data )
			data = data || selector;
			selector = undefined;
		}
		for ( type in types ) {
			on( elem, type, selector, data, types[ type ], one );
		}
		return elem;
	}

	if ( data == null && fn == null ) {

		// ( types, fn )
		fn = selector;
		data = selector = undefined;
	} else if ( fn == null ) {
		if ( typeof selector === "string" ) {

			// ( types, selector, fn )
			fn = data;
			data = undefined;
		} else {

			// ( types, data, fn )
			fn = data;
			data = selector;
			selector = undefined;
		}
	}
	if ( fn === false ) {
		fn = returnFalse;
	} else if ( !fn ) {
		return elem;
	}

	if ( one === 1 ) {
		origFn = fn;
		fn = function( event ) {

			// Can use an empty set, since event contains the info
			jQuery().off( event );
			return origFn.apply( this, arguments );
		};

		// Use same guid so caller can remove using origFn
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	}
	return elem.each( function() {
		jQuery.event.add( this, types, fn, data, selector );
	} );
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.get( elem );

		// Only attach events to objects that accept data
		if ( !acceptData( elem ) ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Ensure that invalid selectors throw exceptions at attach time
		// Evaluate against documentElement in case elem is a non-element node (e.g., document)
		if ( selector ) {
			jQuery.find.matchesSelector( documentElement, selector );
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !( events = elemData.events ) ) {
			events = elemData.events = Object.create( null );
		}
		if ( !( eventHandle = elemData.handle ) ) {
			eventHandle = elemData.handle = function( e ) {

				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend( {
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join( "." )
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !( handlers = events[ type ] ) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup ||
					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

		if ( !elemData || !( events = elemData.events ) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[ 2 ] &&
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector ||
						selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown ||
					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove data and the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			dataPriv.remove( elem, "handle events" );
		}
	},

	dispatch: function( nativeEvent ) {

		var i, j, ret, matched, handleObj, handlerQueue,
			args = new Array( arguments.length ),

			// Make a writable jQuery.Event from the native event object
			event = jQuery.event.fix( nativeEvent ),

			handlers = (
				dataPriv.get( this, "events" ) || Object.create( null )
			)[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[ 0 ] = event;

		for ( i = 1; i < arguments.length; i++ ) {
			args[ i ] = arguments[ i ];
		}

		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( ( handleObj = matched.handlers[ j++ ] ) &&
				!event.isImmediatePropagationStopped() ) {

				// If the event is namespaced, then each handler is only invoked if it is
				// specially universal or its namespaces are a superset of the event's.
				if ( !event.rnamespace || handleObj.namespace === false ||
					event.rnamespace.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
						handleObj.handler ).apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( ( event.result = ret ) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, handleObj, sel, matchedHandlers, matchedSelectors,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		if ( delegateCount &&

			// Support: IE <=9
			// Black-hole SVG <use> instance trees (trac-13180)
			cur.nodeType &&

			// Support: Firefox <=42
			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
			// Support: IE 11 only
			// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
			!( event.type === "click" && event.button >= 1 ) ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't check non-elements (trac-13208)
				// Don't process clicks on disabled elements (trac-6911, trac-8165, trac-11382, trac-11764)
				if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
					matchedHandlers = [];
					matchedSelectors = {};
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (trac-13203)
						sel = handleObj.selector + " ";

						if ( matchedSelectors[ sel ] === undefined ) {
							matchedSelectors[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) > -1 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matchedSelectors[ sel ] ) {
							matchedHandlers.push( handleObj );
						}
					}
					if ( matchedHandlers.length ) {
						handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		cur = this;
		if ( delegateCount < handlers.length ) {
			handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
		}

		return handlerQueue;
	},

	addProp: function( name, hook ) {
		Object.defineProperty( jQuery.Event.prototype, name, {
			enumerable: true,
			configurable: true,

			get: isFunction( hook ) ?
				function() {
					if ( this.originalEvent ) {
						return hook( this.originalEvent );
					}
				} :
				function() {
					if ( this.originalEvent ) {
						return this.originalEvent[ name ];
					}
				},

			set: function( value ) {
				Object.defineProperty( this, name, {
					enumerable: true,
					configurable: true,
					writable: true,
					value: value
				} );
			}
		} );
	},

	fix: function( originalEvent ) {
		return originalEvent[ jQuery.expando ] ?
			originalEvent :
			new jQuery.Event( originalEvent );
	},

	special: {
		load: {

			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		click: {

			// Utilize native event to ensure correct state for checkable inputs
			setup: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Claim the first handler
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					// dataPriv.set( el, "click", ... )
					leverageNative( el, "click", true );
				}

				// Return false to allow normal processing in the caller
				return false;
			},
			trigger: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Force setup before triggering a click
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					leverageNative( el, "click" );
				}

				// Return non-false to allow normal event-path propagation
				return true;
			},

			// For cross-browser consistency, suppress native .click() on links
			// Also prevent it if we're currently inside a leveraged native-event stack
			_default: function( event ) {
				var target = event.target;
				return rcheckableType.test( target.type ) &&
					target.click && nodeName( target, "input" ) &&
					dataPriv.get( target, "click" ) ||
					nodeName( target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	}
};

// Ensure the presence of an event listener that handles manually-triggered
// synthetic events by interrupting progress until reinvoked in response to
// *native* events that it fires directly, ensuring that state changes have
// already occurred before other listeners are invoked.
function leverageNative( el, type, isSetup ) {

	// Missing `isSetup` indicates a trigger call, which must force setup through jQuery.event.add
	if ( !isSetup ) {
		if ( dataPriv.get( el, type ) === undefined ) {
			jQuery.event.add( el, type, returnTrue );
		}
		return;
	}

	// Register the controller as a special universal handler for all event namespaces
	dataPriv.set( el, type, false );
	jQuery.event.add( el, type, {
		namespace: false,
		handler: function( event ) {
			var result,
				saved = dataPriv.get( this, type );

			if ( ( event.isTrigger & 1 ) && this[ type ] ) {

				// Interrupt processing of the outer synthetic .trigger()ed event
				if ( !saved ) {

					// Store arguments for use when handling the inner native event
					// There will always be at least one argument (an event object), so this array
					// will not be confused with a leftover capture object.
					saved = slice.call( arguments );
					dataPriv.set( this, type, saved );

					// Trigger the native event and capture its result
					this[ type ]();
					result = dataPriv.get( this, type );
					dataPriv.set( this, type, false );

					if ( saved !== result ) {

						// Cancel the outer synthetic event
						event.stopImmediatePropagation();
						event.preventDefault();

						return result;
					}

				// If this is an inner synthetic event for an event with a bubbling surrogate
				// (focus or blur), assume that the surrogate already propagated from triggering
				// the native event and prevent that from happening again here.
				// This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the
				// bubbling surrogate propagates *after* the non-bubbling base), but that seems
				// less bad than duplication.
				} else if ( ( jQuery.event.special[ type ] || {} ).delegateType ) {
					event.stopPropagation();
				}

			// If this is a native event triggered above, everything is now in order
			// Fire an inner synthetic event with the original arguments
			} else if ( saved ) {

				// ...and capture the result
				dataPriv.set( this, type, jQuery.event.trigger(
					saved[ 0 ],
					saved.slice( 1 ),
					this
				) );

				// Abort handling of the native event by all jQuery handlers while allowing
				// native handlers on the same element to run. On target, this is achieved
				// by stopping immediate propagation just on the jQuery event. However,
				// the native event is re-wrapped by a jQuery one on each level of the
				// propagation so the only way to stop it for jQuery is to stop it for
				// everyone via native `stopPropagation()`. This is not a problem for
				// focus/blur which don't bubble, but it does also stop click on checkboxes
				// and radios. We accept this limitation.
				event.stopPropagation();
				event.isImmediatePropagationStopped = returnTrue;
			}
		}
	} );
}

jQuery.removeEvent = function( elem, type, handle ) {

	// This "if" is needed for plain objects
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle );
	}
};

jQuery.Event = function( src, props ) {

	// Allow instantiation without the 'new' keyword
	if ( !( this instanceof jQuery.Event ) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&

				// Support: Android <=2.3 only
				src.returnValue === false ?
			returnTrue :
			returnFalse;

		// Create target properties
		// Support: Safari <=6 - 7 only
		// Target should not be a text node (trac-504, trac-13143)
		this.target = ( src.target && src.target.nodeType === 3 ) ?
			src.target.parentNode :
			src.target;

		this.currentTarget = src.currentTarget;
		this.relatedTarget = src.relatedTarget;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || Date.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	constructor: jQuery.Event,
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,
	isSimulated: false,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && !this.isSimulated ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Includes all common event props including KeyEvent and MouseEvent specific props
jQuery.each( {
	altKey: true,
	bubbles: true,
	cancelable: true,
	changedTouches: true,
	ctrlKey: true,
	detail: true,
	eventPhase: true,
	metaKey: true,
	pageX: true,
	pageY: true,
	shiftKey: true,
	view: true,
	"char": true,
	code: true,
	charCode: true,
	key: true,
	keyCode: true,
	button: true,
	buttons: true,
	clientX: true,
	clientY: true,
	offsetX: true,
	offsetY: true,
	pointerId: true,
	pointerType: true,
	screenX: true,
	screenY: true,
	targetTouches: true,
	toElement: true,
	touches: true,
	which: true
}, jQuery.event.addProp );

jQuery.each( { focus: "focusin", blur: "focusout" }, function( type, delegateType ) {

	function focusMappedHandler( nativeEvent ) {
		if ( document.documentMode ) {

			// Support: IE 11+
			// Attach a single focusin/focusout handler on the document while someone wants
			// focus/blur. This is because the former are synchronous in IE while the latter
			// are async. In other browsers, all those handlers are invoked synchronously.

			// `handle` from private data would already wrap the event, but we need
			// to change the `type` here.
			var handle = dataPriv.get( this, "handle" ),
				event = jQuery.event.fix( nativeEvent );
			event.type = nativeEvent.type === "focusin" ? "focus" : "blur";
			event.isSimulated = true;

			// First, handle focusin/focusout
			handle( nativeEvent );

			// ...then, handle focus/blur
			//
			// focus/blur don't bubble while focusin/focusout do; simulate the former by only
			// invoking the handler at the lower level.
			if ( event.target === event.currentTarget ) {

				// The setup part calls `leverageNative`, which, in turn, calls
				// `jQuery.event.add`, so event handle will already have been set
				// by this point.
				handle( event );
			}
		} else {

			// For non-IE browsers, attach a single capturing handler on the document
			// while someone wants focusin/focusout.
			jQuery.event.simulate( delegateType, nativeEvent.target,
				jQuery.event.fix( nativeEvent ) );
		}
	}

	jQuery.event.special[ type ] = {

		// Utilize native event if possible so blur/focus sequence is correct
		setup: function() {

			var attaches;

			// Claim the first handler
			// dataPriv.set( this, "focus", ... )
			// dataPriv.set( this, "blur", ... )
			leverageNative( this, type, true );

			if ( document.documentMode ) {

				// Support: IE 9 - 11+
				// We use the same native handler for focusin & focus (and focusout & blur)
				// so we need to coordinate setup & teardown parts between those events.
				// Use `delegateType` as the key as `type` is already used by `leverageNative`.
				attaches = dataPriv.get( this, delegateType );
				if ( !attaches ) {
					this.addEventListener( delegateType, focusMappedHandler );
				}
				dataPriv.set( this, delegateType, ( attaches || 0 ) + 1 );
			} else {

				// Return false to allow normal processing in the caller
				return false;
			}
		},
		trigger: function() {

			// Force setup before trigger
			leverageNative( this, type );

			// Return non-false to allow normal event-path propagation
			return true;
		},

		teardown: function() {
			var attaches;

			if ( document.documentMode ) {
				attaches = dataPriv.get( this, delegateType ) - 1;
				if ( !attaches ) {
					this.removeEventListener( delegateType, focusMappedHandler );
					dataPriv.remove( this, delegateType );
				} else {
					dataPriv.set( this, delegateType, attaches );
				}
			} else {

				// Return false to indicate standard teardown should be applied
				return false;
			}
		},

		// Suppress native focus or blur if we're currently inside
		// a leveraged native-event stack
		_default: function( event ) {
			return dataPriv.get( event.target, type );
		},

		delegateType: delegateType
	};

	// Support: Firefox <=44
	// Firefox doesn't have focus(in | out) events
	// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
	//
	// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
	// focus(in | out) events fire after focus & blur events,
	// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
	// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
	//
	// Support: IE 9 - 11+
	// To preserve relative focusin/focus & focusout/blur event order guaranteed on the 3.x branch,
	// attach a single handler for both events in IE.
	jQuery.event.special[ delegateType ] = {
		setup: function() {

			// Handle: regular nodes (via `this.ownerDocument`), window
			// (via `this.document`) & document (via `this`).
			var doc = this.ownerDocument || this.document || this,
				dataHolder = document.documentMode ? this : doc,
				attaches = dataPriv.get( dataHolder, delegateType );

			// Support: IE 9 - 11+
			// We use the same native handler for focusin & focus (and focusout & blur)
			// so we need to coordinate setup & teardown parts between those events.
			// Use `delegateType` as the key as `type` is already used by `leverageNative`.
			if ( !attaches ) {
				if ( document.documentMode ) {
					this.addEventListener( delegateType, focusMappedHandler );
				} else {
					doc.addEventListener( type, focusMappedHandler, true );
				}
			}
			dataPriv.set( dataHolder, delegateType, ( attaches || 0 ) + 1 );
		},
		teardown: function() {
			var doc = this.ownerDocument || this.document || this,
				dataHolder = document.documentMode ? this : doc,
				attaches = dataPriv.get( dataHolder, delegateType ) - 1;

			if ( !attaches ) {
				if ( document.documentMode ) {
					this.removeEventListener( delegateType, focusMappedHandler );
				} else {
					doc.removeEventListener( type, focusMappedHandler, true );
				}
				dataPriv.remove( dataHolder, delegateType );
			} else {
				dataPriv.set( dataHolder, delegateType, attaches );
			}
		}
	};
} );

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
jQuery.each( {
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mouseenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
} );

jQuery.fn.extend( {

	on: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn );
	},
	one: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {

			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ?
					handleObj.origType + "." + handleObj.namespace :
					handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {

			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {

			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each( function() {
			jQuery.event.remove( this, types, fn, selector );
		} );
	}
} );


var

	// Support: IE <=10 - 11, Edge 12 - 13 only
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,

	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,

	rcleanScript = /^\s*<!\[CDATA\[|\]\]>\s*$/g;

// Prefer a tbody over its parent table for containing new rows
function manipulationTarget( elem, content ) {
	if ( nodeName( elem, "table" ) &&
		nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

		return jQuery( elem ).children( "tbody" )[ 0 ] || elem;
	}

	return elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	if ( ( elem.type || "" ).slice( 0, 5 ) === "true/" ) {
		elem.type = elem.type.slice( 5 );
	} else {
		elem.removeAttribute( "type" );
	}

	return elem;
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( dataPriv.hasData( src ) ) {
		pdataOld = dataPriv.get( src );
		events = pdataOld.events;

		if ( events ) {
			dataPriv.remove( dest, "handle events" );

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( dataUser.hasData( src ) ) {
		udataOld = dataUser.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		dataUser.set( dest, udataCur );
	}
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

function domManip( collection, args, callback, ignored ) {

	// Flatten any nested arrays
	args = flat( args );

	var fragment, first, scripts, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args[ 0 ],
		valueIsFunction = isFunction( value );

	// We can't cloneNode fragments that contain checked, in WebKit
	if ( valueIsFunction ||
			( l > 1 && typeof value === "string" &&
				!support.checkClone && rchecked.test( value ) ) ) {
		return collection.each( function( index ) {
			var self = collection.eq( index );
			if ( valueIsFunction ) {
				args[ 0 ] = value.call( this, index, self.html() );
			}
			domManip( self, args, callback, ignored );
		} );
	}

	if ( l ) {
		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
		first = fragment.firstChild;

		if ( fragment.childNodes.length === 1 ) {
			fragment = first;
		}

		// Require either new content or an interest in ignored elements to invoke the callback
		if ( first || ignored ) {
			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
			hasScripts = scripts.length;

			// Use the original fragment for the last item
			// instead of the first because it can end up
			// being emptied incorrectly in certain situations (trac-8070).
			for ( ; i < l; i++ ) {
				node = fragment;

				if ( i !== iNoClone ) {
					node = jQuery.clone( node, true, true );

					// Keep references to cloned scripts for later restoration
					if ( hasScripts ) {

						// Support: Android <=4.0 only, PhantomJS 1 only
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( scripts, getAll( node, "script" ) );
					}
				}

				callback.call( collection[ i ], node, i );
			}

			if ( hasScripts ) {
				doc = scripts[ scripts.length - 1 ].ownerDocument;

				// Re-enable scripts
				jQuery.map( scripts, restoreScript );

				// Evaluate executable scripts on first document insertion
				for ( i = 0; i < hasScripts; i++ ) {
					node = scripts[ i ];
					if ( rscriptType.test( node.type || "" ) &&
						!dataPriv.access( node, "globalEval" ) &&
						jQuery.contains( doc, node ) ) {

						if ( node.src && ( node.type || "" ).toLowerCase()  !== "module" ) {

							// Optional AJAX dependency, but won't run scripts if not present
							if ( jQuery._evalUrl && !node.noModule ) {
								jQuery._evalUrl( node.src, {
									nonce: node.nonce || node.getAttribute( "nonce" )
								}, doc );
							}
						} else {

							// Unwrap a CDATA section containing script contents. This shouldn't be
							// needed as in XML documents they're already not visible when
							// inspecting element contents and in HTML documents they have no
							// meaning but we're preserving that logic for backwards compatibility.
							// This will be removed completely in 4.0. See gh-4904.
							DOMEval( node.textContent.replace( rcleanScript, "" ), node, doc );
						}
					}
				}
			}
		}
	}

	return collection;
}

function remove( elem, selector, keepData ) {
	var node,
		nodes = selector ? jQuery.filter( selector, elem ) : elem,
		i = 0;

	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
		if ( !keepData && node.nodeType === 1 ) {
			jQuery.cleanData( getAll( node ) );
		}

		if ( node.parentNode ) {
			if ( keepData && isAttached( node ) ) {
				setGlobalEval( getAll( node, "script" ) );
			}
			node.parentNode.removeChild( node );
		}
	}

	return elem;
}

jQuery.extend( {
	htmlPrefilter: function( html ) {
		return html;
	},

	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = isAttached( elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew jQuery#find here for performance reasons:
			// https://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	cleanData: function( elems ) {
		var data, elem, type,
			special = jQuery.event.special,
			i = 0;

		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
			if ( acceptData( elem ) ) {
				if ( ( data = elem[ dataPriv.expando ] ) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataPriv.expando ] = undefined;
				}
				if ( elem[ dataUser.expando ] ) {

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataUser.expando ] = undefined;
				}
			}
		}
	}
} );

jQuery.fn.extend( {
	detach: function( selector ) {
		return remove( this, selector, true );
	},

	remove: function( selector ) {
		return remove( this, selector );
	},

	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each( function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				} );
		}, null, value, arguments.length );
	},

	append: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		} );
	},

	prepend: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		} );
	},

	before: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		} );
	},

	after: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		} );
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; ( elem = this[ i ] ) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		} );
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = jQuery.htmlPrefilter( value );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch ( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var ignored = [];

		// Make the changes, replacing each non-ignored context element with the new content
		return domManip( this, arguments, function( elem ) {
			var parent = this.parentNode;

			if ( jQuery.inArray( this, ignored ) < 0 ) {
				jQuery.cleanData( getAll( this ) );
				if ( parent ) {
					parent.replaceChild( elem, this );
				}
			}

		// Force callback invocation
		}, ignored );
	}
} );

jQuery.each( {
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: Android <=4.0 only, PhantomJS 1 only
			// .get() because push.apply(_, arraylike) throws on ancient WebKit
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
} );
var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var rcustomProp = /^--/;


var getStyles = function( elem ) {

		// Support: IE <=11 only, Firefox <=30 (trac-15098, trac-14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if ( !view || !view.opener ) {
			view = window;
		}

		return view.getComputedStyle( elem );
	};

var swap = function( elem, options, callback ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.call( elem );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};


var rboxStyle = new RegExp( cssExpand.join( "|" ), "i" );



( function() {

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computeStyleTests() {

		// This is a singleton, we need to execute it only once
		if ( !div ) {
			return;
		}

		container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
			"margin-top:1px;padding:0;border:0";
		div.style.cssText =
			"position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
			"margin:auto;border:1px;padding:1px;" +
			"width:60%;top:1%";
		documentElement.appendChild( container ).appendChild( div );

		var divStyle = window.getComputedStyle( div );
		pixelPositionVal = divStyle.top !== "1%";

		// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
		reliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;

		// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
		// Some styles come back with percentage values, even though they shouldn't
		div.style.right = "60%";
		pixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;

		// Support: IE 9 - 11 only
		// Detect misreporting of content dimensions for box-sizing:border-box elements
		boxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;

		// Support: IE 9 only
		// Detect overflow:scroll screwiness (gh-3699)
		// Support: Chrome <=64
		// Don't get tricked when zoom affects offsetWidth (gh-4029)
		div.style.position = "absolute";
		scrollboxSizeVal = roundPixelMeasures( div.offsetWidth / 3 ) === 12;

		documentElement.removeChild( container );

		// Nullify the div so it wouldn't be stored in the memory and
		// it will also be a sign that checks already performed
		div = null;
	}

	function roundPixelMeasures( measure ) {
		return Math.round( parseFloat( measure ) );
	}

	var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
		reliableTrDimensionsVal, reliableMarginLeftVal,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	// Finish early in limited (non-browser) environments
	if ( !div.style ) {
		return;
	}

	// Support: IE <=9 - 11 only
	// Style of cloned element affects source element cloned (trac-8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	jQuery.extend( support, {
		boxSizingReliable: function() {
			computeStyleTests();
			return boxSizingReliableVal;
		},
		pixelBoxStyles: function() {
			computeStyleTests();
			return pixelBoxStylesVal;
		},
		pixelPosition: function() {
			computeStyleTests();
			return pixelPositionVal;
		},
		reliableMarginLeft: function() {
			computeStyleTests();
			return reliableMarginLeftVal;
		},
		scrollboxSize: function() {
			computeStyleTests();
			return scrollboxSizeVal;
		},

		// Support: IE 9 - 11+, Edge 15 - 18+
		// IE/Edge misreport `getComputedStyle` of table rows with width/height
		// set in CSS while `offset*` properties report correct values.
		// Behavior in IE 9 is more subtle than in newer versions & it passes
		// some versions of this test; make sure not to make it pass there!
		//
		// Support: Firefox 70+
		// Only Firefox includes border widths
		// in computed dimensions. (gh-4529)
		reliableTrDimensions: function() {
			var table, tr, trChild, trStyle;
			if ( reliableTrDimensionsVal == null ) {
				table = document.createElement( "table" );
				tr = document.createElement( "tr" );
				trChild = document.createElement( "div" );

				table.style.cssText = "position:absolute;left:-11111px;border-collapse:separate";
				tr.style.cssText = "box-sizing:content-box;border:1px solid";

				// Support: Chrome 86+
				// Height set through cssText does not get applied.
				// Computed height then comes back as 0.
				tr.style.height = "1px";
				trChild.style.height = "9px";

				// Support: Android 8 Chrome 86+
				// In our bodyBackground.html iframe,
				// display for all div elements is set to "inline",
				// which causes a problem only in Android 8 Chrome 86.
				// Ensuring the div is `display: block`
				// gets around this issue.
				trChild.style.display = "block";

				documentElement
					.appendChild( table )
					.appendChild( tr )
					.appendChild( trChild );

				trStyle = window.getComputedStyle( tr );
				reliableTrDimensionsVal = ( parseInt( trStyle.height, 10 ) +
					parseInt( trStyle.borderTopWidth, 10 ) +
					parseInt( trStyle.borderBottomWidth, 10 ) ) === tr.offsetHeight;

				documentElement.removeChild( table );
			}
			return reliableTrDimensionsVal;
		}
	} );
} )();


function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,
		isCustomProp = rcustomProp.test( name ),

		// Support: Firefox 51+
		// Retrieving style before computed somehow
		// fixes an issue with getting wrong values
		// on detached elements
		style = elem.style;

	computed = computed || getStyles( elem );

	// getPropertyValue is needed for:
	//   .css('filter') (IE 9 only, trac-12537)
	//   .css('--customProperty) (gh-3144)
	if ( computed ) {

		// Support: IE <=9 - 11+
		// IE only supports `"float"` in `getPropertyValue`; in computed styles
		// it's only available as `"cssFloat"`. We no longer modify properties
		// sent to `.css()` apart from camelCasing, so we need to check both.
		// Normally, this would create difference in behavior: if
		// `getPropertyValue` returns an empty string, the value returned
		// by `.css()` would be `undefined`. This is usually the case for
		// disconnected elements. However, in IE even disconnected elements
		// with no styles return `"none"` for `getPropertyValue( "float" )`
		ret = computed.getPropertyValue( name ) || computed[ name ];

		if ( isCustomProp && ret ) {

			// Support: Firefox 105+, Chrome <=105+
			// Spec requires trimming whitespace for custom properties (gh-4926).
			// Firefox only trims leading whitespace. Chrome just collapses
			// both leading & trailing whitespace to a single space.
			//
			// Fall back to `undefined` if empty string returned.
			// This collapses a missing definition with property defined
			// and set to an empty string but there's no standard API
			// allowing us to differentiate them without a performance penalty
			// and returning `undefined` aligns with older jQuery.
			//
			// rtrimCSS treats U+000D CARRIAGE RETURN and U+000C FORM FEED
			// as whitespace while CSS does not, but this is not a problem
			// because CSS preprocessing replaces them with U+000A LINE FEED
			// (which *is* CSS whitespace)
			// https://www.w3.org/TR/css-syntax-3/#input-preprocessing
			ret = ret.replace( rtrimCSS, "$1" ) || undefined;
		}

		if ( ret === "" && !isAttached( elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// A tribute to the "awesome hack by Dean Edwards"
		// Android Browser returns percentage for some values,
		// but width seems to be reliably pixels.
		// This is against the CSSOM draft spec:
		// https://drafts.csswg.org/cssom/#resolved-values
		if ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?

		// Support: IE <=9 - 11 only
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {

	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {

				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return ( this.get = hookFn ).apply( this, arguments );
		}
	};
}


var cssPrefixes = [ "Webkit", "Moz", "ms" ],
	emptyStyle = document.createElement( "div" ).style,
	vendorProps = {};

// Return a vendor-prefixed property or undefined
function vendorPropName( name ) {

	// Check for vendor prefixed names
	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in emptyStyle ) {
			return name;
		}
	}
}

// Return a potentially-mapped jQuery.cssProps or vendor prefixed property
function finalPropName( name ) {
	var final = jQuery.cssProps[ name ] || vendorProps[ name ];

	if ( final ) {
		return final;
	}
	if ( name in emptyStyle ) {
		return name;
	}
	return vendorProps[ name ] = vendorPropName( name ) || name;
}


var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	};

function setPositiveNumber( _elem, value, subtract ) {

	// Any relative (+/-) values have already been
	// normalized at this point
	var matches = rcssNum.exec( value );
	return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
		value;
}

function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {
	var i = dimension === "width" ? 1 : 0,
		extra = 0,
		delta = 0,
		marginDelta = 0;

	// Adjustment may not be necessary
	if ( box === ( isBorderBox ? "border" : "content" ) ) {
		return 0;
	}

	for ( ; i < 4; i += 2 ) {

		// Both box models exclude margin
		// Count margin delta separately to only add it after scroll gutter adjustment.
		// This is needed to make negative margins work with `outerHeight( true )` (gh-3982).
		if ( box === "margin" ) {
			marginDelta += jQuery.css( elem, box + cssExpand[ i ], true, styles );
		}

		// If we get here with a content-box, we're seeking "padding" or "border" or "margin"
		if ( !isBorderBox ) {

			// Add padding
			delta += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// For "border" or "margin", add border
			if ( box !== "padding" ) {
				delta += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );

			// But still keep track of it otherwise
			} else {
				extra += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}

		// If we get here with a border-box (content + padding + border), we're seeking "content" or
		// "padding" or "margin"
		} else {

			// For "content", subtract padding
			if ( box === "content" ) {
				delta -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// For "content" or "padding", subtract border
			if ( box !== "margin" ) {
				delta -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	// Account for positive content-box scroll gutter when requested by providing computedVal
	if ( !isBorderBox && computedVal >= 0 ) {

		// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
		// Assuming integer scroll gutter, subtract the rest and round down
		delta += Math.max( 0, Math.ceil(
			elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
			computedVal -
			delta -
			extra -
			0.5

		// If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
		// Use an explicit zero to avoid NaN (gh-3964)
		) ) || 0;
	}

	return delta + marginDelta;
}

function getWidthOrHeight( elem, dimension, extra ) {

	// Start with computed style
	var styles = getStyles( elem ),

		// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
		// Fake content-box until we know it's needed to know the true value.
		boxSizingNeeded = !support.boxSizingReliable() || extra,
		isBorderBox = boxSizingNeeded &&
			jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
		valueIsBorderBox = isBorderBox,

		val = curCSS( elem, dimension, styles ),
		offsetProp = "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 );

	// Support: Firefox <=54
	// Return a confounding non-pixel value or feign ignorance, as appropriate.
	if ( rnumnonpx.test( val ) ) {
		if ( !extra ) {
			return val;
		}
		val = "auto";
	}


	// Support: IE 9 - 11 only
	// Use offsetWidth/offsetHeight for when box sizing is unreliable.
	// In those cases, the computed value can be trusted to be border-box.
	if ( ( !support.boxSizingReliable() && isBorderBox ||

		// Support: IE 10 - 11+, Edge 15 - 18+
		// IE/Edge misreport `getComputedStyle` of table rows with width/height
		// set in CSS while `offset*` properties report correct values.
		// Interestingly, in some cases IE 9 doesn't suffer from this issue.
		!support.reliableTrDimensions() && nodeName( elem, "tr" ) ||

		// Fall back to offsetWidth/offsetHeight when value is "auto"
		// This happens for inline elements with no explicit setting (gh-3571)
		val === "auto" ||

		// Support: Android <=4.1 - 4.3 only
		// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
		!parseFloat( val ) && jQuery.css( elem, "display", false, styles ) === "inline" ) &&

		// Make sure the element is visible & connected
		elem.getClientRects().length ) {

		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

		// Where available, offsetWidth/offsetHeight approximate border box dimensions.
		// Where not available (e.g., SVG), assume unreliable box-sizing and interpret the
		// retrieved value as a content box dimension.
		valueIsBorderBox = offsetProp in elem;
		if ( valueIsBorderBox ) {
			val = elem[ offsetProp ];
		}
	}

	// Normalize "" and auto
	val = parseFloat( val ) || 0;

	// Adjust for the element's box model
	return ( val +
		boxModelAdjustment(
			elem,
			dimension,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles,

			// Provide the current computed size to request scroll gutter calculation (gh-3589)
			val
		)
	) + "px";
}

jQuery.extend( {

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		animationIterationCount: true,
		aspectRatio: true,
		borderImageSlice: true,
		columnCount: true,
		flexGrow: true,
		flexShrink: true,
		fontWeight: true,
		gridArea: true,
		gridColumn: true,
		gridColumnEnd: true,
		gridColumnStart: true,
		gridRow: true,
		gridRowEnd: true,
		gridRowStart: true,
		lineHeight: true,
		opacity: true,
		order: true,
		orphans: true,
		scale: true,
		widows: true,
		zIndex: true,
		zoom: true,

		// SVG-related
		fillOpacity: true,
		floodOpacity: true,
		stopOpacity: true,
		strokeMiterlimit: true,
		strokeOpacity: true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name ),
			style = elem.style;

		// Make sure that we're working with the right name. We don't
		// want to query the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (trac-7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug trac-9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (trac-7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add the unit (except for certain CSS properties)
			// The isCustomProp check can be removed in jQuery 4.0 when we only auto-append
			// "px" to a few hardcoded values.
			if ( type === "number" && !isCustomProp ) {
				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
			}

			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !( "set" in hooks ) ||
				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

				if ( isCustomProp ) {
					style.setProperty( name, value );
				} else {
					style[ name ] = value;
				}
			}

		} else {

			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks &&
				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name );

		// Make sure that we're working with the right name. We don't
		// want to modify the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || isFinite( num ) ? num || 0 : val;
		}

		return val;
	}
} );

jQuery.each( [ "height", "width" ], function( _i, dimension ) {
	jQuery.cssHooks[ dimension ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

					// Support: Safari 8+
					// Table columns in Safari have non-zero offsetWidth & zero
					// getBoundingClientRect().width unless display is changed.
					// Support: IE <=11 only
					// Running getBoundingClientRect on a disconnected node
					// in IE throws an error.
					( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
					swap( elem, cssShow, function() {
						return getWidthOrHeight( elem, dimension, extra );
					} ) :
					getWidthOrHeight( elem, dimension, extra );
			}
		},

		set: function( elem, value, extra ) {
			var matches,
				styles = getStyles( elem ),

				// Only read styles.position if the test has a chance to fail
				// to avoid forcing a reflow.
				scrollboxSizeBuggy = !support.scrollboxSize() &&
					styles.position === "absolute",

				// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)
				boxSizingNeeded = scrollboxSizeBuggy || extra,
				isBorderBox = boxSizingNeeded &&
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
				subtract = extra ?
					boxModelAdjustment(
						elem,
						dimension,
						extra,
						isBorderBox,
						styles
					) :
					0;

			// Account for unreliable border-box dimensions by comparing offset* to computed and
			// faking a content-box to get border and padding (gh-3699)
			if ( isBorderBox && scrollboxSizeBuggy ) {
				subtract -= Math.ceil(
					elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
					parseFloat( styles[ dimension ] ) -
					boxModelAdjustment( elem, dimension, "border", false, styles ) -
					0.5
				);
			}

			// Convert to pixels if value adjustment is needed
			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
				( matches[ 3 ] || "px" ) !== "px" ) {

				elem.style[ dimension ] = value;
				value = jQuery.css( elem, dimension );
			}

			return setPositiveNumber( elem, value, subtract );
		}
	};
} );

jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
	function( elem, computed ) {
		if ( computed ) {
			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
				elem.getBoundingClientRect().left -
					swap( elem, { marginLeft: 0 }, function() {
						return elem.getBoundingClientRect().left;
					} )
			) + "px";
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each( {
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split( " " ) : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( prefix !== "margin" ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
} );

jQuery.fn.extend( {
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( Array.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	}
} );


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || jQuery.easing._default;
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			// Use a property on the element directly when it is not a DOM element,
			// or when there is no matching style property that exists.
			if ( tween.elem.nodeType !== 1 ||
				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );

			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {

			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.nodeType === 1 && (
				jQuery.cssHooks[ tween.prop ] ||
					tween.elem.style[ finalPropName( tween.prop ) ] != null ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE <=9 only
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	},
	_default: "swing"
};

jQuery.fx = Tween.prototype.init;

// Back compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, inProgress,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rrun = /queueHooks$/;

function schedule() {
	if ( inProgress ) {
		if ( document.hidden === false && window.requestAnimationFrame ) {
			window.requestAnimationFrame( schedule );
		} else {
			window.setTimeout( schedule, jQuery.fx.interval );
		}

		jQuery.fx.tick();
	}
}

// Animations created synchronously will run synchronously
function createFxNow() {
	window.setTimeout( function() {
		fxNow = undefined;
	} );
	return ( fxNow = Date.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
		isBox = "width" in props || "height" in props,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHiddenWithinTree( elem ),
		dataShow = dataPriv.get( elem, "fxshow" );

	// Queue-skipping animations hijack the fx hooks
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always( function() {

			// Ensure the complete handler is called before this completes
			anim.always( function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			} );
		} );
	}

	// Detect show/hide animations
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.test( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// Pretend to be hidden if this is a "show" and
				// there is still data from a stopped show/hide
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;

				// Ignore all other no-op show/hide data
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
		}
	}

	// Bail out if this is a no-op like .hide().hide()
	propTween = !jQuery.isEmptyObject( props );
	if ( !propTween && jQuery.isEmptyObject( orig ) ) {
		return;
	}

	// Restrict "overflow" and "display" styles during box animations
	if ( isBox && elem.nodeType === 1 ) {

		// Support: IE <=9 - 11, Edge 12 - 15
		// Record all 3 overflow attributes because IE does not infer the shorthand
		// from identically-valued overflowX and overflowY and Edge just mirrors
		// the overflowX value there.
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Identify a display type, preferring old show/hide data over the CSS cascade
		restoreDisplay = dataShow && dataShow.display;
		if ( restoreDisplay == null ) {
			restoreDisplay = dataPriv.get( elem, "display" );
		}
		display = jQuery.css( elem, "display" );
		if ( display === "none" ) {
			if ( restoreDisplay ) {
				display = restoreDisplay;
			} else {

				// Get nonempty value(s) by temporarily forcing visibility
				showHide( [ elem ], true );
				restoreDisplay = elem.style.display || restoreDisplay;
				display = jQuery.css( elem, "display" );
				showHide( [ elem ] );
			}
		}

		// Animate inline elements as inline-block
		if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
			if ( jQuery.css( elem, "float" ) === "none" ) {

				// Restore the original display value at the end of pure show/hide animations
				if ( !propTween ) {
					anim.done( function() {
						style.display = restoreDisplay;
					} );
					if ( restoreDisplay == null ) {
						display = style.display;
						restoreDisplay = display === "none" ? "" : display;
					}
				}
				style.display = "inline-block";
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always( function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		} );
	}

	// Implement show/hide animations
	propTween = false;
	for ( prop in orig ) {

		// General show/hide setup for this element animation
		if ( !propTween ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
			}

			// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}

			// Show elements before animating them
			if ( hidden ) {
				showHide( [ elem ], true );
			}

			/* eslint-disable no-loop-func */

			anim.done( function() {

				/* eslint-enable no-loop-func */

				// The final step of a "hide" animation is actually hiding the element
				if ( !hidden ) {
					showHide( [ elem ] );
				}
				dataPriv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			} );
		}

		// Per-property setup
		propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
		if ( !( prop in dataShow ) ) {
			dataShow[ prop ] = propTween.start;
			if ( hidden ) {
				propTween.end = propTween.start;
				propTween.start = 0;
			}
		}
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( Array.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = Animation.prefilters.length,
		deferred = jQuery.Deferred().always( function() {

			// Don't match elem in the :animated selector
			delete tick.elem;
		} ),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

				// Support: Android 2.3 only
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (trac-12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ] );

			// If there's more to do, yield
			if ( percent < 1 && length ) {
				return remaining;
			}

			// If this was an empty animation, synthesize a final progress notification
			if ( !length ) {
				deferred.notifyWith( elem, [ animation, 1, 0 ] );
			}

			// Resolve the animation and report its conclusion
			deferred.resolveWith( elem, [ animation ] );
			return false;
		},
		animation = deferred.promise( {
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
					animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,

					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		} ),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length; index++ ) {
		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			if ( isFunction( result.stop ) ) {
				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
					result.stop.bind( result );
			}
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	// Attach callbacks from options
	animation
		.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		} )
	);

	return animation;
}

jQuery.Animation = jQuery.extend( Animation, {

	tweeners: {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value );
			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
			return tween;
		} ]
	},

	tweener: function( props, callback ) {
		if ( isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.match( rnothtmlwhite );
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length; index++ ) {
			prop = props[ index ];
			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
			Animation.tweeners[ prop ].unshift( callback );
		}
	},

	prefilters: [ defaultPrefilter ],

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			Animation.prefilters.unshift( callback );
		} else {
			Animation.prefilters.push( callback );
		}
	}
} );

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !isFunction( easing ) && easing
	};

	// Go to the end state if fx are off
	if ( jQuery.fx.off ) {
		opt.duration = 0;

	} else {
		if ( typeof opt.duration !== "number" ) {
			if ( opt.duration in jQuery.fx.speeds ) {
				opt.duration = jQuery.fx.speeds[ opt.duration ];

			} else {
				opt.duration = jQuery.fx.speeds._default;
			}
		}
	}

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend( {
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate( { opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || dataPriv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};

		doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue ) {
			this.queue( type || "fx", [] );
		}

		return this.each( function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = dataPriv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &&
					( type == null || timers[ index ].queue === type ) ) {

					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		} );
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each( function() {
			var index,
				data = dataPriv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		} );
	}
} );

jQuery.each( [ "toggle", "show", "hide" ], function( _i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
} );

// Generate shortcuts for custom animations
jQuery.each( {
	slideDown: genFx( "show" ),
	slideUp: genFx( "hide" ),
	slideToggle: genFx( "toggle" ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
} );

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = Date.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];

		// Run the timer and safely remove it when done (allowing for external removal)
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	jQuery.fx.start();
};

jQuery.fx.interval = 13;
jQuery.fx.start = function() {
	if ( inProgress ) {
		return;
	}

	inProgress = true;
	schedule();
};

jQuery.fx.stop = function() {
	inProgress = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,

	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = window.setTimeout( next, time );
		hooks.stop = function() {
			window.clearTimeout( timeout );
		};
	} );
};


( function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: Android <=4.3 only
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE <=11 only
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: IE <=11 only
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
} )();


var boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend( {
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each( function() {
			jQuery.removeAttr( this, name );
		} );
	}
} );

jQuery.extend( {
	attr: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set attributes on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		// Attribute hooks are determined by the lowercase version
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
		}

		if ( value !== undefined ) {
			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;
			}

			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			elem.setAttribute( name, value + "" );
			return value;
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		ret = jQuery.find.attr( elem, name );

		// Non-existent attributes return null, we normalize to undefined
		return ret == null ? undefined : ret;
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	removeAttr: function( elem, value ) {
		var name,
			i = 0,

			// Attribute names can contain non-HTML whitespace characters
			// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
			attrNames = value && value.match( rnothtmlwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( ( name = attrNames[ i++ ] ) ) {
				elem.removeAttribute( name );
			}
		}
	}
} );

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {

			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};

jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( _i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle,
			lowercaseName = name.toLowerCase();

		if ( !isXML ) {

			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ lowercaseName ];
			attrHandle[ lowercaseName ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				lowercaseName :
				null;
			attrHandle[ lowercaseName ] = handle;
		}
		return ret;
	};
} );




var rfocusable = /^(?:input|select|textarea|button)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend( {
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each( function() {
			delete this[ jQuery.propFix[ name ] || name ];
		} );
	}
} );

jQuery.extend( {
	prop: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			return ( elem[ name ] = value );
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		return elem[ name ];
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {

				// Support: IE <=9 - 11 only
				// elem.tabIndex doesn't always return the
				// correct value when it hasn't been explicitly set
				// Use proper attribute retrieval (trac-12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				if ( tabindex ) {
					return parseInt( tabindex, 10 );
				}

				if (
					rfocusable.test( elem.nodeName ) ||
					rclickable.test( elem.nodeName ) &&
					elem.href
				) {
					return 0;
				}

				return -1;
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	}
} );

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
// eslint rule "no-unused-expressions" is disabled for this code
// since it considers such accessions noop
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		},
		set: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent ) {
				parent.selectedIndex;

				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
		}
	};
}

jQuery.each( [
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
} );




	// Strip and collapse whitespace according to HTML spec
	// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
	function stripAndCollapse( value ) {
		var tokens = value.match( rnothtmlwhite ) || [];
		return tokens.join( " " );
	}


function getClass( elem ) {
	return elem.getAttribute && elem.getAttribute( "class" ) || "";
}

function classesToArray( value ) {
	if ( Array.isArray( value ) ) {
		return value;
	}
	if ( typeof value === "string" ) {
		return value.match( rnothtmlwhite ) || [];
	}
	return [];
}

jQuery.fn.extend( {
	addClass: function( value ) {
		var classNames, cur, curValue, className, i, finalValue;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		classNames = classesToArray( value );

		if ( classNames.length ) {
			return this.each( function() {
				curValue = getClass( this );
				cur = this.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					for ( i = 0; i < classNames.length; i++ ) {
						className = classNames[ i ];
						if ( cur.indexOf( " " + className + " " ) < 0 ) {
							cur += className + " ";
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						this.setAttribute( "class", finalValue );
					}
				}
			} );
		}

		return this;
	},

	removeClass: function( value ) {
		var classNames, cur, curValue, className, i, finalValue;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( !arguments.length ) {
			return this.attr( "class", "" );
		}

		classNames = classesToArray( value );

		if ( classNames.length ) {
			return this.each( function() {
				curValue = getClass( this );

				// This expression is here for better compressibility (see addClass)
				cur = this.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					for ( i = 0; i < classNames.length; i++ ) {
						className = classNames[ i ];

						// Remove *all* instances
						while ( cur.indexOf( " " + className + " " ) > -1 ) {
							cur = cur.replace( " " + className + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						this.setAttribute( "class", finalValue );
					}
				}
			} );
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var classNames, className, i, self,
			type = typeof value,
			isValidValue = type === "string" || Array.isArray( value );

		if ( isFunction( value ) ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
					stateVal
				);
			} );
		}

		if ( typeof stateVal === "boolean" && isValidValue ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		classNames = classesToArray( value );

		return this.each( function() {
			if ( isValidValue ) {

				// Toggle individual class names
				self = jQuery( this );

				for ( i = 0; i < classNames.length; i++ ) {
					className = classNames[ i ];

					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( value === undefined || type === "boolean" ) {
				className = getClass( this );
				if ( className ) {

					// Store className if set
					dataPriv.set( this, "__className__", className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				if ( this.setAttribute ) {
					this.setAttribute( "class",
						className || value === false ?
							"" :
							dataPriv.get( this, "__className__" ) || ""
					);
				}
			}
		} );
	},

	hasClass: function( selector ) {
		var className, elem,
			i = 0;

		className = " " + selector + " ";
		while ( ( elem = this[ i++ ] ) ) {
			if ( elem.nodeType === 1 &&
				( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
				return true;
			}
		}

		return false;
	}
} );




var rreturn = /\r/g;

jQuery.fn.extend( {
	val: function( value ) {
		var hooks, ret, valueIsFunction,
			elem = this[ 0 ];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] ||
					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks &&
					"get" in hooks &&
					( ret = hooks.get( elem, "value" ) ) !== undefined
				) {
					return ret;
				}

				ret = elem.value;

				// Handle most common string cases
				if ( typeof ret === "string" ) {
					return ret.replace( rreturn, "" );
				}

				// Handle cases where value is null/undef or number
				return ret == null ? "" : ret;
			}

			return;
		}

		valueIsFunction = isFunction( value );

		return this.each( function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( valueIsFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( Array.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				} );
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		} );
	}
} );

jQuery.extend( {
	valHooks: {
		option: {
			get: function( elem ) {

				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :

					// Support: IE <=10 - 11 only
					// option.text throws exceptions (trac-14686, trac-14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					stripAndCollapse( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option, i,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one",
					values = one ? null : [],
					max = one ? index + 1 : options.length;

				if ( index < 0 ) {
					i = max;

				} else {
					i = one ? index : 0;
				}

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Support: IE <=9 only
					// IE8-9 doesn't update selected after form reset (trac-2551)
					if ( ( option.selected || i === index ) &&

							// Don't return options that are disabled or in a disabled optgroup
							!option.disabled &&
							( !option.parentNode.disabled ||
								!nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];

					/* eslint-disable no-cond-assign */

					if ( option.selected =
						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
					) {
						optionSet = true;
					}

					/* eslint-enable no-cond-assign */
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
} );

// Radios and checkboxes getter/setter
jQuery.each( [ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( Array.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
		};
	}
} );




// Return jQuery for attributes-only inclusion
var location = window.location;

var nonce = { guid: Date.now() };

var rquery = ( /\?/ );



// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml, parserErrorElem;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE 9 - 11 only
	// IE throws on parseFromString with invalid input.
	try {
		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
	} catch ( e ) {}

	parserErrorElem = xml && xml.getElementsByTagName( "parsererror" )[ 0 ];
	if ( !xml || parserErrorElem ) {
		jQuery.error( "Invalid XML: " + (
			parserErrorElem ?
				jQuery.map( parserErrorElem.childNodes, function( el ) {
					return el.textContent;
				} ).join( "\n" ) :
				data
		) );
	}
	return xml;
};


var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	stopPropagationCallback = function( e ) {
		e.stopPropagation();
	};

jQuery.extend( jQuery.event, {

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

		cur = lastElement = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "." ) > -1 ) {

			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split( "." );
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf( ":" ) < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join( "." );
		event.rnamespace = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (trac-9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (trac-9724)
		if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === ( elem.ownerDocument || document ) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
			lastElement = cur;
			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( dataPriv.get( cur, "events" ) || Object.create( null ) )[ event.type ] &&
				dataPriv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( ( !special._default ||
				special._default.apply( eventPath.pop(), data ) === false ) &&
				acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name as the event.
				// Don't do default actions on window, that's where global variables be (trac-6170)
				if ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;

					if ( event.isPropagationStopped() ) {
						lastElement.addEventListener( type, stopPropagationCallback );
					}

					elem[ type ]();

					if ( event.isPropagationStopped() ) {
						lastElement.removeEventListener( type, stopPropagationCallback );
					}

					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	// Piggyback on a donor event to simulate a different one
	// Used only for `focus(in | out)` events
	simulate: function( type, elem, event ) {
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true
			}
		);

		jQuery.event.trigger( e, null, elem );
	}

} );

jQuery.fn.extend( {

	trigger: function( type, data ) {
		return this.each( function() {
			jQuery.event.trigger( type, data, this );
		} );
	},
	triggerHandler: function( type, data ) {
		var elem = this[ 0 ];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
} );


var
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( Array.isArray( obj ) ) {

		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {

				// Treat each array item as a scalar.
				add( prefix, v );

			} else {

				// Item is non-scalar (array or object), encode its numeric index.
				buildParams(
					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
					v,
					traditional,
					add
				);
			}
		} );

	} else if ( !traditional && toType( obj ) === "object" ) {

		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {

		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, valueOrFunction ) {

			// If value is a function, invoke it and use its return value
			var value = isFunction( valueOrFunction ) ?
				valueOrFunction() :
				valueOrFunction;

			s[ s.length ] = encodeURIComponent( key ) + "=" +
				encodeURIComponent( value == null ? "" : value );
		};

	if ( a == null ) {
		return "";
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		} );

	} else {

		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" );
};

jQuery.fn.extend( {
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map( function() {

			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		} ).filter( function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		} ).map( function( _i, elem ) {
			var val = jQuery( this ).val();

			if ( val == null ) {
				return null;
			}

			if ( Array.isArray( val ) ) {
				return jQuery.map( val, function( val ) {
					return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
				} );
			}

			return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		} ).get();
	}
} );


var
	r20 = /%20/g,
	rhash = /#.*$/,
	rantiCache = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

	// trac-7653, trac-8125, trac-8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (trac-10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Anchor tag for parsing the document origin
	originAnchor = document.createElement( "a" );

originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

		if ( isFunction( func ) ) {

			// For each dataType in the dataTypeExpression
			while ( ( dataType = dataTypes[ i++ ] ) ) {

				// Prepend if requested
				if ( dataType[ 0 ] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

				// Otherwise append
				} else {
					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" &&
				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		} );
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes trac-9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {

		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}

		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},

		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

			// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {

								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s.throws ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return {
								state: "parsererror",
								error: conv ? e : "No conversion from " + prev + " to " + current
							};
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend( {

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: location.href,
		type: "GET",
		isLocal: rlocalProtocol.test( location.protocol ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",

		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /\bxml\b/,
			html: /\bhtml/,
			json: /\bjson\b/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": JSON.parse,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,

			// URL without anti-cache param
			cacheURL,

			// Response headers
			responseHeadersString,
			responseHeaders,

			// timeout handle
			timeoutTimer,

			// Url cleanup var
			urlAnchor,

			// Request state (becomes false upon send and true upon completion)
			completed,

			// To know if global events are to be dispatched
			fireGlobals,

			// Loop variable
			i,

			// uncached part of the url
			uncached,

			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),

			// Callbacks context
			callbackContext = s.context || s,

			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &&
				( callbackContext.nodeType || callbackContext.jquery ) ?
				jQuery( callbackContext ) :
				jQuery.event,

			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),

			// Status-dependent callbacks
			statusCode = s.statusCode || {},

			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},

			// Default abort message
			strAbort = "canceled",

			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( completed ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[ 1 ].toLowerCase() + " " ] =
									( responseHeaders[ match[ 1 ].toLowerCase() + " " ] || [] )
										.concat( match[ 2 ] );
							}
						}
						match = responseHeaders[ key.toLowerCase() + " " ];
					}
					return match == null ? null : match.join( ", " );
				},

				// Raw string
				getAllResponseHeaders: function() {
					return completed ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( completed == null ) {
						name = requestHeadersNames[ name.toLowerCase() ] =
							requestHeadersNames[ name.toLowerCase() ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( completed == null ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( completed ) {

							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						} else {

							// Lazy-add the new callbacks in a way that preserves old ones
							for ( code in map ) {
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR );

		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (trac-10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || location.href ) + "" )
			.replace( rprotocol, location.protocol + "//" );

		// Alias method option to type as per ticket trac-12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

		// A cross-domain request is in order when the origin doesn't match the current origin.
		if ( s.crossDomain == null ) {
			urlAnchor = document.createElement( "a" );

			// Support: IE <=8 - 11, Edge 12 - 15
			// IE throws exception on accessing the href property if url is malformed,
			// e.g. http://example.com:80x/
			try {
				urlAnchor.href = s.url;

				// Support: IE <=8 - 11 only
				// Anchor's host property isn't correctly set when s.url is relative
				urlAnchor.href = urlAnchor.href;
				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
					urlAnchor.protocol + "//" + urlAnchor.host;
			} catch ( e ) {

				// If there is an error parsing the URL, assume it is crossDomain,
				// it can be rejected by the transport if it is invalid
				s.crossDomain = true;
			}
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( completed ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (trac-15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		// Remove hash to simplify url manipulation
		cacheURL = s.url.replace( rhash, "" );

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// Remember the hash so we can put it back
			uncached = s.url.slice( cacheURL.length );

			// If data is available and should be processed, append data to url
			if ( s.data && ( s.processData || typeof s.data === "string" ) ) {
				cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

				// trac-9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add or update anti-cache param if needed
			if ( s.cache === false ) {
				cacheURL = cacheURL.replace( rantiCache, "$1" );
				uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce.guid++ ) +
					uncached;
			}

			// Put hash and anti-cache on the URL that will be requested (gh-1732)
			s.url = cacheURL + uncached;

		// Change '%20' to '+' if this is encoded form body content (gh-2658)
		} else if ( s.data && s.processData &&
			( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
			s.data = s.data.replace( r20, "+" );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
				s.accepts[ s.dataTypes[ 0 ] ] +
					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend &&
			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		completeDeferred.add( s.complete );
		jqXHR.done( s.success );
		jqXHR.fail( s.error );

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}

			// If request was aborted inside ajaxSend, stop there
			if ( completed ) {
				return jqXHR;
			}

			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = window.setTimeout( function() {
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				completed = false;
				transport.send( requestHeaders, done );
			} catch ( e ) {

				// Rethrow post-completion exceptions
				if ( completed ) {
					throw e;
				}

				// Propagate others as results
				done( -1, e );
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Ignore repeat invocations
			if ( completed ) {
				return;
			}

			completed = true;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				window.clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Use a noop converter for missing script but not if jsonp
			if ( !isSuccess &&
				jQuery.inArray( "script", s.dataTypes ) > -1 &&
				jQuery.inArray( "json", s.dataTypes ) < 0 ) {
				s.converters[ "text script" ] = function() {};
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader( "Last-Modified" );
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader( "etag" );
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {

				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
} );

jQuery.each( [ "get", "post" ], function( _i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {

		// Shift arguments if data argument was omitted
		if ( isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		// The url can be an options object (which then must have .url)
		return jQuery.ajax( jQuery.extend( {
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		}, jQuery.isPlainObject( url ) && url ) );
	};
} );

jQuery.ajaxPrefilter( function( s ) {
	var i;
	for ( i in s.headers ) {
		if ( i.toLowerCase() === "content-type" ) {
			s.contentType = s.headers[ i ] || "";
		}
	}
} );


jQuery._evalUrl = function( url, options, doc ) {
	return jQuery.ajax( {
		url: url,

		// Make this explicit, since user can override this through ajaxSetup (trac-11264)
		type: "GET",
		dataType: "script",
		cache: true,
		async: false,
		global: false,

		// Only evaluate the response if it is successful (gh-4126)
		// dataFilter is not invoked for failure responses, so using it instead
		// of the default converter is kludgy but it works.
		converters: {
			"text script": function() {}
		},
		dataFilter: function( response ) {
			jQuery.globalEval( response, options, doc );
		}
	} );
};


jQuery.fn.extend( {
	wrapAll: function( html ) {
		var wrap;

		if ( this[ 0 ] ) {
			if ( isFunction( html ) ) {
				html = html.call( this[ 0 ] );
			}

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map( function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			} ).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapInner( html.call( this, i ) );
			} );
		}

		return this.each( function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		} );
	},

	wrap: function( html ) {
		var htmlIsFunction = isFunction( html );

		return this.each( function( i ) {
			jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
		} );
	},

	unwrap: function( selector ) {
		this.parent( selector ).not( "body" ).each( function() {
			jQuery( this ).replaceWith( this.childNodes );
		} );
		return this;
	}
} );


jQuery.expr.pseudos.hidden = function( elem ) {
	return !jQuery.expr.pseudos.visible( elem );
};
jQuery.expr.pseudos.visible = function( elem ) {
	return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
};




jQuery.ajaxSettings.xhr = function() {
	try {
		return new window.XMLHttpRequest();
	} catch ( e ) {}
};

var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE <=9 only
		// trac-1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport( function( options ) {
	var callback, errorCallback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr();

				xhr.open(
					options.type,
					options.url,
					options.async,
					options.username,
					options.password
				);

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
					headers[ "X-Requested-With" ] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							callback = errorCallback = xhr.onload =
								xhr.onerror = xhr.onabort = xhr.ontimeout =
									xhr.onreadystatechange = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {

								// Support: IE <=9 only
								// On a manual native abort, IE9 throws
								// errors on any property access that is not readyState
								if ( typeof xhr.status !== "number" ) {
									complete( 0, "error" );
								} else {
									complete(

										// File: protocol always yields status 0; see trac-8605, trac-14207
										xhr.status,
										xhr.statusText
									);
								}
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,

									// Support: IE <=9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									( xhr.responseType || "text" ) !== "text"  ||
									typeof xhr.responseText !== "string" ?
										{ binary: xhr.response } :
										{ text: xhr.responseText },
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				errorCallback = xhr.onerror = xhr.ontimeout = callback( "error" );

				// Support: IE 9 only
				// Use onreadystatechange to replace onabort
				// to handle uncaught aborts
				if ( xhr.onabort !== undefined ) {
					xhr.onabort = errorCallback;
				} else {
					xhr.onreadystatechange = function() {

						// Check readyState before timeout as it changes
						if ( xhr.readyState === 4 ) {

							// Allow onerror to be called first,
							// but that will not handle a native abort
							// Also, save errorCallback to a variable
							// as xhr.onerror cannot be accessed
							window.setTimeout( function() {
								if ( callback ) {
									errorCallback();
								}
							} );
						}
					};
				}

				// Create the abort callback
				callback = callback( "abort" );

				try {

					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {

					// trac-14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
jQuery.ajaxPrefilter( function( s ) {
	if ( s.crossDomain ) {
		s.contents.script = false;
	}
} );

// Install script dataType
jQuery.ajaxSetup( {
	accepts: {
		script: "text/javascript, application/javascript, " +
			"application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /\b(?:java|ecma)script\b/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
} );

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
} );

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {

	// This transport only deals with cross domain or forced-by-attrs requests
	if ( s.crossDomain || s.scriptAttrs ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery( "<script>" )
					.attr( s.scriptAttrs || {} )
					.prop( { charset: s.scriptCharset, src: s.url } )
					.on( "load error", callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					} );

				// Use native DOM manipulation to avoid our domManip AJAX trickery
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup( {
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce.guid++ ) );
		this[ callback ] = true;
		return callback;
	}
} );

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" &&
				( s.contentType || "" )
					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
				rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters[ "script json" ] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// Force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always( function() {

			// If previous value didn't exist - remove it
			if ( overwritten === undefined ) {
				jQuery( window ).removeProp( callbackName );

			// Otherwise restore preexisting value
			} else {
				window[ callbackName ] = overwritten;
			}

			// Save back as free
			if ( s[ callbackName ] ) {

				// Make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// Save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		} );

		// Delegate to script
		return "script";
	}
} );




// Support: Safari 8 only
// In Safari 8 documents created via document.implementation.createHTMLDocument
// collapse sibling forms: the second one becomes a child of the first one.
// Because of that, this security measure has to be disabled in Safari 8.
// https://bugs.webkit.org/show_bug.cgi?id=137337
support.createHTMLDocument = ( function() {
	var body = document.implementation.createHTMLDocument( "" ).body;
	body.innerHTML = "<form></form><form></form>";
	return body.childNodes.length === 2;
} )();


// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( typeof data !== "string" ) {
		return [];
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}

	var base, parsed, scripts;

	if ( !context ) {

		// Stop scripts or inline event handlers from being executed immediately
		// by using document.implementation
		if ( support.createHTMLDocument ) {
			context = document.implementation.createHTMLDocument( "" );

			// Set the base href for the created document
			// so any parsed elements with URLs
			// are based on the document's URL (gh-2965)
			base = context.createElement( "base" );
			base.href = document.location.href;
			context.head.appendChild( base );
		} else {
			context = document;
		}
	}

	parsed = rsingleTag.exec( data );
	scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[ 1 ] ) ];
	}

	parsed = buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	var selector, type, response,
		self = this,
		off = url.indexOf( " " );

	if ( off > -1 ) {
		selector = stripAndCollapse( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax( {
			url: url,

			// If "type" variable is undefined, then "GET" method will be used.
			// Make value of this field explicit since
			// user can override it through ajaxSetup method
			type: type || "GET",
			dataType: "html",
			data: params
		} ).done( function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		// If the request succeeds, this function gets "data", "status", "jqXHR"
		// but they are ignored because response was set above.
		// If it fails, this function gets "jqXHR", "status", "error"
		} ).always( callback && function( jqXHR, status ) {
			self.each( function() {
				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
			} );
		} );
	}

	return this;
};




jQuery.expr.pseudos.animated = function( elem ) {
	return jQuery.grep( jQuery.timers, function( fn ) {
		return elem === fn.elem;
	} ).length;
};




jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( isFunction( options ) ) {

			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend( {

	// offset() relates an element's border box to the document origin
	offset: function( options ) {

		// Preserve chaining for setter
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each( function( i ) {
					jQuery.offset.setOffset( this, options, i );
				} );
		}

		var rect, win,
			elem = this[ 0 ];

		if ( !elem ) {
			return;
		}

		// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
		// Support: IE <=11 only
		// Running getBoundingClientRect on a
		// disconnected node in IE throws an error
		if ( !elem.getClientRects().length ) {
			return { top: 0, left: 0 };
		}

		// Get document-relative position by adding viewport scroll to viewport-relative gBCR
		rect = elem.getBoundingClientRect();
		win = elem.ownerDocument.defaultView;
		return {
			top: rect.top + win.pageYOffset,
			left: rect.left + win.pageXOffset
		};
	},

	// position() relates an element's margin box to its offset parent's padding box
	// This corresponds to the behavior of CSS absolute positioning
	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset, doc,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// position:fixed elements are offset from the viewport, which itself always has zero offset
		if ( jQuery.css( elem, "position" ) === "fixed" ) {

			// Assume position:fixed implies availability of getBoundingClientRect
			offset = elem.getBoundingClientRect();

		} else {
			offset = this.offset();

			// Account for the *real* offset parent, which can be the document or its root element
			// when a statically positioned element is identified
			doc = elem.ownerDocument;
			offsetParent = elem.offsetParent || doc.documentElement;
			while ( offsetParent &&
				( offsetParent === doc.body || offsetParent === doc.documentElement ) &&
				jQuery.css( offsetParent, "position" ) === "static" ) {

				offsetParent = offsetParent.parentNode;
			}
			if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {

				// Incorporate borders into its offset, since they are outside its content origin
				parentOffset = jQuery( offsetParent ).offset();
				parentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );
				parentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );
			}
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	// This method will return documentElement in the following cases:
	// 1) For the element inside the iframe without offsetParent, this method will return
	//    documentElement of the parent window
	// 2) For the hidden or detached element
	// 3) For body or html element, i.e. in case of the html node - it will return itself
	//
	// but those exceptions were never presented as a real life use-cases
	// and might be considered as more preferable results.
	//
	// This logic, however, is not guaranteed and can change at any point in the future
	offsetParent: function() {
		return this.map( function() {
			var offsetParent = this.offsetParent;

			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || documentElement;
		} );
	}
} );

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {

			// Coalesce documents and windows
			var win;
			if ( isWindow( elem ) ) {
				win = elem;
			} else if ( elem.nodeType === 9 ) {
				win = elem.defaultView;
			}

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : win.pageXOffset,
					top ? val : win.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length );
	};
} );

// Support: Safari <=7 - 9.1, Chrome <=37 - 49
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( _i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
} );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( {
		padding: "inner" + name,
		content: type,
		"": "outer" + name
	}, function( defaultExtra, funcName ) {

		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( isWindow( elem ) ) {

					// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
					return funcName.indexOf( "outer" ) === 0 ?
						elem[ "inner" + name ] :
						elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable );
		};
	} );
} );


jQuery.each( [
	"ajaxStart",
	"ajaxStop",
	"ajaxComplete",
	"ajaxError",
	"ajaxSuccess",
	"ajaxSend"
], function( _i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
} );




jQuery.fn.extend( {

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {

		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ?
			this.off( selector, "**" ) :
			this.off( types, selector || "**", fn );
	},

	hover: function( fnOver, fnOut ) {
		return this
			.on( "mouseenter", fnOver )
			.on( "mouseleave", fnOut || fnOver );
	}
} );

jQuery.each(
	( "blur focus focusin focusout resize scroll click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup contextmenu" ).split( " " ),
	function( _i, name ) {

		// Handle event binding
		jQuery.fn[ name ] = function( data, fn ) {
			return arguments.length > 0 ?
				this.on( name, null, data, fn ) :
				this.trigger( name );
		};
	}
);




// Support: Android <=4.0 only
// Make sure we trim BOM and NBSP
// Require that the "whitespace run" starts from a non-whitespace
// to avoid O(N^2) behavior when the engine would try matching "\s+$" at each space position.
var rtrim = /^[\s\uFEFF\xA0]+|([^\s\uFEFF\xA0])[\s\uFEFF\xA0]+$/g;

// Bind a function to a context, optionally partially applying any
// arguments.
// jQuery.proxy is deprecated to promote standards (specifically Function#bind)
// However, it is not slated for removal any time soon
jQuery.proxy = function( fn, context ) {
	var tmp, args, proxy;

	if ( typeof context === "string" ) {
		tmp = fn[ context ];
		context = fn;
		fn = tmp;
	}

	// Quick check to determine if target is callable, in the spec
	// this throws a TypeError, but we will just return undefined.
	if ( !isFunction( fn ) ) {
		return undefined;
	}

	// Simulated bind
	args = slice.call( arguments, 2 );
	proxy = function() {
		return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
	};

	// Set the guid of unique handler to the same of original handler, so it can be removed
	proxy.guid = fn.guid = fn.guid || jQuery.guid++;

	return proxy;
};

jQuery.holdReady = function( hold ) {
	if ( hold ) {
		jQuery.readyWait++;
	} else {
		jQuery.ready( true );
	}
};
jQuery.isArray = Array.isArray;
jQuery.parseJSON = JSON.parse;
jQuery.nodeName = nodeName;
jQuery.isFunction = isFunction;
jQuery.isWindow = isWindow;
jQuery.camelCase = camelCase;
jQuery.type = toType;

jQuery.now = Date.now;

jQuery.isNumeric = function( obj ) {

	// As of jQuery 3.0, isNumeric is limited to
	// strings and numbers (primitives or objects)
	// that can be coerced to finite numbers (gh-2662)
	var type = jQuery.type( obj );
	return ( type === "number" || type === "string" ) &&

		// parseFloat NaNs numeric-cast false positives ("")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		!isNaN( obj - parseFloat( obj ) );
};

jQuery.trim = function( text ) {
	return text == null ?
		"" :
		( text + "" ).replace( rtrim, "$1" );
};



// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( true ) {
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {
		return jQuery;
	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
}




var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (trac-7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (trac-13566)
if ( typeof noGlobal === "undefined" ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;
} );


/***/ }),

/***/ 509:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var isCallable = __webpack_require__(9985);
var tryToString = __webpack_require__(3691);

var $TypeError = TypeError;

// `Assert: IsCallable(argument) is true`
module.exports = function (argument) {
  if (isCallable(argument)) return argument;
  throw new $TypeError(tryToString(argument) + ' is not a function');
};


/***/ }),

/***/ 2655:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var isConstructor = __webpack_require__(9429);
var tryToString = __webpack_require__(3691);

var $TypeError = TypeError;

// `Assert: IsConstructor(argument) is true`
module.exports = function (argument) {
  if (isConstructor(argument)) return argument;
  throw new $TypeError(tryToString(argument) + ' is not a constructor');
};


/***/ }),

/***/ 3550:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var isPossiblePrototype = __webpack_require__(598);

var $String = String;
var $TypeError = TypeError;

module.exports = function (argument) {
  if (isPossiblePrototype(argument)) return argument;
  throw new $TypeError("Can't set " + $String(argument) + ' as a prototype');
};


/***/ }),

/***/ 7370:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var wellKnownSymbol = __webpack_require__(4201);
var create = __webpack_require__(5391);
var defineProperty = (__webpack_require__(2560).f);

var UNSCOPABLES = wellKnownSymbol('unscopables');
var ArrayPrototype = Array.prototype;

// Array.prototype[@@unscopables]
// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
if (ArrayPrototype[UNSCOPABLES] === undefined) {
  defineProperty(ArrayPrototype, UNSCOPABLES, {
    configurable: true,
    value: create(null)
  });
}

// add a key to Array.prototype[@@unscopables]
module.exports = function (key) {
  ArrayPrototype[UNSCOPABLES][key] = true;
};


/***/ }),

/***/ 1514:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var charAt = (__webpack_require__(730).charAt);

// `AdvanceStringIndex` abstract operation
// https://tc39.es/ecma262/#sec-advancestringindex
module.exports = function (S, index, unicode) {
  return index + (unicode ? charAt(S, index).length : 1);
};


/***/ }),

/***/ 5027:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var isObject = __webpack_require__(8999);

var $String = String;
var $TypeError = TypeError;

// `Assert: Type(argument) is Object`
module.exports = function (argument) {
  if (isObject(argument)) return argument;
  throw new $TypeError($String(argument) + ' is not an object');
};


/***/ }),

/***/ 7075:
/***/ ((module) => {

"use strict";

// eslint-disable-next-line es/no-typed-arrays -- safe
module.exports = typeof ArrayBuffer != 'undefined' && typeof DataView != 'undefined';


/***/ }),

/***/ 4872:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var NATIVE_ARRAY_BUFFER = __webpack_require__(7075);
var DESCRIPTORS = __webpack_require__(7697);
var global = __webpack_require__(9037);
var isCallable = __webpack_require__(9985);
var isObject = __webpack_require__(8999);
var hasOwn = __webpack_require__(6812);
var classof = __webpack_require__(926);
var tryToString = __webpack_require__(3691);
var createNonEnumerableProperty = __webpack_require__(5773);
var defineBuiltIn = __webpack_require__(1880);
var defineBuiltInAccessor = __webpack_require__(2148);
var isPrototypeOf = __webpack_require__(3622);
var getPrototypeOf = __webpack_require__(1868);
var setPrototypeOf = __webpack_require__(9385);
var wellKnownSymbol = __webpack_require__(4201);
var uid = __webpack_require__(4630);
var InternalStateModule = __webpack_require__(618);

var enforceInternalState = InternalStateModule.enforce;
var getInternalState = InternalStateModule.get;
var Int8Array = global.Int8Array;
var Int8ArrayPrototype = Int8Array && Int8Array.prototype;
var Uint8ClampedArray = global.Uint8ClampedArray;
var Uint8ClampedArrayPrototype = Uint8ClampedArray && Uint8ClampedArray.prototype;
var TypedArray = Int8Array && getPrototypeOf(Int8Array);
var TypedArrayPrototype = Int8ArrayPrototype && getPrototypeOf(Int8ArrayPrototype);
var ObjectPrototype = Object.prototype;
var TypeError = global.TypeError;

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var TYPED_ARRAY_TAG = uid('TYPED_ARRAY_TAG');
var TYPED_ARRAY_CONSTRUCTOR = 'TypedArrayConstructor';
// Fixing native typed arrays in Opera Presto crashes the browser, see #595
var NATIVE_ARRAY_BUFFER_VIEWS = NATIVE_ARRAY_BUFFER && !!setPrototypeOf && classof(global.opera) !== 'Opera';
var TYPED_ARRAY_TAG_REQUIRED = false;
var NAME, Constructor, Prototype;

var TypedArrayConstructorsList = {
  Int8Array: 1,
  Uint8Array: 1,
  Uint8ClampedArray: 1,
  Int16Array: 2,
  Uint16Array: 2,
  Int32Array: 4,
  Uint32Array: 4,
  Float32Array: 4,
  Float64Array: 8
};

var BigIntArrayConstructorsList = {
  BigInt64Array: 8,
  BigUint64Array: 8
};

var isView = function isView(it) {
  if (!isObject(it)) return false;
  var klass = classof(it);
  return klass === 'DataView'
    || hasOwn(TypedArrayConstructorsList, klass)
    || hasOwn(BigIntArrayConstructorsList, klass);
};

var getTypedArrayConstructor = function (it) {
  var proto = getPrototypeOf(it);
  if (!isObject(proto)) return;
  var state = getInternalState(proto);
  return (state && hasOwn(state, TYPED_ARRAY_CONSTRUCTOR)) ? state[TYPED_ARRAY_CONSTRUCTOR] : getTypedArrayConstructor(proto);
};

var isTypedArray = function (it) {
  if (!isObject(it)) return false;
  var klass = classof(it);
  return hasOwn(TypedArrayConstructorsList, klass)
    || hasOwn(BigIntArrayConstructorsList, klass);
};

var aTypedArray = function (it) {
  if (isTypedArray(it)) return it;
  throw new TypeError('Target is not a typed array');
};

var aTypedArrayConstructor = function (C) {
  if (isCallable(C) && (!setPrototypeOf || isPrototypeOf(TypedArray, C))) return C;
  throw new TypeError(tryToString(C) + ' is not a typed array constructor');
};

var exportTypedArrayMethod = function (KEY, property, forced, options) {
  if (!DESCRIPTORS) return;
  if (forced) for (var ARRAY in TypedArrayConstructorsList) {
    var TypedArrayConstructor = global[ARRAY];
    if (TypedArrayConstructor && hasOwn(TypedArrayConstructor.prototype, KEY)) try {
      delete TypedArrayConstructor.prototype[KEY];
    } catch (error) {
      // old WebKit bug - some methods are non-configurable
      try {
        TypedArrayConstructor.prototype[KEY] = property;
      } catch (error2) { /* empty */ }
    }
  }
  if (!TypedArrayPrototype[KEY] || forced) {
    defineBuiltIn(TypedArrayPrototype, KEY, forced ? property
      : NATIVE_ARRAY_BUFFER_VIEWS && Int8ArrayPrototype[KEY] || property, options);
  }
};

var exportTypedArrayStaticMethod = function (KEY, property, forced) {
  var ARRAY, TypedArrayConstructor;
  if (!DESCRIPTORS) return;
  if (setPrototypeOf) {
    if (forced) for (ARRAY in TypedArrayConstructorsList) {
      TypedArrayConstructor = global[ARRAY];
      if (TypedArrayConstructor && hasOwn(TypedArrayConstructor, KEY)) try {
        delete TypedArrayConstructor[KEY];
      } catch (error) { /* empty */ }
    }
    if (!TypedArray[KEY] || forced) {
      // V8 ~ Chrome 49-50 `%TypedArray%` methods are non-writable non-configurable
      try {
        return defineBuiltIn(TypedArray, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && TypedArray[KEY] || property);
      } catch (error) { /* empty */ }
    } else return;
  }
  for (ARRAY in TypedArrayConstructorsList) {
    TypedArrayConstructor = global[ARRAY];
    if (TypedArrayConstructor && (!TypedArrayConstructor[KEY] || forced)) {
      defineBuiltIn(TypedArrayConstructor, KEY, property);
    }
  }
};

for (NAME in TypedArrayConstructorsList) {
  Constructor = global[NAME];
  Prototype = Constructor && Constructor.prototype;
  if (Prototype) enforceInternalState(Prototype)[TYPED_ARRAY_CONSTRUCTOR] = Constructor;
  else NATIVE_ARRAY_BUFFER_VIEWS = false;
}

for (NAME in BigIntArrayConstructorsList) {
  Constructor = global[NAME];
  Prototype = Constructor && Constructor.prototype;
  if (Prototype) enforceInternalState(Prototype)[TYPED_ARRAY_CONSTRUCTOR] = Constructor;
}

// WebKit bug - typed arrays constructors prototype is Object.prototype
if (!NATIVE_ARRAY_BUFFER_VIEWS || !isCallable(TypedArray) || TypedArray === Function.prototype) {
  // eslint-disable-next-line no-shadow -- safe
  TypedArray = function TypedArray() {
    throw new TypeError('Incorrect invocation');
  };
  if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) {
    if (global[NAME]) setPrototypeOf(global[NAME], TypedArray);
  }
}

if (!NATIVE_ARRAY_BUFFER_VIEWS || !TypedArrayPrototype || TypedArrayPrototype === ObjectPrototype) {
  TypedArrayPrototype = TypedArray.prototype;
  if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) {
    if (global[NAME]) setPrototypeOf(global[NAME].prototype, TypedArrayPrototype);
  }
}

// WebKit bug - one more object in Uint8ClampedArray prototype chain
if (NATIVE_ARRAY_BUFFER_VIEWS && getPrototypeOf(Uint8ClampedArrayPrototype) !== TypedArrayPrototype) {
  setPrototypeOf(Uint8ClampedArrayPrototype, TypedArrayPrototype);
}

if (DESCRIPTORS && !hasOwn(TypedArrayPrototype, TO_STRING_TAG)) {
  TYPED_ARRAY_TAG_REQUIRED = true;
  defineBuiltInAccessor(TypedArrayPrototype, TO_STRING_TAG, {
    configurable: true,
    get: function () {
      return isObject(this) ? this[TYPED_ARRAY_TAG] : undefined;
    }
  });
  for (NAME in TypedArrayConstructorsList) if (global[NAME]) {
    createNonEnumerableProperty(global[NAME], TYPED_ARRAY_TAG, NAME);
  }
}

module.exports = {
  NATIVE_ARRAY_BUFFER_VIEWS: NATIVE_ARRAY_BUFFER_VIEWS,
  TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQUIRED && TYPED_ARRAY_TAG,
  aTypedArray: aTypedArray,
  aTypedArrayConstructor: aTypedArrayConstructor,
  exportTypedArrayMethod: exportTypedArrayMethod,
  exportTypedArrayStaticMethod: exportTypedArrayStaticMethod,
  getTypedArrayConstructor: getTypedArrayConstructor,
  isView: isView,
  isTypedArray: isTypedArray,
  TypedArray: TypedArray,
  TypedArrayPrototype: TypedArrayPrototype
};


/***/ }),

/***/ 4328:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var toIndexedObject = __webpack_require__(5290);
var toAbsoluteIndex = __webpack_require__(7578);
var lengthOfArrayLike = __webpack_require__(6310);

// `Array.prototype.{ indexOf, includes }` methods implementation
var createMethod = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIndexedObject($this);
    var length = lengthOfArrayLike(O);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare -- NaN check
    if (IS_INCLUDES && el !== el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare -- NaN check
      if (value !== value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) {
      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

module.exports = {
  // `Array.prototype.includes` method
  // https://tc39.es/ecma262/#sec-array.prototype.includes
  includes: createMethod(true),
  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  indexOf: createMethod(false)
};


/***/ }),

/***/ 6834:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var fails = __webpack_require__(3689);

module.exports = function (METHOD_NAME, argument) {
  var method = [][METHOD_NAME];
  return !!method && fails(function () {
    // eslint-disable-next-line no-useless-call -- required for testing
    method.call(null, argument || function () { return 1; }, 1);
  });
};


/***/ }),

/***/ 8820:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var aCallable = __webpack_require__(509);
var toObject = __webpack_require__(690);
var IndexedObject = __webpack_require__(4413);
var lengthOfArrayLike = __webpack_require__(6310);

var $TypeError = TypeError;

// `Array.prototype.{ reduce, reduceRight }` methods implementation
var createMethod = function (IS_RIGHT) {
  return function (that, callbackfn, argumentsLength, memo) {
    var O = toObject(that);
    var self = IndexedObject(O);
    var length = lengthOfArrayLike(O);
    aCallable(callbackfn);
    var index = IS_RIGHT ? length - 1 : 0;
    var i = IS_RIGHT ? -1 : 1;
    if (argumentsLength < 2) while (true) {
      if (index in self) {
        memo = self[index];
        index += i;
        break;
      }
      index += i;
      if (IS_RIGHT ? index < 0 : length <= index) {
        throw new $TypeError('Reduce of empty array with no initial value');
      }
    }
    for (;IS_RIGHT ? index >= 0 : length > index; index += i) if (index in self) {
      memo = callbackfn(memo, self[index], index, O);
    }
    return memo;
  };
};

module.exports = {
  // `Array.prototype.reduce` method
  // https://tc39.es/ecma262/#sec-array.prototype.reduce
  left: createMethod(false),
  // `Array.prototype.reduceRight` method
  // https://tc39.es/ecma262/#sec-array.prototype.reduceright
  right: createMethod(true)
};


/***/ }),

/***/ 6004:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(8844);

module.exports = uncurryThis([].slice);


/***/ }),

/***/ 382:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var arraySlice = __webpack_require__(6004);

var floor = Math.floor;

var sort = function (array, comparefn) {
  var length = array.length;

  if (length < 8) {
    // insertion sort
    var i = 1;
    var element, j;

    while (i < length) {
      j = i;
      element = array[i];
      while (j && comparefn(array[j - 1], element) > 0) {
        array[j] = array[--j];
      }
      if (j !== i++) array[j] = element;
    }
  } else {
    // merge sort
    var middle = floor(length / 2);
    var left = sort(arraySlice(array, 0, middle), comparefn);
    var right = sort(arraySlice(array, middle), comparefn);
    var llength = left.length;
    var rlength = right.length;
    var lindex = 0;
    var rindex = 0;

    while (lindex < llength || rindex < rlength) {
      array[lindex + rindex] = (lindex < llength && rindex < rlength)
        ? comparefn(left[lindex], right[rindex]) <= 0 ? left[lindex++] : right[rindex++]
        : lindex < llength ? left[lindex++] : right[rindex++];
    }
  }

  return array;
};

module.exports = sort;


/***/ }),

/***/ 6648:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(8844);

var toString = uncurryThis({}.toString);
var stringSlice = uncurryThis(''.slice);

module.exports = function (it) {
  return stringSlice(toString(it), 8, -1);
};


/***/ }),

/***/ 926:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var TO_STRING_TAG_SUPPORT = __webpack_require__(3043);
var isCallable = __webpack_require__(9985);
var classofRaw = __webpack_require__(6648);
var wellKnownSymbol = __webpack_require__(4201);

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var $Object = Object;

// ES3 wrong here
var CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) === 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (error) { /* empty */ }
};

// getting tag from ES6+ `Object.prototype.toString`
module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {
  var O, tag, result;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == 'string' ? tag
    // builtinTag case
    : CORRECT_ARGUMENTS ? classofRaw(O)
    // ES3 arguments fallback
    : (result = classofRaw(O)) === 'Object' && isCallable(O.callee) ? 'Arguments' : result;
};


/***/ }),

/***/ 8758:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var hasOwn = __webpack_require__(6812);
var ownKeys = __webpack_require__(9152);
var getOwnPropertyDescriptorModule = __webpack_require__(2474);
var definePropertyModule = __webpack_require__(2560);

module.exports = function (target, source, exceptions) {
  var keys = ownKeys(source);
  var defineProperty = definePropertyModule.f;
  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) {
      defineProperty(target, key, getOwnPropertyDescriptor(source, key));
    }
  }
};


/***/ }),

/***/ 1748:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var fails = __webpack_require__(3689);

module.exports = !fails(function () {
  function F() { /* empty */ }
  F.prototype.constructor = null;
  // eslint-disable-next-line es/no-object-getprototypeof -- required for testing
  return Object.getPrototypeOf(new F()) !== F.prototype;
});


/***/ }),

/***/ 7807:
/***/ ((module) => {

"use strict";

// `CreateIterResultObject` abstract operation
// https://tc39.es/ecma262/#sec-createiterresultobject
module.exports = function (value, done) {
  return { value: value, done: done };
};


/***/ }),

/***/ 5773:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var DESCRIPTORS = __webpack_require__(7697);
var definePropertyModule = __webpack_require__(2560);
var createPropertyDescriptor = __webpack_require__(5684);

module.exports = DESCRIPTORS ? function (object, key, value) {
  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),

/***/ 5684:
/***/ ((module) => {

"use strict";

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),

/***/ 2148:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var makeBuiltIn = __webpack_require__(8702);
var defineProperty = __webpack_require__(2560);

module.exports = function (target, name, descriptor) {
  if (descriptor.get) makeBuiltIn(descriptor.get, name, { getter: true });
  if (descriptor.set) makeBuiltIn(descriptor.set, name, { setter: true });
  return defineProperty.f(target, name, descriptor);
};


/***/ }),

/***/ 1880:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var isCallable = __webpack_require__(9985);
var definePropertyModule = __webpack_require__(2560);
var makeBuiltIn = __webpack_require__(8702);
var defineGlobalProperty = __webpack_require__(5014);

module.exports = function (O, key, value, options) {
  if (!options) options = {};
  var simple = options.enumerable;
  var name = options.name !== undefined ? options.name : key;
  if (isCallable(value)) makeBuiltIn(value, name, options);
  if (options.global) {
    if (simple) O[key] = value;
    else defineGlobalProperty(key, value);
  } else {
    try {
      if (!options.unsafe) delete O[key];
      else if (O[key]) simple = true;
    } catch (error) { /* empty */ }
    if (simple) O[key] = value;
    else definePropertyModule.f(O, key, {
      value: value,
      enumerable: false,
      configurable: !options.nonConfigurable,
      writable: !options.nonWritable
    });
  } return O;
};


/***/ }),

/***/ 5014:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var global = __webpack_require__(9037);

// eslint-disable-next-line es/no-object-defineproperty -- safe
var defineProperty = Object.defineProperty;

module.exports = function (key, value) {
  try {
    defineProperty(global, key, { value: value, configurable: true, writable: true });
  } catch (error) {
    global[key] = value;
  } return value;
};


/***/ }),

/***/ 7697:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var fails = __webpack_require__(3689);

// Detect IE8's incomplete defineProperty implementation
module.exports = !fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] !== 7;
});


/***/ }),

/***/ 6420:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var global = __webpack_require__(9037);
var isObject = __webpack_require__(8999);

var document = global.document;
// typeof document.createElement is 'object' in old IE
var EXISTS = isObject(document) && isObject(document.createElement);

module.exports = function (it) {
  return EXISTS ? document.createElement(it) : {};
};


/***/ }),

/***/ 7365:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var userAgent = __webpack_require__(71);

var firefox = userAgent.match(/firefox\/(\d+)/i);

module.exports = !!firefox && +firefox[1];


/***/ }),

/***/ 7298:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var UA = __webpack_require__(71);

module.exports = /MSIE|Trident/.test(UA);


/***/ }),

/***/ 806:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var global = __webpack_require__(9037);
var classof = __webpack_require__(6648);

module.exports = classof(global.process) === 'process';


/***/ }),

/***/ 71:
/***/ ((module) => {

"use strict";

module.exports = typeof navigator != 'undefined' && String(navigator.userAgent) || '';


/***/ }),

/***/ 3615:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var global = __webpack_require__(9037);
var userAgent = __webpack_require__(71);

var process = global.process;
var Deno = global.Deno;
var versions = process && process.versions || Deno && Deno.version;
var v8 = versions && versions.v8;
var match, version;

if (v8) {
  match = v8.split('.');
  // in old Chrome, versions of V8 isn't V8 = Chrome / 10
  // but their correct versions are not interesting for us
  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
}

// BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`
// so check `userAgent` even if `.v8` exists, but 0
if (!version && userAgent) {
  match = userAgent.match(/Edge\/(\d+)/);
  if (!match || match[1] >= 74) {
    match = userAgent.match(/Chrome\/(\d+)/);
    if (match) version = +match[1];
  }
}

module.exports = version;


/***/ }),

/***/ 7922:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var userAgent = __webpack_require__(71);

var webkit = userAgent.match(/AppleWebKit\/(\d+)\./);

module.exports = !!webkit && +webkit[1];


/***/ }),

/***/ 2739:
/***/ ((module) => {

"use strict";

// IE8- don't enum bug keys
module.exports = [
  'constructor',
  'hasOwnProperty',
  'isPrototypeOf',
  'propertyIsEnumerable',
  'toLocaleString',
  'toString',
  'valueOf'
];


/***/ }),

/***/ 9989:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var global = __webpack_require__(9037);
var getOwnPropertyDescriptor = (__webpack_require__(2474).f);
var createNonEnumerableProperty = __webpack_require__(5773);
var defineBuiltIn = __webpack_require__(1880);
var defineGlobalProperty = __webpack_require__(5014);
var copyConstructorProperties = __webpack_require__(8758);
var isForced = __webpack_require__(5266);

/*
  options.target         - name of the target object
  options.global         - target is the global object
  options.stat           - export as static methods of target
  options.proto          - export as prototype methods of target
  options.real           - real prototype method for the `pure` version
  options.forced         - export even if the native feature is available
  options.bind           - bind methods to the target, required for the `pure` version
  options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe         - use the simple assignment of property instead of delete + defineProperty
  options.sham           - add a flag to not completely full polyfills
  options.enumerable     - export as enumerable property
  options.dontCallGetSet - prevent calling a getter on target
  options.name           - the .name of the function if it does not match the key
*/
module.exports = function (options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var FORCED, target, key, targetProperty, sourceProperty, descriptor;
  if (GLOBAL) {
    target = global;
  } else if (STATIC) {
    target = global[TARGET] || defineGlobalProperty(TARGET, {});
  } else {
    target = global[TARGET] && global[TARGET].prototype;
  }
  if (target) for (key in source) {
    sourceProperty = source[key];
    if (options.dontCallGetSet) {
      descriptor = getOwnPropertyDescriptor(target, key);
      targetProperty = descriptor && descriptor.value;
    } else targetProperty = target[key];
    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
    // contained in target
    if (!FORCED && targetProperty !== undefined) {
      if (typeof sourceProperty == typeof targetProperty) continue;
      copyConstructorProperties(sourceProperty, targetProperty);
    }
    // add a flag to not completely full polyfills
    if (options.sham || (targetProperty && targetProperty.sham)) {
      createNonEnumerableProperty(sourceProperty, 'sham', true);
    }
    defineBuiltIn(target, key, sourceProperty, options);
  }
};


/***/ }),

/***/ 3689:
/***/ ((module) => {

"use strict";

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (error) {
    return true;
  }
};


/***/ }),

/***/ 1735:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var NATIVE_BIND = __webpack_require__(7215);

var FunctionPrototype = Function.prototype;
var apply = FunctionPrototype.apply;
var call = FunctionPrototype.call;

// eslint-disable-next-line es/no-reflect -- safe
module.exports = typeof Reflect == 'object' && Reflect.apply || (NATIVE_BIND ? call.bind(apply) : function () {
  return call.apply(apply, arguments);
});


/***/ }),

/***/ 7215:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var fails = __webpack_require__(3689);

module.exports = !fails(function () {
  // eslint-disable-next-line es/no-function-prototype-bind -- safe
  var test = (function () { /* empty */ }).bind();
  // eslint-disable-next-line no-prototype-builtins -- safe
  return typeof test != 'function' || test.hasOwnProperty('prototype');
});


/***/ }),

/***/ 2615:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var NATIVE_BIND = __webpack_require__(7215);

var call = Function.prototype.call;

module.exports = NATIVE_BIND ? call.bind(call) : function () {
  return call.apply(call, arguments);
};


/***/ }),

/***/ 1236:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var DESCRIPTORS = __webpack_require__(7697);
var hasOwn = __webpack_require__(6812);

var FunctionPrototype = Function.prototype;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;

var EXISTS = hasOwn(FunctionPrototype, 'name');
// additional protection from minified / mangled / dropped function names
var PROPER = EXISTS && (function something() { /* empty */ }).name === 'something';
var CONFIGURABLE = EXISTS && (!DESCRIPTORS || (DESCRIPTORS && getDescriptor(FunctionPrototype, 'name').configurable));

module.exports = {
  EXISTS: EXISTS,
  PROPER: PROPER,
  CONFIGURABLE: CONFIGURABLE
};


/***/ }),

/***/ 2743:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(8844);
var aCallable = __webpack_require__(509);

module.exports = function (object, key, method) {
  try {
    // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
    return uncurryThis(aCallable(Object.getOwnPropertyDescriptor(object, key)[method]));
  } catch (error) { /* empty */ }
};


/***/ }),

/***/ 6576:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var classofRaw = __webpack_require__(6648);
var uncurryThis = __webpack_require__(8844);

module.exports = function (fn) {
  // Nashorn bug:
  //   https://github.com/zloirock/core-js/issues/1128
  //   https://github.com/zloirock/core-js/issues/1130
  if (classofRaw(fn) === 'Function') return uncurryThis(fn);
};


/***/ }),

/***/ 8844:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var NATIVE_BIND = __webpack_require__(7215);

var FunctionPrototype = Function.prototype;
var call = FunctionPrototype.call;
var uncurryThisWithBind = NATIVE_BIND && FunctionPrototype.bind.bind(call, call);

module.exports = NATIVE_BIND ? uncurryThisWithBind : function (fn) {
  return function () {
    return call.apply(fn, arguments);
  };
};


/***/ }),

/***/ 6058:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var global = __webpack_require__(9037);
var isCallable = __webpack_require__(9985);

var aFunction = function (argument) {
  return isCallable(argument) ? argument : undefined;
};

module.exports = function (namespace, method) {
  return arguments.length < 2 ? aFunction(global[namespace]) : global[namespace] && global[namespace][method];
};


/***/ }),

/***/ 2643:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(8844);
var isArray = __webpack_require__(2297);
var isCallable = __webpack_require__(9985);
var classof = __webpack_require__(6648);
var toString = __webpack_require__(4327);

var push = uncurryThis([].push);

module.exports = function (replacer) {
  if (isCallable(replacer)) return replacer;
  if (!isArray(replacer)) return;
  var rawLength = replacer.length;
  var keys = [];
  for (var i = 0; i < rawLength; i++) {
    var element = replacer[i];
    if (typeof element == 'string') push(keys, element);
    else if (typeof element == 'number' || classof(element) === 'Number' || classof(element) === 'String') push(keys, toString(element));
  }
  var keysLength = keys.length;
  var root = true;
  return function (key, value) {
    if (root) {
      root = false;
      return value;
    }
    if (isArray(this)) return value;
    for (var j = 0; j < keysLength; j++) if (keys[j] === key) return value;
  };
};


/***/ }),

/***/ 4849:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var aCallable = __webpack_require__(509);
var isNullOrUndefined = __webpack_require__(981);

// `GetMethod` abstract operation
// https://tc39.es/ecma262/#sec-getmethod
module.exports = function (V, P) {
  var func = V[P];
  return isNullOrUndefined(func) ? undefined : aCallable(func);
};


/***/ }),

/***/ 9037:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var check = function (it) {
  return it && it.Math === Math && it;
};

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
module.exports =
  // eslint-disable-next-line es/no-global-this -- safe
  check(typeof globalThis == 'object' && globalThis) ||
  check(typeof window == 'object' && window) ||
  // eslint-disable-next-line no-restricted-globals -- safe
  check(typeof self == 'object' && self) ||
  check(typeof __webpack_require__.g == 'object' && __webpack_require__.g) ||
  check(typeof this == 'object' && this) ||
  // eslint-disable-next-line no-new-func -- fallback
  (function () { return this; })() || Function('return this')();


/***/ }),

/***/ 6812:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(8844);
var toObject = __webpack_require__(690);

var hasOwnProperty = uncurryThis({}.hasOwnProperty);

// `HasOwnProperty` abstract operation
// https://tc39.es/ecma262/#sec-hasownproperty
// eslint-disable-next-line es/no-object-hasown -- safe
module.exports = Object.hasOwn || function hasOwn(it, key) {
  return hasOwnProperty(toObject(it), key);
};


/***/ }),

/***/ 7248:
/***/ ((module) => {

"use strict";

module.exports = {};


/***/ }),

/***/ 2688:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var getBuiltIn = __webpack_require__(6058);

module.exports = getBuiltIn('document', 'documentElement');


/***/ }),

/***/ 8506:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var DESCRIPTORS = __webpack_require__(7697);
var fails = __webpack_require__(3689);
var createElement = __webpack_require__(6420);

// Thanks to IE8 for its funny defineProperty
module.exports = !DESCRIPTORS && !fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty(createElement('div'), 'a', {
    get: function () { return 7; }
  }).a !== 7;
});


/***/ }),

/***/ 4413:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(8844);
var fails = __webpack_require__(3689);
var classof = __webpack_require__(6648);

var $Object = Object;
var split = uncurryThis(''.split);

// fallback for non-array-like ES3 and non-enumerable old V8 strings
module.exports = fails(function () {
  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
  // eslint-disable-next-line no-prototype-builtins -- safe
  return !$Object('z').propertyIsEnumerable(0);
}) ? function (it) {
  return classof(it) === 'String' ? split(it, '') : $Object(it);
} : $Object;


/***/ }),

/***/ 6738:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(8844);
var isCallable = __webpack_require__(9985);
var store = __webpack_require__(4091);

var functionToString = uncurryThis(Function.toString);

// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper
if (!isCallable(store.inspectSource)) {
  store.inspectSource = function (it) {
    return functionToString(it);
  };
}

module.exports = store.inspectSource;


/***/ }),

/***/ 618:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var NATIVE_WEAK_MAP = __webpack_require__(9834);
var global = __webpack_require__(9037);
var isObject = __webpack_require__(8999);
var createNonEnumerableProperty = __webpack_require__(5773);
var hasOwn = __webpack_require__(6812);
var shared = __webpack_require__(4091);
var sharedKey = __webpack_require__(2713);
var hiddenKeys = __webpack_require__(7248);

var OBJECT_ALREADY_INITIALIZED = 'Object already initialized';
var TypeError = global.TypeError;
var WeakMap = global.WeakMap;
var set, get, has;

var enforce = function (it) {
  return has(it) ? get(it) : set(it, {});
};

var getterFor = function (TYPE) {
  return function (it) {
    var state;
    if (!isObject(it) || (state = get(it)).type !== TYPE) {
      throw new TypeError('Incompatible receiver, ' + TYPE + ' required');
    } return state;
  };
};

if (NATIVE_WEAK_MAP || shared.state) {
  var store = shared.state || (shared.state = new WeakMap());
  /* eslint-disable no-self-assign -- prototype methods protection */
  store.get = store.get;
  store.has = store.has;
  store.set = store.set;
  /* eslint-enable no-self-assign -- prototype methods protection */
  set = function (it, metadata) {
    if (store.has(it)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    store.set(it, metadata);
    return metadata;
  };
  get = function (it) {
    return store.get(it) || {};
  };
  has = function (it) {
    return store.has(it);
  };
} else {
  var STATE = sharedKey('state');
  hiddenKeys[STATE] = true;
  set = function (it, metadata) {
    if (hasOwn(it, STATE)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    createNonEnumerableProperty(it, STATE, metadata);
    return metadata;
  };
  get = function (it) {
    return hasOwn(it, STATE) ? it[STATE] : {};
  };
  has = function (it) {
    return hasOwn(it, STATE);
  };
}

module.exports = {
  set: set,
  get: get,
  has: has,
  enforce: enforce,
  getterFor: getterFor
};


/***/ }),

/***/ 2297:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var classof = __webpack_require__(6648);

// `IsArray` abstract operation
// https://tc39.es/ecma262/#sec-isarray
// eslint-disable-next-line es/no-array-isarray -- safe
module.exports = Array.isArray || function isArray(argument) {
  return classof(argument) === 'Array';
};


/***/ }),

/***/ 9985:
/***/ ((module) => {

"use strict";

// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
var documentAll = typeof document == 'object' && document.all;

// `IsCallable` abstract operation
// https://tc39.es/ecma262/#sec-iscallable
// eslint-disable-next-line unicorn/no-typeof-undefined -- required for testing
module.exports = typeof documentAll == 'undefined' && documentAll !== undefined ? function (argument) {
  return typeof argument == 'function' || argument === documentAll;
} : function (argument) {
  return typeof argument == 'function';
};


/***/ }),

/***/ 9429:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(8844);
var fails = __webpack_require__(3689);
var isCallable = __webpack_require__(9985);
var classof = __webpack_require__(926);
var getBuiltIn = __webpack_require__(6058);
var inspectSource = __webpack_require__(6738);

var noop = function () { /* empty */ };
var construct = getBuiltIn('Reflect', 'construct');
var constructorRegExp = /^\s*(?:class|function)\b/;
var exec = uncurryThis(constructorRegExp.exec);
var INCORRECT_TO_STRING = !constructorRegExp.test(noop);

var isConstructorModern = function isConstructor(argument) {
  if (!isCallable(argument)) return false;
  try {
    construct(noop, [], argument);
    return true;
  } catch (error) {
    return false;
  }
};

var isConstructorLegacy = function isConstructor(argument) {
  if (!isCallable(argument)) return false;
  switch (classof(argument)) {
    case 'AsyncFunction':
    case 'GeneratorFunction':
    case 'AsyncGeneratorFunction': return false;
  }
  try {
    // we can't check .prototype since constructors produced by .bind haven't it
    // `Function#toString` throws on some built-it function in some legacy engines
    // (for example, `DOMQuad` and similar in FF41-)
    return INCORRECT_TO_STRING || !!exec(constructorRegExp, inspectSource(argument));
  } catch (error) {
    return true;
  }
};

isConstructorLegacy.sham = true;

// `IsConstructor` abstract operation
// https://tc39.es/ecma262/#sec-isconstructor
module.exports = !construct || fails(function () {
  var called;
  return isConstructorModern(isConstructorModern.call)
    || !isConstructorModern(Object)
    || !isConstructorModern(function () { called = true; })
    || called;
}) ? isConstructorLegacy : isConstructorModern;


/***/ }),

/***/ 5266:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var fails = __webpack_require__(3689);
var isCallable = __webpack_require__(9985);

var replacement = /#|\.prototype\./;

var isForced = function (feature, detection) {
  var value = data[normalize(feature)];
  return value === POLYFILL ? true
    : value === NATIVE ? false
    : isCallable(detection) ? fails(detection)
    : !!detection;
};

var normalize = isForced.normalize = function (string) {
  return String(string).replace(replacement, '.').toLowerCase();
};

var data = isForced.data = {};
var NATIVE = isForced.NATIVE = 'N';
var POLYFILL = isForced.POLYFILL = 'P';

module.exports = isForced;


/***/ }),

/***/ 981:
/***/ ((module) => {

"use strict";

// we can't use just `it == null` since of `document.all` special case
// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot-aec
module.exports = function (it) {
  return it === null || it === undefined;
};


/***/ }),

/***/ 8999:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var isCallable = __webpack_require__(9985);

module.exports = function (it) {
  return typeof it == 'object' ? it !== null : isCallable(it);
};


/***/ }),

/***/ 598:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var isObject = __webpack_require__(8999);

module.exports = function (argument) {
  return isObject(argument) || argument === null;
};


/***/ }),

/***/ 3931:
/***/ ((module) => {

"use strict";

module.exports = false;


/***/ }),

/***/ 1245:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var isObject = __webpack_require__(8999);
var classof = __webpack_require__(6648);
var wellKnownSymbol = __webpack_require__(4201);

var MATCH = wellKnownSymbol('match');

// `IsRegExp` abstract operation
// https://tc39.es/ecma262/#sec-isregexp
module.exports = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : classof(it) === 'RegExp');
};


/***/ }),

/***/ 734:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var getBuiltIn = __webpack_require__(6058);
var isCallable = __webpack_require__(9985);
var isPrototypeOf = __webpack_require__(3622);
var USE_SYMBOL_AS_UID = __webpack_require__(9525);

var $Object = Object;

module.exports = USE_SYMBOL_AS_UID ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  var $Symbol = getBuiltIn('Symbol');
  return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it));
};


/***/ }),

/***/ 974:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var IteratorPrototype = (__webpack_require__(2013).IteratorPrototype);
var create = __webpack_require__(5391);
var createPropertyDescriptor = __webpack_require__(5684);
var setToStringTag = __webpack_require__(5997);
var Iterators = __webpack_require__(9478);

var returnThis = function () { return this; };

module.exports = function (IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {
  var TO_STRING_TAG = NAME + ' Iterator';
  IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(+!ENUMERABLE_NEXT, next) });
  setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
  Iterators[TO_STRING_TAG] = returnThis;
  return IteratorConstructor;
};


/***/ }),

/***/ 2013:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var fails = __webpack_require__(3689);
var isCallable = __webpack_require__(9985);
var isObject = __webpack_require__(8999);
var create = __webpack_require__(5391);
var getPrototypeOf = __webpack_require__(1868);
var defineBuiltIn = __webpack_require__(1880);
var wellKnownSymbol = __webpack_require__(4201);
var IS_PURE = __webpack_require__(3931);

var ITERATOR = wellKnownSymbol('iterator');
var BUGGY_SAFARI_ITERATORS = false;

// `%IteratorPrototype%` object
// https://tc39.es/ecma262/#sec-%iteratorprototype%-object
var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;

/* eslint-disable es/no-array-prototype-keys -- safe */
if ([].keys) {
  arrayIterator = [].keys();
  // Safari 8 has buggy iterators w/o `next`
  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;
  else {
    PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
  }
}

var NEW_ITERATOR_PROTOTYPE = !isObject(IteratorPrototype) || fails(function () {
  var test = {};
  // FF44- legacy iterators case
  return IteratorPrototype[ITERATOR].call(test) !== test;
});

if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype = {};
else if (IS_PURE) IteratorPrototype = create(IteratorPrototype);

// `%IteratorPrototype%[@@iterator]()` method
// https://tc39.es/ecma262/#sec-%iteratorprototype%-@@iterator
if (!isCallable(IteratorPrototype[ITERATOR])) {
  defineBuiltIn(IteratorPrototype, ITERATOR, function () {
    return this;
  });
}

module.exports = {
  IteratorPrototype: IteratorPrototype,
  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
};


/***/ }),

/***/ 9478:
/***/ ((module) => {

"use strict";

module.exports = {};


/***/ }),

/***/ 6310:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var toLength = __webpack_require__(3126);

// `LengthOfArrayLike` abstract operation
// https://tc39.es/ecma262/#sec-lengthofarraylike
module.exports = function (obj) {
  return toLength(obj.length);
};


/***/ }),

/***/ 8702:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(8844);
var fails = __webpack_require__(3689);
var isCallable = __webpack_require__(9985);
var hasOwn = __webpack_require__(6812);
var DESCRIPTORS = __webpack_require__(7697);
var CONFIGURABLE_FUNCTION_NAME = (__webpack_require__(1236).CONFIGURABLE);
var inspectSource = __webpack_require__(6738);
var InternalStateModule = __webpack_require__(618);

var enforceInternalState = InternalStateModule.enforce;
var getInternalState = InternalStateModule.get;
var $String = String;
// eslint-disable-next-line es/no-object-defineproperty -- safe
var defineProperty = Object.defineProperty;
var stringSlice = uncurryThis(''.slice);
var replace = uncurryThis(''.replace);
var join = uncurryThis([].join);

var CONFIGURABLE_LENGTH = DESCRIPTORS && !fails(function () {
  return defineProperty(function () { /* empty */ }, 'length', { value: 8 }).length !== 8;
});

var TEMPLATE = String(String).split('String');

var makeBuiltIn = module.exports = function (value, name, options) {
  if (stringSlice($String(name), 0, 7) === 'Symbol(') {
    name = '[' + replace($String(name), /^Symbol\(([^)]*)\).*$/, '$1') + ']';
  }
  if (options && options.getter) name = 'get ' + name;
  if (options && options.setter) name = 'set ' + name;
  if (!hasOwn(value, 'name') || (CONFIGURABLE_FUNCTION_NAME && value.name !== name)) {
    if (DESCRIPTORS) defineProperty(value, 'name', { value: name, configurable: true });
    else value.name = name;
  }
  if (CONFIGURABLE_LENGTH && options && hasOwn(options, 'arity') && value.length !== options.arity) {
    defineProperty(value, 'length', { value: options.arity });
  }
  try {
    if (options && hasOwn(options, 'constructor') && options.constructor) {
      if (DESCRIPTORS) defineProperty(value, 'prototype', { writable: false });
    // in V8 ~ Chrome 53, prototypes of some methods, like `Array.prototype.values`, are non-writable
    } else if (value.prototype) value.prototype = undefined;
  } catch (error) { /* empty */ }
  var state = enforceInternalState(value);
  if (!hasOwn(state, 'source')) {
    state.source = join(TEMPLATE, typeof name == 'string' ? name : '');
  } return value;
};

// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
// eslint-disable-next-line no-extend-native -- required
Function.prototype.toString = makeBuiltIn(function toString() {
  return isCallable(this) && getInternalState(this).source || inspectSource(this);
}, 'toString');


/***/ }),

/***/ 8828:
/***/ ((module) => {

"use strict";

var ceil = Math.ceil;
var floor = Math.floor;

// `Math.trunc` method
// https://tc39.es/ecma262/#sec-math.trunc
// eslint-disable-next-line es/no-math-trunc -- safe
module.exports = Math.trunc || function trunc(x) {
  var n = +x;
  return (n > 0 ? floor : ceil)(n);
};


/***/ }),

/***/ 5391:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/* global ActiveXObject -- old IE, WSH */
var anObject = __webpack_require__(5027);
var definePropertiesModule = __webpack_require__(8920);
var enumBugKeys = __webpack_require__(2739);
var hiddenKeys = __webpack_require__(7248);
var html = __webpack_require__(2688);
var documentCreateElement = __webpack_require__(6420);
var sharedKey = __webpack_require__(2713);

var GT = '>';
var LT = '<';
var PROTOTYPE = 'prototype';
var SCRIPT = 'script';
var IE_PROTO = sharedKey('IE_PROTO');

var EmptyConstructor = function () { /* empty */ };

var scriptTag = function (content) {
  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
};

// Create object with fake `null` prototype: use ActiveX Object with cleared prototype
var NullProtoObjectViaActiveX = function (activeXDocument) {
  activeXDocument.write(scriptTag(''));
  activeXDocument.close();
  var temp = activeXDocument.parentWindow.Object;
  activeXDocument = null; // avoid memory leak
  return temp;
};

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var NullProtoObjectViaIFrame = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = documentCreateElement('iframe');
  var JS = 'java' + SCRIPT + ':';
  var iframeDocument;
  iframe.style.display = 'none';
  html.appendChild(iframe);
  // https://github.com/zloirock/core-js/issues/475
  iframe.src = String(JS);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(scriptTag('document.F=Object'));
  iframeDocument.close();
  return iframeDocument.F;
};

// Check for document.domain and active x support
// No need to use active x approach when document.domain is not set
// see https://github.com/es-shims/es5-shim/issues/150
// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
// avoid IE GC bug
var activeXDocument;
var NullProtoObject = function () {
  try {
    activeXDocument = new ActiveXObject('htmlfile');
  } catch (error) { /* ignore */ }
  NullProtoObject = typeof document != 'undefined'
    ? document.domain && activeXDocument
      ? NullProtoObjectViaActiveX(activeXDocument) // old IE
      : NullProtoObjectViaIFrame()
    : NullProtoObjectViaActiveX(activeXDocument); // WSH
  var length = enumBugKeys.length;
  while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
  return NullProtoObject();
};

hiddenKeys[IE_PROTO] = true;

// `Object.create` method
// https://tc39.es/ecma262/#sec-object.create
// eslint-disable-next-line es/no-object-create -- safe
module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    EmptyConstructor[PROTOTYPE] = anObject(O);
    result = new EmptyConstructor();
    EmptyConstructor[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = NullProtoObject();
  return Properties === undefined ? result : definePropertiesModule.f(result, Properties);
};


/***/ }),

/***/ 8920:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var DESCRIPTORS = __webpack_require__(7697);
var V8_PROTOTYPE_DEFINE_BUG = __webpack_require__(5648);
var definePropertyModule = __webpack_require__(2560);
var anObject = __webpack_require__(5027);
var toIndexedObject = __webpack_require__(5290);
var objectKeys = __webpack_require__(300);

// `Object.defineProperties` method
// https://tc39.es/ecma262/#sec-object.defineproperties
// eslint-disable-next-line es/no-object-defineproperties -- safe
exports.f = DESCRIPTORS && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var props = toIndexedObject(Properties);
  var keys = objectKeys(Properties);
  var length = keys.length;
  var index = 0;
  var key;
  while (length > index) definePropertyModule.f(O, key = keys[index++], props[key]);
  return O;
};


/***/ }),

/***/ 2560:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var DESCRIPTORS = __webpack_require__(7697);
var IE8_DOM_DEFINE = __webpack_require__(8506);
var V8_PROTOTYPE_DEFINE_BUG = __webpack_require__(5648);
var anObject = __webpack_require__(5027);
var toPropertyKey = __webpack_require__(8360);

var $TypeError = TypeError;
// eslint-disable-next-line es/no-object-defineproperty -- safe
var $defineProperty = Object.defineProperty;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var ENUMERABLE = 'enumerable';
var CONFIGURABLE = 'configurable';
var WRITABLE = 'writable';

// `Object.defineProperty` method
// https://tc39.es/ecma262/#sec-object.defineproperty
exports.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPropertyKey(P);
  anObject(Attributes);
  if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
    var current = $getOwnPropertyDescriptor(O, P);
    if (current && current[WRITABLE]) {
      O[P] = Attributes.value;
      Attributes = {
        configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],
        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
        writable: false
      };
    }
  } return $defineProperty(O, P, Attributes);
} : $defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPropertyKey(P);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return $defineProperty(O, P, Attributes);
  } catch (error) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw new $TypeError('Accessors not supported');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),

/***/ 2474:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var DESCRIPTORS = __webpack_require__(7697);
var call = __webpack_require__(2615);
var propertyIsEnumerableModule = __webpack_require__(9556);
var createPropertyDescriptor = __webpack_require__(5684);
var toIndexedObject = __webpack_require__(5290);
var toPropertyKey = __webpack_require__(8360);
var hasOwn = __webpack_require__(6812);
var IE8_DOM_DEFINE = __webpack_require__(8506);

// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// `Object.getOwnPropertyDescriptor` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
exports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject(O);
  P = toPropertyKey(P);
  if (IE8_DOM_DEFINE) try {
    return $getOwnPropertyDescriptor(O, P);
  } catch (error) { /* empty */ }
  if (hasOwn(O, P)) return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);
};


/***/ }),

/***/ 2741:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var internalObjectKeys = __webpack_require__(4948);
var enumBugKeys = __webpack_require__(2739);

var hiddenKeys = enumBugKeys.concat('length', 'prototype');

// `Object.getOwnPropertyNames` method
// https://tc39.es/ecma262/#sec-object.getownpropertynames
// eslint-disable-next-line es/no-object-getownpropertynames -- safe
exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return internalObjectKeys(O, hiddenKeys);
};


/***/ }),

/***/ 7518:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// eslint-disable-next-line es/no-object-getownpropertysymbols -- safe
exports.f = Object.getOwnPropertySymbols;


/***/ }),

/***/ 1868:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var hasOwn = __webpack_require__(6812);
var isCallable = __webpack_require__(9985);
var toObject = __webpack_require__(690);
var sharedKey = __webpack_require__(2713);
var CORRECT_PROTOTYPE_GETTER = __webpack_require__(1748);

var IE_PROTO = sharedKey('IE_PROTO');
var $Object = Object;
var ObjectPrototype = $Object.prototype;

// `Object.getPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.getprototypeof
// eslint-disable-next-line es/no-object-getprototypeof -- safe
module.exports = CORRECT_PROTOTYPE_GETTER ? $Object.getPrototypeOf : function (O) {
  var object = toObject(O);
  if (hasOwn(object, IE_PROTO)) return object[IE_PROTO];
  var constructor = object.constructor;
  if (isCallable(constructor) && object instanceof constructor) {
    return constructor.prototype;
  } return object instanceof $Object ? ObjectPrototype : null;
};


/***/ }),

/***/ 3622:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(8844);

module.exports = uncurryThis({}.isPrototypeOf);


/***/ }),

/***/ 4948:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(8844);
var hasOwn = __webpack_require__(6812);
var toIndexedObject = __webpack_require__(5290);
var indexOf = (__webpack_require__(4328).indexOf);
var hiddenKeys = __webpack_require__(7248);

var push = uncurryThis([].push);

module.exports = function (object, names) {
  var O = toIndexedObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) !hasOwn(hiddenKeys, key) && hasOwn(O, key) && push(result, key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (hasOwn(O, key = names[i++])) {
    ~indexOf(result, key) || push(result, key);
  }
  return result;
};


/***/ }),

/***/ 300:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var internalObjectKeys = __webpack_require__(4948);
var enumBugKeys = __webpack_require__(2739);

// `Object.keys` method
// https://tc39.es/ecma262/#sec-object.keys
// eslint-disable-next-line es/no-object-keys -- safe
module.exports = Object.keys || function keys(O) {
  return internalObjectKeys(O, enumBugKeys);
};


/***/ }),

/***/ 9556:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

var $propertyIsEnumerable = {}.propertyIsEnumerable;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// Nashorn ~ JDK8 bug
var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);

// `Object.prototype.propertyIsEnumerable` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable
exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = getOwnPropertyDescriptor(this, V);
  return !!descriptor && descriptor.enumerable;
} : $propertyIsEnumerable;


/***/ }),

/***/ 9385:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/* eslint-disable no-proto -- safe */
var uncurryThisAccessor = __webpack_require__(2743);
var anObject = __webpack_require__(5027);
var aPossiblePrototype = __webpack_require__(3550);

// `Object.setPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.setprototypeof
// Works with __proto__ only. Old v8 can't work with null proto objects.
// eslint-disable-next-line es/no-object-setprototypeof -- safe
module.exports = Object.setPrototypeOf || ('__proto__' in {} ? function () {
  var CORRECT_SETTER = false;
  var test = {};
  var setter;
  try {
    setter = uncurryThisAccessor(Object.prototype, '__proto__', 'set');
    setter(test, []);
    CORRECT_SETTER = test instanceof Array;
  } catch (error) { /* empty */ }
  return function setPrototypeOf(O, proto) {
    anObject(O);
    aPossiblePrototype(proto);
    if (CORRECT_SETTER) setter(O, proto);
    else O.__proto__ = proto;
    return O;
  };
}() : undefined);


/***/ }),

/***/ 5899:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var call = __webpack_require__(2615);
var isCallable = __webpack_require__(9985);
var isObject = __webpack_require__(8999);

var $TypeError = TypeError;

// `OrdinaryToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-ordinarytoprimitive
module.exports = function (input, pref) {
  var fn, val;
  if (pref === 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
  if (isCallable(fn = input.valueOf) && !isObject(val = call(fn, input))) return val;
  if (pref !== 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
  throw new $TypeError("Can't convert object to primitive value");
};


/***/ }),

/***/ 9152:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var getBuiltIn = __webpack_require__(6058);
var uncurryThis = __webpack_require__(8844);
var getOwnPropertyNamesModule = __webpack_require__(2741);
var getOwnPropertySymbolsModule = __webpack_require__(7518);
var anObject = __webpack_require__(5027);

var concat = uncurryThis([].concat);

// all object keys, includes non-enumerable and symbols
module.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
  var keys = getOwnPropertyNamesModule.f(anObject(it));
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;
};


/***/ }),

/***/ 6100:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var call = __webpack_require__(2615);
var anObject = __webpack_require__(5027);
var isCallable = __webpack_require__(9985);
var classof = __webpack_require__(6648);
var regexpExec = __webpack_require__(6308);

var $TypeError = TypeError;

// `RegExpExec` abstract operation
// https://tc39.es/ecma262/#sec-regexpexec
module.exports = function (R, S) {
  var exec = R.exec;
  if (isCallable(exec)) {
    var result = call(exec, R, S);
    if (result !== null) anObject(result);
    return result;
  }
  if (classof(R) === 'RegExp') return call(regexpExec, R, S);
  throw new $TypeError('RegExp#exec called on incompatible receiver');
};


/***/ }),

/***/ 6308:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/* eslint-disable regexp/no-empty-capturing-group, regexp/no-empty-group, regexp/no-lazy-ends -- testing */
/* eslint-disable regexp/no-useless-quantifier -- testing */
var call = __webpack_require__(2615);
var uncurryThis = __webpack_require__(8844);
var toString = __webpack_require__(4327);
var regexpFlags = __webpack_require__(9633);
var stickyHelpers = __webpack_require__(7901);
var shared = __webpack_require__(3430);
var create = __webpack_require__(5391);
var getInternalState = (__webpack_require__(618).get);
var UNSUPPORTED_DOT_ALL = __webpack_require__(2100);
var UNSUPPORTED_NCG = __webpack_require__(6422);

var nativeReplace = shared('native-string-replace', String.prototype.replace);
var nativeExec = RegExp.prototype.exec;
var patchedExec = nativeExec;
var charAt = uncurryThis(''.charAt);
var indexOf = uncurryThis(''.indexOf);
var replace = uncurryThis(''.replace);
var stringSlice = uncurryThis(''.slice);

var UPDATES_LAST_INDEX_WRONG = (function () {
  var re1 = /a/;
  var re2 = /b*/g;
  call(nativeExec, re1, 'a');
  call(nativeExec, re2, 'a');
  return re1.lastIndex !== 0 || re2.lastIndex !== 0;
})();

var UNSUPPORTED_Y = stickyHelpers.BROKEN_CARET;

// nonparticipating capturing group, copied from es5-shim's String#split patch.
var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;

var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y || UNSUPPORTED_DOT_ALL || UNSUPPORTED_NCG;

if (PATCH) {
  patchedExec = function exec(string) {
    var re = this;
    var state = getInternalState(re);
    var str = toString(string);
    var raw = state.raw;
    var result, reCopy, lastIndex, match, i, object, group;

    if (raw) {
      raw.lastIndex = re.lastIndex;
      result = call(patchedExec, raw, str);
      re.lastIndex = raw.lastIndex;
      return result;
    }

    var groups = state.groups;
    var sticky = UNSUPPORTED_Y && re.sticky;
    var flags = call(regexpFlags, re);
    var source = re.source;
    var charsAdded = 0;
    var strCopy = str;

    if (sticky) {
      flags = replace(flags, 'y', '');
      if (indexOf(flags, 'g') === -1) {
        flags += 'g';
      }

      strCopy = stringSlice(str, re.lastIndex);
      // Support anchored sticky behavior.
      if (re.lastIndex > 0 && (!re.multiline || re.multiline && charAt(str, re.lastIndex - 1) !== '\n')) {
        source = '(?: ' + source + ')';
        strCopy = ' ' + strCopy;
        charsAdded++;
      }
      // ^(? + rx + ) is needed, in combination with some str slicing, to
      // simulate the 'y' flag.
      reCopy = new RegExp('^(?:' + source + ')', flags);
    }

    if (NPCG_INCLUDED) {
      reCopy = new RegExp('^' + source + '$(?!\\s)', flags);
    }
    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;

    match = call(nativeExec, sticky ? reCopy : re, strCopy);

    if (sticky) {
      if (match) {
        match.input = stringSlice(match.input, charsAdded);
        match[0] = stringSlice(match[0], charsAdded);
        match.index = re.lastIndex;
        re.lastIndex += match[0].length;
      } else re.lastIndex = 0;
    } else if (UPDATES_LAST_INDEX_WRONG && match) {
      re.lastIndex = re.global ? match.index + match[0].length : lastIndex;
    }
    if (NPCG_INCLUDED && match && match.length > 1) {
      // Fix browsers whose `exec` methods don't consistently return `undefined`
      // for NPCG, like IE8. NOTE: This doesn't work for /(.?)?/
      call(nativeReplace, match[0], reCopy, function () {
        for (i = 1; i < arguments.length - 2; i++) {
          if (arguments[i] === undefined) match[i] = undefined;
        }
      });
    }

    if (match && groups) {
      match.groups = object = create(null);
      for (i = 0; i < groups.length; i++) {
        group = groups[i];
        object[group[0]] = match[group[1]];
      }
    }

    return match;
  };
}

module.exports = patchedExec;


/***/ }),

/***/ 9633:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var anObject = __webpack_require__(5027);

// `RegExp.prototype.flags` getter implementation
// https://tc39.es/ecma262/#sec-get-regexp.prototype.flags
module.exports = function () {
  var that = anObject(this);
  var result = '';
  if (that.hasIndices) result += 'd';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.dotAll) result += 's';
  if (that.unicode) result += 'u';
  if (that.unicodeSets) result += 'v';
  if (that.sticky) result += 'y';
  return result;
};


/***/ }),

/***/ 3477:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var call = __webpack_require__(2615);
var hasOwn = __webpack_require__(6812);
var isPrototypeOf = __webpack_require__(3622);
var regExpFlags = __webpack_require__(9633);

var RegExpPrototype = RegExp.prototype;

module.exports = function (R) {
  var flags = R.flags;
  return flags === undefined && !('flags' in RegExpPrototype) && !hasOwn(R, 'flags') && isPrototypeOf(RegExpPrototype, R)
    ? call(regExpFlags, R) : flags;
};


/***/ }),

/***/ 7901:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var fails = __webpack_require__(3689);
var global = __webpack_require__(9037);

// babel-minify and Closure Compiler transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError
var $RegExp = global.RegExp;

var UNSUPPORTED_Y = fails(function () {
  var re = $RegExp('a', 'y');
  re.lastIndex = 2;
  return re.exec('abcd') !== null;
});

// UC Browser bug
// https://github.com/zloirock/core-js/issues/1008
var MISSED_STICKY = UNSUPPORTED_Y || fails(function () {
  return !$RegExp('a', 'y').sticky;
});

var BROKEN_CARET = UNSUPPORTED_Y || fails(function () {
  // https://bugzilla.mozilla.org/show_bug.cgi?id=773687
  var re = $RegExp('^r', 'gy');
  re.lastIndex = 2;
  return re.exec('str') !== null;
});

module.exports = {
  BROKEN_CARET: BROKEN_CARET,
  MISSED_STICKY: MISSED_STICKY,
  UNSUPPORTED_Y: UNSUPPORTED_Y
};


/***/ }),

/***/ 2100:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var fails = __webpack_require__(3689);
var global = __webpack_require__(9037);

// babel-minify and Closure Compiler transpiles RegExp('.', 's') -> /./s and it causes SyntaxError
var $RegExp = global.RegExp;

module.exports = fails(function () {
  var re = $RegExp('.', 's');
  return !(re.dotAll && re.test('\n') && re.flags === 's');
});


/***/ }),

/***/ 6422:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var fails = __webpack_require__(3689);
var global = __webpack_require__(9037);

// babel-minify and Closure Compiler transpiles RegExp('(?<a>b)', 'g') -> /(?<a>b)/g and it causes SyntaxError
var $RegExp = global.RegExp;

module.exports = fails(function () {
  var re = $RegExp('(?<a>b)', 'g');
  return re.exec('b').groups.a !== 'b' ||
    'b'.replace(re, '$<a>c') !== 'bc';
});


/***/ }),

/***/ 4684:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var isNullOrUndefined = __webpack_require__(981);

var $TypeError = TypeError;

// `RequireObjectCoercible` abstract operation
// https://tc39.es/ecma262/#sec-requireobjectcoercible
module.exports = function (it) {
  if (isNullOrUndefined(it)) throw new $TypeError("Can't call method on " + it);
  return it;
};


/***/ }),

/***/ 5997:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var defineProperty = (__webpack_require__(2560).f);
var hasOwn = __webpack_require__(6812);
var wellKnownSymbol = __webpack_require__(4201);

var TO_STRING_TAG = wellKnownSymbol('toStringTag');

module.exports = function (target, TAG, STATIC) {
  if (target && !STATIC) target = target.prototype;
  if (target && !hasOwn(target, TO_STRING_TAG)) {
    defineProperty(target, TO_STRING_TAG, { configurable: true, value: TAG });
  }
};


/***/ }),

/***/ 2713:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var shared = __webpack_require__(3430);
var uid = __webpack_require__(4630);

var keys = shared('keys');

module.exports = function (key) {
  return keys[key] || (keys[key] = uid(key));
};


/***/ }),

/***/ 4091:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var global = __webpack_require__(9037);
var defineGlobalProperty = __webpack_require__(5014);

var SHARED = '__core-js_shared__';
var store = global[SHARED] || defineGlobalProperty(SHARED, {});

module.exports = store;


/***/ }),

/***/ 3430:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var IS_PURE = __webpack_require__(3931);
var store = __webpack_require__(4091);

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: '3.35.1',
  mode: IS_PURE ? 'pure' : 'global',
  copyright: 'Â© 2014-2024 Denis Pushkarev (zloirock.ru)',
  license: 'https://github.com/zloirock/core-js/blob/v3.35.1/LICENSE',
  source: 'https://github.com/zloirock/core-js'
});


/***/ }),

/***/ 6373:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var anObject = __webpack_require__(5027);
var aConstructor = __webpack_require__(2655);
var isNullOrUndefined = __webpack_require__(981);
var wellKnownSymbol = __webpack_require__(4201);

var SPECIES = wellKnownSymbol('species');

// `SpeciesConstructor` abstract operation
// https://tc39.es/ecma262/#sec-speciesconstructor
module.exports = function (O, defaultConstructor) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || isNullOrUndefined(S = anObject(C)[SPECIES]) ? defaultConstructor : aConstructor(S);
};


/***/ }),

/***/ 730:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(8844);
var toIntegerOrInfinity = __webpack_require__(8700);
var toString = __webpack_require__(4327);
var requireObjectCoercible = __webpack_require__(4684);

var charAt = uncurryThis(''.charAt);
var charCodeAt = uncurryThis(''.charCodeAt);
var stringSlice = uncurryThis(''.slice);

var createMethod = function (CONVERT_TO_STRING) {
  return function ($this, pos) {
    var S = toString(requireObjectCoercible($this));
    var position = toIntegerOrInfinity(pos);
    var size = S.length;
    var first, second;
    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
    first = charCodeAt(S, position);
    return first < 0xD800 || first > 0xDBFF || position + 1 === size
      || (second = charCodeAt(S, position + 1)) < 0xDC00 || second > 0xDFFF
        ? CONVERT_TO_STRING
          ? charAt(S, position)
          : first
        : CONVERT_TO_STRING
          ? stringSlice(S, position, position + 2)
          : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
  };
};

module.exports = {
  // `String.prototype.codePointAt` method
  // https://tc39.es/ecma262/#sec-string.prototype.codepointat
  codeAt: createMethod(false),
  // `String.prototype.at` method
  // https://github.com/mathiasbynens/String.prototype.at
  charAt: createMethod(true)
};


/***/ }),

/***/ 146:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/* eslint-disable es/no-symbol -- required for testing */
var V8_VERSION = __webpack_require__(3615);
var fails = __webpack_require__(3689);
var global = __webpack_require__(9037);

var $String = global.String;

// eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing
module.exports = !!Object.getOwnPropertySymbols && !fails(function () {
  var symbol = Symbol('symbol detection');
  // Chrome 38 Symbol has incorrect toString conversion
  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances
  // nb: Do not call `String` directly to avoid this being optimized out to `symbol+''` which will,
  // of course, fail.
  return !$String(symbol) || !(Object(symbol) instanceof Symbol) ||
    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
    !Symbol.sham && V8_VERSION && V8_VERSION < 41;
});


/***/ }),

/***/ 7578:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var toIntegerOrInfinity = __webpack_require__(8700);

var max = Math.max;
var min = Math.min;

// Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
module.exports = function (index, length) {
  var integer = toIntegerOrInfinity(index);
  return integer < 0 ? max(integer + length, 0) : min(integer, length);
};


/***/ }),

/***/ 5290:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// toObject with fallback for non-array-like ES3 strings
var IndexedObject = __webpack_require__(4413);
var requireObjectCoercible = __webpack_require__(4684);

module.exports = function (it) {
  return IndexedObject(requireObjectCoercible(it));
};


/***/ }),

/***/ 8700:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var trunc = __webpack_require__(8828);

// `ToIntegerOrInfinity` abstract operation
// https://tc39.es/ecma262/#sec-tointegerorinfinity
module.exports = function (argument) {
  var number = +argument;
  // eslint-disable-next-line no-self-compare -- NaN check
  return number !== number || number === 0 ? 0 : trunc(number);
};


/***/ }),

/***/ 3126:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var toIntegerOrInfinity = __webpack_require__(8700);

var min = Math.min;

// `ToLength` abstract operation
// https://tc39.es/ecma262/#sec-tolength
module.exports = function (argument) {
  var len = toIntegerOrInfinity(argument);
  return len > 0 ? min(len, 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
};


/***/ }),

/***/ 690:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var requireObjectCoercible = __webpack_require__(4684);

var $Object = Object;

// `ToObject` abstract operation
// https://tc39.es/ecma262/#sec-toobject
module.exports = function (argument) {
  return $Object(requireObjectCoercible(argument));
};


/***/ }),

/***/ 3250:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var toPositiveInteger = __webpack_require__(5904);

var $RangeError = RangeError;

module.exports = function (it, BYTES) {
  var offset = toPositiveInteger(it);
  if (offset % BYTES) throw new $RangeError('Wrong offset');
  return offset;
};


/***/ }),

/***/ 5904:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var toIntegerOrInfinity = __webpack_require__(8700);

var $RangeError = RangeError;

module.exports = function (it) {
  var result = toIntegerOrInfinity(it);
  if (result < 0) throw new $RangeError("The argument can't be less than 0");
  return result;
};


/***/ }),

/***/ 8732:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var call = __webpack_require__(2615);
var isObject = __webpack_require__(8999);
var isSymbol = __webpack_require__(734);
var getMethod = __webpack_require__(4849);
var ordinaryToPrimitive = __webpack_require__(5899);
var wellKnownSymbol = __webpack_require__(4201);

var $TypeError = TypeError;
var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');

// `ToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-toprimitive
module.exports = function (input, pref) {
  if (!isObject(input) || isSymbol(input)) return input;
  var exoticToPrim = getMethod(input, TO_PRIMITIVE);
  var result;
  if (exoticToPrim) {
    if (pref === undefined) pref = 'default';
    result = call(exoticToPrim, input, pref);
    if (!isObject(result) || isSymbol(result)) return result;
    throw new $TypeError("Can't convert object to primitive value");
  }
  if (pref === undefined) pref = 'number';
  return ordinaryToPrimitive(input, pref);
};


/***/ }),

/***/ 8360:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var toPrimitive = __webpack_require__(8732);
var isSymbol = __webpack_require__(734);

// `ToPropertyKey` abstract operation
// https://tc39.es/ecma262/#sec-topropertykey
module.exports = function (argument) {
  var key = toPrimitive(argument, 'string');
  return isSymbol(key) ? key : key + '';
};


/***/ }),

/***/ 3043:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var wellKnownSymbol = __webpack_require__(4201);

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var test = {};

test[TO_STRING_TAG] = 'z';

module.exports = String(test) === '[object z]';


/***/ }),

/***/ 4327:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var classof = __webpack_require__(926);

var $String = String;

module.exports = function (argument) {
  if (classof(argument) === 'Symbol') throw new TypeError('Cannot convert a Symbol value to a string');
  return $String(argument);
};


/***/ }),

/***/ 3691:
/***/ ((module) => {

"use strict";

var $String = String;

module.exports = function (argument) {
  try {
    return $String(argument);
  } catch (error) {
    return 'Object';
  }
};


/***/ }),

/***/ 4630:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(8844);

var id = 0;
var postfix = Math.random();
var toString = uncurryThis(1.0.toString);

module.exports = function (key) {
  return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString(++id + postfix, 36);
};


/***/ }),

/***/ 9525:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/* eslint-disable es/no-symbol -- required for testing */
var NATIVE_SYMBOL = __webpack_require__(146);

module.exports = NATIVE_SYMBOL
  && !Symbol.sham
  && typeof Symbol.iterator == 'symbol';


/***/ }),

/***/ 5648:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var DESCRIPTORS = __webpack_require__(7697);
var fails = __webpack_require__(3689);

// V8 ~ Chrome 36-
// https://bugs.chromium.org/p/v8/issues/detail?id=3334
module.exports = DESCRIPTORS && fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty(function () { /* empty */ }, 'prototype', {
    value: 42,
    writable: false
  }).prototype !== 42;
});


/***/ }),

/***/ 9834:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var global = __webpack_require__(9037);
var isCallable = __webpack_require__(9985);

var WeakMap = global.WeakMap;

module.exports = isCallable(WeakMap) && /native code/.test(String(WeakMap));


/***/ }),

/***/ 4201:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var global = __webpack_require__(9037);
var shared = __webpack_require__(3430);
var hasOwn = __webpack_require__(6812);
var uid = __webpack_require__(4630);
var NATIVE_SYMBOL = __webpack_require__(146);
var USE_SYMBOL_AS_UID = __webpack_require__(9525);

var Symbol = global.Symbol;
var WellKnownSymbolsStore = shared('wks');
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol['for'] || Symbol : Symbol && Symbol.withoutSetter || uid;

module.exports = function (name) {
  if (!hasOwn(WellKnownSymbolsStore, name)) {
    WellKnownSymbolsStore[name] = NATIVE_SYMBOL && hasOwn(Symbol, name)
      ? Symbol[name]
      : createWellKnownSymbol('Symbol.' + name);
  } return WellKnownSymbolsStore[name];
};


/***/ }),

/***/ 278:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(9989);
var $reduce = (__webpack_require__(8820).left);
var arrayMethodIsStrict = __webpack_require__(6834);
var CHROME_VERSION = __webpack_require__(3615);
var IS_NODE = __webpack_require__(806);

// Chrome 80-82 has a critical bug
// https://bugs.chromium.org/p/chromium/issues/detail?id=1049982
var CHROME_BUG = !IS_NODE && CHROME_VERSION > 79 && CHROME_VERSION < 83;
var FORCED = CHROME_BUG || !arrayMethodIsStrict('reduce');

// `Array.prototype.reduce` method
// https://tc39.es/ecma262/#sec-array.prototype.reduce
$({ target: 'Array', proto: true, forced: FORCED }, {
  reduce: function reduce(callbackfn /* , initialValue */) {
    var length = arguments.length;
    return $reduce(this, callbackfn, length, length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),

/***/ 3383:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// this method was added to unscopables after implementation
// in popular engines, so it's moved to a separate module
var addToUnscopables = __webpack_require__(7370);

// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('flat');


/***/ }),

/***/ 8324:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(9989);
var getBuiltIn = __webpack_require__(6058);
var apply = __webpack_require__(1735);
var call = __webpack_require__(2615);
var uncurryThis = __webpack_require__(8844);
var fails = __webpack_require__(3689);
var isCallable = __webpack_require__(9985);
var isSymbol = __webpack_require__(734);
var arraySlice = __webpack_require__(6004);
var getReplacerFunction = __webpack_require__(2643);
var NATIVE_SYMBOL = __webpack_require__(146);

var $String = String;
var $stringify = getBuiltIn('JSON', 'stringify');
var exec = uncurryThis(/./.exec);
var charAt = uncurryThis(''.charAt);
var charCodeAt = uncurryThis(''.charCodeAt);
var replace = uncurryThis(''.replace);
var numberToString = uncurryThis(1.0.toString);

var tester = /[\uD800-\uDFFF]/g;
var low = /^[\uD800-\uDBFF]$/;
var hi = /^[\uDC00-\uDFFF]$/;

var WRONG_SYMBOLS_CONVERSION = !NATIVE_SYMBOL || fails(function () {
  var symbol = getBuiltIn('Symbol')('stringify detection');
  // MS Edge converts symbol values to JSON as {}
  return $stringify([symbol]) !== '[null]'
    // WebKit converts symbol values to JSON as null
    || $stringify({ a: symbol }) !== '{}'
    // V8 throws on boxed symbols
    || $stringify(Object(symbol)) !== '{}';
});

// https://github.com/tc39/proposal-well-formed-stringify
var ILL_FORMED_UNICODE = fails(function () {
  return $stringify('\uDF06\uD834') !== '"\\udf06\\ud834"'
    || $stringify('\uDEAD') !== '"\\udead"';
});

var stringifyWithSymbolsFix = function (it, replacer) {
  var args = arraySlice(arguments);
  var $replacer = getReplacerFunction(replacer);
  if (!isCallable($replacer) && (it === undefined || isSymbol(it))) return; // IE8 returns string on undefined
  args[1] = function (key, value) {
    // some old implementations (like WebKit) could pass numbers as keys
    if (isCallable($replacer)) value = call($replacer, this, $String(key), value);
    if (!isSymbol(value)) return value;
  };
  return apply($stringify, null, args);
};

var fixIllFormed = function (match, offset, string) {
  var prev = charAt(string, offset - 1);
  var next = charAt(string, offset + 1);
  if ((exec(low, match) && !exec(hi, next)) || (exec(hi, match) && !exec(low, prev))) {
    return '\\u' + numberToString(charCodeAt(match, 0), 16);
  } return match;
};

if ($stringify) {
  // `JSON.stringify` method
  // https://tc39.es/ecma262/#sec-json.stringify
  $({ target: 'JSON', stat: true, arity: 3, forced: WRONG_SYMBOLS_CONVERSION || ILL_FORMED_UNICODE }, {
    // eslint-disable-next-line no-unused-vars -- required for `.length`
    stringify: function stringify(it, replacer, space) {
      var args = arraySlice(arguments);
      var result = apply(WRONG_SYMBOLS_CONVERSION ? stringifyWithSymbolsFix : $stringify, null, args);
      return ILL_FORMED_UNICODE && typeof result == 'string' ? replace(result, tester, fixIllFormed) : result;
    }
  });
}


/***/ }),

/***/ 9866:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/* eslint-disable es/no-string-prototype-matchall -- safe */
var $ = __webpack_require__(9989);
var call = __webpack_require__(2615);
var uncurryThis = __webpack_require__(6576);
var createIteratorConstructor = __webpack_require__(974);
var createIterResultObject = __webpack_require__(7807);
var requireObjectCoercible = __webpack_require__(4684);
var toLength = __webpack_require__(3126);
var toString = __webpack_require__(4327);
var anObject = __webpack_require__(5027);
var isNullOrUndefined = __webpack_require__(981);
var classof = __webpack_require__(6648);
var isRegExp = __webpack_require__(1245);
var getRegExpFlags = __webpack_require__(3477);
var getMethod = __webpack_require__(4849);
var defineBuiltIn = __webpack_require__(1880);
var fails = __webpack_require__(3689);
var wellKnownSymbol = __webpack_require__(4201);
var speciesConstructor = __webpack_require__(6373);
var advanceStringIndex = __webpack_require__(1514);
var regExpExec = __webpack_require__(6100);
var InternalStateModule = __webpack_require__(618);
var IS_PURE = __webpack_require__(3931);

var MATCH_ALL = wellKnownSymbol('matchAll');
var REGEXP_STRING = 'RegExp String';
var REGEXP_STRING_ITERATOR = REGEXP_STRING + ' Iterator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(REGEXP_STRING_ITERATOR);
var RegExpPrototype = RegExp.prototype;
var $TypeError = TypeError;
var stringIndexOf = uncurryThis(''.indexOf);
var nativeMatchAll = uncurryThis(''.matchAll);

var WORKS_WITH_NON_GLOBAL_REGEX = !!nativeMatchAll && !fails(function () {
  nativeMatchAll('a', /./);
});

var $RegExpStringIterator = createIteratorConstructor(function RegExpStringIterator(regexp, string, $global, fullUnicode) {
  setInternalState(this, {
    type: REGEXP_STRING_ITERATOR,
    regexp: regexp,
    string: string,
    global: $global,
    unicode: fullUnicode,
    done: false
  });
}, REGEXP_STRING, function next() {
  var state = getInternalState(this);
  if (state.done) return createIterResultObject(undefined, true);
  var R = state.regexp;
  var S = state.string;
  var match = regExpExec(R, S);
  if (match === null) {
    state.done = true;
    return createIterResultObject(undefined, true);
  }
  if (state.global) {
    if (toString(match[0]) === '') R.lastIndex = advanceStringIndex(S, toLength(R.lastIndex), state.unicode);
    return createIterResultObject(match, false);
  }
  state.done = true;
  return createIterResultObject(match, false);
});

var $matchAll = function (string) {
  var R = anObject(this);
  var S = toString(string);
  var C = speciesConstructor(R, RegExp);
  var flags = toString(getRegExpFlags(R));
  var matcher, $global, fullUnicode;
  matcher = new C(C === RegExp ? R.source : R, flags);
  $global = !!~stringIndexOf(flags, 'g');
  fullUnicode = !!~stringIndexOf(flags, 'u');
  matcher.lastIndex = toLength(R.lastIndex);
  return new $RegExpStringIterator(matcher, S, $global, fullUnicode);
};

// `String.prototype.matchAll` method
// https://tc39.es/ecma262/#sec-string.prototype.matchall
$({ target: 'String', proto: true, forced: WORKS_WITH_NON_GLOBAL_REGEX }, {
  matchAll: function matchAll(regexp) {
    var O = requireObjectCoercible(this);
    var flags, S, matcher, rx;
    if (!isNullOrUndefined(regexp)) {
      if (isRegExp(regexp)) {
        flags = toString(requireObjectCoercible(getRegExpFlags(regexp)));
        if (!~stringIndexOf(flags, 'g')) throw new $TypeError('`.matchAll` does not allow non-global regexes');
      }
      if (WORKS_WITH_NON_GLOBAL_REGEX) return nativeMatchAll(O, regexp);
      matcher = getMethod(regexp, MATCH_ALL);
      if (matcher === undefined && IS_PURE && classof(regexp) === 'RegExp') matcher = $matchAll;
      if (matcher) return call(matcher, regexp, O);
    } else if (WORKS_WITH_NON_GLOBAL_REGEX) return nativeMatchAll(O, regexp);
    S = toString(O);
    rx = new RegExp(regexp, 'g');
    return IS_PURE ? call($matchAll, rx, S) : rx[MATCH_ALL](S);
  }
});

IS_PURE || MATCH_ALL in RegExpPrototype || defineBuiltIn(RegExpPrototype, MATCH_ALL, $matchAll);


/***/ }),

/***/ 6544:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// `Symbol.prototype.description` getter
// https://tc39.es/ecma262/#sec-symbol.prototype.description

var $ = __webpack_require__(9989);
var DESCRIPTORS = __webpack_require__(7697);
var global = __webpack_require__(9037);
var uncurryThis = __webpack_require__(8844);
var hasOwn = __webpack_require__(6812);
var isCallable = __webpack_require__(9985);
var isPrototypeOf = __webpack_require__(3622);
var toString = __webpack_require__(4327);
var defineBuiltInAccessor = __webpack_require__(2148);
var copyConstructorProperties = __webpack_require__(8758);

var NativeSymbol = global.Symbol;
var SymbolPrototype = NativeSymbol && NativeSymbol.prototype;

if (DESCRIPTORS && isCallable(NativeSymbol) && (!('description' in SymbolPrototype) ||
  // Safari 12 bug
  NativeSymbol().description !== undefined
)) {
  var EmptyStringDescriptionStore = {};
  // wrap Symbol constructor for correct work with undefined description
  var SymbolWrapper = function Symbol() {
    var description = arguments.length < 1 || arguments[0] === undefined ? undefined : toString(arguments[0]);
    var result = isPrototypeOf(SymbolPrototype, this)
      ? new NativeSymbol(description)
      // in Edge 13, String(Symbol(undefined)) === 'Symbol(undefined)'
      : description === undefined ? NativeSymbol() : NativeSymbol(description);
    if (description === '') EmptyStringDescriptionStore[result] = true;
    return result;
  };

  copyConstructorProperties(SymbolWrapper, NativeSymbol);
  SymbolWrapper.prototype = SymbolPrototype;
  SymbolPrototype.constructor = SymbolWrapper;

  var NATIVE_SYMBOL = String(NativeSymbol('description detection')) === 'Symbol(description detection)';
  var thisSymbolValue = uncurryThis(SymbolPrototype.valueOf);
  var symbolDescriptiveString = uncurryThis(SymbolPrototype.toString);
  var regexp = /^Symbol\((.*)\)[^)]+$/;
  var replace = uncurryThis(''.replace);
  var stringSlice = uncurryThis(''.slice);

  defineBuiltInAccessor(SymbolPrototype, 'description', {
    configurable: true,
    get: function description() {
      var symbol = thisSymbolValue(this);
      if (hasOwn(EmptyStringDescriptionStore, symbol)) return '';
      var string = symbolDescriptiveString(symbol);
      var desc = NATIVE_SYMBOL ? stringSlice(string, 7, -1) : replace(string, regexp, '$1');
      return desc === '' ? undefined : desc;
    }
  });

  $({ global: true, constructor: true, forced: true }, {
    Symbol: SymbolWrapper
  });
}


/***/ }),

/***/ 9976:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var global = __webpack_require__(9037);
var call = __webpack_require__(2615);
var ArrayBufferViewCore = __webpack_require__(4872);
var lengthOfArrayLike = __webpack_require__(6310);
var toOffset = __webpack_require__(3250);
var toIndexedObject = __webpack_require__(690);
var fails = __webpack_require__(3689);

var RangeError = global.RangeError;
var Int8Array = global.Int8Array;
var Int8ArrayPrototype = Int8Array && Int8Array.prototype;
var $set = Int8ArrayPrototype && Int8ArrayPrototype.set;
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

var WORKS_WITH_OBJECTS_AND_GENERIC_ON_TYPED_ARRAYS = !fails(function () {
  // eslint-disable-next-line es/no-typed-arrays -- required for testing
  var array = new Uint8ClampedArray(2);
  call($set, array, { length: 1, 0: 3 }, 1);
  return array[1] !== 3;
});

// https://bugs.chromium.org/p/v8/issues/detail?id=11294 and other
var TO_OBJECT_BUG = WORKS_WITH_OBJECTS_AND_GENERIC_ON_TYPED_ARRAYS && ArrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS && fails(function () {
  var array = new Int8Array(2);
  array.set(1);
  array.set('2', 1);
  return array[0] !== 0 || array[1] !== 2;
});

// `%TypedArray%.prototype.set` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.set
exportTypedArrayMethod('set', function set(arrayLike /* , offset */) {
  aTypedArray(this);
  var offset = toOffset(arguments.length > 1 ? arguments[1] : undefined, 1);
  var src = toIndexedObject(arrayLike);
  if (WORKS_WITH_OBJECTS_AND_GENERIC_ON_TYPED_ARRAYS) return call($set, this, src, offset);
  var length = this.length;
  var len = lengthOfArrayLike(src);
  var index = 0;
  if (len + offset > length) throw new RangeError('Wrong length');
  while (index < len) this[offset + index] = src[index++];
}, !WORKS_WITH_OBJECTS_AND_GENERIC_ON_TYPED_ARRAYS || TO_OBJECT_BUG);


/***/ }),

/***/ 3356:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var global = __webpack_require__(9037);
var uncurryThis = __webpack_require__(6576);
var fails = __webpack_require__(3689);
var aCallable = __webpack_require__(509);
var internalSort = __webpack_require__(382);
var ArrayBufferViewCore = __webpack_require__(4872);
var FF = __webpack_require__(7365);
var IE_OR_EDGE = __webpack_require__(7298);
var V8 = __webpack_require__(3615);
var WEBKIT = __webpack_require__(7922);

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
var Uint16Array = global.Uint16Array;
var nativeSort = Uint16Array && uncurryThis(Uint16Array.prototype.sort);

// WebKit
var ACCEPT_INCORRECT_ARGUMENTS = !!nativeSort && !(fails(function () {
  nativeSort(new Uint16Array(2), null);
}) && fails(function () {
  nativeSort(new Uint16Array(2), {});
}));

var STABLE_SORT = !!nativeSort && !fails(function () {
  // feature detection can be too slow, so check engines versions
  if (V8) return V8 < 74;
  if (FF) return FF < 67;
  if (IE_OR_EDGE) return true;
  if (WEBKIT) return WEBKIT < 602;

  var array = new Uint16Array(516);
  var expected = Array(516);
  var index, mod;

  for (index = 0; index < 516; index++) {
    mod = index % 4;
    array[index] = 515 - index;
    expected[index] = index - 2 * mod + 3;
  }

  nativeSort(array, function (a, b) {
    return (a / 4 | 0) - (b / 4 | 0);
  });

  for (index = 0; index < 516; index++) {
    if (array[index] !== expected[index]) return true;
  }
});

var getSortCompare = function (comparefn) {
  return function (x, y) {
    if (comparefn !== undefined) return +comparefn(x, y) || 0;
    // eslint-disable-next-line no-self-compare -- NaN check
    if (y !== y) return -1;
    // eslint-disable-next-line no-self-compare -- NaN check
    if (x !== x) return 1;
    if (x === 0 && y === 0) return 1 / x > 0 && 1 / y < 0 ? 1 : -1;
    return x > y;
  };
};

// `%TypedArray%.prototype.sort` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.sort
exportTypedArrayMethod('sort', function sort(comparefn) {
  if (comparefn !== undefined) aCallable(comparefn);
  if (STABLE_SORT) return nativeSort(this, comparefn);

  return internalSort(aTypedArray(this), getSortCompare(comparefn));
}, !STABLE_SORT || ACCEPT_INCORRECT_ARGUMENTS);


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.json.stringify.js
var es_json_stringify = __webpack_require__(8324);
// EXTERNAL MODULE: ./node_modules/jquery/dist/jquery.js
var jquery = __webpack_require__(9755);
var jquery_default = /*#__PURE__*/__webpack_require__.n(jquery);
// EXTERNAL MODULE: ./node_modules/jquery-validation/dist/jquery.validate.js
var jquery_validate = __webpack_require__(3587);
;// CONCATENATED MODULE: ./src/scripts/globals.ts
const _EXTENSION_ID = (/* unused pure expression or super */ null && ("ndakideadaglgpbblmppfonobpdgggin"));

const _APP_ID = (/* unused pure expression or super */ null && ("alhngdkjgnedakdlnamimgfihgkmenbh"));

const _SELF_ID = (/* unused pure expression or super */ null && ("ndakideadaglgpbblmppfonobpdgggin"));

const _VERSION = (/* unused pure expression or super */ null && ("1.4.3"));

(function () {
  if (false) {}
})();
function isExtension() {
  return "ndakideadaglgpbblmppfonobpdgggin" === "ndakideadaglgpbblmppfonobpdgggin";
}
function isApp() {
  return "ndakideadaglgpbblmppfonobpdgggin" === "alhngdkjgnedakdlnamimgfihgkmenbh";
}
function globals_GetClientVersionID() {
  if (isApp()) {
    return 'ChromeApp-' + "1.4.3";
  } else {
    return 'ChromeAppExt-' + "1.4.3";
  }
}
;// CONCATENATED MODULE: ./src/scripts/http/http.ts
async function http_getResponseBody(resp) {
  if (resp.ok) {
    return resp.json().then(respBody => respBody);
  }
  throw Error(`request ${resp.url} failed with HTTP ${resp.status} ${resp.statusText}`);
}
;// CONCATENATED MODULE: ./src/scripts/time/format.ts
function iso8601DateTimeZone(d) {
  const offset = -d.getTimezoneOffset();
  const sign = offset >= 0 ? '+' : '-';
  return d.getFullYear() + '-' + pad(d.getMonth() + 1) + '-' + pad(d.getDate()) + 'T' + pad(d.getHours()) + ':' + pad(d.getMinutes()) + ':' + pad(d.getSeconds()) + sign + pad(offset / 60) + ':' + pad(offset % 60);
}
function pad(n) {
  const abs = Math.floor(Math.abs(n));
  return (abs < 10 ? '0' : '') + abs;
}
;// CONCATENATED MODULE: ./src/scripts/log/log.ts


let remoteLogging = undefined;
if (self.chrome && chrome.storage && chrome.storage.local !== undefined) {
  chrome.storage.local.get('remoteLoggingURL', d => {
    if (d && d.remoteLoggingURL && d.remoteLoggingURL.startsWith('http')) {
      log_log(`Remote logging initialised: ${JSON.stringify(d)}`);
      remoteLogging = d;
    }
  });
}
function remoteLog(request) {
  if (!remoteLogging || !remoteLogging.remoteLoggingURL) {
    return;
  }
  chrome.tabs.query({
    active: true,
    currentWindow: true
  }, function (tabs) {
    if (tabs.length > 0) {
      request.body = `tab:${tabs[0].id} - ${request.body}`;
    } else {
      request.body = `??? - ${request.body}`;
    }
    fetch(`${remoteLogging.remoteLoggingURL}`, request).catch(e => {
      console.error('failed to remote log', e);
    });
  });
}
function isRemoteLogging() {
  return remoteLogging !== undefined;
}
function log_log(...args) {
  if (offscreenContext()) {
    sendToServiceWorker('log', args);
  } else {
    console.log.apply(console, [iso8601DateTimeZone(new Date()), ...args]);
  }
  if (isRemoteLogging()) {
    remoteLog({
      method: 'POST',
      body: JSON.stringify(['INFO', ...args])
    });
  }
}
function log_error(...args) {
  if (offscreenContext()) {
    sendToServiceWorker('error', args);
  } else {
    console.error.apply(console, [iso8601DateTimeZone(new Date()), ...args]);
  }
  if (isRemoteLogging()) {
    remoteLog({
      method: 'POST',
      body: JSON.stringify(['ERROR', ...args])
    });
  }
}
function log_warn(...args) {
  if (offscreenContext()) {
    sendToServiceWorker('warn', args);
  } else {
    console.warn.apply(console, [iso8601DateTimeZone(new Date()), ...args]);
  }
  if (isRemoteLogging()) {
    remoteLog({
      method: 'POST',
      body: JSON.stringify(['WARN', ...args])
    });
  }
}
function offscreenContext() {
  try {
    chrome.runtime.getManifest();
  } catch (e) {
    return true;
  }
  return false;
}
function sendToServiceWorker(type, data) {
  chrome.runtime.sendMessage({
    type,
    target: 'background',
    data
  });
}
;// CONCATENATED MODULE: ./src/scripts/log/index.ts

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.unscopables.flat.js
var es_array_unscopables_flat = __webpack_require__(3383);
// EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.set.js
var es_typed_array_set = __webpack_require__(9976);
// EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.sort.js
var es_typed_array_sort = __webpack_require__(3356);
;// CONCATENATED MODULE: ./src/scripts/random/string.ts


const RANDOM_STRING_CHARSET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
function string_cryptoRandomString(length) {
  let result = '';
  for (const v of crypto.getRandomValues(new Uint32Array(length))) {
    result += RANDOM_STRING_CHARSET[v % RANDOM_STRING_CHARSET.length];
  }
  return result;
}
;// CONCATENATED MODULE: ./src/scripts/random/index.ts

;// CONCATENATED MODULE: ./src/scripts/identity/clientId.ts


const CLIENT_ID_LENGTH = 22;
async function clientId_getClientId() {
  const clientId = await getLocalStorageData('clientId');
  if (clientId) {
    return Promise.resolve(clientId);
  } else {
    return setLocalStorageData('clientId', cryptoRandomString(CLIENT_ID_LENGTH));
  }
}
;// CONCATENATED MODULE: ./src/scripts/identity/index.ts

;// CONCATENATED MODULE: ./node_modules/pc-mobility-cloud/client/ts/session.ts

async function session_createSession(baseUrl, req) {
  const init = prepareRequestInit(req.clientToken, req.clientId);
  init.method = "POST";
  const response = await fetch(`${sessionPath(baseUrl)}`, init);
  if (response.status !== 200) {
    throw `error creating client session [${response.status}]`;
  }
  return await response.json();
}
async function session_createOffer(baseUrl, req) {
  const init = prepareRequestInit(req.clientToken, req.clientId);
  init.method = "PUT";
  init.body = JSON.stringify({
    iceOffer: req.iceOffer
  });
  const response = await fetch(`${sessionPath(baseUrl)}/${req.sessionId}/offer`, init);
  if (response.status == 400) {
    throw `error sending offer: expired session`;
  }
  if (response.status != 200) {
    throw `error sending offer: [${response.status}]`;
  }
  return await response.json();
}
async function session_notifyClientCandidates(baseUrl, req) {
  const init = prepareRequestInit(req.clientToken, req.clientId);
  init.method = "POST";
  init.body = JSON.stringify({
    iceCandidates: req.iceCandidates
  });
  const response = await fetch(`${sessionPath(baseUrl)}/${req.sessionId}/candidate`, init);
  if (response.status == 400) {
    throw `error notifying new candidates: expired session`;
  }
  if (response.status != 200) {
    throw `error notifying new candidates: [${response.status}]`;
  }
  return await response.json();
}
async function session_getAnswer(baseUrl, req) {
  const init = prepareRequestInit(req.clientToken, req.clientId);
  init.method = "GET";
  const response = await fetch(`${sessionPath(baseUrl)}/${req.sessionId}/answer`, init);
  if (response.status == 404) {
    return "pending";
  }
  if (response.status == 400) {
    throw "error retrieving answer: expired session";
  }
  if (response.status != 200) {
    throw `error retrieving answer: [${response.status}]`;
  }
  return await response.json();
}
async function session_getServerCandidates(baseUrl, req) {
  const date = req.since;
  const init = prepareRequestInit(req.clientToken, req.clientId);
  init.method = "GET";
  const response = await fetch(`${sessionPath(baseUrl)}/${req.sessionId}/servercandidates?since=${req.since}`, init);
  if (response.status == 400) {
    throw `error receiving new candidates: expired session`;
  }
  if (response.status != 200) {
    throw `error receiving new candidates: [${response.status}]`;
  }
  return await response.json();
}
async function session_deleteSession(baseUrl, req) {
  const init = prepareRequestInit(req.clientToken, req.clientId);
  init.method = "DELETE";
  const response = await fetch(`${sessionPath(baseUrl)}/${req.sessionId}`, init);
  if (response.status != 200) {
    throw `error deleting session: [${response.status}]`;
  }
  return await response.json();
}
function prepareRequestInit(clientToken, clientId) {
  const headers = new Headers();
  headers.append("Authorization", `Bearer ${clientToken}`);
  headers.append("X-PaperCut-Client-Id", clientId);
  headers.append("User-Agent", "PaperCutMobilityPrintCloudClientES/1.0.0");
  return {
    headers: headers
  };
}
function sessionPath(baseUrl) {
  return `${baseUrl}/client/v1/session`;
}
;// CONCATENATED MODULE: ./node_modules/pc-mobility-cloud/client/ts/index.ts

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.symbol.description.js
var es_symbol_description = __webpack_require__(6544);
;// CONCATENATED MODULE: ./src/scripts/peer/blob.ts

const DEFAULT_CHUNK_SIZE = 16384;
const MIN_CHUNK_SIZE = 1;
function blob_chunkBlob(blob, chunkSize) {
  if (chunkSize < MIN_CHUNK_SIZE) {
    chunkSize = DEFAULT_CHUNK_SIZE;
  }
  return {
    *[Symbol.iterator]() {
      let offset = 0;
      let end = Math.min(offset + chunkSize, blob.size);
      while (offset < blob.size) {
        yield blob.slice(offset, end);
        offset = end;
        end = Math.min(offset + chunkSize, blob.size);
      }
      return;
    }
  };
}
async function blob_blobToArrayBuffer(blob) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onloadend = () => resolve(reader.result);
    reader.onerror = () => reject(reader.error);
    reader.readAsArrayBuffer(blob);
  });
}
async function blobToString(blob) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onloadend = () => resolve(reader.result);
    reader.onerror = () => reject(reader.error);
    reader.readAsBinaryString(blob);
  });
}
;// CONCATENATED MODULE: ./src/scripts/peer/datachannel.ts




class datachannel_DataChannel {
  constructor(serverId, dataChannel, getChunkSize) {
    this.dataChannel = dataChannel;
    this.getChunkSize = getChunkSize;
    this.label = `${serverId}.${dataChannel.label}`;
  }
  async sendBlob(b) {
    const chunkSize = this.getChunkSize();
    const thresholdLow = chunkSize;
    const thresholdHigh = Math.max(chunkSize * 8, 1024 * 1024);
    const chunked = chunkBlob(b, chunkSize)[Symbol.iterator]();
    const numChunks = Math.ceil(b.size / chunkSize);
    const logEveryNChunks = Math.floor(1024 * 1024 / chunkSize);
    log(`[${this.label}] sendBlob: size=${b.size} bytes, numChunks=${numChunks}`);
    this.dataChannel.bufferedAmountLowThreshold = thresholdLow;
    const deferred = {
      resolved: false
    };
    deferred.promise = new Promise(resolve => {
      deferred.resolve = () => {
        deferred.resolved = true;
        resolve();
      };
    });
    let chunkIdx = 0;
    let fillInProgress = false;
    const fillToCapacity = async () => {
      fillInProgress = true;
      while (true) {
        if (this.dataChannel.bufferedAmount >= thresholdHigh) {
          fillInProgress = false;
          return;
        }
        const {
          value,
          done
        } = chunked.next();
        if (done) {
          deferred.resolve();
          return;
        }
        if (chunkIdx > 0 && chunkIdx % logEveryNChunks === 0) {
          log(`Transferred ${chunkIdx + 1} out of ${numChunks} chunks. [`, 'label=', this.label, ']');
        }
        const buf = await blobToArrayBuffer(value);
        this.dataChannel.send(buf);
        chunkIdx++;
      }
    };
    this.dataChannel.onbufferedamountlow = async () => {
      if (deferred.resolved || fillInProgress) {
        return;
      }
      await fillToCapacity();
    };
    log(`[${this.label}] ` + 'Starting data channel transfer. [', 'size=', b.size, 'chunkSize=', chunkSize, 'chunks=', numChunks, 'bufferHigh=', thresholdHigh, ']');
    const start = Date.now();
    await fillToCapacity();
    await deferred.promise;
    this.dataChannel.onbufferedamountlow = undefined;
    log('Data channel transfer complete. [', 'label=', this.label, 'duration=', `${Date.now() - start}ms`, ']');
  }
  sendString(s) {
    log(`[${this.label}] sendString: size=${s.length} bytes`);
    if (this.isClosed()) {
      error(`Cannot send message on closed channel '${this.label}`);
      return;
    }
    this.dataChannel.send(s);
  }
  isClosed() {
    return this.dataChannel.readyState === 'closed';
  }
  close() {
    this.dataChannel.close();
  }
  onOpen(f) {
    this.dataChannel.onopen = ev => {
      f(this, ev);
    };
  }
  onMessage(f) {
    this.dataChannel.onmessage = ev => {
      const msg = new Message(ev);
      f(this, msg);
    };
  }
  clearOnMessage() {
    this.dataChannel.onmessage = null;
  }
  onClose(f) {
    this.dataChannel.onclose = ev => {
      f(this, ev);
    };
  }
  onError(f) {
    this.dataChannel.onerror = ev => {
      f(this, ev);
    };
  }
}
;// CONCATENATED MODULE: ./src/scripts/peer/signal.ts

function signal_decodeSessionDescription(offer) {
  return JSON.parse(atob(offer));
}
function signal_encodeSessionDescription(sd) {
  return btoa(JSON.stringify(sd));
}
;// CONCATENATED MODULE: ./src/scripts/peer/peer.ts



const peer_MIN_CHUNK_SIZE = (/* unused pure expression or super */ null && (16 * 1024));
const MAX_CHUNK_SIZE = (/* unused pure expression or super */ null && (256 * 1024));
class peer_Peer {
  constructor(serverId, iceConfig) {
    this.dataChannels = new Map();
    this.connectionStateChangeCallbacks = [];
    this.serverId = serverId;
    this.connection = new RTCPeerConnection(createRTCConfig(iceConfig));
    this.connection.onconnectionstatechange = ev => {
      for (const f of this.connectionStateChangeCallbacks) {
        f(this, ev);
      }
    };
  }
  getServerId() {
    return this.serverId;
  }
  createDataChannel(label) {
    const dc = this.connection.createDataChannel(label);
    const channel = new DataChannel(this.serverId, dc, this.getChunkSize.bind(this));
    this.dataChannels.set(label, channel);
    return channel;
  }
  getChunkSize() {
    if (this.connection.sctp) {
      log(`[${this.getServerId()}]`, `Using SCTP specified chunk size value: ${this.connection.sctp.maxMessageSize} bytes`);
      return Math.min(this.connection.sctp.maxMessageSize - 1, MAX_CHUNK_SIZE);
    }
    log(`[${this.getServerId()}] Using fall-back chunk size value: ${peer_MIN_CHUNK_SIZE} bytes`);
    return peer_MIN_CHUNK_SIZE;
  }
  onDataChannel(f) {
    this.connection.ondatachannel = ev => {
      const dc = new DataChannel(this.serverId, ev.channel, this.getChunkSize.bind(this));
      this.dataChannels.set(dc.label, dc);
      f(this, dc);
    };
  }
  onNegotiationNeeded(f) {
    this.connection.onnegotiationneeded = ev => {
      f(this, ev);
    };
  }
  onICECandidate(f) {
    this.connection.onicecandidate = ev => {
      f(this, ev);
    };
  }
  isPeerConnected() {
    log(`[${this.serverId}] checking peer connection state:`, this.connection.iceConnectionState);
    return this.connection.connectionState === 'connected';
  }
  close() {
    log(`[${this.serverId}] closing peer connection...`);
    this.connection.close();
  }
  async createAnswer(offer) {
    const offerSessionDescription = decodeSessionDescription(offer);
    await this.connection.setRemoteDescription(offerSessionDescription);
    const answer = await this.connection.createAnswer();
    await this.connection.setLocalDescription(answer);
    return encodeSessionDescription(answer);
  }
  onConnectionStateChange(f) {
    this.connectionStateChangeCallbacks.push(f);
  }
  async onICEConnectionStateChange(f) {
    this.connection.oniceconnectionstatechange = ev => {
      f(this, ev);
    };
  }
  getConnectionState() {
    return this.connection.connectionState;
  }
  getICEConnectionState() {
    return this.connection.iceConnectionState;
  }
  async createOffer() {
    const offer = await this.connection.createOffer();
    await this.connection.setLocalDescription(offer);
    const result = this.connection.localDescription;
    return encodeSessionDescription(result);
  }
  async registerAnswer(answer) {
    const answerSessionDescription = decodeSessionDescription(answer);
    await this.connection.setRemoteDescription(answerSessionDescription);
  }
  addIceCandidate(candidate) {
    return this.connection.addIceCandidate(candidate);
  }
  getDataChannel(label) {
    return this.dataChannels.get(label);
  }
  getSelectedCandidatePair() {
    const iceTransport = this.getICETransport();
    if (!iceTransport) {
      return null;
    }
    return iceTransport.getSelectedCandidatePair();
  }
  getICETransport() {
    const sctp = this.connection.sctp;
    if (!sctp) {
      return null;
    }
    return sctp.transport.iceTransport;
  }
  waitForLiveConnection(waitFor) {
    return new Promise((res, rej) => {
      const timeout = setTimeout(() => rej(`timeout waiting for peer connection ${this.serverId}, state:` + this.getConnectionState()), waitFor);
      this.onConnectionStateChange((ctx, _) => {
        switch (ctx.getConnectionState()) {
          case 'closed':
            break;
          case 'connected':
            clearTimeout(timeout);
            res();
            break;
          case 'connecting':
            break;
          case 'disconnected':
            break;
          case 'failed':
            clearTimeout(timeout);
            rej('failed');
            break;
          case 'new':
            break;
        }
      });
    });
  }
}
function createRTCConfig(iceConfig) {
  return {
    iceServers: iceConfig.servers,
    iceTransportPolicy: 'all'
  };
}
;// CONCATENATED MODULE: ./src/scripts/peer/index.ts





// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.reduce.js
var es_array_reduce = __webpack_require__(278);
;// CONCATENATED MODULE: ./src/scripts/cloudprint/client.ts







class client_MobRTCClient {
  constructor(id, peer, timeout, chunkSize, version) {
    this.id = id;
    this.peer = peer;
    this.timeout = timeout;
    this.chunkSize = chunkSize;
    this.version = version;
    this.shortTimeout = timeout / 4;
    this.serverId = peer.getServerId();
  }
  getID() {
    return this.id;
  }
  async getServerInfo() {
    log(`[${this.serverId}] Fetching server info...`);
    const dc = this.getServerInfoChannel();
    dc.sendString(' ');
    return this.readJsonResponseFromChannel(dc, this.shortTimeout);
  }
  async sendPrintJobDetails(printToken, printerUrl, params, fileSize) {
    log(`[${this.serverId}]`, `Submitting print job details: printerUrl=${printerUrl}, fileSize=${fileSize} bytes.`);
    const msg = JSON.stringify({
      clientVersion: this.version,
      printToken,
      printerUrl,
      params,
      fileSize
    });
    const dc = this.getJobDetailsChannel();
    dc.sendString(msg);
    let buf;
    let data;
    try {
      buf = await this.readChunkedResponse(dc);
      data = byteArrayToString(buf);
    } catch (e) {
      error(`[${this.serverId}] error parsing print job details response.`, e);
      throw e;
    }
    if (client_MobRTCClient.isError(data)) {
      throw new Error(data);
    }
    return data;
  }
  async sendPrintJob(file) {
    if (file.size == 0) {
      throw new Error(`invalid file size: [${file.size}]`);
    }
    return this.getJobChannel().sendBlob(file);
  }
  isReady() {
    return this.peer && this.peer.isPeerConnected();
  }
  close() {
    this.peer.close();
  }
  async getPrintToken(shareToken) {
    log(`[${this.serverId}] Exchanging share token for print token.`);
    return new Promise(async (resolve, reject) => {
      const dc = this.getTokenChannel();
      dc.sendString(shareToken);
      let buf;
      try {
        buf = await this.readChunkedResponse(dc);
      } catch (e) {
        return reject(e);
      }
      let printToken;
      try {
        printToken = byteArrayToString(buf);
      } catch (e) {
        error(`[${this.serverId}] error parsing auth-token response.`, e);
        return reject(e);
      }
      if (client_MobRTCClient.isError(printToken)) {
        return reject(`failed to exchange shareToken for printToken: ${printToken}`);
      }
      return resolve(printToken);
    });
  }
  readChunkedResponse(dc, chunkTimeout = this.timeout) {
    log(`[${dc.label}] readChunkedResponse,  chunkTimeout=${chunkTimeout}ms`);
    return new Promise((resolve, reject) => {
      let chunkIdx = 0;
      const startTime = performance.now();
      const buf = [];
      let onTimeout = setTimeout(() => {
        dc.clearOnMessage();
        return reject(`${chunkTimeout}ms timeout reached waiting for the first response.`);
      }, chunkTimeout);
      let logEveryNChunks = 0;
      dc.onMessage((ctx, msg) => {
        clearTimeout(onTimeout);
        onTimeout = setTimeout(() => {
          ctx.clearOnMessage();
          return reject(`${this.timeout}ms timeout reached waiting for data chunk: [${chunkIdx}]`);
        }, this.timeout);
        chunkIdx++;
        if (msg.stringData() === 'FINISH') {
          clearTimeout(onTimeout);
          ctx.clearOnMessage();
          if (buf.length == 0) {
            return resolve(new Uint8Array());
          }
          const result = buf.reduce((prev, next) => concatByteArrays(prev, next));
          log(`[${dc.label}]`, `Finished receiving ${(result.length / 1024).toFixed(2)}KiB,`, `chunks received: [${chunkIdx}]`, `took: ${(performance.now() - startTime).toFixed(2)} ms`);
          return resolve(result);
        }
        const chunk = msg.data();
        buf.push(new Uint8Array(chunk));
        if (logEveryNChunks === 0 && chunk.byteLength > 0) {
          logEveryNChunks = Math.floor(1024 * 1024 / chunk.byteLength);
        } else if (logEveryNChunks > 0 && chunkIdx > 0 && chunkIdx % logEveryNChunks === 0) {
          log(`[${dc.label}]: `, `Received ${chunkIdx} chunks,`, `${(chunk.byteLength * chunkIdx / 1024).toFixed(2)}KiB .`);
        }
      });
    });
  }
  async getPrinters(printToken) {
    return new Promise(async (resolve, reject) => {
      const dc = this.getPrinterChannel();
      dc.sendString(printToken);
      let printers;
      try {
        printers = await this.readJsonResponseFromChannel(dc);
      } catch (e) {
        error(`[${this.serverId}] error reading printer info response.`, e);
        return reject(e);
      }
      printers.forEach(p => {
        p.id = `http://localhost:9163/printers/${encodeURIComponent(p.name)}`;
        p.name = `${p.name} - [${p.description}]`;
      });
      return resolve(printers);
    });
  }
  async getCapabilities(printerId) {
    const dc = this.getCapabilitiesChannel();
    dc.sendString(printerId);
    return this.readJsonResponseFromChannel(dc);
  }
  async readJsonResponseFromChannel(dc, timeout = this.timeout) {
    return new Promise(async (resolve, reject) => {
      const tag = `${this.serverId}.${dc.label}`;
      let buf;
      try {
        buf = await this.readChunkedResponse(dc, timeout);
        const data = byteArrayToString(buf);
        if (client_MobRTCClient.isError(data)) {
          error(`[${tag}]: Server responded with error: ${data}`);
          return reject(`Server responded with error on: ${dc.label}`);
        }
        try {
          resolve(JSON.parse(data));
        } catch (e) {
          error(`[${tag}]: error parsing JSON response: `, e, buf);
          return reject(e);
        }
      } catch (e) {
        error(`[${tag}]: error reading response: `, e, buf);
        return reject(e);
      }
    });
  }
  getServerInfoChannel() {
    return this.peer.getDataChannel(SERVER_INFO_LABEL);
  }
  getPrinterChannel() {
    return this.peer.getDataChannel(PRINTER_CHANNEL_LABEL);
  }
  getJobChannel() {
    return this.peer.getDataChannel(JOB_CHANNEL_LABEL);
  }
  getTokenChannel() {
    return this.peer.getDataChannel(TOKEN_CHANNEL_LABEL);
  }
  getCapabilitiesChannel() {
    return this.peer.getDataChannel(CAPABILITIES_CHANNEL_LABEL);
  }
  getJobDetailsChannel() {
    return this.peer.getDataChannel(JOB_DETAILS_LABEL);
  }
  static isError(data) {
    return data.startsWith('ERROR:');
  }
}
function byteArrayToString(buf) {
  const utf8decode = new TextDecoder();
  return utf8decode.decode(buf);
}
function concatByteArrays(head, tail) {
  const concatResult = new Uint8Array(head.length + tail.length);
  concatResult.set(head);
  concatResult.set(tail, head.length);
  return concatResult;
}
;// CONCATENATED MODULE: ./src/scripts/cloudprint/clientbuilder.ts






const clientbuilder_SERVER_INFO_LABEL = 'SERVERINFO';
const clientbuilder_JOB_CHANNEL_LABEL = 'JOB';
const clientbuilder_JOB_DETAILS_LABEL = 'JOBDETAILS';
const clientbuilder_PRINTER_CHANNEL_LABEL = 'PRINTER';
const clientbuilder_TOKEN_CHANNEL_LABEL = 'TOKEN';
const clientbuilder_CAPABILITIES_CHANNEL_LABEL = 'CAPABILITIES';
const CLIENT_API_BASE_URL_PROD = 'https://mp.cloud.papercut.com';
const CLIENT_API_BASE_URL_TEST = 'https://mp.cloud.papercut.software';
class MobRTCClientBuilder {
  constructor(serverId) {
    this.clientId = '';
    this.timeout = 20000;
    this.shareToken = '';
    this.printToken = '';
    this.baseUrl = CLIENT_API_BASE_URL_PROD;
    this.serverId = serverId;
  }
  setClientId(clientId) {
    this.clientId = clientId;
    return this;
  }
  setTimeout(timeout) {
    this.timeout = timeout;
    return this;
  }
  setShareToken(shareToken) {
    this.shareToken = shareToken;
    return this;
  }
  setPrintToken(printToken) {
    this.printToken = printToken;
    return this;
  }
  setBaseUrl(baseUrl) {
    this.baseUrl = baseUrl;
    return this;
  }
  async build() {
    let receivedAnswer = false;
    const clientCandidates = [];
    const clientToken = this.printToken || this.shareToken;
    log(`[MOB RTC Builder.${this.serverId}] Client '${this.clientId}' creating session via ${this.baseUrl} ...`);
    const {
      id,
      iceConfig
    } = await createSession(this.baseUrl, {
      clientToken,
      clientId: this.clientId
    });
    let sessionDeleted = false;
    log(`[MOB RTC Builder.${this.serverId}] ICE servers`, iceConfig.servers);
    const sessionParams = {
      clientToken,
      sessionId: id,
      clientId: this.clientId
    };
    log(`[MOB RTC Builder.${this.serverId}] starting peer connection: ` + `serverId=${this.serverId}, sessionId=${id}, clientId=${this.clientId}`);
    const peer = new Peer(this.serverId, iceConfig);
    peer.onConnectionStateChange((ctx, _) => {
      if (sessionDeleted) {
        return;
      }
      switch (ctx.getConnectionState()) {
        case 'closed':
        case 'failed':
          log(`[MOB RTC Builder.${this.serverId}] RTC connection closed, deleting session.`, 'sessionId', id);
          sessionDeleted = true;
          deleteSession(this.baseUrl, {
            ...sessionParams
          }).then(() => {
            log(`[MOB RTC Builder.${this.serverId}] Cloud session deleted.`, 'sessionId', id);
          });
          break;
        default:
          log(`[MOB RTC Builder.${this.serverId}] RTC connection state changed: ${ctx.getConnectionState()}`);
      }
    });
    peer.onICECandidate(async (ctx, ev) => {
      if (ev.candidate == null) {
        log(`[MOB RTC Builder.${this.serverId}] candidates exhausted`, id);
        return;
      }
      if (!receivedAnswer) {
        clientCandidates.push(JSON.stringify(ev.candidate));
        return;
      }
      try {
        log(`[MOB RTC Builder.${this.serverId}] found candidate, sending to remote peer`, 'candidate', ev.candidate, 'sessionId', id);
        await notifyClientCandidates(this.baseUrl, {
          ...sessionParams,
          iceCandidates: [JSON.stringify(ev.candidate)]
        });
      } catch (e) {
        ctx.close();
        await deleteSession(this.baseUrl, {
          ...sessionParams
        });
        throw e;
      }
    });
    const start = Date.now();
    const peerConnectionLive = peer.waitForLiveConnection(this.timeout);
    log(`[MOB RTC Builder.${this.serverId}] registering ice candidate send handler`);
    const offer = new Promise(res => {
      peer.onNegotiationNeeded(async (ctx, _) => {
        const offer = await ctx.createOffer();
        res(offer);
      });
    });
    const dataChannels = this.setDataChannelHandlers(peer);
    log(`[MOB RTC Builder.${this.serverId}] sending offer to remote peer`);
    await createOffer(this.baseUrl, {
      ...sessionParams,
      iceOffer: await offer
    });
    log(`[MOB RTC Builder.${this.serverId}] awaiting answer`);
    const answer = await pollGetAnswer(this.baseUrl, {
      ...sessionParams
    }, {
      interval: 500,
      timeout: 15000
    });
    if (answer == 'timeout') {
      throw new Error('could not retrieve remote answer');
    }
    log(`[MOB RTC Builder.${this.serverId}] registering remote answer locally`);
    await peer.registerAnswer(answer.iceAnswer);
    receivedAnswer = true;
    if (clientCandidates.length > 0) {
      log(`[MOB RTC Builder.${this.serverId}] sending buffered candidate to peer`);
      await notifyClientCandidates(this.baseUrl, {
        ...sessionParams,
        iceCandidates: clientCandidates
      });
    }
    this.pollForCandidates(peer, sessionParams);
    try {
      await peerConnectionLive;
    } catch (e) {
      log(`[MOB RTC Builder.${this.serverId}] Peer connection failed...`);
      throw e;
    }
    const sel = peer.getSelectedCandidatePair();
    log(`Selected peer candidates, local: ${JSON.stringify(sel.local)}, remote: ${JSON.stringify(sel.remote)}`);
    log(`[MOB RTC Builder.${this.serverId}] Peer connection is live. `, `Time to establish: ${(Date.now() - start) / 1000}s.`);
    try {
      await Promise.race([dataChannels, new Promise(res => setTimeout(res, this.timeout))]);
    } catch (e) {
      throw e;
    }
    log(`[MOB RTC Builder.${this.serverId}] Creating Mobility Cloud client: 
			version=${GetClientVersionID()},
			sessionId=${sessionParams.sessionId}
			clientId=${sessionParams.clientId}
			timeout=${this.timeout}ms, 
			maxChunkSize=${iceConfig.maxChunkSize}`);
    return new MobRTCClient(sessionParams.sessionId, peer, this.timeout, iceConfig.maxChunkSize, GetClientVersionID());
  }
  pollForCandidates(peer, sessionParams, timeoutMs = 20000) {
    log(`[MOB RTC Builder.${this.serverId}]`, `session '${sessionParams.sessionId}' starting polling for server candidates...`);
    new Promise(async res => {
      let time = 0;
      let shouldBreak = false;
      setTimeout(() => {
        shouldBreak = true;
      }, timeoutMs);
      while (true) {
        const {
          iceCandidates,
          updated
        } = await getServerCandidates(this.baseUrl, {
          ...sessionParams,
          since: time
        });
        time = updated;
        iceCandidates.forEach(c => {
          log(`[MOB RTC Builder.${this.serverId}] session '${sessionParams.sessionId}' got candidate`, c);
          const candidate = JSON.parse(c);
          peer.addIceCandidate(candidate);
        });
        await delay(500);
        if (shouldBreak) {
          break;
        }
      }
      res();
    }).then(_ => {
      log(`[MOB RTC Builder.${this.serverId}]`, `session '${sessionParams.sessionId}' stopped waiting for more server candidates`);
    });
  }
  setDataChannelHandler(peer, label) {
    const channel = peer.createDataChannel(label);
    channel.onClose((ctx, _) => {
      log(`[MOB RTC Client] [${ctx.label}] datachannel closed`);
    });
    channel.onError((ctx, ev) => {
      if (ev.error.message == 'Transport channel closed') {} else {
        log(`[MOB RTC Client] [${ctx.label}] datachannel error`, ev.error.errorDetail);
      }
    });
    return new Promise(resolve => {
      channel.onOpen((ctx, _) => {
        log(`[MOB RTC Client] [${ctx.label}] datachannel open and ready`);
        resolve();
      });
    });
  }
  setDataChannelHandlers(peer) {
    return Promise.all([this.setDataChannelHandler(peer, clientbuilder_SERVER_INFO_LABEL), this.setDataChannelHandler(peer, clientbuilder_CAPABILITIES_CHANNEL_LABEL), this.setDataChannelHandler(peer, clientbuilder_TOKEN_CHANNEL_LABEL), this.setDataChannelHandler(peer, clientbuilder_PRINTER_CHANNEL_LABEL), this.setDataChannelHandler(peer, clientbuilder_JOB_CHANNEL_LABEL), this.setDataChannelHandler(peer, clientbuilder_JOB_DETAILS_LABEL)]);
  }
}
async function delay(ms) {
  return new Promise(res => setTimeout(() => {
    chrome.runtime.sendMessage({
      msg: 'keep active'
    });
    res();
  }, ms));
}
async function pollGetAnswer(baseUrl, req, pollOptions) {
  let shouldBreak = false;
  const timeout = setTimeout(() => {
    shouldBreak = true;
  }, pollOptions.timeout);
  while (true) {
    if (shouldBreak) {
      break;
    }
    const response = await getAnswer(baseUrl, req);
    if (response !== 'pending') {
      clearTimeout(timeout);
      return response;
    }
    await delay(pollOptions.interval);
  }
  return 'timeout';
}
;// CONCATENATED MODULE: ./src/scripts/cloudprint/index.ts



;// CONCATENATED MODULE: ./src/scripts/printer/capabilities.ts
const defaultColorOptions = [{
  type: 'STANDARD_COLOR',
  is_default: true
}, {
  type: 'STANDARD_MONOCHROME'
}];
const defaultDuplexOptions = [{
  type: 'NO_DUPLEX',
  is_default: true
}, {
  type: 'LONG_EDGE'
}, {
  type: 'SHORT_EDGE'
}];
const defaultPaperSize = 'A4';
const defaultMediaSizes = [{
  name: 'ISO_A0',
  width_microns: 841000,
  height_microns: 1189000,
  is_default: false,
  custom_display_name: 'A0'
}, {
  name: 'ISO_A1',
  width_microns: 594000,
  height_microns: 841000,
  is_default: false,
  custom_display_name: 'A1'
}, {
  name: 'ISO_A2',
  width_microns: 420000,
  height_microns: 594000,
  is_default: false,
  custom_display_name: 'A2'
}, {
  name: 'ISO_A3',
  width_microns: 297000,
  height_microns: 420000,
  is_default: false,
  custom_display_name: 'A3'
}, {
  name: 'ISO_A4',
  width_microns: 210000,
  height_microns: 297000,
  is_default: 'A4' === defaultPaperSize.toUpperCase(),
  custom_display_name: 'A4'
}, {
  name: 'ISO_A5',
  width_microns: 148000,
  height_microns: 210000,
  is_default: false,
  custom_display_name: 'A5'
}, {
  name: 'ISO_A6',
  width_microns: 105000,
  height_microns: 148000,
  is_default: false,
  custom_display_name: 'A6'
}, {
  name: 'ISO_A7',
  width_microns: 74000,
  height_microns: 105000,
  is_default: false,
  custom_display_name: 'A7'
}, {
  name: 'ISO_A8',
  width_microns: 52000,
  height_microns: 74000,
  is_default: false,
  custom_display_name: 'A8'
}, {
  name: 'ISO_A9',
  width_microns: 37000,
  height_microns: 52000,
  is_default: false,
  custom_display_name: 'A9'
}, {
  name: 'ISO_A10',
  width_microns: 26000,
  height_microns: 37000,
  is_default: false,
  custom_display_name: 'A10'
}, {
  name: 'JIS_B0',
  width_microns: 1030000,
  height_microns: 1456000,
  is_default: false,
  custom_display_name: 'JIS B0'
}, {
  name: 'JIS_B1',
  width_microns: 728000,
  height_microns: 1030000,
  is_default: false,
  custom_display_name: 'JIS B1'
}, {
  name: 'JIS_B2',
  width_microns: 515000,
  height_microns: 728000,
  is_default: false,
  custom_display_name: 'JIS B2'
}, {
  name: 'JIS_B3',
  width_microns: 364000,
  height_microns: 515000,
  is_default: false,
  custom_display_name: 'JIS B3'
}, {
  name: 'JIS_B4',
  width_microns: 257000,
  height_microns: 364000,
  is_default: false,
  custom_display_name: 'JIS B4'
}, {
  name: 'JIS_B5',
  width_microns: 182000,
  height_microns: 257000,
  is_default: false,
  custom_display_name: 'JIS B5'
}, {
  name: 'JIS_B6',
  width_microns: 128000,
  height_microns: 182000,
  is_default: false,
  custom_display_name: 'JIS B6'
}, {
  name: 'JIS_B7',
  width_microns: 91000,
  height_microns: 128000,
  is_default: false,
  custom_display_name: 'JIS B7'
}, {
  name: 'JIS_B8',
  width_microns: 64000,
  height_microns: 91000,
  is_default: false,
  custom_display_name: 'JIS B8'
}, {
  name: 'JIS_B9',
  width_microns: 45000,
  height_microns: 64000,
  is_default: false,
  custom_display_name: 'JIS B9'
}, {
  name: 'JIS_B10',
  width_microns: 32000,
  height_microns: 45000,
  is_default: false,
  custom_display_name: 'JIS B10'
}, {
  name: 'ISO_B0',
  width_microns: 1000000,
  height_microns: 1414000,
  is_default: false,
  custom_display_name: 'ISO B0'
}, {
  name: 'ISO_B1',
  width_microns: 707000,
  height_microns: 1000000,
  is_default: false,
  custom_display_name: 'ISO B1'
}, {
  name: 'ISO_B2',
  width_microns: 500000,
  height_microns: 707000,
  is_default: false,
  custom_display_name: 'ISO B2'
}, {
  name: 'ISO_B3',
  width_microns: 353000,
  height_microns: 500000,
  is_default: false,
  custom_display_name: 'ISO B3'
}, {
  name: 'ISO_B4',
  width_microns: 250000,
  height_microns: 353000,
  is_default: false,
  custom_display_name: 'ISO B4'
}, {
  name: 'ISO_B5',
  width_microns: 176000,
  height_microns: 250000,
  is_default: false,
  custom_display_name: 'ISO B5'
}, {
  name: 'ISO_B6',
  width_microns: 125000,
  height_microns: 176000,
  is_default: false,
  custom_display_name: 'ISO B6'
}, {
  name: 'ISO_B7',
  width_microns: 88000,
  height_microns: 125000,
  is_default: false,
  custom_display_name: 'ISO B7'
}, {
  name: 'ISO_B8',
  width_microns: 62000,
  height_microns: 88000,
  is_default: false,
  custom_display_name: 'ISO B8'
}, {
  name: 'ISO_B9',
  width_microns: 44000,
  height_microns: 62000,
  is_default: false,
  custom_display_name: 'ISO B9'
}, {
  name: 'ISO_B10',
  width_microns: 31000,
  height_microns: 44000,
  is_default: false,
  custom_display_name: 'ISO B10'
}, {
  name: 'NA_LETTER',
  width_microns: 215900,
  height_microns: 279400,
  is_default: false,
  custom_display_name: 'Letter'
}, {
  name: 'NA_LEGAL',
  width_microns: 215900,
  height_microns: 355600,
  is_default: false,
  custom_display_name: 'Legal'
}, {
  name: 'NA_5X7',
  width_microns: 127000,
  height_microns: 177800,
  is_default: false,
  custom_display_name: '5X7'
}, {
  name: 'NA_EXECUTIVE',
  width_microns: 184150,
  height_microns: 266700,
  is_default: false,
  custom_display_name: 'Executive'
}, {
  name: 'NA_INVOICE',
  width_microns: 139700,
  height_microns: 215900,
  is_default: false,
  custom_display_name: 'Invoice'
}, {
  name: 'NA_LEDGER',
  width_microns: 279400,
  height_microns: 431800,
  is_default: false,
  custom_display_name: 'Ledger'
}];
function createPrinterCapabilities(colorOptions = defaultColorOptions, duplexOptions = defaultDuplexOptions, mediaSizes = defaultMediaSizes) {
  return {
    version: '1.0',
    printer: {
      supported_content_type: [{
        content_type: 'application/pdf'
      }],
      color: {
        option: colorOptions
      },
      duplex: {
        option: duplexOptions
      },
      page_orientation: {
        option: [{
          type: 'PORTRAIT',
          is_default: true
        }, {
          type: 'LANDSCAPE',
          is_default: false
        }, {
          type: 'AUTO',
          is_default: false
        }]
      },
      copies: {
        default: 1,
        max: 100
      },
      media_size: {
        option: mediaSizes
      }
    }
  };
}
function capabilities_parseMobilityPrintCapabilities(capabilities) {
  const mediaSizes = capabilities.mediaSizes.map(m => ({
    name: 'CUSTOM',
    width_microns: m.widthMicrons,
    height_microns: m.heightMicrons,
    is_default: m.isDefault,
    custom_display_name: m.customDisplayName || m.name
  }));
  if (mediaSizes.length > 0 && mediaSizes.every(function (m) {
    return !m.is_default;
  })) {
    mediaSizes[0].is_default = true;
  }
  const colorOptions = capabilities.color.map(function (n) {
    return {
      type: n
    };
  });
  if (colorOptions.length > 0) {
    colorOptions[0]['is_default'] = true;
  }
  const duplexOptions = capabilities.duplex.map(function (n) {
    return {
      type: n
    };
  });
  if (duplexOptions.length > 0) {
    duplexOptions[0]['is_default'] = true;
  }
  return createPrinterCapabilities(colorOptions, duplexOptions, mediaSizes);
}
;// CONCATENATED MODULE: ./src/scripts/storage/storage.ts
async function getManagedStorageData(key) {
  return new Promise((resolve, reject) => {
    chrome.storage.managed.get(key, function (data) {
      if (data && data[key]) {
        resolve(data[key]);
      } else if (chrome.runtime.lastError) {
        reject(chrome.runtime.lastError);
      } else {
        resolve(undefined);
      }
    });
  });
}
async function storage_getLocalStorageData(key) {
  return new Promise((resolve, reject) => {
    chrome.storage.local.get(key, result => {
      if (result && result[key]) {
        resolve(result[key]);
      } else if (chrome.runtime.lastError) {
        reject(chrome.runtime.lastError);
      } else {
        resolve(undefined);
      }
    });
  });
}
async function removeLocalStorageData(keys) {
  return new Promise((resolve, reject) => {
    chrome.storage.local.remove(keys, () => {
      if (chrome.runtime.lastError) {
        reject(chrome.runtime.lastError);
      } else {
        resolve();
      }
    });
  });
}
async function storage_setLocalStorageData(key, data) {
  return new Promise((resolve, reject) => {
    chrome.storage.local.set({
      [key]: data
    }, () => {
      if (chrome.runtime.lastError) {
        reject(chrome.runtime.lastError.message);
      } else {
        resolve(data);
      }
    });
  });
}
async function saveMap(key, map) {
  return new Promise((resolve, reject) => {
    chrome.storage.local.set({
      [key]: Array.from(map.entries())
    }, () => {
      if (chrome.runtime.lastError) {
        reject(chrome.runtime.lastError.message);
      } else {
        resolve(key);
      }
    });
  });
}
async function storage_loadMap(key) {
  return new Promise((resolve, reject) => {
    chrome.storage.local.get(key, d => {
      if (d && d[key]) {
        const map = new Map();
        for (const [k, v] of d[key]) {
          map.set(k, v);
        }
        resolve(map);
      } else if (chrome.runtime.lastError) {
        reject(chrome.runtime.lastError.message);
      } else {
        resolve(undefined);
      }
    });
  });
}
;// CONCATENATED MODULE: ./src/scripts/wait.ts
async function sleep(millis) {
  return new Promise(r => setTimeout(r, millis));
}
async function waitForCondition(condTestFunc, sleepMillis = 1000, sleepMaxMillis = 60000) {
  const started = performance.now();
  while (!condTestFunc()) {
    if (performance.now() - started > sleepMaxMillis) {
      return false;
    }
    await sleep(sleepMillis);
  }
  return true;
}
async function workerWaitUntil(promise) {
  const keepAlive = setInterval(function () {
    console.log('Keep-alive');
    chrome.runtime.getPlatformInfo();
  }, 25 * 1000);
  const startTime = Date.now();
  try {
    console.log('Waiting with keep-alive...');
    return await promise;
  } catch (e) {
    console.log('Wait completed with error:', e);
  } finally {
    console.log(`Finished waiting with keep-alive, elapsed: ${(Date.now() - startTime) / 1000}seconds`);
    clearInterval(keepAlive);
  }
}
;// CONCATENATED MODULE: ./src/scripts/offnetwork/offnetworkcache.ts





const printerCapabilitiesCache = new Map();
const serverIdToClientCache = new Map();
const storageKeyServerIdToInfoCache = 'serverIdToInfoCache';
const serverIdToInfoCache = new Map();
const storageKeyPrinterTimeUsedMap = 'printerTimeUsedMap';
const storageKeyPrinterCapabilitiesMap = 'printerCapabilitiesMap';
const storageKeyPrinterServerMap = 'printerServerMap';
const storageKeyPrintTokenCache = 'printTokenCache';
const printerTimeUsedMap = new Map();
const printerNameToServerIdCache = new Map();
const printTokenCache = new Map();
const storageKeyReclaimStorageLimitKb = 'reclaimStorageLimitKb';
const storageKeyPrintedOlderThanDays = 'printedOlderThanDays';
let reclaimStorageLimitKb;
let printedOlderThanDays;
let cacheLoaded = false;
async function offnetworkcache_initCache() {
  const [storageLimit, printedAge] = await Promise.all([getLocalStorageData(storageKeyReclaimStorageLimitKb).then(v => v ? +v : 4096), getLocalStorageData(storageKeyPrintedOlderThanDays).then(v => v ? +v : 30)]);
  reclaimStorageLimitKb = storageLimit;
  printedOlderThanDays = printedAge;
  log(`Local storage cleanup settings: reclaimStorageLimitKb=${reclaimStorageLimitKb} KiB, ` + `printedOlderThanDays=${printedOlderThanDays} days`);
  populateCache(reclaimStorageLimitKb, printedOlderThanDays);
}
function getServerIdToClientCache() {
  return serverIdToClientCache;
}
function offnetworkcache_getServerIdToServerInfoCache() {
  return serverIdToInfoCache;
}
function offnetworkcache_getPrinterNameToServerIdCache() {
  return printerNameToServerIdCache;
}
function offnetworkcache_getPrintTokenCache() {
  return printTokenCache;
}
function updatePrintToken(printTokenCacheID, printToken) {
  if (!printToken) {
    log_warn('updatePrintToken: Print token is not provided');
  }
  log_log(` updatePrintToken: Saving print token for: ${printTokenCacheID}`);
  offnetworkcache_getPrintTokenCache().set(printTokenCacheID, printToken);
  saveMapToStorage(storageKeyPrintTokenCache, printTokenCache).then(() => log_log(` updatePrintToken: Updated print token for: ${printTokenCacheID}`));
}
function updateServerInfo(serverId, serverInfo) {
  const idToServerInfoCache = offnetworkcache_getServerIdToServerInfoCache();
  idToServerInfoCache.set(serverId, serverInfo);
  saveMapToStorage(storageKeyServerIdToInfoCache, idToServerInfoCache).then(() => log_log(`Updated info for server '${serverId}: ${JSON.stringify(serverInfo)}...`));
}
function populateCache(reclaimStorageLimitKb, printedOlderThanDays) {
  Promise.all([loadMapFromStorage(storageKeyPrinterTimeUsedMap, printerTimeUsedMap), loadMapFromStorage(storageKeyPrinterCapabilitiesMap, printerCapabilitiesCache), loadMapFromStorage(storageKeyPrinterServerMap, printerNameToServerIdCache), loadMapFromStorage(storageKeyPrintTokenCache, printTokenCache), loadMapFromStorage(storageKeyServerIdToInfoCache, serverIdToInfoCache)]).then(() => {
    chrome.storage.local.getBytesInUse(bytesInUse => {
      log(`[OffNetworkCache:populateCache] total cached storage: ${(bytesInUse / 1024).toFixed(2)}KiB`);
      if (bytesInUse / 1024 >= reclaimStorageLimitKb) {
        warn(`Exceeded storage limit threshold of ${reclaimStorageLimitKb}KiB, 
					cleanup capabilities for printers not used in ${printedOlderThanDays} days...`);
        cleanupStorage(printedOlderThanDays).then(() => log(`Completed cleanup of printers used > ${printedOlderThanDays} days`));
      }
      cacheLoaded = true;
      log('[OffNetworkCache:populateCache] completed.');
    });
  });
}
async function loadMapFromStorage(key, toMap) {
  try {
    const map = await loadMap(key);
    if (map) {
      copyToMap(map, toMap);
      log(`Loaded '${key}' with ${map.size} items from local storage...`);
    } else {
      log(`Unable to load '${key} from local storage - it does not exist`);
    }
  } catch (reason) {
    return error(`Unable to load '${key}' from local storage: ${reason}`);
  }
}
async function saveMapToStorage(key, map) {
  try {
    await saveMap(key, map);
    return log_log(`Saved '${key}' with ${map.size} items to local storage...`);
  } catch (reason) {
    log_error(`Failed to save data to local storage: ${reason}`);
    if (reason && reason.toLowerCase().includes('quota')) {
      cleanupStorage(printedOlderThanDays).then(() => log_log(`Completed cleanup of printers used > ${printedOlderThanDays} days`));
    }
  }
}
function copyToMap(src, dst) {
  dst.clear();
  src.forEach((value, key) => dst.set(key, value));
}
function daysAgo(timestampMillis) {
  const millisPerDay = 1000 * 60 * 60 * 24;
  if (timestampMillis === undefined) {
    return undefined;
  }
  return (Date.now() - timestampMillis) / millisPerDay;
}
async function cleanupStorage(printedOlderThanDays) {
  log_log(`[OffNetworkCache:cleanupStorage] Storage cleanup requested, printing threshold=${printedOlderThanDays}days`);
  chrome.storage.local.getBytesInUse(usedBytes => {
    log_log(`[OffNetworkCache:cleanupStorage] Storage cleanup, ${(usedBytes / 1024).toFixed(2)}KiB used`);
    log_log(`[OffNetworkCache:cleanupStorage] ${printerCapabilitiesCache.size} printer capabilities cached`);
  });
  for (const printerId of printerCapabilitiesCache.keys()) {
    const printerName = printerNameFromUrl(printerId);
    const unusedPrinter = printerName == undefined || (await offnetworkcache_getServerIdForPrinter(printerId)) === undefined;
    const printedDays = daysAgo(printerTimeUsedMap.get(printerId));
    let discard = false;
    if (unusedPrinter) {
      log_log(`[OffNetworkCache:cleanupStorage] Discarding unused printer capability: ${printerName}`);
      discard = true;
    } else if (printedDays === undefined || printedDays > printedOlderThanDays) {
      log_log(`[OffNetworkCache:cleanupStorage] Discarding printer capability older than ${printedOlderThanDays} days: 
			${printerName}, last printed: ${printedDays ? printedDays.toFixed(0) + ' days ago' : 'never'}`);
      discard = true;
    }
    if (discard) {
      printerTimeUsedMap.delete(printerId);
      printerCapabilitiesCache.delete(printerId);
    }
  }
  log_log(`[OffNetworkCache:cleanupStorage] ${printerCapabilitiesCache.size} printer capabilities after clean-up`);
  Promise.all([saveMapToStorage(storageKeyPrinterTimeUsedMap, printerTimeUsedMap), saveMapToStorage(storageKeyPrinterCapabilitiesMap, printerCapabilitiesCache)]).then(() => {
    chrome.storage.local.getBytesInUse(bytesInUse => {
      log_log(`[OffNetworkCache:cleanupStorage] Cleanup complete, ${(bytesInUse / 1024).toFixed(2)}KiB used`);
    });
  });
}
async function offnetworkcache_updatePrinterCache(serverId, printers) {
  for (const printer of printers) {
    printerCapabilitiesCache.set(printer.id, printer.capabilities);
    printerNameToServerIdCache.set(printer.name, serverId);
  }
  await Promise.all([saveMapToStorage(storageKeyPrinterTimeUsedMap, printerTimeUsedMap), saveMapToStorage(storageKeyPrinterCapabilitiesMap, printerCapabilitiesCache), saveMapToStorage(storageKeyPrinterServerMap, printerNameToServerIdCache)]).catch(e => {
    log_error(`Failed to save data caches to storage: ${e.name} - ${e.message}`);
  });
}
function getPrinterCapabilities(printerId) {
  const cap = printerCapabilitiesCache.get(printerId);
  if (!cap) {
    log(`Cached printer capability for '${printerId}' missing from cache!`);
    return null;
  }
  log(`Found cached printer capabilities for: ${printerId} => ${JSON.stringify(cap)}`);
  return parseMobilityPrintCapabilities(cap);
}
function offnetworkcache_updateLastPrintedTime(printerUrl) {
  printerTimeUsedMap.set(printerUrl, Date.now());
  saveMapToStorage(storageKeyPrinterTimeUsedMap, printerTimeUsedMap).then(() => {
    log(`Saved last printed date for: ${printerUrl}`);
  });
}
async function offnetworkcache_getServerIdForPrinter(printerUrl) {
  const printerName = printerNameFromUrl(printerUrl);
  if (!printerName) {
    return undefined;
  }
  const ready = await waitForCondition(() => {
    log_log('[OffNetworkCache:getServerIdForPrinter] Waiting for cache to be loaded and ready...');
    return cacheLoaded;
  });
  if (!ready) {
    log_error('[OffNetworkCache:getServerIdForPrinter] Giving up waited for cache to be ready...');
    return undefined;
  }
  for (const [cachedPrinterName, serverId] of printerNameToServerIdCache) {
    if (cachedPrinterName.startsWith(printerName)) {
      return serverId;
    }
  }
  return undefined;
}
function printerNameFromUrl(printerUrl) {
  try {
    const urlPath = new URL(printerUrl).pathname;
    const lastSlash = urlPath.lastIndexOf('/');
    return decodeURIComponent(urlPath.substring(lastSlash + 1));
  } catch (e) {
    log_error(`Cannot find printer name - invalid URL: ${printerUrl}`, e);
    return undefined;
  }
}
;// CONCATENATED MODULE: ./src/scripts/offnetwork/offnetwork-utils.ts




const LINKS_STORAGE_KEY = 'CloudPrintInviteLinks';
const CLOUD_PRINT_ERR = 'Cloud Print error';
async function initCloudPrint() {
  log('[OffNetwork] Initializing Cloud Print');
  await getClientId();
  return initCache();
}
function isCloudPrintError(e) {
  if (typeof e === 'string') {
    return e.includes(CLOUD_PRINT_ERR);
  }
  return e && e.message && e.message.includes(CLOUD_PRINT_ERR);
}
async function saveBYODLink(link) {
  const links = await getAllLinks();
  if (!links.includes(link)) {
    log(`no existing link found, saving the received link as a BYOD link: ${link}`);
    const byodLinks = await getBYODLinks();
    byodLinks.push(link);
    chrome.storage.local.set({
      CloudPrintInviteLinks: byodLinks
    });
  } else {
    log('found existing link');
  }
}
function getBYODLinks() {
  return new Promise(res => {
    chrome.storage.local.get(LINKS_STORAGE_KEY, data => {
      if (data && data[LINKS_STORAGE_KEY]) {
        log(`getting ${data[LINKS_STORAGE_KEY].length} BYOD link(s)...`);
        return res(data[LINKS_STORAGE_KEY]);
      } else {
        log('no BYOD links found');
        res([]);
      }
    });
  });
}
function getManagedLinks() {
  return new Promise(res => {
    chrome.storage.managed.get(LINKS_STORAGE_KEY, data => {
      if (data && data[LINKS_STORAGE_KEY]) {
        log(`getting ${data[LINKS_STORAGE_KEY].length} managed link(s)...`);
        return res(data[LINKS_STORAGE_KEY]);
      } else {
        log('no managed links found');
        return res([]);
      }
    });
  });
}
async function getAllLinks() {
  const storedLinks = await getManagedLinks();
  const byodLinks = await getBYODLinks();
  return storedLinks.concat(byodLinks);
}
async function offnetwork_utils_getOffNetworkLinks() {
  const allLinks = await getAllLinks();
  const links = allLinks.map(s => {
    try {
      return CloudPrintLink.parse(s);
    } catch (e) {
      error('Failed to parse Cloud Print link.', 'link', s, e);
    }
  }).filter(res => res != null);
  log('Parsed Cloud Print links.', links.map(l => l.orgId + '/' + l.serverId + ' ' + (l.expires() ? `(expiry: ${l.expiry.toISOString()})` : '(no expiry)')));
  return links;
}
function offnetwork_utils_getPrintTokenCacheID(serverId, shareToken) {
  return serverId + ':' + shareToken;
}
async function offnetwork_utils_getShareToken(serverId) {
  return (await offnetwork_utils_getLink(serverId)).shareToken;
}
async function offnetwork_utils_getLink(serverId) {
  const link = (await offnetwork_utils_getOffNetworkLinks()).find(link => link.serverId == serverId);
  if (!link) {
    throw new Error(`no link for server ${serverId}`);
  }
  return link;
}
// EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.match-all.js
var es_string_match_all = __webpack_require__(9866);
;// CONCATENATED MODULE: ./src/scripts/offnetwork/offscreen-utils.ts


const OFFSCREEN_DOCUMENT_PATH = '/offscreen.html';
let offScreenDocumentCheck = Promise.resolve();
async function getOffScreenDocument() {
  offScreenDocumentCheck = offScreenDocumentCheck.then(async () => {
    if (!(await hasDocument())) {
      log('[Offscreen] creating offscreen document...');
      try {
        await chrome.offscreen.createDocument({
          url: OFFSCREEN_DOCUMENT_PATH,
          reasons: [chrome.offscreen.Reason.WEB_RTC],
          justification: 'WebRTC for Mobility Cloud Print'
        });
      } catch (error) {
        if (!error.message.startsWith('Only a single offscreen document')) {
          throw error;
        }
      }
    }
  });
  return offScreenDocumentCheck;
}
async function offscreen_utils_messageOffScreen(data) {
  await getOffScreenDocument();
  const clientUrl = chrome.runtime.getURL(OFFSCREEN_DOCUMENT_PATH);
  const messageClient = (await self.clients.matchAll({
    includeUncontrolled: true
  })).find(c => c.url === clientUrl);
  const messageChannel = new MessageChannel();
  messageClient.postMessage(data, [messageChannel.port2]);
  const {
    data: offscreenResponse
  } = await new Promise(cb => messageChannel.port1.onmessage = cb);
  log(`[Offscreen.${data.MsgType}] got response`, offscreenResponse);
  return offscreenResponse;
}
async function hasDocument() {
  const clientWindows = await self.clients.matchAll();
  log('[Offscreen] checking for offscreen window...', clientWindows);
  for (const clientWindow of clientWindows) {
    if (clientWindow.url.endsWith(OFFSCREEN_DOCUMENT_PATH)) {
      log('[Offscreen] found existing offscreen document', clientWindow);
      return true;
    }
  }
  log('[Offscreen] could not find existing offscreen document');
  return false;
}
try {
  chrome.runtime.onSuspend.addListener(() => {
    chrome.offscreen.closeDocument().then(() => {
      log_log('[Offscreen] document closed on extension unload');
    }).catch(error => {
      error('Failed to close offscreen document on unload:', error);
    });
  });
} catch (e) {
  console.log(`Error: ${e}`);
}
;// CONCATENATED MODULE: ./src/scripts/offnetwork/offnetwork_extension.ts







try {
  chrome.runtime.onMessage.addListener(handleMessages);
} catch (e) {
  console.log(`Error: ${e}`);
}
async function handleMessages(message) {
  if (message.target !== 'background') {
    return;
  }
  switch (message.type) {
    case 'log':
      {
        log_log(message.data);
        break;
      }
    case 'error':
      {
        log_error(message.data);
        break;
      }
    case 'warn':
      {
        log_warn(message.data);
        break;
      }
    case 'cache-server-info':
      {
        log_log(`[offscreen.${message.type}] cache server info: ${message.data.ServerID}`);
        updateServerInfo(message.data.ServerID, message.data.ServerInfo);
        break;
      }
    case 'update-print-token-cache':
      {
        log_log(`[offscreen.${message.type}] cache print token for server: ${message.data.ServerID}`);
        updatePrintToken(offnetwork_utils_getPrintTokenCacheID(message.data.ServerID, message.data.ShareToken), message.data.PrintToken);
        break;
      }
    case 'delete-print-token-cache':
      {
        log_log(`[offscreen.${message.type}] remove print token for server: ${message.data.ServerID}`);
        offnetworkcache_getPrintTokenCache().delete(offnetwork_utils_getPrintTokenCacheID(message.data.ServerID, message.data.ShareToken));
        break;
      }
    case 'update-printer-cache':
      {
        log_log(`[offscreen.${message.type}] update cached printers for server: ${message.data.ServerID}`);
        await offnetworkcache_updatePrinterCache(message.data.ServerID, message.data.PrinterList);
        break;
      }
    default:
      console.warn(`Unexpected message received for background script: '${JSON.stringify(message)}'.`);
  }
}
async function getPrintersFromAllServers() {
  let links;
  try {
    links = await getOffNetworkLinks();
  } catch (e) {
    error('[OffNetwork:getPrintersFromAllServers] failed to get links: ', e);
  }
  if (links.length === 0) {
    log('[OffNetwork:getPrintersFromAllServers] No Cloud Print links, skipping Cloud Print discovery.');
    return [];
  }
  log('[OffNetwork:getPrintersFromAllServers] links', links);
  const serverIds = new Set(links.map(link => link.serverId));
  const printerNameToServerIdCache = getPrinterNameToServerIdCache();
  for (const [printerName, serverId] of printerNameToServerIdCache.entries()) {
    if (!serverIds.has(serverId)) {
      printerNameToServerIdCache.delete(printerName);
    }
  }
  const printerResults = [...serverIds].map(async serverId => {
    try {
      const printers = await getPrintersFromServer(serverId);
      log(`[OffNetwork:getPrintersFromAllServers] got ${printers.length} printers from '${serverId}'`, printers);
      return printers;
    } catch (e) {
      error(`[OffNetwork:getPrintersFromAllServers] failed for ${serverId}: `, e);
      return [];
    }
  });
  const result = (await Promise.all(printerResults)).flat(Infinity);
  log(`[OffNetwork:getPrintersFromAllServers] completed with ${result.length} Cloud Print printers.`);
  return result;
}
async function offnetwork_extension_getServerInfoRTC(serverId) {
  log(`[OffNetwork:getServerInfoRTC] Requesting server info: ${serverId}`);
  const shareToken = await getShareToken(serverId);
  const printTokenCacheID = getPrintTokenCacheID(serverId, shareToken);
  const printToken = getPrintTokenCache().get(printTokenCacheID);
  const clientId = await getClientId();
  const data = {
    ServerID: serverId,
    ClientID: clientId,
    TestEnv: (await getLink(serverId)).testEnv,
    ShareToken: shareToken,
    PrintToken: printToken,
    MsgType: 'get-server-info-rtc'
  };
  const serverInfo = await messageOffScreen(data);
  if (!serverInfo.RespState) {
    error('[OffNetwork:getServerInfoRTC] server info fetch error ', serverInfo.RespData);
    throw new Error(serverInfo.RespData);
  }
  return serverInfo.RespData;
}
async function getPrintersFromServer(serverId) {
  log(`[OffNetwork:getPrintersFromServer] fetching printers for server '${serverId}'...`);
  const shareToken = await getShareToken(serverId);
  const printTokenCacheID = getPrintTokenCacheID(serverId, shareToken);
  const printToken = getPrintTokenCache().get(printTokenCacheID);
  const clientId = await getClientId();
  const data = {
    ServerID: serverId,
    ClientID: clientId,
    TestEnv: (await getLink(serverId)).testEnv,
    ShareToken: shareToken,
    PrintToken: printToken,
    MsgType: 'get-printers-from-server'
  };
  const printerResult = await messageOffScreen(data);
  if (!printerResult.RespState) {
    error('[OffNetwork:getPrintersFromServer] cloud print job submit error (promise reject): ', printerResult.RespData);
    throw new Error(printerResult.RespData);
  }
  await updatePrinterCache(serverId, printerResult.RespData);
  return printerResult.RespData;
}
async function getPrinterInfoRTC(printerId) {
  log(`[OffNetwork:getPrinterInfoRTC] Requesting printer info: ${printerId}`);
  const serverId = await getServerIdForPrinter(printerId);
  if (!serverId) {
    throw new Error(`unknown server id for printer: ${printerId}`);
  }
  const shareToken = await getShareToken(serverId);
  const printTokenCacheID = getPrintTokenCacheID(serverId, shareToken);
  const printToken = getPrintTokenCache().get(printTokenCacheID);
  const clientId = await getClientId();
  const data = {
    PrinterID: printerId,
    ServerID: serverId,
    ClientID: clientId,
    TestEnv: (await getLink(serverId)).testEnv,
    ShareToken: shareToken,
    PrintToken: printToken,
    MsgType: 'get-printer-info-rtc'
  };
  const capabilities = await messageOffScreen(data);
  if (!capabilities.RespState) {
    error('[OffNetwork:getCapabilitiesOffNetwork] cloud printer capabilities fetch error ', capabilities.RespData);
    throw new Error('Error fetching capabilities via cloud client');
  }
  log('[getPrinterInfoRTC] Received printer capabilities.', capabilities.RespData);
  return capabilities.RespData;
}
async function submitPrintJobRTC(file, printerUrl, params) {
  const serverId = await getServerIdForPrinter(printerUrl);
  if (!serverId) {
    throw new Error(`unknown server id for printer ${printerUrl}`);
  }
  log('[OffNetwork:submitPrintJobRTC]', 'serverId', serverId, 'params', {
    ...params,
    credentials: '[REDACTED]'
  });
  const shareToken = await getShareToken(serverId);
  const printTokenCacheID = getPrintTokenCacheID(serverId, shareToken);
  const printToken = getPrintTokenCache().get(printTokenCacheID);
  const clientId = await getClientId();
  const data = {
    FileData: file,
    PrinterURL: printerUrl,
    Params: params,
    ServerID: serverId,
    ClientID: clientId,
    TestEnv: (await getLink(serverId)).testEnv,
    ShareToken: shareToken,
    PrintToken: printToken,
    MsgType: 'submit-print-job-rtc'
  };
  const jobDetails = await messageOffScreen(data);
  if (!jobDetails.RespState) {
    error('[OffNetwork:submitPrintJobRTC] cloud print job submit error (promise reject): ', jobDetails.RespData);
    throw new Error(jobDetails.RespData);
  }
  log('[submitPrintJobRTC] received job submit result (jobDetails) from offscreen doc: ', jobDetails.RespData);
  updateLastPrintedTime(printerUrl);
  return jobDetails.RespData;
}
;// CONCATENATED MODULE: ./src/scripts/printer/printer.ts
function printer_getUrlBaseOfPrinterUrl(printerUrl) {
  return printerUrl.replace(/\/printers\/.*/i, '');
}
function getPrinterName(printerUrl) {
  return printerUrl.slice(printerUrl.lastIndexOf('/printers/') + '/printers/'.length);
}
;// CONCATENATED MODULE: ./node_modules/jsencrypt/lib/lib/jsbn/util.js
var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
function int2char(n) {
    return BI_RM.charAt(n);
}
//#region BIT_OPERATIONS
// (public) this & a
function op_and(x, y) {
    return x & y;
}
// (public) this | a
function op_or(x, y) {
    return x | y;
}
// (public) this ^ a
function op_xor(x, y) {
    return x ^ y;
}
// (public) this & ~a
function op_andnot(x, y) {
    return x & ~y;
}
// return index of lowest 1-bit in x, x < 2^31
function lbit(x) {
    if (x == 0) {
        return -1;
    }
    var r = 0;
    if ((x & 0xffff) == 0) {
        x >>= 16;
        r += 16;
    }
    if ((x & 0xff) == 0) {
        x >>= 8;
        r += 8;
    }
    if ((x & 0xf) == 0) {
        x >>= 4;
        r += 4;
    }
    if ((x & 3) == 0) {
        x >>= 2;
        r += 2;
    }
    if ((x & 1) == 0) {
        ++r;
    }
    return r;
}
// return number of 1 bits in x
function cbit(x) {
    var r = 0;
    while (x != 0) {
        x &= x - 1;
        ++r;
    }
    return r;
}
//#endregion BIT_OPERATIONS

;// CONCATENATED MODULE: ./node_modules/jsencrypt/lib/lib/jsbn/base64.js

var b64map = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var b64pad = "=";
function hex2b64(h) {
    var i;
    var c;
    var ret = "";
    for (i = 0; i + 3 <= h.length; i += 3) {
        c = parseInt(h.substring(i, i + 3), 16);
        ret += b64map.charAt(c >> 6) + b64map.charAt(c & 63);
    }
    if (i + 1 == h.length) {
        c = parseInt(h.substring(i, i + 1), 16);
        ret += b64map.charAt(c << 2);
    }
    else if (i + 2 == h.length) {
        c = parseInt(h.substring(i, i + 2), 16);
        ret += b64map.charAt(c >> 2) + b64map.charAt((c & 3) << 4);
    }
    while ((ret.length & 3) > 0) {
        ret += b64pad;
    }
    return ret;
}
// convert a base64 string to hex
function b64tohex(s) {
    var ret = "";
    var i;
    var k = 0; // b64 state, 0-3
    var slop = 0;
    for (i = 0; i < s.length; ++i) {
        if (s.charAt(i) == b64pad) {
            break;
        }
        var v = b64map.indexOf(s.charAt(i));
        if (v < 0) {
            continue;
        }
        if (k == 0) {
            ret += int2char(v >> 2);
            slop = v & 3;
            k = 1;
        }
        else if (k == 1) {
            ret += int2char((slop << 2) | (v >> 4));
            slop = v & 0xf;
            k = 2;
        }
        else if (k == 2) {
            ret += int2char(slop);
            ret += int2char(v >> 2);
            slop = v & 3;
            k = 3;
        }
        else {
            ret += int2char((slop << 2) | (v >> 4));
            ret += int2char(v & 0xf);
            k = 0;
        }
    }
    if (k == 1) {
        ret += int2char(slop << 2);
    }
    return ret;
}
// convert a base64 string to a byte/number array
function b64toBA(s) {
    // piggyback on b64tohex for now, optimize later
    var h = b64tohex(s);
    var i;
    var a = [];
    for (i = 0; 2 * i < h.length; ++i) {
        a[i] = parseInt(h.substring(2 * i, 2 * i + 2), 16);
    }
    return a;
}

;// CONCATENATED MODULE: ./node_modules/jsencrypt/lib/lib/asn1js/hex.js
// Hex JavaScript decoder
// Copyright (c) 2008-2013 Lapo Luchini <lapo@lapo.it>
// Permission to use, copy, modify, and/or distribute this software for any
// purpose with or without fee is hereby granted, provided that the above
// copyright notice and this permission notice appear in all copies.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
/*jshint browser: true, strict: true, immed: true, latedef: true, undef: true, regexdash: false */
var decoder;
var Hex = {
    decode: function (a) {
        var i;
        if (decoder === undefined) {
            var hex = "0123456789ABCDEF";
            var ignore = " \f\n\r\t\u00A0\u2028\u2029";
            decoder = {};
            for (i = 0; i < 16; ++i) {
                decoder[hex.charAt(i)] = i;
            }
            hex = hex.toLowerCase();
            for (i = 10; i < 16; ++i) {
                decoder[hex.charAt(i)] = i;
            }
            for (i = 0; i < ignore.length; ++i) {
                decoder[ignore.charAt(i)] = -1;
            }
        }
        var out = [];
        var bits = 0;
        var char_count = 0;
        for (i = 0; i < a.length; ++i) {
            var c = a.charAt(i);
            if (c == "=") {
                break;
            }
            c = decoder[c];
            if (c == -1) {
                continue;
            }
            if (c === undefined) {
                throw new Error("Illegal character at offset " + i);
            }
            bits |= c;
            if (++char_count >= 2) {
                out[out.length] = bits;
                bits = 0;
                char_count = 0;
            }
            else {
                bits <<= 4;
            }
        }
        if (char_count) {
            throw new Error("Hex encoding incomplete: 4 bits missing");
        }
        return out;
    }
};

;// CONCATENATED MODULE: ./node_modules/jsencrypt/lib/lib/asn1js/base64.js
// Base64 JavaScript decoder
// Copyright (c) 2008-2013 Lapo Luchini <lapo@lapo.it>
// Permission to use, copy, modify, and/or distribute this software for any
// purpose with or without fee is hereby granted, provided that the above
// copyright notice and this permission notice appear in all copies.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
/*jshint browser: true, strict: true, immed: true, latedef: true, undef: true, regexdash: false */
var base64_decoder;
var Base64 = {
    decode: function (a) {
        var i;
        if (base64_decoder === undefined) {
            var b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
            var ignore = "= \f\n\r\t\u00A0\u2028\u2029";
            base64_decoder = Object.create(null);
            for (i = 0; i < 64; ++i) {
                base64_decoder[b64.charAt(i)] = i;
            }
            base64_decoder['-'] = 62; //+
            base64_decoder['_'] = 63; //-
            for (i = 0; i < ignore.length; ++i) {
                base64_decoder[ignore.charAt(i)] = -1;
            }
        }
        var out = [];
        var bits = 0;
        var char_count = 0;
        for (i = 0; i < a.length; ++i) {
            var c = a.charAt(i);
            if (c == "=") {
                break;
            }
            c = base64_decoder[c];
            if (c == -1) {
                continue;
            }
            if (c === undefined) {
                throw new Error("Illegal character at offset " + i);
            }
            bits |= c;
            if (++char_count >= 4) {
                out[out.length] = (bits >> 16);
                out[out.length] = (bits >> 8) & 0xFF;
                out[out.length] = bits & 0xFF;
                bits = 0;
                char_count = 0;
            }
            else {
                bits <<= 6;
            }
        }
        switch (char_count) {
            case 1:
                throw new Error("Base64 encoding incomplete: at least 2 bits missing");
            case 2:
                out[out.length] = (bits >> 10);
                break;
            case 3:
                out[out.length] = (bits >> 16);
                out[out.length] = (bits >> 8) & 0xFF;
                break;
        }
        return out;
    },
    re: /-----BEGIN [^-]+-----([A-Za-z0-9+\/=\s]+)-----END [^-]+-----|begin-base64[^\n]+\n([A-Za-z0-9+\/=\s]+)====/,
    unarmor: function (a) {
        var m = Base64.re.exec(a);
        if (m) {
            if (m[1]) {
                a = m[1];
            }
            else if (m[2]) {
                a = m[2];
            }
            else {
                throw new Error("RegExp out of sync");
            }
        }
        return Base64.decode(a);
    }
};

;// CONCATENATED MODULE: ./node_modules/jsencrypt/lib/lib/asn1js/int10.js
// Big integer base-10 printing library
// Copyright (c) 2014 Lapo Luchini <lapo@lapo.it>
// Permission to use, copy, modify, and/or distribute this software for any
// purpose with or without fee is hereby granted, provided that the above
// copyright notice and this permission notice appear in all copies.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
/*jshint browser: true, strict: true, immed: true, latedef: true, undef: true, regexdash: false */
var max = 10000000000000; // biggest integer that can still fit 2^53 when multiplied by 256
var Int10 = /** @class */ (function () {
    function Int10(value) {
        this.buf = [+value || 0];
    }
    Int10.prototype.mulAdd = function (m, c) {
        // assert(m <= 256)
        var b = this.buf;
        var l = b.length;
        var i;
        var t;
        for (i = 0; i < l; ++i) {
            t = b[i] * m + c;
            if (t < max) {
                c = 0;
            }
            else {
                c = 0 | (t / max);
                t -= c * max;
            }
            b[i] = t;
        }
        if (c > 0) {
            b[i] = c;
        }
    };
    Int10.prototype.sub = function (c) {
        // assert(m <= 256)
        var b = this.buf;
        var l = b.length;
        var i;
        var t;
        for (i = 0; i < l; ++i) {
            t = b[i] - c;
            if (t < 0) {
                t += max;
                c = 1;
            }
            else {
                c = 0;
            }
            b[i] = t;
        }
        while (b[b.length - 1] === 0) {
            b.pop();
        }
    };
    Int10.prototype.toString = function (base) {
        if ((base || 10) != 10) {
            throw new Error("only base 10 is supported");
        }
        var b = this.buf;
        var s = b[b.length - 1].toString();
        for (var i = b.length - 2; i >= 0; --i) {
            s += (max + b[i]).toString().substring(1);
        }
        return s;
    };
    Int10.prototype.valueOf = function () {
        var b = this.buf;
        var v = 0;
        for (var i = b.length - 1; i >= 0; --i) {
            v = v * max + b[i];
        }
        return v;
    };
    Int10.prototype.simplify = function () {
        var b = this.buf;
        return (b.length == 1) ? b[0] : this;
    };
    return Int10;
}());


;// CONCATENATED MODULE: ./node_modules/jsencrypt/lib/lib/asn1js/asn1.js
// ASN.1 JavaScript decoder
// Copyright (c) 2008-2014 Lapo Luchini <lapo@lapo.it>
// Permission to use, copy, modify, and/or distribute this software for any
// purpose with or without fee is hereby granted, provided that the above
// copyright notice and this permission notice appear in all copies.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
/*jshint browser: true, strict: true, immed: true, latedef: true, undef: true, regexdash: false */
/*global oids */

var ellipsis = "\u2026";
var reTimeS = /^(\d\d)(0[1-9]|1[0-2])(0[1-9]|[12]\d|3[01])([01]\d|2[0-3])(?:([0-5]\d)(?:([0-5]\d)(?:[.,](\d{1,3}))?)?)?(Z|[-+](?:[0]\d|1[0-2])([0-5]\d)?)?$/;
var reTimeL = /^(\d\d\d\d)(0[1-9]|1[0-2])(0[1-9]|[12]\d|3[01])([01]\d|2[0-3])(?:([0-5]\d)(?:([0-5]\d)(?:[.,](\d{1,3}))?)?)?(Z|[-+](?:[0]\d|1[0-2])([0-5]\d)?)?$/;
function stringCut(str, len) {
    if (str.length > len) {
        str = str.substring(0, len) + ellipsis;
    }
    return str;
}
var Stream = /** @class */ (function () {
    function Stream(enc, pos) {
        this.hexDigits = "0123456789ABCDEF";
        if (enc instanceof Stream) {
            this.enc = enc.enc;
            this.pos = enc.pos;
        }
        else {
            // enc should be an array or a binary string
            this.enc = enc;
            this.pos = pos;
        }
    }
    Stream.prototype.get = function (pos) {
        if (pos === undefined) {
            pos = this.pos++;
        }
        if (pos >= this.enc.length) {
            throw new Error("Requesting byte offset ".concat(pos, " on a stream of length ").concat(this.enc.length));
        }
        return ("string" === typeof this.enc) ? this.enc.charCodeAt(pos) : this.enc[pos];
    };
    Stream.prototype.hexByte = function (b) {
        return this.hexDigits.charAt((b >> 4) & 0xF) + this.hexDigits.charAt(b & 0xF);
    };
    Stream.prototype.hexDump = function (start, end, raw) {
        var s = "";
        for (var i = start; i < end; ++i) {
            s += this.hexByte(this.get(i));
            if (raw !== true) {
                switch (i & 0xF) {
                    case 0x7:
                        s += "  ";
                        break;
                    case 0xF:
                        s += "\n";
                        break;
                    default:
                        s += " ";
                }
            }
        }
        return s;
    };
    Stream.prototype.isASCII = function (start, end) {
        for (var i = start; i < end; ++i) {
            var c = this.get(i);
            if (c < 32 || c > 176) {
                return false;
            }
        }
        return true;
    };
    Stream.prototype.parseStringISO = function (start, end) {
        var s = "";
        for (var i = start; i < end; ++i) {
            s += String.fromCharCode(this.get(i));
        }
        return s;
    };
    Stream.prototype.parseStringUTF = function (start, end) {
        var s = "";
        for (var i = start; i < end;) {
            var c = this.get(i++);
            if (c < 128) {
                s += String.fromCharCode(c);
            }
            else if ((c > 191) && (c < 224)) {
                s += String.fromCharCode(((c & 0x1F) << 6) | (this.get(i++) & 0x3F));
            }
            else {
                s += String.fromCharCode(((c & 0x0F) << 12) | ((this.get(i++) & 0x3F) << 6) | (this.get(i++) & 0x3F));
            }
        }
        return s;
    };
    Stream.prototype.parseStringBMP = function (start, end) {
        var str = "";
        var hi;
        var lo;
        for (var i = start; i < end;) {
            hi = this.get(i++);
            lo = this.get(i++);
            str += String.fromCharCode((hi << 8) | lo);
        }
        return str;
    };
    Stream.prototype.parseTime = function (start, end, shortYear) {
        var s = this.parseStringISO(start, end);
        var m = (shortYear ? reTimeS : reTimeL).exec(s);
        if (!m) {
            return "Unrecognized time: " + s;
        }
        if (shortYear) {
            // to avoid querying the timer, use the fixed range [1970, 2069]
            // it will conform with ITU X.400 [-10, +40] sliding window until 2030
            m[1] = +m[1];
            m[1] += (+m[1] < 70) ? 2000 : 1900;
        }
        s = m[1] + "-" + m[2] + "-" + m[3] + " " + m[4];
        if (m[5]) {
            s += ":" + m[5];
            if (m[6]) {
                s += ":" + m[6];
                if (m[7]) {
                    s += "." + m[7];
                }
            }
        }
        if (m[8]) {
            s += " UTC";
            if (m[8] != "Z") {
                s += m[8];
                if (m[9]) {
                    s += ":" + m[9];
                }
            }
        }
        return s;
    };
    Stream.prototype.parseInteger = function (start, end) {
        var v = this.get(start);
        var neg = (v > 127);
        var pad = neg ? 255 : 0;
        var len;
        var s = "";
        // skip unuseful bits (not allowed in DER)
        while (v == pad && ++start < end) {
            v = this.get(start);
        }
        len = end - start;
        if (len === 0) {
            return neg ? -1 : 0;
        }
        // show bit length of huge integers
        if (len > 4) {
            s = v;
            len <<= 3;
            while (((+s ^ pad) & 0x80) == 0) {
                s = +s << 1;
                --len;
            }
            s = "(" + len + " bit)\n";
        }
        // decode the integer
        if (neg) {
            v = v - 256;
        }
        var n = new Int10(v);
        for (var i = start + 1; i < end; ++i) {
            n.mulAdd(256, this.get(i));
        }
        return s + n.toString();
    };
    Stream.prototype.parseBitString = function (start, end, maxLength) {
        var unusedBit = this.get(start);
        var lenBit = ((end - start - 1) << 3) - unusedBit;
        var intro = "(" + lenBit + " bit)\n";
        var s = "";
        for (var i = start + 1; i < end; ++i) {
            var b = this.get(i);
            var skip = (i == end - 1) ? unusedBit : 0;
            for (var j = 7; j >= skip; --j) {
                s += (b >> j) & 1 ? "1" : "0";
            }
            if (s.length > maxLength) {
                return intro + stringCut(s, maxLength);
            }
        }
        return intro + s;
    };
    Stream.prototype.parseOctetString = function (start, end, maxLength) {
        if (this.isASCII(start, end)) {
            return stringCut(this.parseStringISO(start, end), maxLength);
        }
        var len = end - start;
        var s = "(" + len + " byte)\n";
        maxLength /= 2; // we work in bytes
        if (len > maxLength) {
            end = start + maxLength;
        }
        for (var i = start; i < end; ++i) {
            s += this.hexByte(this.get(i));
        }
        if (len > maxLength) {
            s += ellipsis;
        }
        return s;
    };
    Stream.prototype.parseOID = function (start, end, maxLength) {
        var s = "";
        var n = new Int10();
        var bits = 0;
        for (var i = start; i < end; ++i) {
            var v = this.get(i);
            n.mulAdd(128, v & 0x7F);
            bits += 7;
            if (!(v & 0x80)) { // finished
                if (s === "") {
                    n = n.simplify();
                    if (n instanceof Int10) {
                        n.sub(80);
                        s = "2." + n.toString();
                    }
                    else {
                        var m = n < 80 ? n < 40 ? 0 : 1 : 2;
                        s = m + "." + (n - m * 40);
                    }
                }
                else {
                    s += "." + n.toString();
                }
                if (s.length > maxLength) {
                    return stringCut(s, maxLength);
                }
                n = new Int10();
                bits = 0;
            }
        }
        if (bits > 0) {
            s += ".incomplete";
        }
        return s;
    };
    return Stream;
}());

var ASN1 = /** @class */ (function () {
    function ASN1(stream, header, length, tag, sub) {
        if (!(tag instanceof ASN1Tag)) {
            throw new Error("Invalid tag value.");
        }
        this.stream = stream;
        this.header = header;
        this.length = length;
        this.tag = tag;
        this.sub = sub;
    }
    ASN1.prototype.typeName = function () {
        switch (this.tag.tagClass) {
            case 0: // universal
                switch (this.tag.tagNumber) {
                    case 0x00:
                        return "EOC";
                    case 0x01:
                        return "BOOLEAN";
                    case 0x02:
                        return "INTEGER";
                    case 0x03:
                        return "BIT_STRING";
                    case 0x04:
                        return "OCTET_STRING";
                    case 0x05:
                        return "NULL";
                    case 0x06:
                        return "OBJECT_IDENTIFIER";
                    case 0x07:
                        return "ObjectDescriptor";
                    case 0x08:
                        return "EXTERNAL";
                    case 0x09:
                        return "REAL";
                    case 0x0A:
                        return "ENUMERATED";
                    case 0x0B:
                        return "EMBEDDED_PDV";
                    case 0x0C:
                        return "UTF8String";
                    case 0x10:
                        return "SEQUENCE";
                    case 0x11:
                        return "SET";
                    case 0x12:
                        return "NumericString";
                    case 0x13:
                        return "PrintableString"; // ASCII subset
                    case 0x14:
                        return "TeletexString"; // aka T61String
                    case 0x15:
                        return "VideotexString";
                    case 0x16:
                        return "IA5String"; // ASCII
                    case 0x17:
                        return "UTCTime";
                    case 0x18:
                        return "GeneralizedTime";
                    case 0x19:
                        return "GraphicString";
                    case 0x1A:
                        return "VisibleString"; // ASCII subset
                    case 0x1B:
                        return "GeneralString";
                    case 0x1C:
                        return "UniversalString";
                    case 0x1E:
                        return "BMPString";
                }
                return "Universal_" + this.tag.tagNumber.toString();
            case 1:
                return "Application_" + this.tag.tagNumber.toString();
            case 2:
                return "[" + this.tag.tagNumber.toString() + "]"; // Context
            case 3:
                return "Private_" + this.tag.tagNumber.toString();
        }
    };
    ASN1.prototype.content = function (maxLength) {
        if (this.tag === undefined) {
            return null;
        }
        if (maxLength === undefined) {
            maxLength = Infinity;
        }
        var content = this.posContent();
        var len = Math.abs(this.length);
        if (!this.tag.isUniversal()) {
            if (this.sub !== null) {
                return "(" + this.sub.length + " elem)";
            }
            return this.stream.parseOctetString(content, content + len, maxLength);
        }
        switch (this.tag.tagNumber) {
            case 0x01: // BOOLEAN
                return (this.stream.get(content) === 0) ? "false" : "true";
            case 0x02: // INTEGER
                return this.stream.parseInteger(content, content + len);
            case 0x03: // BIT_STRING
                return this.sub ? "(" + this.sub.length + " elem)" :
                    this.stream.parseBitString(content, content + len, maxLength);
            case 0x04: // OCTET_STRING
                return this.sub ? "(" + this.sub.length + " elem)" :
                    this.stream.parseOctetString(content, content + len, maxLength);
            // case 0x05: // NULL
            case 0x06: // OBJECT_IDENTIFIER
                return this.stream.parseOID(content, content + len, maxLength);
            // case 0x07: // ObjectDescriptor
            // case 0x08: // EXTERNAL
            // case 0x09: // REAL
            // case 0x0A: // ENUMERATED
            // case 0x0B: // EMBEDDED_PDV
            case 0x10: // SEQUENCE
            case 0x11: // SET
                if (this.sub !== null) {
                    return "(" + this.sub.length + " elem)";
                }
                else {
                    return "(no elem)";
                }
            case 0x0C: // UTF8String
                return stringCut(this.stream.parseStringUTF(content, content + len), maxLength);
            case 0x12: // NumericString
            case 0x13: // PrintableString
            case 0x14: // TeletexString
            case 0x15: // VideotexString
            case 0x16: // IA5String
            // case 0x19: // GraphicString
            case 0x1A: // VisibleString
                // case 0x1B: // GeneralString
                // case 0x1C: // UniversalString
                return stringCut(this.stream.parseStringISO(content, content + len), maxLength);
            case 0x1E: // BMPString
                return stringCut(this.stream.parseStringBMP(content, content + len), maxLength);
            case 0x17: // UTCTime
            case 0x18: // GeneralizedTime
                return this.stream.parseTime(content, content + len, (this.tag.tagNumber == 0x17));
        }
        return null;
    };
    ASN1.prototype.toString = function () {
        return this.typeName() + "@" + this.stream.pos + "[header:" + this.header + ",length:" + this.length + ",sub:" + ((this.sub === null) ? "null" : this.sub.length) + "]";
    };
    ASN1.prototype.toPrettyString = function (indent) {
        if (indent === undefined) {
            indent = "";
        }
        var s = indent + this.typeName() + " @" + this.stream.pos;
        if (this.length >= 0) {
            s += "+";
        }
        s += this.length;
        if (this.tag.tagConstructed) {
            s += " (constructed)";
        }
        else if ((this.tag.isUniversal() && ((this.tag.tagNumber == 0x03) || (this.tag.tagNumber == 0x04))) && (this.sub !== null)) {
            s += " (encapsulates)";
        }
        s += "\n";
        if (this.sub !== null) {
            indent += "  ";
            for (var i = 0, max = this.sub.length; i < max; ++i) {
                s += this.sub[i].toPrettyString(indent);
            }
        }
        return s;
    };
    ASN1.prototype.posStart = function () {
        return this.stream.pos;
    };
    ASN1.prototype.posContent = function () {
        return this.stream.pos + this.header;
    };
    ASN1.prototype.posEnd = function () {
        return this.stream.pos + this.header + Math.abs(this.length);
    };
    ASN1.prototype.toHexString = function () {
        return this.stream.hexDump(this.posStart(), this.posEnd(), true);
    };
    ASN1.decodeLength = function (stream) {
        var buf = stream.get();
        var len = buf & 0x7F;
        if (len == buf) {
            return len;
        }
        // no reason to use Int10, as it would be a huge buffer anyways
        if (len > 6) {
            throw new Error("Length over 48 bits not supported at position " + (stream.pos - 1));
        }
        if (len === 0) {
            return null;
        } // undefined
        buf = 0;
        for (var i = 0; i < len; ++i) {
            buf = (buf * 256) + stream.get();
        }
        return buf;
    };
    /**
     * Retrieve the hexadecimal value (as a string) of the current ASN.1 element
     * @returns {string}
     * @public
     */
    ASN1.prototype.getHexStringValue = function () {
        var hexString = this.toHexString();
        var offset = this.header * 2;
        var length = this.length * 2;
        return hexString.substr(offset, length);
    };
    ASN1.decode = function (str) {
        var stream;
        if (!(str instanceof Stream)) {
            stream = new Stream(str, 0);
        }
        else {
            stream = str;
        }
        var streamStart = new Stream(stream);
        var tag = new ASN1Tag(stream);
        var len = ASN1.decodeLength(stream);
        var start = stream.pos;
        var header = start - streamStart.pos;
        var sub = null;
        var getSub = function () {
            var ret = [];
            if (len !== null) {
                // definite length
                var end = start + len;
                while (stream.pos < end) {
                    ret[ret.length] = ASN1.decode(stream);
                }
                if (stream.pos != end) {
                    throw new Error("Content size is not correct for container starting at offset " + start);
                }
            }
            else {
                // undefined length
                try {
                    for (;;) {
                        var s = ASN1.decode(stream);
                        if (s.tag.isEOC()) {
                            break;
                        }
                        ret[ret.length] = s;
                    }
                    len = start - stream.pos; // undefined lengths are represented as negative values
                }
                catch (e) {
                    throw new Error("Exception while decoding undefined length content: " + e);
                }
            }
            return ret;
        };
        if (tag.tagConstructed) {
            // must have valid content
            sub = getSub();
        }
        else if (tag.isUniversal() && ((tag.tagNumber == 0x03) || (tag.tagNumber == 0x04))) {
            // sometimes BitString and OctetString are used to encapsulate ASN.1
            try {
                if (tag.tagNumber == 0x03) {
                    if (stream.get() != 0) {
                        throw new Error("BIT STRINGs with unused bits cannot encapsulate.");
                    }
                }
                sub = getSub();
                for (var i = 0; i < sub.length; ++i) {
                    if (sub[i].tag.isEOC()) {
                        throw new Error("EOC is not supposed to be actual content.");
                    }
                }
            }
            catch (e) {
                // but silently ignore when they don't
                sub = null;
            }
        }
        if (sub === null) {
            if (len === null) {
                throw new Error("We can't skip over an invalid tag with undefined length at offset " + start);
            }
            stream.pos = start + Math.abs(len);
        }
        return new ASN1(streamStart, header, len, tag, sub);
    };
    return ASN1;
}());

var ASN1Tag = /** @class */ (function () {
    function ASN1Tag(stream) {
        var buf = stream.get();
        this.tagClass = buf >> 6;
        this.tagConstructed = ((buf & 0x20) !== 0);
        this.tagNumber = buf & 0x1F;
        if (this.tagNumber == 0x1F) { // long tag
            var n = new Int10();
            do {
                buf = stream.get();
                n.mulAdd(128, buf & 0x7F);
            } while (buf & 0x80);
            this.tagNumber = n.simplify();
        }
    }
    ASN1Tag.prototype.isUniversal = function () {
        return this.tagClass === 0x00;
    };
    ASN1Tag.prototype.isEOC = function () {
        return this.tagClass === 0x00 && this.tagNumber === 0x00;
    };
    return ASN1Tag;
}());


;// CONCATENATED MODULE: ./node_modules/jsencrypt/lib/lib/jsbn/jsbn.js
// Copyright (c) 2005  Tom Wu
// All Rights Reserved.
// See "LICENSE" for details.
// Basic JavaScript BN library - subset useful for RSA encryption.

// Bits per digit
var dbits;
// JavaScript engine analysis
var canary = 0xdeadbeefcafe;
var j_lm = ((canary & 0xffffff) == 0xefcafe);
//#region
var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];
var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];
//#endregion
// (public) Constructor
var BigInteger = /** @class */ (function () {
    function BigInteger(a, b, c) {
        if (a != null) {
            if ("number" == typeof a) {
                this.fromNumber(a, b, c);
            }
            else if (b == null && "string" != typeof a) {
                this.fromString(a, 256);
            }
            else {
                this.fromString(a, b);
            }
        }
    }
    //#region PUBLIC
    // BigInteger.prototype.toString = bnToString;
    // (public) return string representation in given radix
    BigInteger.prototype.toString = function (b) {
        if (this.s < 0) {
            return "-" + this.negate().toString(b);
        }
        var k;
        if (b == 16) {
            k = 4;
        }
        else if (b == 8) {
            k = 3;
        }
        else if (b == 2) {
            k = 1;
        }
        else if (b == 32) {
            k = 5;
        }
        else if (b == 4) {
            k = 2;
        }
        else {
            return this.toRadix(b);
        }
        var km = (1 << k) - 1;
        var d;
        var m = false;
        var r = "";
        var i = this.t;
        var p = this.DB - (i * this.DB) % k;
        if (i-- > 0) {
            if (p < this.DB && (d = this[i] >> p) > 0) {
                m = true;
                r = int2char(d);
            }
            while (i >= 0) {
                if (p < k) {
                    d = (this[i] & ((1 << p) - 1)) << (k - p);
                    d |= this[--i] >> (p += this.DB - k);
                }
                else {
                    d = (this[i] >> (p -= k)) & km;
                    if (p <= 0) {
                        p += this.DB;
                        --i;
                    }
                }
                if (d > 0) {
                    m = true;
                }
                if (m) {
                    r += int2char(d);
                }
            }
        }
        return m ? r : "0";
    };
    // BigInteger.prototype.negate = bnNegate;
    // (public) -this
    BigInteger.prototype.negate = function () {
        var r = nbi();
        BigInteger.ZERO.subTo(this, r);
        return r;
    };
    // BigInteger.prototype.abs = bnAbs;
    // (public) |this|
    BigInteger.prototype.abs = function () {
        return (this.s < 0) ? this.negate() : this;
    };
    // BigInteger.prototype.compareTo = bnCompareTo;
    // (public) return + if this > a, - if this < a, 0 if equal
    BigInteger.prototype.compareTo = function (a) {
        var r = this.s - a.s;
        if (r != 0) {
            return r;
        }
        var i = this.t;
        r = i - a.t;
        if (r != 0) {
            return (this.s < 0) ? -r : r;
        }
        while (--i >= 0) {
            if ((r = this[i] - a[i]) != 0) {
                return r;
            }
        }
        return 0;
    };
    // BigInteger.prototype.bitLength = bnBitLength;
    // (public) return the number of bits in "this"
    BigInteger.prototype.bitLength = function () {
        if (this.t <= 0) {
            return 0;
        }
        return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ (this.s & this.DM));
    };
    // BigInteger.prototype.mod = bnMod;
    // (public) this mod a
    BigInteger.prototype.mod = function (a) {
        var r = nbi();
        this.abs().divRemTo(a, null, r);
        if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) {
            a.subTo(r, r);
        }
        return r;
    };
    // BigInteger.prototype.modPowInt = bnModPowInt;
    // (public) this^e % m, 0 <= e < 2^32
    BigInteger.prototype.modPowInt = function (e, m) {
        var z;
        if (e < 256 || m.isEven()) {
            z = new Classic(m);
        }
        else {
            z = new Montgomery(m);
        }
        return this.exp(e, z);
    };
    // BigInteger.prototype.clone = bnClone;
    // (public)
    BigInteger.prototype.clone = function () {
        var r = nbi();
        this.copyTo(r);
        return r;
    };
    // BigInteger.prototype.intValue = bnIntValue;
    // (public) return value as integer
    BigInteger.prototype.intValue = function () {
        if (this.s < 0) {
            if (this.t == 1) {
                return this[0] - this.DV;
            }
            else if (this.t == 0) {
                return -1;
            }
        }
        else if (this.t == 1) {
            return this[0];
        }
        else if (this.t == 0) {
            return 0;
        }
        // assumes 16 < DB < 32
        return ((this[1] & ((1 << (32 - this.DB)) - 1)) << this.DB) | this[0];
    };
    // BigInteger.prototype.byteValue = bnByteValue;
    // (public) return value as byte
    BigInteger.prototype.byteValue = function () {
        return (this.t == 0) ? this.s : (this[0] << 24) >> 24;
    };
    // BigInteger.prototype.shortValue = bnShortValue;
    // (public) return value as short (assumes DB>=16)
    BigInteger.prototype.shortValue = function () {
        return (this.t == 0) ? this.s : (this[0] << 16) >> 16;
    };
    // BigInteger.prototype.signum = bnSigNum;
    // (public) 0 if this == 0, 1 if this > 0
    BigInteger.prototype.signum = function () {
        if (this.s < 0) {
            return -1;
        }
        else if (this.t <= 0 || (this.t == 1 && this[0] <= 0)) {
            return 0;
        }
        else {
            return 1;
        }
    };
    // BigInteger.prototype.toByteArray = bnToByteArray;
    // (public) convert to bigendian byte array
    BigInteger.prototype.toByteArray = function () {
        var i = this.t;
        var r = [];
        r[0] = this.s;
        var p = this.DB - (i * this.DB) % 8;
        var d;
        var k = 0;
        if (i-- > 0) {
            if (p < this.DB && (d = this[i] >> p) != (this.s & this.DM) >> p) {
                r[k++] = d | (this.s << (this.DB - p));
            }
            while (i >= 0) {
                if (p < 8) {
                    d = (this[i] & ((1 << p) - 1)) << (8 - p);
                    d |= this[--i] >> (p += this.DB - 8);
                }
                else {
                    d = (this[i] >> (p -= 8)) & 0xff;
                    if (p <= 0) {
                        p += this.DB;
                        --i;
                    }
                }
                if ((d & 0x80) != 0) {
                    d |= -256;
                }
                if (k == 0 && (this.s & 0x80) != (d & 0x80)) {
                    ++k;
                }
                if (k > 0 || d != this.s) {
                    r[k++] = d;
                }
            }
        }
        return r;
    };
    // BigInteger.prototype.equals = bnEquals;
    BigInteger.prototype.equals = function (a) {
        return (this.compareTo(a) == 0);
    };
    // BigInteger.prototype.min = bnMin;
    BigInteger.prototype.min = function (a) {
        return (this.compareTo(a) < 0) ? this : a;
    };
    // BigInteger.prototype.max = bnMax;
    BigInteger.prototype.max = function (a) {
        return (this.compareTo(a) > 0) ? this : a;
    };
    // BigInteger.prototype.and = bnAnd;
    BigInteger.prototype.and = function (a) {
        var r = nbi();
        this.bitwiseTo(a, op_and, r);
        return r;
    };
    // BigInteger.prototype.or = bnOr;
    BigInteger.prototype.or = function (a) {
        var r = nbi();
        this.bitwiseTo(a, op_or, r);
        return r;
    };
    // BigInteger.prototype.xor = bnXor;
    BigInteger.prototype.xor = function (a) {
        var r = nbi();
        this.bitwiseTo(a, op_xor, r);
        return r;
    };
    // BigInteger.prototype.andNot = bnAndNot;
    BigInteger.prototype.andNot = function (a) {
        var r = nbi();
        this.bitwiseTo(a, op_andnot, r);
        return r;
    };
    // BigInteger.prototype.not = bnNot;
    // (public) ~this
    BigInteger.prototype.not = function () {
        var r = nbi();
        for (var i = 0; i < this.t; ++i) {
            r[i] = this.DM & ~this[i];
        }
        r.t = this.t;
        r.s = ~this.s;
        return r;
    };
    // BigInteger.prototype.shiftLeft = bnShiftLeft;
    // (public) this << n
    BigInteger.prototype.shiftLeft = function (n) {
        var r = nbi();
        if (n < 0) {
            this.rShiftTo(-n, r);
        }
        else {
            this.lShiftTo(n, r);
        }
        return r;
    };
    // BigInteger.prototype.shiftRight = bnShiftRight;
    // (public) this >> n
    BigInteger.prototype.shiftRight = function (n) {
        var r = nbi();
        if (n < 0) {
            this.lShiftTo(-n, r);
        }
        else {
            this.rShiftTo(n, r);
        }
        return r;
    };
    // BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
    // (public) returns index of lowest 1-bit (or -1 if none)
    BigInteger.prototype.getLowestSetBit = function () {
        for (var i = 0; i < this.t; ++i) {
            if (this[i] != 0) {
                return i * this.DB + lbit(this[i]);
            }
        }
        if (this.s < 0) {
            return this.t * this.DB;
        }
        return -1;
    };
    // BigInteger.prototype.bitCount = bnBitCount;
    // (public) return number of set bits
    BigInteger.prototype.bitCount = function () {
        var r = 0;
        var x = this.s & this.DM;
        for (var i = 0; i < this.t; ++i) {
            r += cbit(this[i] ^ x);
        }
        return r;
    };
    // BigInteger.prototype.testBit = bnTestBit;
    // (public) true iff nth bit is set
    BigInteger.prototype.testBit = function (n) {
        var j = Math.floor(n / this.DB);
        if (j >= this.t) {
            return (this.s != 0);
        }
        return ((this[j] & (1 << (n % this.DB))) != 0);
    };
    // BigInteger.prototype.setBit = bnSetBit;
    // (public) this | (1<<n)
    BigInteger.prototype.setBit = function (n) {
        return this.changeBit(n, op_or);
    };
    // BigInteger.prototype.clearBit = bnClearBit;
    // (public) this & ~(1<<n)
    BigInteger.prototype.clearBit = function (n) {
        return this.changeBit(n, op_andnot);
    };
    // BigInteger.prototype.flipBit = bnFlipBit;
    // (public) this ^ (1<<n)
    BigInteger.prototype.flipBit = function (n) {
        return this.changeBit(n, op_xor);
    };
    // BigInteger.prototype.add = bnAdd;
    // (public) this + a
    BigInteger.prototype.add = function (a) {
        var r = nbi();
        this.addTo(a, r);
        return r;
    };
    // BigInteger.prototype.subtract = bnSubtract;
    // (public) this - a
    BigInteger.prototype.subtract = function (a) {
        var r = nbi();
        this.subTo(a, r);
        return r;
    };
    // BigInteger.prototype.multiply = bnMultiply;
    // (public) this * a
    BigInteger.prototype.multiply = function (a) {
        var r = nbi();
        this.multiplyTo(a, r);
        return r;
    };
    // BigInteger.prototype.divide = bnDivide;
    // (public) this / a
    BigInteger.prototype.divide = function (a) {
        var r = nbi();
        this.divRemTo(a, r, null);
        return r;
    };
    // BigInteger.prototype.remainder = bnRemainder;
    // (public) this % a
    BigInteger.prototype.remainder = function (a) {
        var r = nbi();
        this.divRemTo(a, null, r);
        return r;
    };
    // BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
    // (public) [this/a,this%a]
    BigInteger.prototype.divideAndRemainder = function (a) {
        var q = nbi();
        var r = nbi();
        this.divRemTo(a, q, r);
        return [q, r];
    };
    // BigInteger.prototype.modPow = bnModPow;
    // (public) this^e % m (HAC 14.85)
    BigInteger.prototype.modPow = function (e, m) {
        var i = e.bitLength();
        var k;
        var r = nbv(1);
        var z;
        if (i <= 0) {
            return r;
        }
        else if (i < 18) {
            k = 1;
        }
        else if (i < 48) {
            k = 3;
        }
        else if (i < 144) {
            k = 4;
        }
        else if (i < 768) {
            k = 5;
        }
        else {
            k = 6;
        }
        if (i < 8) {
            z = new Classic(m);
        }
        else if (m.isEven()) {
            z = new Barrett(m);
        }
        else {
            z = new Montgomery(m);
        }
        // precomputation
        var g = [];
        var n = 3;
        var k1 = k - 1;
        var km = (1 << k) - 1;
        g[1] = z.convert(this);
        if (k > 1) {
            var g2 = nbi();
            z.sqrTo(g[1], g2);
            while (n <= km) {
                g[n] = nbi();
                z.mulTo(g2, g[n - 2], g[n]);
                n += 2;
            }
        }
        var j = e.t - 1;
        var w;
        var is1 = true;
        var r2 = nbi();
        var t;
        i = nbits(e[j]) - 1;
        while (j >= 0) {
            if (i >= k1) {
                w = (e[j] >> (i - k1)) & km;
            }
            else {
                w = (e[j] & ((1 << (i + 1)) - 1)) << (k1 - i);
                if (j > 0) {
                    w |= e[j - 1] >> (this.DB + i - k1);
                }
            }
            n = k;
            while ((w & 1) == 0) {
                w >>= 1;
                --n;
            }
            if ((i -= n) < 0) {
                i += this.DB;
                --j;
            }
            if (is1) { // ret == 1, don't bother squaring or multiplying it
                g[w].copyTo(r);
                is1 = false;
            }
            else {
                while (n > 1) {
                    z.sqrTo(r, r2);
                    z.sqrTo(r2, r);
                    n -= 2;
                }
                if (n > 0) {
                    z.sqrTo(r, r2);
                }
                else {
                    t = r;
                    r = r2;
                    r2 = t;
                }
                z.mulTo(r2, g[w], r);
            }
            while (j >= 0 && (e[j] & (1 << i)) == 0) {
                z.sqrTo(r, r2);
                t = r;
                r = r2;
                r2 = t;
                if (--i < 0) {
                    i = this.DB - 1;
                    --j;
                }
            }
        }
        return z.revert(r);
    };
    // BigInteger.prototype.modInverse = bnModInverse;
    // (public) 1/this % m (HAC 14.61)
    BigInteger.prototype.modInverse = function (m) {
        var ac = m.isEven();
        if ((this.isEven() && ac) || m.signum() == 0) {
            return BigInteger.ZERO;
        }
        var u = m.clone();
        var v = this.clone();
        var a = nbv(1);
        var b = nbv(0);
        var c = nbv(0);
        var d = nbv(1);
        while (u.signum() != 0) {
            while (u.isEven()) {
                u.rShiftTo(1, u);
                if (ac) {
                    if (!a.isEven() || !b.isEven()) {
                        a.addTo(this, a);
                        b.subTo(m, b);
                    }
                    a.rShiftTo(1, a);
                }
                else if (!b.isEven()) {
                    b.subTo(m, b);
                }
                b.rShiftTo(1, b);
            }
            while (v.isEven()) {
                v.rShiftTo(1, v);
                if (ac) {
                    if (!c.isEven() || !d.isEven()) {
                        c.addTo(this, c);
                        d.subTo(m, d);
                    }
                    c.rShiftTo(1, c);
                }
                else if (!d.isEven()) {
                    d.subTo(m, d);
                }
                d.rShiftTo(1, d);
            }
            if (u.compareTo(v) >= 0) {
                u.subTo(v, u);
                if (ac) {
                    a.subTo(c, a);
                }
                b.subTo(d, b);
            }
            else {
                v.subTo(u, v);
                if (ac) {
                    c.subTo(a, c);
                }
                d.subTo(b, d);
            }
        }
        if (v.compareTo(BigInteger.ONE) != 0) {
            return BigInteger.ZERO;
        }
        if (d.compareTo(m) >= 0) {
            return d.subtract(m);
        }
        if (d.signum() < 0) {
            d.addTo(m, d);
        }
        else {
            return d;
        }
        if (d.signum() < 0) {
            return d.add(m);
        }
        else {
            return d;
        }
    };
    // BigInteger.prototype.pow = bnPow;
    // (public) this^e
    BigInteger.prototype.pow = function (e) {
        return this.exp(e, new NullExp());
    };
    // BigInteger.prototype.gcd = bnGCD;
    // (public) gcd(this,a) (HAC 14.54)
    BigInteger.prototype.gcd = function (a) {
        var x = (this.s < 0) ? this.negate() : this.clone();
        var y = (a.s < 0) ? a.negate() : a.clone();
        if (x.compareTo(y) < 0) {
            var t = x;
            x = y;
            y = t;
        }
        var i = x.getLowestSetBit();
        var g = y.getLowestSetBit();
        if (g < 0) {
            return x;
        }
        if (i < g) {
            g = i;
        }
        if (g > 0) {
            x.rShiftTo(g, x);
            y.rShiftTo(g, y);
        }
        while (x.signum() > 0) {
            if ((i = x.getLowestSetBit()) > 0) {
                x.rShiftTo(i, x);
            }
            if ((i = y.getLowestSetBit()) > 0) {
                y.rShiftTo(i, y);
            }
            if (x.compareTo(y) >= 0) {
                x.subTo(y, x);
                x.rShiftTo(1, x);
            }
            else {
                y.subTo(x, y);
                y.rShiftTo(1, y);
            }
        }
        if (g > 0) {
            y.lShiftTo(g, y);
        }
        return y;
    };
    // BigInteger.prototype.isProbablePrime = bnIsProbablePrime;
    // (public) test primality with certainty >= 1-.5^t
    BigInteger.prototype.isProbablePrime = function (t) {
        var i;
        var x = this.abs();
        if (x.t == 1 && x[0] <= lowprimes[lowprimes.length - 1]) {
            for (i = 0; i < lowprimes.length; ++i) {
                if (x[0] == lowprimes[i]) {
                    return true;
                }
            }
            return false;
        }
        if (x.isEven()) {
            return false;
        }
        i = 1;
        while (i < lowprimes.length) {
            var m = lowprimes[i];
            var j = i + 1;
            while (j < lowprimes.length && m < lplim) {
                m *= lowprimes[j++];
            }
            m = x.modInt(m);
            while (i < j) {
                if (m % lowprimes[i++] == 0) {
                    return false;
                }
            }
        }
        return x.millerRabin(t);
    };
    //#endregion PUBLIC
    //#region PROTECTED
    // BigInteger.prototype.copyTo = bnpCopyTo;
    // (protected) copy this to r
    BigInteger.prototype.copyTo = function (r) {
        for (var i = this.t - 1; i >= 0; --i) {
            r[i] = this[i];
        }
        r.t = this.t;
        r.s = this.s;
    };
    // BigInteger.prototype.fromInt = bnpFromInt;
    // (protected) set from integer value x, -DV <= x < DV
    BigInteger.prototype.fromInt = function (x) {
        this.t = 1;
        this.s = (x < 0) ? -1 : 0;
        if (x > 0) {
            this[0] = x;
        }
        else if (x < -1) {
            this[0] = x + this.DV;
        }
        else {
            this.t = 0;
        }
    };
    // BigInteger.prototype.fromString = bnpFromString;
    // (protected) set from string and radix
    BigInteger.prototype.fromString = function (s, b) {
        var k;
        if (b == 16) {
            k = 4;
        }
        else if (b == 8) {
            k = 3;
        }
        else if (b == 256) {
            k = 8;
            /* byte array */
        }
        else if (b == 2) {
            k = 1;
        }
        else if (b == 32) {
            k = 5;
        }
        else if (b == 4) {
            k = 2;
        }
        else {
            this.fromRadix(s, b);
            return;
        }
        this.t = 0;
        this.s = 0;
        var i = s.length;
        var mi = false;
        var sh = 0;
        while (--i >= 0) {
            var x = (k == 8) ? (+s[i]) & 0xff : intAt(s, i);
            if (x < 0) {
                if (s.charAt(i) == "-") {
                    mi = true;
                }
                continue;
            }
            mi = false;
            if (sh == 0) {
                this[this.t++] = x;
            }
            else if (sh + k > this.DB) {
                this[this.t - 1] |= (x & ((1 << (this.DB - sh)) - 1)) << sh;
                this[this.t++] = (x >> (this.DB - sh));
            }
            else {
                this[this.t - 1] |= x << sh;
            }
            sh += k;
            if (sh >= this.DB) {
                sh -= this.DB;
            }
        }
        if (k == 8 && ((+s[0]) & 0x80) != 0) {
            this.s = -1;
            if (sh > 0) {
                this[this.t - 1] |= ((1 << (this.DB - sh)) - 1) << sh;
            }
        }
        this.clamp();
        if (mi) {
            BigInteger.ZERO.subTo(this, this);
        }
    };
    // BigInteger.prototype.clamp = bnpClamp;
    // (protected) clamp off excess high words
    BigInteger.prototype.clamp = function () {
        var c = this.s & this.DM;
        while (this.t > 0 && this[this.t - 1] == c) {
            --this.t;
        }
    };
    // BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
    // (protected) r = this << n*DB
    BigInteger.prototype.dlShiftTo = function (n, r) {
        var i;
        for (i = this.t - 1; i >= 0; --i) {
            r[i + n] = this[i];
        }
        for (i = n - 1; i >= 0; --i) {
            r[i] = 0;
        }
        r.t = this.t + n;
        r.s = this.s;
    };
    // BigInteger.prototype.drShiftTo = bnpDRShiftTo;
    // (protected) r = this >> n*DB
    BigInteger.prototype.drShiftTo = function (n, r) {
        for (var i = n; i < this.t; ++i) {
            r[i - n] = this[i];
        }
        r.t = Math.max(this.t - n, 0);
        r.s = this.s;
    };
    // BigInteger.prototype.lShiftTo = bnpLShiftTo;
    // (protected) r = this << n
    BigInteger.prototype.lShiftTo = function (n, r) {
        var bs = n % this.DB;
        var cbs = this.DB - bs;
        var bm = (1 << cbs) - 1;
        var ds = Math.floor(n / this.DB);
        var c = (this.s << bs) & this.DM;
        for (var i = this.t - 1; i >= 0; --i) {
            r[i + ds + 1] = (this[i] >> cbs) | c;
            c = (this[i] & bm) << bs;
        }
        for (var i = ds - 1; i >= 0; --i) {
            r[i] = 0;
        }
        r[ds] = c;
        r.t = this.t + ds + 1;
        r.s = this.s;
        r.clamp();
    };
    // BigInteger.prototype.rShiftTo = bnpRShiftTo;
    // (protected) r = this >> n
    BigInteger.prototype.rShiftTo = function (n, r) {
        r.s = this.s;
        var ds = Math.floor(n / this.DB);
        if (ds >= this.t) {
            r.t = 0;
            return;
        }
        var bs = n % this.DB;
        var cbs = this.DB - bs;
        var bm = (1 << bs) - 1;
        r[0] = this[ds] >> bs;
        for (var i = ds + 1; i < this.t; ++i) {
            r[i - ds - 1] |= (this[i] & bm) << cbs;
            r[i - ds] = this[i] >> bs;
        }
        if (bs > 0) {
            r[this.t - ds - 1] |= (this.s & bm) << cbs;
        }
        r.t = this.t - ds;
        r.clamp();
    };
    // BigInteger.prototype.subTo = bnpSubTo;
    // (protected) r = this - a
    BigInteger.prototype.subTo = function (a, r) {
        var i = 0;
        var c = 0;
        var m = Math.min(a.t, this.t);
        while (i < m) {
            c += this[i] - a[i];
            r[i++] = c & this.DM;
            c >>= this.DB;
        }
        if (a.t < this.t) {
            c -= a.s;
            while (i < this.t) {
                c += this[i];
                r[i++] = c & this.DM;
                c >>= this.DB;
            }
            c += this.s;
        }
        else {
            c += this.s;
            while (i < a.t) {
                c -= a[i];
                r[i++] = c & this.DM;
                c >>= this.DB;
            }
            c -= a.s;
        }
        r.s = (c < 0) ? -1 : 0;
        if (c < -1) {
            r[i++] = this.DV + c;
        }
        else if (c > 0) {
            r[i++] = c;
        }
        r.t = i;
        r.clamp();
    };
    // BigInteger.prototype.multiplyTo = bnpMultiplyTo;
    // (protected) r = this * a, r != this,a (HAC 14.12)
    // "this" should be the larger one if appropriate.
    BigInteger.prototype.multiplyTo = function (a, r) {
        var x = this.abs();
        var y = a.abs();
        var i = x.t;
        r.t = i + y.t;
        while (--i >= 0) {
            r[i] = 0;
        }
        for (i = 0; i < y.t; ++i) {
            r[i + x.t] = x.am(0, y[i], r, i, 0, x.t);
        }
        r.s = 0;
        r.clamp();
        if (this.s != a.s) {
            BigInteger.ZERO.subTo(r, r);
        }
    };
    // BigInteger.prototype.squareTo = bnpSquareTo;
    // (protected) r = this^2, r != this (HAC 14.16)
    BigInteger.prototype.squareTo = function (r) {
        var x = this.abs();
        var i = r.t = 2 * x.t;
        while (--i >= 0) {
            r[i] = 0;
        }
        for (i = 0; i < x.t - 1; ++i) {
            var c = x.am(i, x[i], r, 2 * i, 0, 1);
            if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {
                r[i + x.t] -= x.DV;
                r[i + x.t + 1] = 1;
            }
        }
        if (r.t > 0) {
            r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1);
        }
        r.s = 0;
        r.clamp();
    };
    // BigInteger.prototype.divRemTo = bnpDivRemTo;
    // (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)
    // r != q, this != m.  q or r may be null.
    BigInteger.prototype.divRemTo = function (m, q, r) {
        var pm = m.abs();
        if (pm.t <= 0) {
            return;
        }
        var pt = this.abs();
        if (pt.t < pm.t) {
            if (q != null) {
                q.fromInt(0);
            }
            if (r != null) {
                this.copyTo(r);
            }
            return;
        }
        if (r == null) {
            r = nbi();
        }
        var y = nbi();
        var ts = this.s;
        var ms = m.s;
        var nsh = this.DB - nbits(pm[pm.t - 1]); // normalize modulus
        if (nsh > 0) {
            pm.lShiftTo(nsh, y);
            pt.lShiftTo(nsh, r);
        }
        else {
            pm.copyTo(y);
            pt.copyTo(r);
        }
        var ys = y.t;
        var y0 = y[ys - 1];
        if (y0 == 0) {
            return;
        }
        var yt = y0 * (1 << this.F1) + ((ys > 1) ? y[ys - 2] >> this.F2 : 0);
        var d1 = this.FV / yt;
        var d2 = (1 << this.F1) / yt;
        var e = 1 << this.F2;
        var i = r.t;
        var j = i - ys;
        var t = (q == null) ? nbi() : q;
        y.dlShiftTo(j, t);
        if (r.compareTo(t) >= 0) {
            r[r.t++] = 1;
            r.subTo(t, r);
        }
        BigInteger.ONE.dlShiftTo(ys, t);
        t.subTo(y, y); // "negative" y so we can replace sub with am later
        while (y.t < ys) {
            y[y.t++] = 0;
        }
        while (--j >= 0) {
            // Estimate quotient digit
            var qd = (r[--i] == y0) ? this.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2);
            if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd) { // Try it out
                y.dlShiftTo(j, t);
                r.subTo(t, r);
                while (r[i] < --qd) {
                    r.subTo(t, r);
                }
            }
        }
        if (q != null) {
            r.drShiftTo(ys, q);
            if (ts != ms) {
                BigInteger.ZERO.subTo(q, q);
            }
        }
        r.t = ys;
        r.clamp();
        if (nsh > 0) {
            r.rShiftTo(nsh, r);
        } // Denormalize remainder
        if (ts < 0) {
            BigInteger.ZERO.subTo(r, r);
        }
    };
    // BigInteger.prototype.invDigit = bnpInvDigit;
    // (protected) return "-1/this % 2^DB"; useful for Mont. reduction
    // justification:
    //         xy == 1 (mod m)
    //         xy =  1+km
    //   xy(2-xy) = (1+km)(1-km)
    // x[y(2-xy)] = 1-k^2m^2
    // x[y(2-xy)] == 1 (mod m^2)
    // if y is 1/x mod m, then y(2-xy) is 1/x mod m^2
    // should reduce x and y(2-xy) by m^2 at each step to keep size bounded.
    // JS multiply "overflows" differently from C/C++, so care is needed here.
    BigInteger.prototype.invDigit = function () {
        if (this.t < 1) {
            return 0;
        }
        var x = this[0];
        if ((x & 1) == 0) {
            return 0;
        }
        var y = x & 3; // y == 1/x mod 2^2
        y = (y * (2 - (x & 0xf) * y)) & 0xf; // y == 1/x mod 2^4
        y = (y * (2 - (x & 0xff) * y)) & 0xff; // y == 1/x mod 2^8
        y = (y * (2 - (((x & 0xffff) * y) & 0xffff))) & 0xffff; // y == 1/x mod 2^16
        // last step - calculate inverse mod DV directly;
        // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints
        y = (y * (2 - x * y % this.DV)) % this.DV; // y == 1/x mod 2^dbits
        // we really want the negative inverse, and -DV < y < DV
        return (y > 0) ? this.DV - y : -y;
    };
    // BigInteger.prototype.isEven = bnpIsEven;
    // (protected) true iff this is even
    BigInteger.prototype.isEven = function () {
        return ((this.t > 0) ? (this[0] & 1) : this.s) == 0;
    };
    // BigInteger.prototype.exp = bnpExp;
    // (protected) this^e, e < 2^32, doing sqr and mul with "r" (HAC 14.79)
    BigInteger.prototype.exp = function (e, z) {
        if (e > 0xffffffff || e < 1) {
            return BigInteger.ONE;
        }
        var r = nbi();
        var r2 = nbi();
        var g = z.convert(this);
        var i = nbits(e) - 1;
        g.copyTo(r);
        while (--i >= 0) {
            z.sqrTo(r, r2);
            if ((e & (1 << i)) > 0) {
                z.mulTo(r2, g, r);
            }
            else {
                var t = r;
                r = r2;
                r2 = t;
            }
        }
        return z.revert(r);
    };
    // BigInteger.prototype.chunkSize = bnpChunkSize;
    // (protected) return x s.t. r^x < DV
    BigInteger.prototype.chunkSize = function (r) {
        return Math.floor(Math.LN2 * this.DB / Math.log(r));
    };
    // BigInteger.prototype.toRadix = bnpToRadix;
    // (protected) convert to radix string
    BigInteger.prototype.toRadix = function (b) {
        if (b == null) {
            b = 10;
        }
        if (this.signum() == 0 || b < 2 || b > 36) {
            return "0";
        }
        var cs = this.chunkSize(b);
        var a = Math.pow(b, cs);
        var d = nbv(a);
        var y = nbi();
        var z = nbi();
        var r = "";
        this.divRemTo(d, y, z);
        while (y.signum() > 0) {
            r = (a + z.intValue()).toString(b).substr(1) + r;
            y.divRemTo(d, y, z);
        }
        return z.intValue().toString(b) + r;
    };
    // BigInteger.prototype.fromRadix = bnpFromRadix;
    // (protected) convert from radix string
    BigInteger.prototype.fromRadix = function (s, b) {
        this.fromInt(0);
        if (b == null) {
            b = 10;
        }
        var cs = this.chunkSize(b);
        var d = Math.pow(b, cs);
        var mi = false;
        var j = 0;
        var w = 0;
        for (var i = 0; i < s.length; ++i) {
            var x = intAt(s, i);
            if (x < 0) {
                if (s.charAt(i) == "-" && this.signum() == 0) {
                    mi = true;
                }
                continue;
            }
            w = b * w + x;
            if (++j >= cs) {
                this.dMultiply(d);
                this.dAddOffset(w, 0);
                j = 0;
                w = 0;
            }
        }
        if (j > 0) {
            this.dMultiply(Math.pow(b, j));
            this.dAddOffset(w, 0);
        }
        if (mi) {
            BigInteger.ZERO.subTo(this, this);
        }
    };
    // BigInteger.prototype.fromNumber = bnpFromNumber;
    // (protected) alternate constructor
    BigInteger.prototype.fromNumber = function (a, b, c) {
        if ("number" == typeof b) {
            // new BigInteger(int,int,RNG)
            if (a < 2) {
                this.fromInt(1);
            }
            else {
                this.fromNumber(a, c);
                if (!this.testBit(a - 1)) {
                    // force MSB set
                    this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);
                }
                if (this.isEven()) {
                    this.dAddOffset(1, 0);
                } // force odd
                while (!this.isProbablePrime(b)) {
                    this.dAddOffset(2, 0);
                    if (this.bitLength() > a) {
                        this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);
                    }
                }
            }
        }
        else {
            // new BigInteger(int,RNG)
            var x = [];
            var t = a & 7;
            x.length = (a >> 3) + 1;
            b.nextBytes(x);
            if (t > 0) {
                x[0] &= ((1 << t) - 1);
            }
            else {
                x[0] = 0;
            }
            this.fromString(x, 256);
        }
    };
    // BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
    // (protected) r = this op a (bitwise)
    BigInteger.prototype.bitwiseTo = function (a, op, r) {
        var i;
        var f;
        var m = Math.min(a.t, this.t);
        for (i = 0; i < m; ++i) {
            r[i] = op(this[i], a[i]);
        }
        if (a.t < this.t) {
            f = a.s & this.DM;
            for (i = m; i < this.t; ++i) {
                r[i] = op(this[i], f);
            }
            r.t = this.t;
        }
        else {
            f = this.s & this.DM;
            for (i = m; i < a.t; ++i) {
                r[i] = op(f, a[i]);
            }
            r.t = a.t;
        }
        r.s = op(this.s, a.s);
        r.clamp();
    };
    // BigInteger.prototype.changeBit = bnpChangeBit;
    // (protected) this op (1<<n)
    BigInteger.prototype.changeBit = function (n, op) {
        var r = BigInteger.ONE.shiftLeft(n);
        this.bitwiseTo(r, op, r);
        return r;
    };
    // BigInteger.prototype.addTo = bnpAddTo;
    // (protected) r = this + a
    BigInteger.prototype.addTo = function (a, r) {
        var i = 0;
        var c = 0;
        var m = Math.min(a.t, this.t);
        while (i < m) {
            c += this[i] + a[i];
            r[i++] = c & this.DM;
            c >>= this.DB;
        }
        if (a.t < this.t) {
            c += a.s;
            while (i < this.t) {
                c += this[i];
                r[i++] = c & this.DM;
                c >>= this.DB;
            }
            c += this.s;
        }
        else {
            c += this.s;
            while (i < a.t) {
                c += a[i];
                r[i++] = c & this.DM;
                c >>= this.DB;
            }
            c += a.s;
        }
        r.s = (c < 0) ? -1 : 0;
        if (c > 0) {
            r[i++] = c;
        }
        else if (c < -1) {
            r[i++] = this.DV + c;
        }
        r.t = i;
        r.clamp();
    };
    // BigInteger.prototype.dMultiply = bnpDMultiply;
    // (protected) this *= n, this >= 0, 1 < n < DV
    BigInteger.prototype.dMultiply = function (n) {
        this[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
        ++this.t;
        this.clamp();
    };
    // BigInteger.prototype.dAddOffset = bnpDAddOffset;
    // (protected) this += n << w words, this >= 0
    BigInteger.prototype.dAddOffset = function (n, w) {
        if (n == 0) {
            return;
        }
        while (this.t <= w) {
            this[this.t++] = 0;
        }
        this[w] += n;
        while (this[w] >= this.DV) {
            this[w] -= this.DV;
            if (++w >= this.t) {
                this[this.t++] = 0;
            }
            ++this[w];
        }
    };
    // BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
    // (protected) r = lower n words of "this * a", a.t <= n
    // "this" should be the larger one if appropriate.
    BigInteger.prototype.multiplyLowerTo = function (a, n, r) {
        var i = Math.min(this.t + a.t, n);
        r.s = 0; // assumes a,this >= 0
        r.t = i;
        while (i > 0) {
            r[--i] = 0;
        }
        for (var j = r.t - this.t; i < j; ++i) {
            r[i + this.t] = this.am(0, a[i], r, i, 0, this.t);
        }
        for (var j = Math.min(a.t, n); i < j; ++i) {
            this.am(0, a[i], r, i, 0, n - i);
        }
        r.clamp();
    };
    // BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
    // (protected) r = "this * a" without lower n words, n > 0
    // "this" should be the larger one if appropriate.
    BigInteger.prototype.multiplyUpperTo = function (a, n, r) {
        --n;
        var i = r.t = this.t + a.t - n;
        r.s = 0; // assumes a,this >= 0
        while (--i >= 0) {
            r[i] = 0;
        }
        for (i = Math.max(n - this.t, 0); i < a.t; ++i) {
            r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n);
        }
        r.clamp();
        r.drShiftTo(1, r);
    };
    // BigInteger.prototype.modInt = bnpModInt;
    // (protected) this % n, n < 2^26
    BigInteger.prototype.modInt = function (n) {
        if (n <= 0) {
            return 0;
        }
        var d = this.DV % n;
        var r = (this.s < 0) ? n - 1 : 0;
        if (this.t > 0) {
            if (d == 0) {
                r = this[0] % n;
            }
            else {
                for (var i = this.t - 1; i >= 0; --i) {
                    r = (d * r + this[i]) % n;
                }
            }
        }
        return r;
    };
    // BigInteger.prototype.millerRabin = bnpMillerRabin;
    // (protected) true if probably prime (HAC 4.24, Miller-Rabin)
    BigInteger.prototype.millerRabin = function (t) {
        var n1 = this.subtract(BigInteger.ONE);
        var k = n1.getLowestSetBit();
        if (k <= 0) {
            return false;
        }
        var r = n1.shiftRight(k);
        t = (t + 1) >> 1;
        if (t > lowprimes.length) {
            t = lowprimes.length;
        }
        var a = nbi();
        for (var i = 0; i < t; ++i) {
            // Pick bases at random, instead of starting at 2
            a.fromInt(lowprimes[Math.floor(Math.random() * lowprimes.length)]);
            var y = a.modPow(r, this);
            if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
                var j = 1;
                while (j++ < k && y.compareTo(n1) != 0) {
                    y = y.modPowInt(2, this);
                    if (y.compareTo(BigInteger.ONE) == 0) {
                        return false;
                    }
                }
                if (y.compareTo(n1) != 0) {
                    return false;
                }
            }
        }
        return true;
    };
    // BigInteger.prototype.square = bnSquare;
    // (public) this^2
    BigInteger.prototype.square = function () {
        var r = nbi();
        this.squareTo(r);
        return r;
    };
    //#region ASYNC
    // Public API method
    BigInteger.prototype.gcda = function (a, callback) {
        var x = (this.s < 0) ? this.negate() : this.clone();
        var y = (a.s < 0) ? a.negate() : a.clone();
        if (x.compareTo(y) < 0) {
            var t = x;
            x = y;
            y = t;
        }
        var i = x.getLowestSetBit();
        var g = y.getLowestSetBit();
        if (g < 0) {
            callback(x);
            return;
        }
        if (i < g) {
            g = i;
        }
        if (g > 0) {
            x.rShiftTo(g, x);
            y.rShiftTo(g, y);
        }
        // Workhorse of the algorithm, gets called 200 - 800 times per 512 bit keygen.
        var gcda1 = function () {
            if ((i = x.getLowestSetBit()) > 0) {
                x.rShiftTo(i, x);
            }
            if ((i = y.getLowestSetBit()) > 0) {
                y.rShiftTo(i, y);
            }
            if (x.compareTo(y) >= 0) {
                x.subTo(y, x);
                x.rShiftTo(1, x);
            }
            else {
                y.subTo(x, y);
                y.rShiftTo(1, y);
            }
            if (!(x.signum() > 0)) {
                if (g > 0) {
                    y.lShiftTo(g, y);
                }
                setTimeout(function () { callback(y); }, 0); // escape
            }
            else {
                setTimeout(gcda1, 0);
            }
        };
        setTimeout(gcda1, 10);
    };
    // (protected) alternate constructor
    BigInteger.prototype.fromNumberAsync = function (a, b, c, callback) {
        if ("number" == typeof b) {
            if (a < 2) {
                this.fromInt(1);
            }
            else {
                this.fromNumber(a, c);
                if (!this.testBit(a - 1)) {
                    this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);
                }
                if (this.isEven()) {
                    this.dAddOffset(1, 0);
                }
                var bnp_1 = this;
                var bnpfn1_1 = function () {
                    bnp_1.dAddOffset(2, 0);
                    if (bnp_1.bitLength() > a) {
                        bnp_1.subTo(BigInteger.ONE.shiftLeft(a - 1), bnp_1);
                    }
                    if (bnp_1.isProbablePrime(b)) {
                        setTimeout(function () { callback(); }, 0); // escape
                    }
                    else {
                        setTimeout(bnpfn1_1, 0);
                    }
                };
                setTimeout(bnpfn1_1, 0);
            }
        }
        else {
            var x = [];
            var t = a & 7;
            x.length = (a >> 3) + 1;
            b.nextBytes(x);
            if (t > 0) {
                x[0] &= ((1 << t) - 1);
            }
            else {
                x[0] = 0;
            }
            this.fromString(x, 256);
        }
    };
    return BigInteger;
}());

//#region REDUCERS
//#region NullExp
var NullExp = /** @class */ (function () {
    function NullExp() {
    }
    // NullExp.prototype.convert = nNop;
    NullExp.prototype.convert = function (x) {
        return x;
    };
    // NullExp.prototype.revert = nNop;
    NullExp.prototype.revert = function (x) {
        return x;
    };
    // NullExp.prototype.mulTo = nMulTo;
    NullExp.prototype.mulTo = function (x, y, r) {
        x.multiplyTo(y, r);
    };
    // NullExp.prototype.sqrTo = nSqrTo;
    NullExp.prototype.sqrTo = function (x, r) {
        x.squareTo(r);
    };
    return NullExp;
}());
// Modular reduction using "classic" algorithm
var Classic = /** @class */ (function () {
    function Classic(m) {
        this.m = m;
    }
    // Classic.prototype.convert = cConvert;
    Classic.prototype.convert = function (x) {
        if (x.s < 0 || x.compareTo(this.m) >= 0) {
            return x.mod(this.m);
        }
        else {
            return x;
        }
    };
    // Classic.prototype.revert = cRevert;
    Classic.prototype.revert = function (x) {
        return x;
    };
    // Classic.prototype.reduce = cReduce;
    Classic.prototype.reduce = function (x) {
        x.divRemTo(this.m, null, x);
    };
    // Classic.prototype.mulTo = cMulTo;
    Classic.prototype.mulTo = function (x, y, r) {
        x.multiplyTo(y, r);
        this.reduce(r);
    };
    // Classic.prototype.sqrTo = cSqrTo;
    Classic.prototype.sqrTo = function (x, r) {
        x.squareTo(r);
        this.reduce(r);
    };
    return Classic;
}());
//#endregion
//#region Montgomery
// Montgomery reduction
var Montgomery = /** @class */ (function () {
    function Montgomery(m) {
        this.m = m;
        this.mp = m.invDigit();
        this.mpl = this.mp & 0x7fff;
        this.mph = this.mp >> 15;
        this.um = (1 << (m.DB - 15)) - 1;
        this.mt2 = 2 * m.t;
    }
    // Montgomery.prototype.convert = montConvert;
    // xR mod m
    Montgomery.prototype.convert = function (x) {
        var r = nbi();
        x.abs().dlShiftTo(this.m.t, r);
        r.divRemTo(this.m, null, r);
        if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) {
            this.m.subTo(r, r);
        }
        return r;
    };
    // Montgomery.prototype.revert = montRevert;
    // x/R mod m
    Montgomery.prototype.revert = function (x) {
        var r = nbi();
        x.copyTo(r);
        this.reduce(r);
        return r;
    };
    // Montgomery.prototype.reduce = montReduce;
    // x = x/R mod m (HAC 14.32)
    Montgomery.prototype.reduce = function (x) {
        while (x.t <= this.mt2) {
            // pad x so am has enough room later
            x[x.t++] = 0;
        }
        for (var i = 0; i < this.m.t; ++i) {
            // faster way of calculating u0 = x[i]*mp mod DV
            var j = x[i] & 0x7fff;
            var u0 = (j * this.mpl + (((j * this.mph + (x[i] >> 15) * this.mpl) & this.um) << 15)) & x.DM;
            // use am to combine the multiply-shift-add into one call
            j = i + this.m.t;
            x[j] += this.m.am(0, u0, x, i, 0, this.m.t);
            // propagate carry
            while (x[j] >= x.DV) {
                x[j] -= x.DV;
                x[++j]++;
            }
        }
        x.clamp();
        x.drShiftTo(this.m.t, x);
        if (x.compareTo(this.m) >= 0) {
            x.subTo(this.m, x);
        }
    };
    // Montgomery.prototype.mulTo = montMulTo;
    // r = "xy/R mod m"; x,y != r
    Montgomery.prototype.mulTo = function (x, y, r) {
        x.multiplyTo(y, r);
        this.reduce(r);
    };
    // Montgomery.prototype.sqrTo = montSqrTo;
    // r = "x^2/R mod m"; x != r
    Montgomery.prototype.sqrTo = function (x, r) {
        x.squareTo(r);
        this.reduce(r);
    };
    return Montgomery;
}());
//#endregion Montgomery
//#region Barrett
// Barrett modular reduction
var Barrett = /** @class */ (function () {
    function Barrett(m) {
        this.m = m;
        // setup Barrett
        this.r2 = nbi();
        this.q3 = nbi();
        BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);
        this.mu = this.r2.divide(m);
    }
    // Barrett.prototype.convert = barrettConvert;
    Barrett.prototype.convert = function (x) {
        if (x.s < 0 || x.t > 2 * this.m.t) {
            return x.mod(this.m);
        }
        else if (x.compareTo(this.m) < 0) {
            return x;
        }
        else {
            var r = nbi();
            x.copyTo(r);
            this.reduce(r);
            return r;
        }
    };
    // Barrett.prototype.revert = barrettRevert;
    Barrett.prototype.revert = function (x) {
        return x;
    };
    // Barrett.prototype.reduce = barrettReduce;
    // x = x mod m (HAC 14.42)
    Barrett.prototype.reduce = function (x) {
        x.drShiftTo(this.m.t - 1, this.r2);
        if (x.t > this.m.t + 1) {
            x.t = this.m.t + 1;
            x.clamp();
        }
        this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
        this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
        while (x.compareTo(this.r2) < 0) {
            x.dAddOffset(1, this.m.t + 1);
        }
        x.subTo(this.r2, x);
        while (x.compareTo(this.m) >= 0) {
            x.subTo(this.m, x);
        }
    };
    // Barrett.prototype.mulTo = barrettMulTo;
    // r = x*y mod m; x,y != r
    Barrett.prototype.mulTo = function (x, y, r) {
        x.multiplyTo(y, r);
        this.reduce(r);
    };
    // Barrett.prototype.sqrTo = barrettSqrTo;
    // r = x^2 mod m; x != r
    Barrett.prototype.sqrTo = function (x, r) {
        x.squareTo(r);
        this.reduce(r);
    };
    return Barrett;
}());
//#endregion
//#endregion REDUCERS
// return new, unset BigInteger
function nbi() { return new BigInteger(null); }
function parseBigInt(str, r) {
    return new BigInteger(str, r);
}
// am: Compute w_j += (x*this_i), propagate carries,
// c is initial carry, returns final carry.
// c < 3*dvalue, x < 2*dvalue, this_i < dvalue
// We need to select the fastest one that works in this environment.
var inBrowser = typeof navigator !== "undefined";
if (inBrowser && j_lm && (navigator.appName == "Microsoft Internet Explorer")) {
    // am2 avoids a big mult-and-extract completely.
    // Max digit bits should be <= 30 because we do bitwise ops
    // on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)
    BigInteger.prototype.am = function am2(i, x, w, j, c, n) {
        var xl = x & 0x7fff;
        var xh = x >> 15;
        while (--n >= 0) {
            var l = this[i] & 0x7fff;
            var h = this[i++] >> 15;
            var m = xh * l + h * xl;
            l = xl * l + ((m & 0x7fff) << 15) + w[j] + (c & 0x3fffffff);
            c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);
            w[j++] = l & 0x3fffffff;
        }
        return c;
    };
    dbits = 30;
}
else if (inBrowser && j_lm && (navigator.appName != "Netscape")) {
    // am1: use a single mult and divide to get the high bits,
    // max digit bits should be 26 because
    // max internal value = 2*dvalue^2-2*dvalue (< 2^53)
    BigInteger.prototype.am = function am1(i, x, w, j, c, n) {
        while (--n >= 0) {
            var v = x * this[i++] + w[j] + c;
            c = Math.floor(v / 0x4000000);
            w[j++] = v & 0x3ffffff;
        }
        return c;
    };
    dbits = 26;
}
else { // Mozilla/Netscape seems to prefer am3
    // Alternately, set max digit bits to 28 since some
    // browsers slow down when dealing with 32-bit numbers.
    BigInteger.prototype.am = function am3(i, x, w, j, c, n) {
        var xl = x & 0x3fff;
        var xh = x >> 14;
        while (--n >= 0) {
            var l = this[i] & 0x3fff;
            var h = this[i++] >> 14;
            var m = xh * l + h * xl;
            l = xl * l + ((m & 0x3fff) << 14) + w[j] + c;
            c = (l >> 28) + (m >> 14) + xh * h;
            w[j++] = l & 0xfffffff;
        }
        return c;
    };
    dbits = 28;
}
BigInteger.prototype.DB = dbits;
BigInteger.prototype.DM = ((1 << dbits) - 1);
BigInteger.prototype.DV = (1 << dbits);
var BI_FP = 52;
BigInteger.prototype.FV = Math.pow(2, BI_FP);
BigInteger.prototype.F1 = BI_FP - dbits;
BigInteger.prototype.F2 = 2 * dbits - BI_FP;
// Digit conversions
var BI_RC = [];
var rr;
var vv;
rr = "0".charCodeAt(0);
for (vv = 0; vv <= 9; ++vv) {
    BI_RC[rr++] = vv;
}
rr = "a".charCodeAt(0);
for (vv = 10; vv < 36; ++vv) {
    BI_RC[rr++] = vv;
}
rr = "A".charCodeAt(0);
for (vv = 10; vv < 36; ++vv) {
    BI_RC[rr++] = vv;
}
function intAt(s, i) {
    var c = BI_RC[s.charCodeAt(i)];
    return (c == null) ? -1 : c;
}
// return bigint initialized to value
function nbv(i) {
    var r = nbi();
    r.fromInt(i);
    return r;
}
// returns bit length of the integer x
function nbits(x) {
    var r = 1;
    var t;
    if ((t = x >>> 16) != 0) {
        x = t;
        r += 16;
    }
    if ((t = x >> 8) != 0) {
        x = t;
        r += 8;
    }
    if ((t = x >> 4) != 0) {
        x = t;
        r += 4;
    }
    if ((t = x >> 2) != 0) {
        x = t;
        r += 2;
    }
    if ((t = x >> 1) != 0) {
        x = t;
        r += 1;
    }
    return r;
}
// "constants"
BigInteger.ZERO = nbv(0);
BigInteger.ONE = nbv(1);

;// CONCATENATED MODULE: ./node_modules/jsencrypt/lib/lib/jsbn/prng4.js
// prng4.js - uses Arcfour as a PRNG
var Arcfour = /** @class */ (function () {
    function Arcfour() {
        this.i = 0;
        this.j = 0;
        this.S = [];
    }
    // Arcfour.prototype.init = ARC4init;
    // Initialize arcfour context from key, an array of ints, each from [0..255]
    Arcfour.prototype.init = function (key) {
        var i;
        var j;
        var t;
        for (i = 0; i < 256; ++i) {
            this.S[i] = i;
        }
        j = 0;
        for (i = 0; i < 256; ++i) {
            j = (j + this.S[i] + key[i % key.length]) & 255;
            t = this.S[i];
            this.S[i] = this.S[j];
            this.S[j] = t;
        }
        this.i = 0;
        this.j = 0;
    };
    // Arcfour.prototype.next = ARC4next;
    Arcfour.prototype.next = function () {
        var t;
        this.i = (this.i + 1) & 255;
        this.j = (this.j + this.S[this.i]) & 255;
        t = this.S[this.i];
        this.S[this.i] = this.S[this.j];
        this.S[this.j] = t;
        return this.S[(t + this.S[this.i]) & 255];
    };
    return Arcfour;
}());

// Plug in your RNG constructor here
function prng_newstate() {
    return new Arcfour();
}
// Pool size must be a multiple of 4 and greater than 32.
// An array of bytes the size of the pool will be passed to init()
var rng_psize = 256;

;// CONCATENATED MODULE: ./node_modules/jsencrypt/lib/lib/jsbn/rng.js
// Random number generator - requires a PRNG backend, e.g. prng4.js

var rng_state;
var rng_pool = null;
var rng_pptr;
// Initialize the pool with junk if needed.
if (rng_pool == null) {
    rng_pool = [];
    rng_pptr = 0;
    var t = void 0;
    if (typeof window !== 'undefined' && window.crypto && window.crypto.getRandomValues) {
        // Extract entropy (2048 bits) from RNG if available
        var z = new Uint32Array(256);
        window.crypto.getRandomValues(z);
        for (t = 0; t < z.length; ++t) {
            rng_pool[rng_pptr++] = z[t] & 255;
        }
    }
    // Use mouse events for entropy, if we do not have enough entropy by the time
    // we need it, entropy will be generated by Math.random.
    var count = 0;
    var onMouseMoveListener_1 = function (ev) {
        count = count || 0;
        if (count >= 256 || rng_pptr >= rng_psize) {
            if (window.removeEventListener) {
                window.removeEventListener("mousemove", onMouseMoveListener_1, false);
            }
            else if (window.detachEvent) {
                window.detachEvent("onmousemove", onMouseMoveListener_1);
            }
            return;
        }
        try {
            var mouseCoordinates = ev.x + ev.y;
            rng_pool[rng_pptr++] = mouseCoordinates & 255;
            count += 1;
        }
        catch (e) {
            // Sometimes Firefox will deny permission to access event properties for some reason. Ignore.
        }
    };
    if (typeof window !== 'undefined') {
        if (window.addEventListener) {
            window.addEventListener("mousemove", onMouseMoveListener_1, false);
        }
        else if (window.attachEvent) {
            window.attachEvent("onmousemove", onMouseMoveListener_1);
        }
    }
}
function rng_get_byte() {
    if (rng_state == null) {
        rng_state = prng_newstate();
        // At this point, we may not have collected enough entropy.  If not, fall back to Math.random
        while (rng_pptr < rng_psize) {
            var random = Math.floor(65536 * Math.random());
            rng_pool[rng_pptr++] = random & 255;
        }
        rng_state.init(rng_pool);
        for (rng_pptr = 0; rng_pptr < rng_pool.length; ++rng_pptr) {
            rng_pool[rng_pptr] = 0;
        }
        rng_pptr = 0;
    }
    // TODO: allow reseeding after first request
    return rng_state.next();
}
var SecureRandom = /** @class */ (function () {
    function SecureRandom() {
    }
    SecureRandom.prototype.nextBytes = function (ba) {
        for (var i = 0; i < ba.length; ++i) {
            ba[i] = rng_get_byte();
        }
    };
    return SecureRandom;
}());


;// CONCATENATED MODULE: ./node_modules/jsencrypt/lib/lib/jsbn/rsa.js
// Depends on jsbn.js and rng.js
// Version 1.1: support utf-8 encoding in pkcs1pad2
// convert a (hex) string to a bignum object


// function linebrk(s,n) {
//   var ret = "";
//   var i = 0;
//   while(i + n < s.length) {
//     ret += s.substring(i,i+n) + "\n";
//     i += n;
//   }
//   return ret + s.substring(i,s.length);
// }
// function byte2Hex(b) {
//   if(b < 0x10)
//     return "0" + b.toString(16);
//   else
//     return b.toString(16);
// }
function pkcs1pad1(s, n) {
    if (n < s.length + 22) {
        console.error("Message too long for RSA");
        return null;
    }
    var len = n - s.length - 6;
    var filler = "";
    for (var f = 0; f < len; f += 2) {
        filler += "ff";
    }
    var m = "0001" + filler + "00" + s;
    return parseBigInt(m, 16);
}
// PKCS#1 (type 2, random) pad input string s to n bytes, and return a bigint
function pkcs1pad2(s, n) {
    if (n < s.length + 11) { // TODO: fix for utf-8
        console.error("Message too long for RSA");
        return null;
    }
    var ba = [];
    var i = s.length - 1;
    while (i >= 0 && n > 0) {
        var c = s.charCodeAt(i--);
        if (c < 128) { // encode using utf-8
            ba[--n] = c;
        }
        else if ((c > 127) && (c < 2048)) {
            ba[--n] = (c & 63) | 128;
            ba[--n] = (c >> 6) | 192;
        }
        else {
            ba[--n] = (c & 63) | 128;
            ba[--n] = ((c >> 6) & 63) | 128;
            ba[--n] = (c >> 12) | 224;
        }
    }
    ba[--n] = 0;
    var rng = new SecureRandom();
    var x = [];
    while (n > 2) { // random non-zero pad
        x[0] = 0;
        while (x[0] == 0) {
            rng.nextBytes(x);
        }
        ba[--n] = x[0];
    }
    ba[--n] = 2;
    ba[--n] = 0;
    return new BigInteger(ba);
}
// "empty" RSA key constructor
var rsa_RSAKey = /** @class */ (function () {
    function RSAKey() {
        this.n = null;
        this.e = 0;
        this.d = null;
        this.p = null;
        this.q = null;
        this.dmp1 = null;
        this.dmq1 = null;
        this.coeff = null;
    }
    //#region PROTECTED
    // protected
    // RSAKey.prototype.doPublic = RSADoPublic;
    // Perform raw public operation on "x": return x^e (mod n)
    RSAKey.prototype.doPublic = function (x) {
        return x.modPowInt(this.e, this.n);
    };
    // RSAKey.prototype.doPrivate = RSADoPrivate;
    // Perform raw private operation on "x": return x^d (mod n)
    RSAKey.prototype.doPrivate = function (x) {
        if (this.p == null || this.q == null) {
            return x.modPow(this.d, this.n);
        }
        // TODO: re-calculate any missing CRT params
        var xp = x.mod(this.p).modPow(this.dmp1, this.p);
        var xq = x.mod(this.q).modPow(this.dmq1, this.q);
        while (xp.compareTo(xq) < 0) {
            xp = xp.add(this.p);
        }
        return xp.subtract(xq).multiply(this.coeff).mod(this.p).multiply(this.q).add(xq);
    };
    //#endregion PROTECTED
    //#region PUBLIC
    // RSAKey.prototype.setPublic = RSASetPublic;
    // Set the public key fields N and e from hex strings
    RSAKey.prototype.setPublic = function (N, E) {
        if (N != null && E != null && N.length > 0 && E.length > 0) {
            this.n = parseBigInt(N, 16);
            this.e = parseInt(E, 16);
        }
        else {
            console.error("Invalid RSA public key");
        }
    };
    // RSAKey.prototype.encrypt = RSAEncrypt;
    // Return the PKCS#1 RSA encryption of "text" as an even-length hex string
    RSAKey.prototype.encrypt = function (text) {
        var maxLength = (this.n.bitLength() + 7) >> 3;
        var m = pkcs1pad2(text, maxLength);
        if (m == null) {
            return null;
        }
        var c = this.doPublic(m);
        if (c == null) {
            return null;
        }
        var h = c.toString(16);
        var length = h.length;
        // fix zero before result
        for (var i = 0; i < maxLength * 2 - length; i++) {
            h = "0" + h;
        }
        return h;
    };
    // RSAKey.prototype.setPrivate = RSASetPrivate;
    // Set the private key fields N, e, and d from hex strings
    RSAKey.prototype.setPrivate = function (N, E, D) {
        if (N != null && E != null && N.length > 0 && E.length > 0) {
            this.n = parseBigInt(N, 16);
            this.e = parseInt(E, 16);
            this.d = parseBigInt(D, 16);
        }
        else {
            console.error("Invalid RSA private key");
        }
    };
    // RSAKey.prototype.setPrivateEx = RSASetPrivateEx;
    // Set the private key fields N, e, d and CRT params from hex strings
    RSAKey.prototype.setPrivateEx = function (N, E, D, P, Q, DP, DQ, C) {
        if (N != null && E != null && N.length > 0 && E.length > 0) {
            this.n = parseBigInt(N, 16);
            this.e = parseInt(E, 16);
            this.d = parseBigInt(D, 16);
            this.p = parseBigInt(P, 16);
            this.q = parseBigInt(Q, 16);
            this.dmp1 = parseBigInt(DP, 16);
            this.dmq1 = parseBigInt(DQ, 16);
            this.coeff = parseBigInt(C, 16);
        }
        else {
            console.error("Invalid RSA private key");
        }
    };
    // RSAKey.prototype.generate = RSAGenerate;
    // Generate a new random private key B bits long, using public expt E
    RSAKey.prototype.generate = function (B, E) {
        var rng = new SecureRandom();
        var qs = B >> 1;
        this.e = parseInt(E, 16);
        var ee = new BigInteger(E, 16);
        for (;;) {
            for (;;) {
                this.p = new BigInteger(B - qs, 1, rng);
                if (this.p.subtract(BigInteger.ONE).gcd(ee).compareTo(BigInteger.ONE) == 0 && this.p.isProbablePrime(10)) {
                    break;
                }
            }
            for (;;) {
                this.q = new BigInteger(qs, 1, rng);
                if (this.q.subtract(BigInteger.ONE).gcd(ee).compareTo(BigInteger.ONE) == 0 && this.q.isProbablePrime(10)) {
                    break;
                }
            }
            if (this.p.compareTo(this.q) <= 0) {
                var t = this.p;
                this.p = this.q;
                this.q = t;
            }
            var p1 = this.p.subtract(BigInteger.ONE);
            var q1 = this.q.subtract(BigInteger.ONE);
            var phi = p1.multiply(q1);
            if (phi.gcd(ee).compareTo(BigInteger.ONE) == 0) {
                this.n = this.p.multiply(this.q);
                this.d = ee.modInverse(phi);
                this.dmp1 = this.d.mod(p1);
                this.dmq1 = this.d.mod(q1);
                this.coeff = this.q.modInverse(this.p);
                break;
            }
        }
    };
    // RSAKey.prototype.decrypt = RSADecrypt;
    // Return the PKCS#1 RSA decryption of "ctext".
    // "ctext" is an even-length hex string and the output is a plain string.
    RSAKey.prototype.decrypt = function (ctext) {
        var c = parseBigInt(ctext, 16);
        var m = this.doPrivate(c);
        if (m == null) {
            return null;
        }
        return pkcs1unpad2(m, (this.n.bitLength() + 7) >> 3);
    };
    // Generate a new random private key B bits long, using public expt E
    RSAKey.prototype.generateAsync = function (B, E, callback) {
        var rng = new SecureRandom();
        var qs = B >> 1;
        this.e = parseInt(E, 16);
        var ee = new BigInteger(E, 16);
        var rsa = this;
        // These functions have non-descript names because they were originally for(;;) loops.
        // I don't know about cryptography to give them better names than loop1-4.
        var loop1 = function () {
            var loop4 = function () {
                if (rsa.p.compareTo(rsa.q) <= 0) {
                    var t = rsa.p;
                    rsa.p = rsa.q;
                    rsa.q = t;
                }
                var p1 = rsa.p.subtract(BigInteger.ONE);
                var q1 = rsa.q.subtract(BigInteger.ONE);
                var phi = p1.multiply(q1);
                if (phi.gcd(ee).compareTo(BigInteger.ONE) == 0) {
                    rsa.n = rsa.p.multiply(rsa.q);
                    rsa.d = ee.modInverse(phi);
                    rsa.dmp1 = rsa.d.mod(p1);
                    rsa.dmq1 = rsa.d.mod(q1);
                    rsa.coeff = rsa.q.modInverse(rsa.p);
                    setTimeout(function () { callback(); }, 0); // escape
                }
                else {
                    setTimeout(loop1, 0);
                }
            };
            var loop3 = function () {
                rsa.q = nbi();
                rsa.q.fromNumberAsync(qs, 1, rng, function () {
                    rsa.q.subtract(BigInteger.ONE).gcda(ee, function (r) {
                        if (r.compareTo(BigInteger.ONE) == 0 && rsa.q.isProbablePrime(10)) {
                            setTimeout(loop4, 0);
                        }
                        else {
                            setTimeout(loop3, 0);
                        }
                    });
                });
            };
            var loop2 = function () {
                rsa.p = nbi();
                rsa.p.fromNumberAsync(B - qs, 1, rng, function () {
                    rsa.p.subtract(BigInteger.ONE).gcda(ee, function (r) {
                        if (r.compareTo(BigInteger.ONE) == 0 && rsa.p.isProbablePrime(10)) {
                            setTimeout(loop3, 0);
                        }
                        else {
                            setTimeout(loop2, 0);
                        }
                    });
                });
            };
            setTimeout(loop2, 0);
        };
        setTimeout(loop1, 0);
    };
    RSAKey.prototype.sign = function (text, digestMethod, digestName) {
        var header = getDigestHeader(digestName);
        var digest = header + digestMethod(text).toString();
        var m = pkcs1pad1(digest, this.n.bitLength() / 4);
        if (m == null) {
            return null;
        }
        var c = this.doPrivate(m);
        if (c == null) {
            return null;
        }
        var h = c.toString(16);
        if ((h.length & 1) == 0) {
            return h;
        }
        else {
            return "0" + h;
        }
    };
    RSAKey.prototype.verify = function (text, signature, digestMethod) {
        var c = parseBigInt(signature, 16);
        var m = this.doPublic(c);
        if (m == null) {
            return null;
        }
        var unpadded = m.toString(16).replace(/^1f+00/, "");
        var digest = removeDigestHeader(unpadded);
        return digest == digestMethod(text).toString();
    };
    return RSAKey;
}());

// Undo PKCS#1 (type 2, random) padding and, if valid, return the plaintext
function pkcs1unpad2(d, n) {
    var b = d.toByteArray();
    var i = 0;
    while (i < b.length && b[i] == 0) {
        ++i;
    }
    if (b.length - i != n - 1 || b[i] != 2) {
        return null;
    }
    ++i;
    while (b[i] != 0) {
        if (++i >= b.length) {
            return null;
        }
    }
    var ret = "";
    while (++i < b.length) {
        var c = b[i] & 255;
        if (c < 128) { // utf-8 decode
            ret += String.fromCharCode(c);
        }
        else if ((c > 191) && (c < 224)) {
            ret += String.fromCharCode(((c & 31) << 6) | (b[i + 1] & 63));
            ++i;
        }
        else {
            ret += String.fromCharCode(((c & 15) << 12) | ((b[i + 1] & 63) << 6) | (b[i + 2] & 63));
            i += 2;
        }
    }
    return ret;
}
// https://tools.ietf.org/html/rfc3447#page-43
var DIGEST_HEADERS = {
    md2: "3020300c06082a864886f70d020205000410",
    md5: "3020300c06082a864886f70d020505000410",
    sha1: "3021300906052b0e03021a05000414",
    sha224: "302d300d06096086480165030402040500041c",
    sha256: "3031300d060960864801650304020105000420",
    sha384: "3041300d060960864801650304020205000430",
    sha512: "3051300d060960864801650304020305000440",
    ripemd160: "3021300906052b2403020105000414"
};
function getDigestHeader(name) {
    return DIGEST_HEADERS[name] || "";
}
function removeDigestHeader(str) {
    for (var name_1 in DIGEST_HEADERS) {
        if (DIGEST_HEADERS.hasOwnProperty(name_1)) {
            var header = DIGEST_HEADERS[name_1];
            var len = header.length;
            if (str.substr(0, len) == header) {
                return str.substr(len);
            }
        }
    }
    return str;
}
// Return the PKCS#1 RSA encryption of "text" as a Base64-encoded string
// function RSAEncryptB64(text) {
//  var h = this.encrypt(text);
//  if(h) return hex2b64(h); else return null;
// }
// public
// RSAKey.prototype.encrypt_b64 = RSAEncryptB64;

;// CONCATENATED MODULE: ./node_modules/jsencrypt/lib/lib/jsrsasign/yahoo.js
/*!
Copyright (c) 2011, Yahoo! Inc. All rights reserved.
Code licensed under the BSD License:
http://developer.yahoo.com/yui/license.html
version: 2.9.0
*/
var YAHOO = {};
YAHOO.lang = {
    /**
     * Utility to set up the prototype, constructor and superclass properties to
     * support an inheritance strategy that can chain constructors and methods.
     * Static members will not be inherited.
     *
     * @method extend
     * @static
     * @param {Function} subc   the object to modify
     * @param {Function} superc the object to inherit
     * @param {Object} overrides  additional properties/methods to add to the
     *                              subclass prototype.  These will override the
     *                              matching items obtained from the superclass
     *                              if present.
     */
    extend: function (subc, superc, overrides) {
        if (!superc || !subc) {
            throw new Error("YAHOO.lang.extend failed, please check that " +
                "all dependencies are included.");
        }
        var F = function () { };
        F.prototype = superc.prototype;
        subc.prototype = new F();
        subc.prototype.constructor = subc;
        subc.superclass = superc.prototype;
        if (superc.prototype.constructor == Object.prototype.constructor) {
            superc.prototype.constructor = superc;
        }
        if (overrides) {
            var i;
            for (i in overrides) {
                subc.prototype[i] = overrides[i];
            }
            /*
             * IE will not enumerate native functions in a derived object even if the
             * function was overridden.  This is a workaround for specific functions
             * we care about on the Object prototype.
             * @property _IEEnumFix
             * @param {Function} r  the object to receive the augmentation
             * @param {Function} s  the object that supplies the properties to augment
             * @static
             * @private
             */
            var _IEEnumFix = function () { }, ADD = ["toString", "valueOf"];
            try {
                if (/MSIE/.test(navigator.userAgent)) {
                    _IEEnumFix = function (r, s) {
                        for (i = 0; i < ADD.length; i = i + 1) {
                            var fname = ADD[i], f = s[fname];
                            if (typeof f === 'function' && f != Object.prototype[fname]) {
                                r[fname] = f;
                            }
                        }
                    };
                }
            }
            catch (ex) { }
            ;
            _IEEnumFix(subc.prototype, overrides);
        }
    }
};

;// CONCATENATED MODULE: ./node_modules/jsencrypt/lib/lib/jsrsasign/asn1-1.0.js
/* asn1-1.0.13.js (c) 2013-2017 Kenji Urushima | kjur.github.com/jsrsasign/license
 */
/*
 * asn1.js - ASN.1 DER encoder classes
 *
 * Copyright (c) 2013-2017 Kenji Urushima (kenji.urushima@gmail.com)
 *
 * This software is licensed under the terms of the MIT License.
 * https://kjur.github.io/jsrsasign/license
 *
 * The above copyright and license notice shall be
 * included in all copies or substantial portions of the Software.
 */


/**
 * @fileOverview
 * @name asn1-1.0.js
 * @author Kenji Urushima kenji.urushima@gmail.com
 * @version asn1 1.0.13 (2017-Jun-02)
 * @since jsrsasign 2.1
 * @license <a href="https://kjur.github.io/jsrsasign/license/">MIT License</a>
 */
/**
 * kjur's class library name space
 * <p>
 * This name space provides following name spaces:
 * <ul>
 * <li>{@link KJUR.asn1} - ASN.1 primitive hexadecimal encoder</li>
 * <li>{@link KJUR.asn1.x509} - ASN.1 structure for X.509 certificate and CRL</li>
 * <li>{@link KJUR.crypto} - Java Cryptographic Extension(JCE) style MessageDigest/Signature
 * class and utilities</li>
 * </ul>
 * </p>
 * NOTE: Please ignore method summary and document of this namespace. This caused by a bug of jsdoc2.
 * @name KJUR
 * @namespace kjur's class library name space
 */
var KJUR = {};
/**
 * kjur's ASN.1 class library name space
 * <p>
 * This is ITU-T X.690 ASN.1 DER encoder class library and
 * class structure and methods is very similar to
 * org.bouncycastle.asn1 package of
 * well known BouncyCaslte Cryptography Library.
 * <h4>PROVIDING ASN.1 PRIMITIVES</h4>
 * Here are ASN.1 DER primitive classes.
 * <ul>
 * <li>0x01 {@link KJUR.asn1.DERBoolean}</li>
 * <li>0x02 {@link KJUR.asn1.DERInteger}</li>
 * <li>0x03 {@link KJUR.asn1.DERBitString}</li>
 * <li>0x04 {@link KJUR.asn1.DEROctetString}</li>
 * <li>0x05 {@link KJUR.asn1.DERNull}</li>
 * <li>0x06 {@link KJUR.asn1.DERObjectIdentifier}</li>
 * <li>0x0a {@link KJUR.asn1.DEREnumerated}</li>
 * <li>0x0c {@link KJUR.asn1.DERUTF8String}</li>
 * <li>0x12 {@link KJUR.asn1.DERNumericString}</li>
 * <li>0x13 {@link KJUR.asn1.DERPrintableString}</li>
 * <li>0x14 {@link KJUR.asn1.DERTeletexString}</li>
 * <li>0x16 {@link KJUR.asn1.DERIA5String}</li>
 * <li>0x17 {@link KJUR.asn1.DERUTCTime}</li>
 * <li>0x18 {@link KJUR.asn1.DERGeneralizedTime}</li>
 * <li>0x30 {@link KJUR.asn1.DERSequence}</li>
 * <li>0x31 {@link KJUR.asn1.DERSet}</li>
 * </ul>
 * <h4>OTHER ASN.1 CLASSES</h4>
 * <ul>
 * <li>{@link KJUR.asn1.ASN1Object}</li>
 * <li>{@link KJUR.asn1.DERAbstractString}</li>
 * <li>{@link KJUR.asn1.DERAbstractTime}</li>
 * <li>{@link KJUR.asn1.DERAbstractStructured}</li>
 * <li>{@link KJUR.asn1.DERTaggedObject}</li>
 * </ul>
 * <h4>SUB NAME SPACES</h4>
 * <ul>
 * <li>{@link KJUR.asn1.cades} - CAdES long term signature format</li>
 * <li>{@link KJUR.asn1.cms} - Cryptographic Message Syntax</li>
 * <li>{@link KJUR.asn1.csr} - Certificate Signing Request (CSR/PKCS#10)</li>
 * <li>{@link KJUR.asn1.tsp} - RFC 3161 Timestamping Protocol Format</li>
 * <li>{@link KJUR.asn1.x509} - RFC 5280 X.509 certificate and CRL</li>
 * </ul>
 * </p>
 * NOTE: Please ignore method summary and document of this namespace.
 * This caused by a bug of jsdoc2.
 * @name KJUR.asn1
 * @namespace
 */
if (typeof KJUR.asn1 == "undefined" || !KJUR.asn1)
    KJUR.asn1 = {};
/**
 * ASN1 utilities class
 * @name KJUR.asn1.ASN1Util
 * @class ASN1 utilities class
 * @since asn1 1.0.2
 */
KJUR.asn1.ASN1Util = new function () {
    this.integerToByteHex = function (i) {
        var h = i.toString(16);
        if ((h.length % 2) == 1)
            h = '0' + h;
        return h;
    };
    this.bigIntToMinTwosComplementsHex = function (bigIntegerValue) {
        var h = bigIntegerValue.toString(16);
        if (h.substr(0, 1) != '-') {
            if (h.length % 2 == 1) {
                h = '0' + h;
            }
            else {
                if (!h.match(/^[0-7]/)) {
                    h = '00' + h;
                }
            }
        }
        else {
            var hPos = h.substr(1);
            var xorLen = hPos.length;
            if (xorLen % 2 == 1) {
                xorLen += 1;
            }
            else {
                if (!h.match(/^[0-7]/)) {
                    xorLen += 2;
                }
            }
            var hMask = '';
            for (var i = 0; i < xorLen; i++) {
                hMask += 'f';
            }
            var biMask = new BigInteger(hMask, 16);
            var biNeg = biMask.xor(bigIntegerValue).add(BigInteger.ONE);
            h = biNeg.toString(16).replace(/^-/, '');
        }
        return h;
    };
    /**
     * get PEM string from hexadecimal data and header string
     * @name getPEMStringFromHex
     * @memberOf KJUR.asn1.ASN1Util
     * @function
     * @param {String} dataHex hexadecimal string of PEM body
     * @param {String} pemHeader PEM header string (ex. 'RSA PRIVATE KEY')
     * @return {String} PEM formatted string of input data
     * @description
     * This method converts a hexadecimal string to a PEM string with
     * a specified header. Its line break will be CRLF("\r\n").
     * @example
     * var pem  = KJUR.asn1.ASN1Util.getPEMStringFromHex('616161', 'RSA PRIVATE KEY');
     * // value of pem will be:
     * -----BEGIN PRIVATE KEY-----
     * YWFh
     * -----END PRIVATE KEY-----
     */
    this.getPEMStringFromHex = function (dataHex, pemHeader) {
        return hextopem(dataHex, pemHeader);
    };
    /**
     * generate ASN1Object specifed by JSON parameters
     * @name newObject
     * @memberOf KJUR.asn1.ASN1Util
     * @function
     * @param {Array} param JSON parameter to generate ASN1Object
     * @return {KJUR.asn1.ASN1Object} generated object
     * @since asn1 1.0.3
     * @description
     * generate any ASN1Object specified by JSON param
     * including ASN.1 primitive or structured.
     * Generally 'param' can be described as follows:
     * <blockquote>
     * {TYPE-OF-ASNOBJ: ASN1OBJ-PARAMETER}
     * </blockquote>
     * 'TYPE-OF-ASN1OBJ' can be one of following symbols:
     * <ul>
     * <li>'bool' - DERBoolean</li>
     * <li>'int' - DERInteger</li>
     * <li>'bitstr' - DERBitString</li>
     * <li>'octstr' - DEROctetString</li>
     * <li>'null' - DERNull</li>
     * <li>'oid' - DERObjectIdentifier</li>
     * <li>'enum' - DEREnumerated</li>
     * <li>'utf8str' - DERUTF8String</li>
     * <li>'numstr' - DERNumericString</li>
     * <li>'prnstr' - DERPrintableString</li>
     * <li>'telstr' - DERTeletexString</li>
     * <li>'ia5str' - DERIA5String</li>
     * <li>'utctime' - DERUTCTime</li>
     * <li>'gentime' - DERGeneralizedTime</li>
     * <li>'seq' - DERSequence</li>
     * <li>'set' - DERSet</li>
     * <li>'tag' - DERTaggedObject</li>
     * </ul>
     * @example
     * newObject({'prnstr': 'aaa'});
     * newObject({'seq': [{'int': 3}, {'prnstr': 'aaa'}]})
     * // ASN.1 Tagged Object
     * newObject({'tag': {'tag': 'a1',
     *                    'explicit': true,
     *                    'obj': {'seq': [{'int': 3}, {'prnstr': 'aaa'}]}}});
     * // more simple representation of ASN.1 Tagged Object
     * newObject({'tag': ['a1',
     *                    true,
     *                    {'seq': [
     *                      {'int': 3},
     *                      {'prnstr': 'aaa'}]}
     *                   ]});
     */
    this.newObject = function (param) {
        var _KJUR = KJUR, _KJUR_asn1 = _KJUR.asn1, _DERBoolean = _KJUR_asn1.DERBoolean, _DERInteger = _KJUR_asn1.DERInteger, _DERBitString = _KJUR_asn1.DERBitString, _DEROctetString = _KJUR_asn1.DEROctetString, _DERNull = _KJUR_asn1.DERNull, _DERObjectIdentifier = _KJUR_asn1.DERObjectIdentifier, _DEREnumerated = _KJUR_asn1.DEREnumerated, _DERUTF8String = _KJUR_asn1.DERUTF8String, _DERNumericString = _KJUR_asn1.DERNumericString, _DERPrintableString = _KJUR_asn1.DERPrintableString, _DERTeletexString = _KJUR_asn1.DERTeletexString, _DERIA5String = _KJUR_asn1.DERIA5String, _DERUTCTime = _KJUR_asn1.DERUTCTime, _DERGeneralizedTime = _KJUR_asn1.DERGeneralizedTime, _DERSequence = _KJUR_asn1.DERSequence, _DERSet = _KJUR_asn1.DERSet, _DERTaggedObject = _KJUR_asn1.DERTaggedObject, _newObject = _KJUR_asn1.ASN1Util.newObject;
        var keys = Object.keys(param);
        if (keys.length != 1)
            throw "key of param shall be only one.";
        var key = keys[0];
        if (":bool:int:bitstr:octstr:null:oid:enum:utf8str:numstr:prnstr:telstr:ia5str:utctime:gentime:seq:set:tag:".indexOf(":" + key + ":") == -1)
            throw "undefined key: " + key;
        if (key == "bool")
            return new _DERBoolean(param[key]);
        if (key == "int")
            return new _DERInteger(param[key]);
        if (key == "bitstr")
            return new _DERBitString(param[key]);
        if (key == "octstr")
            return new _DEROctetString(param[key]);
        if (key == "null")
            return new _DERNull(param[key]);
        if (key == "oid")
            return new _DERObjectIdentifier(param[key]);
        if (key == "enum")
            return new _DEREnumerated(param[key]);
        if (key == "utf8str")
            return new _DERUTF8String(param[key]);
        if (key == "numstr")
            return new _DERNumericString(param[key]);
        if (key == "prnstr")
            return new _DERPrintableString(param[key]);
        if (key == "telstr")
            return new _DERTeletexString(param[key]);
        if (key == "ia5str")
            return new _DERIA5String(param[key]);
        if (key == "utctime")
            return new _DERUTCTime(param[key]);
        if (key == "gentime")
            return new _DERGeneralizedTime(param[key]);
        if (key == "seq") {
            var paramList = param[key];
            var a = [];
            for (var i = 0; i < paramList.length; i++) {
                var asn1Obj = _newObject(paramList[i]);
                a.push(asn1Obj);
            }
            return new _DERSequence({ 'array': a });
        }
        if (key == "set") {
            var paramList = param[key];
            var a = [];
            for (var i = 0; i < paramList.length; i++) {
                var asn1Obj = _newObject(paramList[i]);
                a.push(asn1Obj);
            }
            return new _DERSet({ 'array': a });
        }
        if (key == "tag") {
            var tagParam = param[key];
            if (Object.prototype.toString.call(tagParam) === '[object Array]' &&
                tagParam.length == 3) {
                var obj = _newObject(tagParam[2]);
                return new _DERTaggedObject({ tag: tagParam[0],
                    explicit: tagParam[1],
                    obj: obj });
            }
            else {
                var newParam = {};
                if (tagParam.explicit !== undefined)
                    newParam.explicit = tagParam.explicit;
                if (tagParam.tag !== undefined)
                    newParam.tag = tagParam.tag;
                if (tagParam.obj === undefined)
                    throw "obj shall be specified for 'tag'.";
                newParam.obj = _newObject(tagParam.obj);
                return new _DERTaggedObject(newParam);
            }
        }
    };
    /**
     * get encoded hexadecimal string of ASN1Object specifed by JSON parameters
     * @name jsonToASN1HEX
     * @memberOf KJUR.asn1.ASN1Util
     * @function
     * @param {Array} param JSON parameter to generate ASN1Object
     * @return hexadecimal string of ASN1Object
     * @since asn1 1.0.4
     * @description
     * As for ASN.1 object representation of JSON object,
     * please see {@link newObject}.
     * @example
     * jsonToASN1HEX({'prnstr': 'aaa'});
     */
    this.jsonToASN1HEX = function (param) {
        var asn1Obj = this.newObject(param);
        return asn1Obj.getEncodedHex();
    };
};
/**
 * get dot noted oid number string from hexadecimal value of OID
 * @name oidHexToInt
 * @memberOf KJUR.asn1.ASN1Util
 * @function
 * @param {String} hex hexadecimal value of object identifier
 * @return {String} dot noted string of object identifier
 * @since jsrsasign 4.8.3 asn1 1.0.7
 * @description
 * This static method converts from hexadecimal string representation of
 * ASN.1 value of object identifier to oid number string.
 * @example
 * KJUR.asn1.ASN1Util.oidHexToInt('550406') &rarr; "2.5.4.6"
 */
KJUR.asn1.ASN1Util.oidHexToInt = function (hex) {
    var s = "";
    var i01 = parseInt(hex.substr(0, 2), 16);
    var i0 = Math.floor(i01 / 40);
    var i1 = i01 % 40;
    var s = i0 + "." + i1;
    var binbuf = "";
    for (var i = 2; i < hex.length; i += 2) {
        var value = parseInt(hex.substr(i, 2), 16);
        var bin = ("00000000" + value.toString(2)).slice(-8);
        binbuf = binbuf + bin.substr(1, 7);
        if (bin.substr(0, 1) == "0") {
            var bi = new BigInteger(binbuf, 2);
            s = s + "." + bi.toString(10);
            binbuf = "";
        }
    }
    ;
    return s;
};
/**
 * get hexadecimal value of object identifier from dot noted oid value
 * @name oidIntToHex
 * @memberOf KJUR.asn1.ASN1Util
 * @function
 * @param {String} oidString dot noted string of object identifier
 * @return {String} hexadecimal value of object identifier
 * @since jsrsasign 4.8.3 asn1 1.0.7
 * @description
 * This static method converts from object identifier value string.
 * to hexadecimal string representation of it.
 * @example
 * KJUR.asn1.ASN1Util.oidIntToHex("2.5.4.6") &rarr; "550406"
 */
KJUR.asn1.ASN1Util.oidIntToHex = function (oidString) {
    var itox = function (i) {
        var h = i.toString(16);
        if (h.length == 1)
            h = '0' + h;
        return h;
    };
    var roidtox = function (roid) {
        var h = '';
        var bi = new BigInteger(roid, 10);
        var b = bi.toString(2);
        var padLen = 7 - b.length % 7;
        if (padLen == 7)
            padLen = 0;
        var bPad = '';
        for (var i = 0; i < padLen; i++)
            bPad += '0';
        b = bPad + b;
        for (var i = 0; i < b.length - 1; i += 7) {
            var b8 = b.substr(i, 7);
            if (i != b.length - 7)
                b8 = '1' + b8;
            h += itox(parseInt(b8, 2));
        }
        return h;
    };
    if (!oidString.match(/^[0-9.]+$/)) {
        throw "malformed oid string: " + oidString;
    }
    var h = '';
    var a = oidString.split('.');
    var i0 = parseInt(a[0]) * 40 + parseInt(a[1]);
    h += itox(i0);
    a.splice(0, 2);
    for (var i = 0; i < a.length; i++) {
        h += roidtox(a[i]);
    }
    return h;
};
// ********************************************************************
//  Abstract ASN.1 Classes
// ********************************************************************
// ********************************************************************
/**
 * base class for ASN.1 DER encoder object
 * @name KJUR.asn1.ASN1Object
 * @class base class for ASN.1 DER encoder object
 * @property {Boolean} isModified flag whether internal data was changed
 * @property {String} hTLV hexadecimal string of ASN.1 TLV
 * @property {String} hT hexadecimal string of ASN.1 TLV tag(T)
 * @property {String} hL hexadecimal string of ASN.1 TLV length(L)
 * @property {String} hV hexadecimal string of ASN.1 TLV value(V)
 * @description
 */
KJUR.asn1.ASN1Object = function () {
    var isModified = true;
    var hTLV = null;
    var hT = '00';
    var hL = '00';
    var hV = '';
    /**
     * get hexadecimal ASN.1 TLV length(L) bytes from TLV value(V)
     * @name getLengthHexFromValue
     * @memberOf KJUR.asn1.ASN1Object#
     * @function
     * @return {String} hexadecimal string of ASN.1 TLV length(L)
     */
    this.getLengthHexFromValue = function () {
        if (typeof this.hV == "undefined" || this.hV == null) {
            throw "this.hV is null or undefined.";
        }
        if (this.hV.length % 2 == 1) {
            throw "value hex must be even length: n=" + hV.length + ",v=" + this.hV;
        }
        var n = this.hV.length / 2;
        var hN = n.toString(16);
        if (hN.length % 2 == 1) {
            hN = "0" + hN;
        }
        if (n < 128) {
            return hN;
        }
        else {
            var hNlen = hN.length / 2;
            if (hNlen > 15) {
                throw "ASN.1 length too long to represent by 8x: n = " + n.toString(16);
            }
            var head = 128 + hNlen;
            return head.toString(16) + hN;
        }
    };
    /**
     * get hexadecimal string of ASN.1 TLV bytes
     * @name getEncodedHex
     * @memberOf KJUR.asn1.ASN1Object#
     * @function
     * @return {String} hexadecimal string of ASN.1 TLV
     */
    this.getEncodedHex = function () {
        if (this.hTLV == null || this.isModified) {
            this.hV = this.getFreshValueHex();
            this.hL = this.getLengthHexFromValue();
            this.hTLV = this.hT + this.hL + this.hV;
            this.isModified = false;
            //alert("first time: " + this.hTLV);
        }
        return this.hTLV;
    };
    /**
     * get hexadecimal string of ASN.1 TLV value(V) bytes
     * @name getValueHex
     * @memberOf KJUR.asn1.ASN1Object#
     * @function
     * @return {String} hexadecimal string of ASN.1 TLV value(V) bytes
     */
    this.getValueHex = function () {
        this.getEncodedHex();
        return this.hV;
    };
    this.getFreshValueHex = function () {
        return '';
    };
};
// == BEGIN DERAbstractString ================================================
/**
 * base class for ASN.1 DER string classes
 * @name KJUR.asn1.DERAbstractString
 * @class base class for ASN.1 DER string classes
 * @param {Array} params associative array of parameters (ex. {'str': 'aaa'})
 * @property {String} s internal string of value
 * @extends KJUR.asn1.ASN1Object
 * @description
 * <br/>
 * As for argument 'params' for constructor, you can specify one of
 * following properties:
 * <ul>
 * <li>str - specify initial ASN.1 value(V) by a string</li>
 * <li>hex - specify initial ASN.1 value(V) by a hexadecimal string</li>
 * </ul>
 * NOTE: 'params' can be omitted.
 */
KJUR.asn1.DERAbstractString = function (params) {
    KJUR.asn1.DERAbstractString.superclass.constructor.call(this);
    var s = null;
    var hV = null;
    /**
     * get string value of this string object
     * @name getString
     * @memberOf KJUR.asn1.DERAbstractString#
     * @function
     * @return {String} string value of this string object
     */
    this.getString = function () {
        return this.s;
    };
    /**
     * set value by a string
     * @name setString
     * @memberOf KJUR.asn1.DERAbstractString#
     * @function
     * @param {String} newS value by a string to set
     */
    this.setString = function (newS) {
        this.hTLV = null;
        this.isModified = true;
        this.s = newS;
        this.hV = stohex(this.s);
    };
    /**
     * set value by a hexadecimal string
     * @name setStringHex
     * @memberOf KJUR.asn1.DERAbstractString#
     * @function
     * @param {String} newHexString value by a hexadecimal string to set
     */
    this.setStringHex = function (newHexString) {
        this.hTLV = null;
        this.isModified = true;
        this.s = null;
        this.hV = newHexString;
    };
    this.getFreshValueHex = function () {
        return this.hV;
    };
    if (typeof params != "undefined") {
        if (typeof params == "string") {
            this.setString(params);
        }
        else if (typeof params['str'] != "undefined") {
            this.setString(params['str']);
        }
        else if (typeof params['hex'] != "undefined") {
            this.setStringHex(params['hex']);
        }
    }
};
YAHOO.lang.extend(KJUR.asn1.DERAbstractString, KJUR.asn1.ASN1Object);
// == END   DERAbstractString ================================================
// == BEGIN DERAbstractTime ==================================================
/**
 * base class for ASN.1 DER Generalized/UTCTime class
 * @name KJUR.asn1.DERAbstractTime
 * @class base class for ASN.1 DER Generalized/UTCTime class
 * @param {Array} params associative array of parameters (ex. {'str': '130430235959Z'})
 * @extends KJUR.asn1.ASN1Object
 * @description
 * @see KJUR.asn1.ASN1Object - superclass
 */
KJUR.asn1.DERAbstractTime = function (params) {
    KJUR.asn1.DERAbstractTime.superclass.constructor.call(this);
    var s = null;
    var date = null;
    // --- PRIVATE METHODS --------------------
    this.localDateToUTC = function (d) {
        utc = d.getTime() + (d.getTimezoneOffset() * 60000);
        var utcDate = new Date(utc);
        return utcDate;
    };
    /*
     * format date string by Data object
     * @name formatDate
     * @memberOf KJUR.asn1.AbstractTime;
     * @param {Date} dateObject
     * @param {string} type 'utc' or 'gen'
     * @param {boolean} withMillis flag for with millisections or not
     * @description
     * 'withMillis' flag is supported from asn1 1.0.6.
     */
    this.formatDate = function (dateObject, type, withMillis) {
        var pad = this.zeroPadding;
        var d = this.localDateToUTC(dateObject);
        var year = String(d.getFullYear());
        if (type == 'utc')
            year = year.substr(2, 2);
        var month = pad(String(d.getMonth() + 1), 2);
        var day = pad(String(d.getDate()), 2);
        var hour = pad(String(d.getHours()), 2);
        var min = pad(String(d.getMinutes()), 2);
        var sec = pad(String(d.getSeconds()), 2);
        var s = year + month + day + hour + min + sec;
        if (withMillis === true) {
            var millis = d.getMilliseconds();
            if (millis != 0) {
                var sMillis = pad(String(millis), 3);
                sMillis = sMillis.replace(/[0]+$/, "");
                s = s + "." + sMillis;
            }
        }
        return s + "Z";
    };
    this.zeroPadding = function (s, len) {
        if (s.length >= len)
            return s;
        return new Array(len - s.length + 1).join('0') + s;
    };
    // --- PUBLIC METHODS --------------------
    /**
     * get string value of this string object
     * @name getString
     * @memberOf KJUR.asn1.DERAbstractTime#
     * @function
     * @return {String} string value of this time object
     */
    this.getString = function () {
        return this.s;
    };
    /**
     * set value by a string
     * @name setString
     * @memberOf KJUR.asn1.DERAbstractTime#
     * @function
     * @param {String} newS value by a string to set such like "130430235959Z"
     */
    this.setString = function (newS) {
        this.hTLV = null;
        this.isModified = true;
        this.s = newS;
        this.hV = stohex(newS);
    };
    /**
     * set value by a Date object
     * @name setByDateValue
     * @memberOf KJUR.asn1.DERAbstractTime#
     * @function
     * @param {Integer} year year of date (ex. 2013)
     * @param {Integer} month month of date between 1 and 12 (ex. 12)
     * @param {Integer} day day of month
     * @param {Integer} hour hours of date
     * @param {Integer} min minutes of date
     * @param {Integer} sec seconds of date
     */
    this.setByDateValue = function (year, month, day, hour, min, sec) {
        var dateObject = new Date(Date.UTC(year, month - 1, day, hour, min, sec, 0));
        this.setByDate(dateObject);
    };
    this.getFreshValueHex = function () {
        return this.hV;
    };
};
YAHOO.lang.extend(KJUR.asn1.DERAbstractTime, KJUR.asn1.ASN1Object);
// == END   DERAbstractTime ==================================================
// == BEGIN DERAbstractStructured ============================================
/**
 * base class for ASN.1 DER structured class
 * @name KJUR.asn1.DERAbstractStructured
 * @class base class for ASN.1 DER structured class
 * @property {Array} asn1Array internal array of ASN1Object
 * @extends KJUR.asn1.ASN1Object
 * @description
 * @see KJUR.asn1.ASN1Object - superclass
 */
KJUR.asn1.DERAbstractStructured = function (params) {
    KJUR.asn1.DERAbstractString.superclass.constructor.call(this);
    var asn1Array = null;
    /**
     * set value by array of ASN1Object
     * @name setByASN1ObjectArray
     * @memberOf KJUR.asn1.DERAbstractStructured#
     * @function
     * @param {array} asn1ObjectArray array of ASN1Object to set
     */
    this.setByASN1ObjectArray = function (asn1ObjectArray) {
        this.hTLV = null;
        this.isModified = true;
        this.asn1Array = asn1ObjectArray;
    };
    /**
     * append an ASN1Object to internal array
     * @name appendASN1Object
     * @memberOf KJUR.asn1.DERAbstractStructured#
     * @function
     * @param {ASN1Object} asn1Object to add
     */
    this.appendASN1Object = function (asn1Object) {
        this.hTLV = null;
        this.isModified = true;
        this.asn1Array.push(asn1Object);
    };
    this.asn1Array = new Array();
    if (typeof params != "undefined") {
        if (typeof params['array'] != "undefined") {
            this.asn1Array = params['array'];
        }
    }
};
YAHOO.lang.extend(KJUR.asn1.DERAbstractStructured, KJUR.asn1.ASN1Object);
// ********************************************************************
//  ASN.1 Object Classes
// ********************************************************************
// ********************************************************************
/**
 * class for ASN.1 DER Boolean
 * @name KJUR.asn1.DERBoolean
 * @class class for ASN.1 DER Boolean
 * @extends KJUR.asn1.ASN1Object
 * @description
 * @see KJUR.asn1.ASN1Object - superclass
 */
KJUR.asn1.DERBoolean = function () {
    KJUR.asn1.DERBoolean.superclass.constructor.call(this);
    this.hT = "01";
    this.hTLV = "0101ff";
};
YAHOO.lang.extend(KJUR.asn1.DERBoolean, KJUR.asn1.ASN1Object);
// ********************************************************************
/**
 * class for ASN.1 DER Integer
 * @name KJUR.asn1.DERInteger
 * @class class for ASN.1 DER Integer
 * @extends KJUR.asn1.ASN1Object
 * @description
 * <br/>
 * As for argument 'params' for constructor, you can specify one of
 * following properties:
 * <ul>
 * <li>int - specify initial ASN.1 value(V) by integer value</li>
 * <li>bigint - specify initial ASN.1 value(V) by BigInteger object</li>
 * <li>hex - specify initial ASN.1 value(V) by a hexadecimal string</li>
 * </ul>
 * NOTE: 'params' can be omitted.
 */
KJUR.asn1.DERInteger = function (params) {
    KJUR.asn1.DERInteger.superclass.constructor.call(this);
    this.hT = "02";
    /**
     * set value by Tom Wu's BigInteger object
     * @name setByBigInteger
     * @memberOf KJUR.asn1.DERInteger#
     * @function
     * @param {BigInteger} bigIntegerValue to set
     */
    this.setByBigInteger = function (bigIntegerValue) {
        this.hTLV = null;
        this.isModified = true;
        this.hV = KJUR.asn1.ASN1Util.bigIntToMinTwosComplementsHex(bigIntegerValue);
    };
    /**
     * set value by integer value
     * @name setByInteger
     * @memberOf KJUR.asn1.DERInteger
     * @function
     * @param {Integer} integer value to set
     */
    this.setByInteger = function (intValue) {
        var bi = new BigInteger(String(intValue), 10);
        this.setByBigInteger(bi);
    };
    /**
     * set value by integer value
     * @name setValueHex
     * @memberOf KJUR.asn1.DERInteger#
     * @function
     * @param {String} hexadecimal string of integer value
     * @description
     * <br/>
     * NOTE: Value shall be represented by minimum octet length of
     * two's complement representation.
     * @example
     * new KJUR.asn1.DERInteger(123);
     * new KJUR.asn1.DERInteger({'int': 123});
     * new KJUR.asn1.DERInteger({'hex': '1fad'});
     */
    this.setValueHex = function (newHexString) {
        this.hV = newHexString;
    };
    this.getFreshValueHex = function () {
        return this.hV;
    };
    if (typeof params != "undefined") {
        if (typeof params['bigint'] != "undefined") {
            this.setByBigInteger(params['bigint']);
        }
        else if (typeof params['int'] != "undefined") {
            this.setByInteger(params['int']);
        }
        else if (typeof params == "number") {
            this.setByInteger(params);
        }
        else if (typeof params['hex'] != "undefined") {
            this.setValueHex(params['hex']);
        }
    }
};
YAHOO.lang.extend(KJUR.asn1.DERInteger, KJUR.asn1.ASN1Object);
// ********************************************************************
/**
 * class for ASN.1 DER encoded BitString primitive
 * @name KJUR.asn1.DERBitString
 * @class class for ASN.1 DER encoded BitString primitive
 * @extends KJUR.asn1.ASN1Object
 * @description
 * <br/>
 * As for argument 'params' for constructor, you can specify one of
 * following properties:
 * <ul>
 * <li>bin - specify binary string (ex. '10111')</li>
 * <li>array - specify array of boolean (ex. [true,false,true,true])</li>
 * <li>hex - specify hexadecimal string of ASN.1 value(V) including unused bits</li>
 * <li>obj - specify {@link KJUR.asn1.ASN1Util.newObject}
 * argument for "BitString encapsulates" structure.</li>
 * </ul>
 * NOTE1: 'params' can be omitted.<br/>
 * NOTE2: 'obj' parameter have been supported since
 * asn1 1.0.11, jsrsasign 6.1.1 (2016-Sep-25).<br/>
 * @example
 * // default constructor
 * o = new KJUR.asn1.DERBitString();
 * // initialize with binary string
 * o = new KJUR.asn1.DERBitString({bin: "1011"});
 * // initialize with boolean array
 * o = new KJUR.asn1.DERBitString({array: [true,false,true,true]});
 * // initialize with hexadecimal string (04 is unused bits)
 * o = new KJUR.asn1.DEROctetString({hex: "04bac0"});
 * // initialize with ASN1Util.newObject argument for encapsulated
 * o = new KJUR.asn1.DERBitString({obj: {seq: [{int: 3}, {prnstr: 'aaa'}]}});
 * // above generates a ASN.1 data like this:
 * // BIT STRING, encapsulates {
 * //   SEQUENCE {
 * //     INTEGER 3
 * //     PrintableString 'aaa'
 * //     }
 * //   }
 */
KJUR.asn1.DERBitString = function (params) {
    if (params !== undefined && typeof params.obj !== "undefined") {
        var o = KJUR.asn1.ASN1Util.newObject(params.obj);
        params.hex = "00" + o.getEncodedHex();
    }
    KJUR.asn1.DERBitString.superclass.constructor.call(this);
    this.hT = "03";
    /**
     * set ASN.1 value(V) by a hexadecimal string including unused bits
     * @name setHexValueIncludingUnusedBits
     * @memberOf KJUR.asn1.DERBitString#
     * @function
     * @param {String} newHexStringIncludingUnusedBits
     */
    this.setHexValueIncludingUnusedBits = function (newHexStringIncludingUnusedBits) {
        this.hTLV = null;
        this.isModified = true;
        this.hV = newHexStringIncludingUnusedBits;
    };
    /**
     * set ASN.1 value(V) by unused bit and hexadecimal string of value
     * @name setUnusedBitsAndHexValue
     * @memberOf KJUR.asn1.DERBitString#
     * @function
     * @param {Integer} unusedBits
     * @param {String} hValue
     */
    this.setUnusedBitsAndHexValue = function (unusedBits, hValue) {
        if (unusedBits < 0 || 7 < unusedBits) {
            throw "unused bits shall be from 0 to 7: u = " + unusedBits;
        }
        var hUnusedBits = "0" + unusedBits;
        this.hTLV = null;
        this.isModified = true;
        this.hV = hUnusedBits + hValue;
    };
    /**
     * set ASN.1 DER BitString by binary string<br/>
     * @name setByBinaryString
     * @memberOf KJUR.asn1.DERBitString#
     * @function
     * @param {String} binaryString binary value string (i.e. '10111')
     * @description
     * Its unused bits will be calculated automatically by length of
     * 'binaryValue'. <br/>
     * NOTE: Trailing zeros '0' will be ignored.
     * @example
     * o = new KJUR.asn1.DERBitString();
     * o.setByBooleanArray("01011");
     */
    this.setByBinaryString = function (binaryString) {
        binaryString = binaryString.replace(/0+$/, '');
        var unusedBits = 8 - binaryString.length % 8;
        if (unusedBits == 8)
            unusedBits = 0;
        for (var i = 0; i <= unusedBits; i++) {
            binaryString += '0';
        }
        var h = '';
        for (var i = 0; i < binaryString.length - 1; i += 8) {
            var b = binaryString.substr(i, 8);
            var x = parseInt(b, 2).toString(16);
            if (x.length == 1)
                x = '0' + x;
            h += x;
        }
        this.hTLV = null;
        this.isModified = true;
        this.hV = '0' + unusedBits + h;
    };
    /**
     * set ASN.1 TLV value(V) by an array of boolean<br/>
     * @name setByBooleanArray
     * @memberOf KJUR.asn1.DERBitString#
     * @function
     * @param {array} booleanArray array of boolean (ex. [true, false, true])
     * @description
     * NOTE: Trailing falses will be ignored in the ASN.1 DER Object.
     * @example
     * o = new KJUR.asn1.DERBitString();
     * o.setByBooleanArray([false, true, false, true, true]);
     */
    this.setByBooleanArray = function (booleanArray) {
        var s = '';
        for (var i = 0; i < booleanArray.length; i++) {
            if (booleanArray[i] == true) {
                s += '1';
            }
            else {
                s += '0';
            }
        }
        this.setByBinaryString(s);
    };
    /**
     * generate an array of falses with specified length<br/>
     * @name newFalseArray
     * @memberOf KJUR.asn1.DERBitString
     * @function
     * @param {Integer} nLength length of array to generate
     * @return {array} array of boolean falses
     * @description
     * This static method may be useful to initialize boolean array.
     * @example
     * o = new KJUR.asn1.DERBitString();
     * o.newFalseArray(3) &rarr; [false, false, false]
     */
    this.newFalseArray = function (nLength) {
        var a = new Array(nLength);
        for (var i = 0; i < nLength; i++) {
            a[i] = false;
        }
        return a;
    };
    this.getFreshValueHex = function () {
        return this.hV;
    };
    if (typeof params != "undefined") {
        if (typeof params == "string" && params.toLowerCase().match(/^[0-9a-f]+$/)) {
            this.setHexValueIncludingUnusedBits(params);
        }
        else if (typeof params['hex'] != "undefined") {
            this.setHexValueIncludingUnusedBits(params['hex']);
        }
        else if (typeof params['bin'] != "undefined") {
            this.setByBinaryString(params['bin']);
        }
        else if (typeof params['array'] != "undefined") {
            this.setByBooleanArray(params['array']);
        }
    }
};
YAHOO.lang.extend(KJUR.asn1.DERBitString, KJUR.asn1.ASN1Object);
// ********************************************************************
/**
 * class for ASN.1 DER OctetString<br/>
 * @name KJUR.asn1.DEROctetString
 * @class class for ASN.1 DER OctetString
 * @param {Array} params associative array of parameters (ex. {'str': 'aaa'})
 * @extends KJUR.asn1.DERAbstractString
 * @description
 * This class provides ASN.1 OctetString simple type.<br/>
 * Supported "params" attributes are:
 * <ul>
 * <li>str - to set a string as a value</li>
 * <li>hex - to set a hexadecimal string as a value</li>
 * <li>obj - to set a encapsulated ASN.1 value by JSON object
 * which is defined in {@link KJUR.asn1.ASN1Util.newObject}</li>
 * </ul>
 * NOTE: A parameter 'obj' have been supported
 * for "OCTET STRING, encapsulates" structure.
 * since asn1 1.0.11, jsrsasign 6.1.1 (2016-Sep-25).
 * @see KJUR.asn1.DERAbstractString - superclass
 * @example
 * // default constructor
 * o = new KJUR.asn1.DEROctetString();
 * // initialize with string
 * o = new KJUR.asn1.DEROctetString({str: "aaa"});
 * // initialize with hexadecimal string
 * o = new KJUR.asn1.DEROctetString({hex: "616161"});
 * // initialize with ASN1Util.newObject argument
 * o = new KJUR.asn1.DEROctetString({obj: {seq: [{int: 3}, {prnstr: 'aaa'}]}});
 * // above generates a ASN.1 data like this:
 * // OCTET STRING, encapsulates {
 * //   SEQUENCE {
 * //     INTEGER 3
 * //     PrintableString 'aaa'
 * //     }
 * //   }
 */
KJUR.asn1.DEROctetString = function (params) {
    if (params !== undefined && typeof params.obj !== "undefined") {
        var o = KJUR.asn1.ASN1Util.newObject(params.obj);
        params.hex = o.getEncodedHex();
    }
    KJUR.asn1.DEROctetString.superclass.constructor.call(this, params);
    this.hT = "04";
};
YAHOO.lang.extend(KJUR.asn1.DEROctetString, KJUR.asn1.DERAbstractString);
// ********************************************************************
/**
 * class for ASN.1 DER Null
 * @name KJUR.asn1.DERNull
 * @class class for ASN.1 DER Null
 * @extends KJUR.asn1.ASN1Object
 * @description
 * @see KJUR.asn1.ASN1Object - superclass
 */
KJUR.asn1.DERNull = function () {
    KJUR.asn1.DERNull.superclass.constructor.call(this);
    this.hT = "05";
    this.hTLV = "0500";
};
YAHOO.lang.extend(KJUR.asn1.DERNull, KJUR.asn1.ASN1Object);
// ********************************************************************
/**
 * class for ASN.1 DER ObjectIdentifier
 * @name KJUR.asn1.DERObjectIdentifier
 * @class class for ASN.1 DER ObjectIdentifier
 * @param {Array} params associative array of parameters (ex. {'oid': '2.5.4.5'})
 * @extends KJUR.asn1.ASN1Object
 * @description
 * <br/>
 * As for argument 'params' for constructor, you can specify one of
 * following properties:
 * <ul>
 * <li>oid - specify initial ASN.1 value(V) by a oid string (ex. 2.5.4.13)</li>
 * <li>hex - specify initial ASN.1 value(V) by a hexadecimal string</li>
 * </ul>
 * NOTE: 'params' can be omitted.
 */
KJUR.asn1.DERObjectIdentifier = function (params) {
    var itox = function (i) {
        var h = i.toString(16);
        if (h.length == 1)
            h = '0' + h;
        return h;
    };
    var roidtox = function (roid) {
        var h = '';
        var bi = new BigInteger(roid, 10);
        var b = bi.toString(2);
        var padLen = 7 - b.length % 7;
        if (padLen == 7)
            padLen = 0;
        var bPad = '';
        for (var i = 0; i < padLen; i++)
            bPad += '0';
        b = bPad + b;
        for (var i = 0; i < b.length - 1; i += 7) {
            var b8 = b.substr(i, 7);
            if (i != b.length - 7)
                b8 = '1' + b8;
            h += itox(parseInt(b8, 2));
        }
        return h;
    };
    KJUR.asn1.DERObjectIdentifier.superclass.constructor.call(this);
    this.hT = "06";
    /**
     * set value by a hexadecimal string
     * @name setValueHex
     * @memberOf KJUR.asn1.DERObjectIdentifier#
     * @function
     * @param {String} newHexString hexadecimal value of OID bytes
     */
    this.setValueHex = function (newHexString) {
        this.hTLV = null;
        this.isModified = true;
        this.s = null;
        this.hV = newHexString;
    };
    /**
     * set value by a OID string<br/>
     * @name setValueOidString
     * @memberOf KJUR.asn1.DERObjectIdentifier#
     * @function
     * @param {String} oidString OID string (ex. 2.5.4.13)
     * @example
     * o = new KJUR.asn1.DERObjectIdentifier();
     * o.setValueOidString("2.5.4.13");
     */
    this.setValueOidString = function (oidString) {
        if (!oidString.match(/^[0-9.]+$/)) {
            throw "malformed oid string: " + oidString;
        }
        var h = '';
        var a = oidString.split('.');
        var i0 = parseInt(a[0]) * 40 + parseInt(a[1]);
        h += itox(i0);
        a.splice(0, 2);
        for (var i = 0; i < a.length; i++) {
            h += roidtox(a[i]);
        }
        this.hTLV = null;
        this.isModified = true;
        this.s = null;
        this.hV = h;
    };
    /**
     * set value by a OID name
     * @name setValueName
     * @memberOf KJUR.asn1.DERObjectIdentifier#
     * @function
     * @param {String} oidName OID name (ex. 'serverAuth')
     * @since 1.0.1
     * @description
     * OID name shall be defined in 'KJUR.asn1.x509.OID.name2oidList'.
     * Otherwise raise error.
     * @example
     * o = new KJUR.asn1.DERObjectIdentifier();
     * o.setValueName("serverAuth");
     */
    this.setValueName = function (oidName) {
        var oid = KJUR.asn1.x509.OID.name2oid(oidName);
        if (oid !== '') {
            this.setValueOidString(oid);
        }
        else {
            throw "DERObjectIdentifier oidName undefined: " + oidName;
        }
    };
    this.getFreshValueHex = function () {
        return this.hV;
    };
    if (params !== undefined) {
        if (typeof params === "string") {
            if (params.match(/^[0-2].[0-9.]+$/)) {
                this.setValueOidString(params);
            }
            else {
                this.setValueName(params);
            }
        }
        else if (params.oid !== undefined) {
            this.setValueOidString(params.oid);
        }
        else if (params.hex !== undefined) {
            this.setValueHex(params.hex);
        }
        else if (params.name !== undefined) {
            this.setValueName(params.name);
        }
    }
};
YAHOO.lang.extend(KJUR.asn1.DERObjectIdentifier, KJUR.asn1.ASN1Object);
// ********************************************************************
/**
 * class for ASN.1 DER Enumerated
 * @name KJUR.asn1.DEREnumerated
 * @class class for ASN.1 DER Enumerated
 * @extends KJUR.asn1.ASN1Object
 * @description
 * <br/>
 * As for argument 'params' for constructor, you can specify one of
 * following properties:
 * <ul>
 * <li>int - specify initial ASN.1 value(V) by integer value</li>
 * <li>hex - specify initial ASN.1 value(V) by a hexadecimal string</li>
 * </ul>
 * NOTE: 'params' can be omitted.
 * @example
 * new KJUR.asn1.DEREnumerated(123);
 * new KJUR.asn1.DEREnumerated({int: 123});
 * new KJUR.asn1.DEREnumerated({hex: '1fad'});
 */
KJUR.asn1.DEREnumerated = function (params) {
    KJUR.asn1.DEREnumerated.superclass.constructor.call(this);
    this.hT = "0a";
    /**
     * set value by Tom Wu's BigInteger object
     * @name setByBigInteger
     * @memberOf KJUR.asn1.DEREnumerated#
     * @function
     * @param {BigInteger} bigIntegerValue to set
     */
    this.setByBigInteger = function (bigIntegerValue) {
        this.hTLV = null;
        this.isModified = true;
        this.hV = KJUR.asn1.ASN1Util.bigIntToMinTwosComplementsHex(bigIntegerValue);
    };
    /**
     * set value by integer value
     * @name setByInteger
     * @memberOf KJUR.asn1.DEREnumerated#
     * @function
     * @param {Integer} integer value to set
     */
    this.setByInteger = function (intValue) {
        var bi = new BigInteger(String(intValue), 10);
        this.setByBigInteger(bi);
    };
    /**
     * set value by integer value
     * @name setValueHex
     * @memberOf KJUR.asn1.DEREnumerated#
     * @function
     * @param {String} hexadecimal string of integer value
     * @description
     * <br/>
     * NOTE: Value shall be represented by minimum octet length of
     * two's complement representation.
     */
    this.setValueHex = function (newHexString) {
        this.hV = newHexString;
    };
    this.getFreshValueHex = function () {
        return this.hV;
    };
    if (typeof params != "undefined") {
        if (typeof params['int'] != "undefined") {
            this.setByInteger(params['int']);
        }
        else if (typeof params == "number") {
            this.setByInteger(params);
        }
        else if (typeof params['hex'] != "undefined") {
            this.setValueHex(params['hex']);
        }
    }
};
YAHOO.lang.extend(KJUR.asn1.DEREnumerated, KJUR.asn1.ASN1Object);
// ********************************************************************
/**
 * class for ASN.1 DER UTF8String
 * @name KJUR.asn1.DERUTF8String
 * @class class for ASN.1 DER UTF8String
 * @param {Array} params associative array of parameters (ex. {'str': 'aaa'})
 * @extends KJUR.asn1.DERAbstractString
 * @description
 * @see KJUR.asn1.DERAbstractString - superclass
 */
KJUR.asn1.DERUTF8String = function (params) {
    KJUR.asn1.DERUTF8String.superclass.constructor.call(this, params);
    this.hT = "0c";
};
YAHOO.lang.extend(KJUR.asn1.DERUTF8String, KJUR.asn1.DERAbstractString);
// ********************************************************************
/**
 * class for ASN.1 DER NumericString
 * @name KJUR.asn1.DERNumericString
 * @class class for ASN.1 DER NumericString
 * @param {Array} params associative array of parameters (ex. {'str': 'aaa'})
 * @extends KJUR.asn1.DERAbstractString
 * @description
 * @see KJUR.asn1.DERAbstractString - superclass
 */
KJUR.asn1.DERNumericString = function (params) {
    KJUR.asn1.DERNumericString.superclass.constructor.call(this, params);
    this.hT = "12";
};
YAHOO.lang.extend(KJUR.asn1.DERNumericString, KJUR.asn1.DERAbstractString);
// ********************************************************************
/**
 * class for ASN.1 DER PrintableString
 * @name KJUR.asn1.DERPrintableString
 * @class class for ASN.1 DER PrintableString
 * @param {Array} params associative array of parameters (ex. {'str': 'aaa'})
 * @extends KJUR.asn1.DERAbstractString
 * @description
 * @see KJUR.asn1.DERAbstractString - superclass
 */
KJUR.asn1.DERPrintableString = function (params) {
    KJUR.asn1.DERPrintableString.superclass.constructor.call(this, params);
    this.hT = "13";
};
YAHOO.lang.extend(KJUR.asn1.DERPrintableString, KJUR.asn1.DERAbstractString);
// ********************************************************************
/**
 * class for ASN.1 DER TeletexString
 * @name KJUR.asn1.DERTeletexString
 * @class class for ASN.1 DER TeletexString
 * @param {Array} params associative array of parameters (ex. {'str': 'aaa'})
 * @extends KJUR.asn1.DERAbstractString
 * @description
 * @see KJUR.asn1.DERAbstractString - superclass
 */
KJUR.asn1.DERTeletexString = function (params) {
    KJUR.asn1.DERTeletexString.superclass.constructor.call(this, params);
    this.hT = "14";
};
YAHOO.lang.extend(KJUR.asn1.DERTeletexString, KJUR.asn1.DERAbstractString);
// ********************************************************************
/**
 * class for ASN.1 DER IA5String
 * @name KJUR.asn1.DERIA5String
 * @class class for ASN.1 DER IA5String
 * @param {Array} params associative array of parameters (ex. {'str': 'aaa'})
 * @extends KJUR.asn1.DERAbstractString
 * @description
 * @see KJUR.asn1.DERAbstractString - superclass
 */
KJUR.asn1.DERIA5String = function (params) {
    KJUR.asn1.DERIA5String.superclass.constructor.call(this, params);
    this.hT = "16";
};
YAHOO.lang.extend(KJUR.asn1.DERIA5String, KJUR.asn1.DERAbstractString);
// ********************************************************************
/**
 * class for ASN.1 DER UTCTime
 * @name KJUR.asn1.DERUTCTime
 * @class class for ASN.1 DER UTCTime
 * @param {Array} params associative array of parameters (ex. {'str': '130430235959Z'})
 * @extends KJUR.asn1.DERAbstractTime
 * @description
 * <br/>
 * As for argument 'params' for constructor, you can specify one of
 * following properties:
 * <ul>
 * <li>str - specify initial ASN.1 value(V) by a string (ex.'130430235959Z')</li>
 * <li>hex - specify initial ASN.1 value(V) by a hexadecimal string</li>
 * <li>date - specify Date object.</li>
 * </ul>
 * NOTE: 'params' can be omitted.
 * <h4>EXAMPLES</h4>
 * @example
 * d1 = new KJUR.asn1.DERUTCTime();
 * d1.setString('130430125959Z');
 *
 * d2 = new KJUR.asn1.DERUTCTime({'str': '130430125959Z'});
 * d3 = new KJUR.asn1.DERUTCTime({'date': new Date(Date.UTC(2015, 0, 31, 0, 0, 0, 0))});
 * d4 = new KJUR.asn1.DERUTCTime('130430125959Z');
 */
KJUR.asn1.DERUTCTime = function (params) {
    KJUR.asn1.DERUTCTime.superclass.constructor.call(this, params);
    this.hT = "17";
    /**
     * set value by a Date object<br/>
     * @name setByDate
     * @memberOf KJUR.asn1.DERUTCTime#
     * @function
     * @param {Date} dateObject Date object to set ASN.1 value(V)
     * @example
     * o = new KJUR.asn1.DERUTCTime();
     * o.setByDate(new Date("2016/12/31"));
     */
    this.setByDate = function (dateObject) {
        this.hTLV = null;
        this.isModified = true;
        this.date = dateObject;
        this.s = this.formatDate(this.date, 'utc');
        this.hV = stohex(this.s);
    };
    this.getFreshValueHex = function () {
        if (typeof this.date == "undefined" && typeof this.s == "undefined") {
            this.date = new Date();
            this.s = this.formatDate(this.date, 'utc');
            this.hV = stohex(this.s);
        }
        return this.hV;
    };
    if (params !== undefined) {
        if (params.str !== undefined) {
            this.setString(params.str);
        }
        else if (typeof params == "string" && params.match(/^[0-9]{12}Z$/)) {
            this.setString(params);
        }
        else if (params.hex !== undefined) {
            this.setStringHex(params.hex);
        }
        else if (params.date !== undefined) {
            this.setByDate(params.date);
        }
    }
};
YAHOO.lang.extend(KJUR.asn1.DERUTCTime, KJUR.asn1.DERAbstractTime);
// ********************************************************************
/**
 * class for ASN.1 DER GeneralizedTime
 * @name KJUR.asn1.DERGeneralizedTime
 * @class class for ASN.1 DER GeneralizedTime
 * @param {Array} params associative array of parameters (ex. {'str': '20130430235959Z'})
 * @property {Boolean} withMillis flag to show milliseconds or not
 * @extends KJUR.asn1.DERAbstractTime
 * @description
 * <br/>
 * As for argument 'params' for constructor, you can specify one of
 * following properties:
 * <ul>
 * <li>str - specify initial ASN.1 value(V) by a string (ex.'20130430235959Z')</li>
 * <li>hex - specify initial ASN.1 value(V) by a hexadecimal string</li>
 * <li>date - specify Date object.</li>
 * <li>millis - specify flag to show milliseconds (from 1.0.6)</li>
 * </ul>
 * NOTE1: 'params' can be omitted.
 * NOTE2: 'withMillis' property is supported from asn1 1.0.6.
 */
KJUR.asn1.DERGeneralizedTime = function (params) {
    KJUR.asn1.DERGeneralizedTime.superclass.constructor.call(this, params);
    this.hT = "18";
    this.withMillis = false;
    /**
     * set value by a Date object
     * @name setByDate
     * @memberOf KJUR.asn1.DERGeneralizedTime#
     * @function
     * @param {Date} dateObject Date object to set ASN.1 value(V)
     * @example
     * When you specify UTC time, use 'Date.UTC' method like this:<br/>
     * o1 = new DERUTCTime();
     * o1.setByDate(date);
     *
     * date = new Date(Date.UTC(2015, 0, 31, 23, 59, 59, 0)); #2015JAN31 23:59:59
     */
    this.setByDate = function (dateObject) {
        this.hTLV = null;
        this.isModified = true;
        this.date = dateObject;
        this.s = this.formatDate(this.date, 'gen', this.withMillis);
        this.hV = stohex(this.s);
    };
    this.getFreshValueHex = function () {
        if (this.date === undefined && this.s === undefined) {
            this.date = new Date();
            this.s = this.formatDate(this.date, 'gen', this.withMillis);
            this.hV = stohex(this.s);
        }
        return this.hV;
    };
    if (params !== undefined) {
        if (params.str !== undefined) {
            this.setString(params.str);
        }
        else if (typeof params == "string" && params.match(/^[0-9]{14}Z$/)) {
            this.setString(params);
        }
        else if (params.hex !== undefined) {
            this.setStringHex(params.hex);
        }
        else if (params.date !== undefined) {
            this.setByDate(params.date);
        }
        if (params.millis === true) {
            this.withMillis = true;
        }
    }
};
YAHOO.lang.extend(KJUR.asn1.DERGeneralizedTime, KJUR.asn1.DERAbstractTime);
// ********************************************************************
/**
 * class for ASN.1 DER Sequence
 * @name KJUR.asn1.DERSequence
 * @class class for ASN.1 DER Sequence
 * @extends KJUR.asn1.DERAbstractStructured
 * @description
 * <br/>
 * As for argument 'params' for constructor, you can specify one of
 * following properties:
 * <ul>
 * <li>array - specify array of ASN1Object to set elements of content</li>
 * </ul>
 * NOTE: 'params' can be omitted.
 */
KJUR.asn1.DERSequence = function (params) {
    KJUR.asn1.DERSequence.superclass.constructor.call(this, params);
    this.hT = "30";
    this.getFreshValueHex = function () {
        var h = '';
        for (var i = 0; i < this.asn1Array.length; i++) {
            var asn1Obj = this.asn1Array[i];
            h += asn1Obj.getEncodedHex();
        }
        this.hV = h;
        return this.hV;
    };
};
YAHOO.lang.extend(KJUR.asn1.DERSequence, KJUR.asn1.DERAbstractStructured);
// ********************************************************************
/**
 * class for ASN.1 DER Set
 * @name KJUR.asn1.DERSet
 * @class class for ASN.1 DER Set
 * @extends KJUR.asn1.DERAbstractStructured
 * @description
 * <br/>
 * As for argument 'params' for constructor, you can specify one of
 * following properties:
 * <ul>
 * <li>array - specify array of ASN1Object to set elements of content</li>
 * <li>sortflag - flag for sort (default: true). ASN.1 BER is not sorted in 'SET OF'.</li>
 * </ul>
 * NOTE1: 'params' can be omitted.<br/>
 * NOTE2: sortflag is supported since 1.0.5.
 */
KJUR.asn1.DERSet = function (params) {
    KJUR.asn1.DERSet.superclass.constructor.call(this, params);
    this.hT = "31";
    this.sortFlag = true; // item shall be sorted only in ASN.1 DER
    this.getFreshValueHex = function () {
        var a = new Array();
        for (var i = 0; i < this.asn1Array.length; i++) {
            var asn1Obj = this.asn1Array[i];
            a.push(asn1Obj.getEncodedHex());
        }
        if (this.sortFlag == true)
            a.sort();
        this.hV = a.join('');
        return this.hV;
    };
    if (typeof params != "undefined") {
        if (typeof params.sortflag != "undefined" &&
            params.sortflag == false)
            this.sortFlag = false;
    }
};
YAHOO.lang.extend(KJUR.asn1.DERSet, KJUR.asn1.DERAbstractStructured);
// ********************************************************************
/**
 * class for ASN.1 DER TaggedObject
 * @name KJUR.asn1.DERTaggedObject
 * @class class for ASN.1 DER TaggedObject
 * @extends KJUR.asn1.ASN1Object
 * @description
 * <br/>
 * Parameter 'tagNoNex' is ASN.1 tag(T) value for this object.
 * For example, if you find '[1]' tag in a ASN.1 dump,
 * 'tagNoHex' will be 'a1'.
 * <br/>
 * As for optional argument 'params' for constructor, you can specify *ANY* of
 * following properties:
 * <ul>
 * <li>explicit - specify true if this is explicit tag otherwise false
 *     (default is 'true').</li>
 * <li>tag - specify tag (default is 'a0' which means [0])</li>
 * <li>obj - specify ASN1Object which is tagged</li>
 * </ul>
 * @example
 * d1 = new KJUR.asn1.DERUTF8String({'str':'a'});
 * d2 = new KJUR.asn1.DERTaggedObject({'obj': d1});
 * hex = d2.getEncodedHex();
 */
KJUR.asn1.DERTaggedObject = function (params) {
    KJUR.asn1.DERTaggedObject.superclass.constructor.call(this);
    this.hT = "a0";
    this.hV = '';
    this.isExplicit = true;
    this.asn1Object = null;
    /**
     * set value by an ASN1Object
     * @name setString
     * @memberOf KJUR.asn1.DERTaggedObject#
     * @function
     * @param {Boolean} isExplicitFlag flag for explicit/implicit tag
     * @param {Integer} tagNoHex hexadecimal string of ASN.1 tag
     * @param {ASN1Object} asn1Object ASN.1 to encapsulate
     */
    this.setASN1Object = function (isExplicitFlag, tagNoHex, asn1Object) {
        this.hT = tagNoHex;
        this.isExplicit = isExplicitFlag;
        this.asn1Object = asn1Object;
        if (this.isExplicit) {
            this.hV = this.asn1Object.getEncodedHex();
            this.hTLV = null;
            this.isModified = true;
        }
        else {
            this.hV = null;
            this.hTLV = asn1Object.getEncodedHex();
            this.hTLV = this.hTLV.replace(/^../, tagNoHex);
            this.isModified = false;
        }
    };
    this.getFreshValueHex = function () {
        return this.hV;
    };
    if (typeof params != "undefined") {
        if (typeof params['tag'] != "undefined") {
            this.hT = params['tag'];
        }
        if (typeof params['explicit'] != "undefined") {
            this.isExplicit = params['explicit'];
        }
        if (typeof params['obj'] != "undefined") {
            this.asn1Object = params['obj'];
            this.setASN1Object(this.isExplicit, this.hT, this.asn1Object);
        }
    }
};
YAHOO.lang.extend(KJUR.asn1.DERTaggedObject, KJUR.asn1.ASN1Object);

;// CONCATENATED MODULE: ./node_modules/jsencrypt/lib/JSEncryptRSAKey.js
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();







/**
 * Create a new JSEncryptRSAKey that extends Tom Wu's RSA key object.
 * This object is just a decorator for parsing the key parameter
 * @param {string|Object} key - The key in string format, or an object containing
 * the parameters needed to build a RSAKey object.
 * @constructor
 */
var JSEncryptRSAKey = /** @class */ (function (_super) {
    __extends(JSEncryptRSAKey, _super);
    function JSEncryptRSAKey(key) {
        var _this = _super.call(this) || this;
        // Call the super constructor.
        //  RSAKey.call(this);
        // If a key key was provided.
        if (key) {
            // If this is a string...
            if (typeof key === "string") {
                _this.parseKey(key);
            }
            else if (JSEncryptRSAKey.hasPrivateKeyProperty(key) ||
                JSEncryptRSAKey.hasPublicKeyProperty(key)) {
                // Set the values for the key.
                _this.parsePropertiesFrom(key);
            }
        }
        return _this;
    }
    /**
     * Method to parse a pem encoded string containing both a public or private key.
     * The method will translate the pem encoded string in a der encoded string and
     * will parse private key and public key parameters. This method accepts public key
     * in the rsaencryption pkcs #1 format (oid: 1.2.840.113549.1.1.1).
     *
     * @todo Check how many rsa formats use the same format of pkcs #1.
     *
     * The format is defined as:
     * PublicKeyInfo ::= SEQUENCE {
     *   algorithm       AlgorithmIdentifier,
     *   PublicKey       BIT STRING
     * }
     * Where AlgorithmIdentifier is:
     * AlgorithmIdentifier ::= SEQUENCE {
     *   algorithm       OBJECT IDENTIFIER,     the OID of the enc algorithm
     *   parameters      ANY DEFINED BY algorithm OPTIONAL (NULL for PKCS #1)
     * }
     * and PublicKey is a SEQUENCE encapsulated in a BIT STRING
     * RSAPublicKey ::= SEQUENCE {
     *   modulus           INTEGER,  -- n
     *   publicExponent    INTEGER   -- e
     * }
     * it's possible to examine the structure of the keys obtained from openssl using
     * an asn.1 dumper as the one used here to parse the components: http://lapo.it/asn1js/
     * @argument {string} pem the pem encoded string, can include the BEGIN/END header/footer
     * @private
     */
    JSEncryptRSAKey.prototype.parseKey = function (pem) {
        try {
            var modulus = 0;
            var public_exponent = 0;
            var reHex = /^\s*(?:[0-9A-Fa-f][0-9A-Fa-f]\s*)+$/;
            var der = reHex.test(pem) ? Hex.decode(pem) : Base64.unarmor(pem);
            var asn1 = ASN1.decode(der);
            // Fixes a bug with OpenSSL 1.0+ private keys
            if (asn1.sub.length === 3) {
                asn1 = asn1.sub[2].sub[0];
            }
            if (asn1.sub.length === 9) {
                // Parse the private key.
                modulus = asn1.sub[1].getHexStringValue(); // bigint
                this.n = parseBigInt(modulus, 16);
                public_exponent = asn1.sub[2].getHexStringValue(); // int
                this.e = parseInt(public_exponent, 16);
                var private_exponent = asn1.sub[3].getHexStringValue(); // bigint
                this.d = parseBigInt(private_exponent, 16);
                var prime1 = asn1.sub[4].getHexStringValue(); // bigint
                this.p = parseBigInt(prime1, 16);
                var prime2 = asn1.sub[5].getHexStringValue(); // bigint
                this.q = parseBigInt(prime2, 16);
                var exponent1 = asn1.sub[6].getHexStringValue(); // bigint
                this.dmp1 = parseBigInt(exponent1, 16);
                var exponent2 = asn1.sub[7].getHexStringValue(); // bigint
                this.dmq1 = parseBigInt(exponent2, 16);
                var coefficient = asn1.sub[8].getHexStringValue(); // bigint
                this.coeff = parseBigInt(coefficient, 16);
            }
            else if (asn1.sub.length === 2) {
                if (asn1.sub[0].sub) {
                    // Parse ASN.1 SubjectPublicKeyInfo type as defined by X.509
                    var bit_string = asn1.sub[1];
                    var sequence = bit_string.sub[0];
                    modulus = sequence.sub[0].getHexStringValue();
                    this.n = parseBigInt(modulus, 16);
                    public_exponent = sequence.sub[1].getHexStringValue();
                    this.e = parseInt(public_exponent, 16);
                }
                else {
                    // Parse ASN.1 RSAPublicKey type as defined by PKCS #1
                    modulus = asn1.sub[0].getHexStringValue();
                    this.n = parseBigInt(modulus, 16);
                    public_exponent = asn1.sub[1].getHexStringValue();
                    this.e = parseInt(public_exponent, 16);
                }
            }
            else {
                return false;
            }
            return true;
        }
        catch (ex) {
            return false;
        }
    };
    /**
     * Translate rsa parameters in a hex encoded string representing the rsa key.
     *
     * The translation follow the ASN.1 notation :
     * RSAPrivateKey ::= SEQUENCE {
     *   version           Version,
     *   modulus           INTEGER,  -- n
     *   publicExponent    INTEGER,  -- e
     *   privateExponent   INTEGER,  -- d
     *   prime1            INTEGER,  -- p
     *   prime2            INTEGER,  -- q
     *   exponent1         INTEGER,  -- d mod (p1)
     *   exponent2         INTEGER,  -- d mod (q-1)
     *   coefficient       INTEGER,  -- (inverse of q) mod p
     * }
     * @returns {string}  DER Encoded String representing the rsa private key
     * @private
     */
    JSEncryptRSAKey.prototype.getPrivateBaseKey = function () {
        var options = {
            array: [
                new KJUR.asn1.DERInteger({ int: 0 }),
                new KJUR.asn1.DERInteger({ bigint: this.n }),
                new KJUR.asn1.DERInteger({ int: this.e }),
                new KJUR.asn1.DERInteger({ bigint: this.d }),
                new KJUR.asn1.DERInteger({ bigint: this.p }),
                new KJUR.asn1.DERInteger({ bigint: this.q }),
                new KJUR.asn1.DERInteger({ bigint: this.dmp1 }),
                new KJUR.asn1.DERInteger({ bigint: this.dmq1 }),
                new KJUR.asn1.DERInteger({ bigint: this.coeff }),
            ],
        };
        var seq = new KJUR.asn1.DERSequence(options);
        return seq.getEncodedHex();
    };
    /**
     * base64 (pem) encoded version of the DER encoded representation
     * @returns {string} pem encoded representation without header and footer
     * @public
     */
    JSEncryptRSAKey.prototype.getPrivateBaseKeyB64 = function () {
        return hex2b64(this.getPrivateBaseKey());
    };
    /**
     * Translate rsa parameters in a hex encoded string representing the rsa public key.
     * The representation follow the ASN.1 notation :
     * PublicKeyInfo ::= SEQUENCE {
     *   algorithm       AlgorithmIdentifier,
     *   PublicKey       BIT STRING
     * }
     * Where AlgorithmIdentifier is:
     * AlgorithmIdentifier ::= SEQUENCE {
     *   algorithm       OBJECT IDENTIFIER,     the OID of the enc algorithm
     *   parameters      ANY DEFINED BY algorithm OPTIONAL (NULL for PKCS #1)
     * }
     * and PublicKey is a SEQUENCE encapsulated in a BIT STRING
     * RSAPublicKey ::= SEQUENCE {
     *   modulus           INTEGER,  -- n
     *   publicExponent    INTEGER   -- e
     * }
     * @returns {string} DER Encoded String representing the rsa public key
     * @private
     */
    JSEncryptRSAKey.prototype.getPublicBaseKey = function () {
        var first_sequence = new KJUR.asn1.DERSequence({
            array: [
                new KJUR.asn1.DERObjectIdentifier({ oid: "1.2.840.113549.1.1.1" }),
                new KJUR.asn1.DERNull(),
            ],
        });
        var second_sequence = new KJUR.asn1.DERSequence({
            array: [
                new KJUR.asn1.DERInteger({ bigint: this.n }),
                new KJUR.asn1.DERInteger({ int: this.e }),
            ],
        });
        var bit_string = new KJUR.asn1.DERBitString({
            hex: "00" + second_sequence.getEncodedHex(),
        });
        var seq = new KJUR.asn1.DERSequence({
            array: [first_sequence, bit_string],
        });
        return seq.getEncodedHex();
    };
    /**
     * base64 (pem) encoded version of the DER encoded representation
     * @returns {string} pem encoded representation without header and footer
     * @public
     */
    JSEncryptRSAKey.prototype.getPublicBaseKeyB64 = function () {
        return hex2b64(this.getPublicBaseKey());
    };
    /**
     * wrap the string in block of width chars. The default value for rsa keys is 64
     * characters.
     * @param {string} str the pem encoded string without header and footer
     * @param {Number} [width=64] - the length the string has to be wrapped at
     * @returns {string}
     * @private
     */
    JSEncryptRSAKey.wordwrap = function (str, width) {
        width = width || 64;
        if (!str) {
            return str;
        }
        var regex = "(.{1," + width + "})( +|$\n?)|(.{1," + width + "})";
        return str.match(RegExp(regex, "g")).join("\n");
    };
    /**
     * Retrieve the pem encoded private key
     * @returns {string} the pem encoded private key with header/footer
     * @public
     */
    JSEncryptRSAKey.prototype.getPrivateKey = function () {
        var key = "-----BEGIN RSA PRIVATE KEY-----\n";
        key += JSEncryptRSAKey.wordwrap(this.getPrivateBaseKeyB64()) + "\n";
        key += "-----END RSA PRIVATE KEY-----";
        return key;
    };
    /**
     * Retrieve the pem encoded public key
     * @returns {string} the pem encoded public key with header/footer
     * @public
     */
    JSEncryptRSAKey.prototype.getPublicKey = function () {
        var key = "-----BEGIN PUBLIC KEY-----\n";
        key += JSEncryptRSAKey.wordwrap(this.getPublicBaseKeyB64()) + "\n";
        key += "-----END PUBLIC KEY-----";
        return key;
    };
    /**
     * Check if the object contains the necessary parameters to populate the rsa modulus
     * and public exponent parameters.
     * @param {Object} [obj={}] - An object that may contain the two public key
     * parameters
     * @returns {boolean} true if the object contains both the modulus and the public exponent
     * properties (n and e)
     * @todo check for types of n and e. N should be a parseable bigInt object, E should
     * be a parseable integer number
     * @private
     */
    JSEncryptRSAKey.hasPublicKeyProperty = function (obj) {
        obj = obj || {};
        return obj.hasOwnProperty("n") && obj.hasOwnProperty("e");
    };
    /**
     * Check if the object contains ALL the parameters of an RSA key.
     * @param {Object} [obj={}] - An object that may contain nine rsa key
     * parameters
     * @returns {boolean} true if the object contains all the parameters needed
     * @todo check for types of the parameters all the parameters but the public exponent
     * should be parseable bigint objects, the public exponent should be a parseable integer number
     * @private
     */
    JSEncryptRSAKey.hasPrivateKeyProperty = function (obj) {
        obj = obj || {};
        return (obj.hasOwnProperty("n") &&
            obj.hasOwnProperty("e") &&
            obj.hasOwnProperty("d") &&
            obj.hasOwnProperty("p") &&
            obj.hasOwnProperty("q") &&
            obj.hasOwnProperty("dmp1") &&
            obj.hasOwnProperty("dmq1") &&
            obj.hasOwnProperty("coeff"));
    };
    /**
     * Parse the properties of obj in the current rsa object. Obj should AT LEAST
     * include the modulus and public exponent (n, e) parameters.
     * @param {Object} obj - the object containing rsa parameters
     * @private
     */
    JSEncryptRSAKey.prototype.parsePropertiesFrom = function (obj) {
        this.n = obj.n;
        this.e = obj.e;
        if (obj.hasOwnProperty("d")) {
            this.d = obj.d;
            this.p = obj.p;
            this.q = obj.q;
            this.dmp1 = obj.dmp1;
            this.dmq1 = obj.dmq1;
            this.coeff = obj.coeff;
        }
    };
    return JSEncryptRSAKey;
}(rsa_RSAKey));


;// CONCATENATED MODULE: ./node_modules/jsencrypt/lib/JSEncrypt.js
var _a;


var version = typeof process !== 'undefined'
    ? (_a = process.env) === null || _a === void 0 ? void 0 : _a.npm_package_version
    : undefined;
/**
 *
 * @param {Object} [options = {}] - An object to customize JSEncrypt behaviour
 * possible parameters are:
 * - default_key_size        {number}  default: 1024 the key size in bit
 * - default_public_exponent {string}  default: '010001' the hexadecimal representation of the public exponent
 * - log                     {boolean} default: false whether log warn/error or not
 * @constructor
 */
var JSEncrypt_JSEncrypt = /** @class */ (function () {
    function JSEncrypt(options) {
        if (options === void 0) { options = {}; }
        options = options || {};
        this.default_key_size = options.default_key_size
            ? parseInt(options.default_key_size, 10)
            : 1024;
        this.default_public_exponent = options.default_public_exponent || "010001"; // 65537 default openssl public exponent for rsa key type
        this.log = options.log || false;
        // The private and public key.
        this.key = null;
    }
    /**
     * Method to set the rsa key parameter (one method is enough to set both the public
     * and the private key, since the private key contains the public key paramenters)
     * Log a warning if logs are enabled
     * @param {Object|string} key the pem encoded string or an object (with or without header/footer)
     * @public
     */
    JSEncrypt.prototype.setKey = function (key) {
        if (this.log && this.key) {
            console.warn("A key was already set, overriding existing.");
        }
        this.key = new JSEncryptRSAKey(key);
    };
    /**
     * Proxy method for setKey, for api compatibility
     * @see setKey
     * @public
     */
    JSEncrypt.prototype.setPrivateKey = function (privkey) {
        // Create the key.
        this.setKey(privkey);
    };
    /**
     * Proxy method for setKey, for api compatibility
     * @see setKey
     * @public
     */
    JSEncrypt.prototype.setPublicKey = function (pubkey) {
        // Sets the public key.
        this.setKey(pubkey);
    };
    /**
     * Proxy method for RSAKey object's decrypt, decrypt the string using the private
     * components of the rsa key object. Note that if the object was not set will be created
     * on the fly (by the getKey method) using the parameters passed in the JSEncrypt constructor
     * @param {string} str base64 encoded crypted string to decrypt
     * @return {string} the decrypted string
     * @public
     */
    JSEncrypt.prototype.decrypt = function (str) {
        // Return the decrypted string.
        try {
            return this.getKey().decrypt(b64tohex(str));
        }
        catch (ex) {
            return false;
        }
    };
    /**
     * Proxy method for RSAKey object's encrypt, encrypt the string using the public
     * components of the rsa key object. Note that if the object was not set will be created
     * on the fly (by the getKey method) using the parameters passed in the JSEncrypt constructor
     * @param {string} str the string to encrypt
     * @return {string} the encrypted string encoded in base64
     * @public
     */
    JSEncrypt.prototype.encrypt = function (str) {
        // Return the encrypted string.
        try {
            return hex2b64(this.getKey().encrypt(str));
        }
        catch (ex) {
            return false;
        }
    };
    /**
     * Proxy method for RSAKey object's sign.
     * @param {string} str the string to sign
     * @param {function} digestMethod hash method
     * @param {string} digestName the name of the hash algorithm
     * @return {string} the signature encoded in base64
     * @public
     */
    JSEncrypt.prototype.sign = function (str, digestMethod, digestName) {
        // return the RSA signature of 'str' in 'hex' format.
        try {
            return hex2b64(this.getKey().sign(str, digestMethod, digestName));
        }
        catch (ex) {
            return false;
        }
    };
    /**
     * Proxy method for RSAKey object's verify.
     * @param {string} str the string to verify
     * @param {string} signature the signature encoded in base64 to compare the string to
     * @param {function} digestMethod hash method
     * @return {boolean} whether the data and signature match
     * @public
     */
    JSEncrypt.prototype.verify = function (str, signature, digestMethod) {
        // Return the decrypted 'digest' of the signature.
        try {
            return this.getKey().verify(str, b64tohex(signature), digestMethod);
        }
        catch (ex) {
            return false;
        }
    };
    /**
     * Getter for the current JSEncryptRSAKey object. If it doesn't exists a new object
     * will be created and returned
     * @param {callback} [cb] the callback to be called if we want the key to be generated
     * in an async fashion
     * @returns {JSEncryptRSAKey} the JSEncryptRSAKey object
     * @public
     */
    JSEncrypt.prototype.getKey = function (cb) {
        // Only create new if it does not exist.
        if (!this.key) {
            // Get a new private key.
            this.key = new JSEncryptRSAKey();
            if (cb && {}.toString.call(cb) === "[object Function]") {
                this.key.generateAsync(this.default_key_size, this.default_public_exponent, cb);
                return;
            }
            // Generate the key.
            this.key.generate(this.default_key_size, this.default_public_exponent);
        }
        return this.key;
    };
    /**
     * Returns the pem encoded representation of the private key
     * If the key doesn't exists a new key will be created
     * @returns {string} pem encoded representation of the private key WITH header and footer
     * @public
     */
    JSEncrypt.prototype.getPrivateKey = function () {
        // Return the private representation of this key.
        return this.getKey().getPrivateKey();
    };
    /**
     * Returns the pem encoded representation of the private key
     * If the key doesn't exists a new key will be created
     * @returns {string} pem encoded representation of the private key WITHOUT header and footer
     * @public
     */
    JSEncrypt.prototype.getPrivateKeyB64 = function () {
        // Return the private representation of this key.
        return this.getKey().getPrivateBaseKeyB64();
    };
    /**
     * Returns the pem encoded representation of the public key
     * If the key doesn't exists a new key will be created
     * @returns {string} pem encoded representation of the public key WITH header and footer
     * @public
     */
    JSEncrypt.prototype.getPublicKey = function () {
        // Return the private representation of this key.
        return this.getKey().getPublicKey();
    };
    /**
     * Returns the pem encoded representation of the public key
     * If the key doesn't exists a new key will be created
     * @returns {string} pem encoded representation of the public key WITHOUT header and footer
     * @public
     */
    JSEncrypt.prototype.getPublicKeyB64 = function () {
        // Return the private representation of this key.
        return this.getKey().getPublicBaseKeyB64();
    };
    JSEncrypt.version = version;
    return JSEncrypt;
}());


;// CONCATENATED MODULE: ./node_modules/jsencrypt/lib/index.js


/* harmony default export */ const lib = ((/* unused pure expression or super */ null && (JSEncrypt)));

;// CONCATENATED MODULE: ./src/scripts/rsa.ts




class RSAEncrypt {
  constructor(modulus, exponent) {
    if (isExtension()) {
      this.encryptor = new JSEncrypt_JSEncrypt({
        log: true
      });
      const key = this.encryptor.getKey();
      const n = parseBigInt(modulus, 16);
      const e = parseInt(exponent, 16);
      key.parsePropertiesFrom({
        n,
        e
      });
    } else {
      const key = new RSAKey();
      key.setPublic(modulus, exponent);
      this.key = key;
    }
  }
  encrypt(data) {
    if (isExtension()) {
      try {
        return this.encryptor.getKey().encrypt(data);
      } catch (e) {
        log_error(`Failed to encrypt ${data.length} characters`, e);
        return null;
      }
    } else {
      return this.key.encrypt(data);
    }
  }
}
;// CONCATENATED MODULE: ./src/scripts/auth.ts







const GoogleUserInfoURL = 'https://www.googleapis.com/oauth2/v2/userinfo';
const GSuiteTokenRevokeUrl = 'https://accounts.google.com/o/oauth2/revoke';
async function auth_authenticateWithGSuiteHTTP(serverBaseURL, isInteractive) {
  return Promise.all([getRsaPublicKey(serverBaseURL), getGoogleAuthInfo(isInteractive)]).then(([rsaKey, authInfo]) => {
    return encryptCredentialsWithKey(`${authInfo.email}`, `${authInfo.token}`, rsaKey);
  });
}
async function authenticateWithGSuite(printJob, isInteractive, encryptForMobility = true) {
  log_log(`Authenticating with G-Suite: 
		printJobId=${printJob.printerId}, isInteractive=${isInteractive}, encryptForMobility=${encryptForMobility}`);
  if (encryptForMobility) {
    const serverBaseURL = printer_getUrlBaseOfPrinterUrl(printJob.printerId);
    return auth_authenticateWithGSuiteHTTP(serverBaseURL, isInteractive);
  }
  return getGoogleAuthInfo(isInteractive).then(googleAuth => new Promise(resolve => {
    return resolve({
      provider: 'google',
      userid: googleAuth.email,
      token: googleAuth.token
    });
  }));
}
async function getGoogleAuthInfo(isInteractive) {
  log_log(`Getting auth info from G-Suite: isInteractive=${isInteractive}`);
  const retryWithRefreshedToken = async (e, oldToken) => {
    log_error('failed to get Google user info. refreshing token...', e);
    const details = {
      interactive: isInteractive
    };
    return refreshToken(oldToken, details).then(newToken => getGSuiteUserInfo(newToken));
  };
  return getGSuiteToken(isInteractive).then(token => getGSuiteUserInfo(token).catch(e => retryWithRefreshedToken(e, token)));
}
async function getGSuiteToken(isInteractive) {
  const details = {
    interactive: isInteractive
  };
  return new Promise((resolve, reject) => {
    chrome.identity.getAuthToken(details, token => {
      if (chrome.runtime.lastError) {
        reject(chrome.runtime.lastError.message);
        return;
      }
      resolve(token);
    });
  });
}
async function refreshToken(expiredToken, details) {
  return new Promise((resolve, reject) => {
    log_log(`Refreshing user token for: '${details.account}'...`);
    chrome.identity.removeCachedAuthToken({
      token: expiredToken
    }, () => {
      chrome.identity.getAuthToken(details, token => {
        if (chrome.runtime.lastError) {
          log_error(`Failed to refresh token: ${chrome.runtime.lastError.message}`);
          reject(chrome.runtime.lastError.message);
          return;
        }
        resolve(token);
      });
    });
  });
}
async function getGSuiteUserInfo(accessToken) {
  log_log('[getGSuiteUserInfo] Fetching user info from G-Suite...');
  try {
    const response = await fetch(`${GoogleUserInfoURL}?access_token=${accessToken}`);
    if (response.status !== 200) {
      throw new Error(`Failed to resolve G-Suite user: ${await response.text()}`);
    }
    const resp = await response.json();
    log_log(`[getGSuiteUserInfo] Resolved user: ${resp.email}`);
    return {
      token: accessToken,
      email: resp.email
    };
  } catch (err) {
    log_error('[getGSuiteUserInfo] Error:', err);
    throw err;
  }
}
async function getRsaPublicKey(urlBase) {
  try {
    const response = await fetch(urlBase + '/public-key', {
      method: 'GET',
      headers: {
        'client-type': clientVersionID()
      }
    }).then(response => http_getResponseBody(response));
    return parseRsaKey(response);
  } catch (err) {
    log_error('[getRsaPublicKey] Error:', err);
    throw err;
  }
  function parseRsaKey(resp) {
    if (!resp.modulus || !resp.exponent) {
      throw new Error('Invalid encryption key info returned by the server');
    } else {
      const keyLength = resp.modulus.length * 8 / 2;
      log_log(`[getRsaPublicKey] Mobility Print is using ${keyLength}bit RSA key...`);
      return new RSAEncrypt(resp.modulus, resp.exponent);
    }
  }
}
async function isGSuiteEnabledHTTP(urlBase) {
  log(`[isGSuiteEnabledHTTP] Checking if GSuite is enabled on server: ${urlBase}...`);
  try {
    const response = await fetch(urlBase + '/auth-options', {
      method: 'GET',
      headers: {
        'client-type': clientVersionID()
      }
    }).then(resp => getResponseBody(resp));
    return response.signInWithGoogle;
  } catch (err) {
    error('[isGSuiteEnabledHTTP] Error:', err);
    throw err;
  }
}
async function isGSuiteEnabledRTC(printerId) {
  const serverId = await getServerIdForPrinter(printerId);
  if (!serverId) {
    throw new Error(`unknown server id for printer: ${printerId}`);
  }
  const serverInfo = getServerIdToServerInfoCache().get(serverId);
  if (serverInfo) {
    return serverInfo.signInWithGoogle;
  }
  log(`Information for server '${serverId}' is not cached, fetching...`);
  return getServerInfoRTC(serverId).then(info => info.signInWithGoogle).catch(e => {
    error('Unable to determine if Google sign-in is enabled.', e);
    throw e;
  });
}
async function isGSuiteEnabled(printJob, cloudPrintJob = false) {
  log(`isGSuiteEnabled: printerId=${printJob.printerId} (${cloudPrintJob ? 'Cloud Job' : 'Local Job'})`);
  if (cloudPrintJob) {
    return isGSuiteEnabledRTC(printJob.printerId);
  }
  const urlBase = getUrlBaseOfPrinterUrl(printJob.printerId);
  return isGSuiteEnabledHTTP(urlBase);
}
async function revokeCachedGSuiteAuthToken(msBufferTime = 0) {
  log_log('Revoking auth token with G-Suite...');
  return new Promise(async (resolve, reject) => {
    try {
      const token = await new Promise(innerResolve => {
        chrome.identity.getAuthToken({
          interactive: false
        }, innerToken => {
          innerResolve(innerToken);
        });
      });
      if (token === null) {
        resolve();
        return;
      }
      const tokenParam = 'token=' + token;
      const response = await fetch(`${GSuiteTokenRevokeUrl}?${tokenParam}`, {
        method: 'GET',
        headers: {
          'Content-type': 'application/x-www-form-urlencoded'
        }
      });
      if (response.status === 200) {
        setTimeout(() => {
          resolve();
        }, msBufferTime);
      } else {
        reject(await response.text());
      }
    } catch (err) {
      log_error('[revokeCachedGSuiteAuthToken] Error:', err);
      reject('Connection failed');
    }
  });
}
async function encryptCredentialsWithKey(username, password, rsaKey) {
  log_log('Encrypting credentials...');
  const plainCredentials = username + ':' + password;
  const encrypted = rsaKey.encrypt(plainCredentials);
  if (!encrypted) {
    log_error('Credential encryption failed!', 'length', plainCredentials.length);
  }
  return encrypted;
}
function clientVersionID() {
  if (isExtension()) {
    return 'ChromeAppExt-' + chrome.runtime.getManifest().version;
  }
  return 'ChromeApp-' + chrome.runtime.getManifest().version;
}
async function auth_encryptCredentials(mpServerBaseUrl, username, password) {
  log_log(`Encrypting credentials for ${mpServerBaseUrl}...`);
  return getRsaPublicKey(mpServerBaseUrl).then(rsaKey => {
    return encryptCredentialsWithKey(username, password, rsaKey);
  });
}
const auth_inMemoryCreds = {
  rememberMe: false
};
function auth_rememberCredsInMemory(credentials) {
  auth_inMemoryCreds.username = credentials.username;
  auth_inMemoryCreds.password = credentials.password;
  auth_inMemoryCreds.rememberMe = credentials.rememberMe;
}
function clearInMemoryCreds() {
  auth_inMemoryCreds.username = undefined;
  auth_inMemoryCreds.password = undefined;
}
function auth_inMemoryCredsAvailable() {
  return auth_inMemoryCreds.username != null && auth_inMemoryCreds.password != null;
}
;// CONCATENATED MODULE: ./src/scripts/chrome/message/message_extension.ts

async function message_extension_sendPageMessage(msg, opts = {}) {
  return new Promise((resolve, reject) => {
    const tabMessage = opts.tabId !== undefined;
    console.info(`sendPageMessage(${tabMessage ? 'tab' : 'ext'}): ` + `${JSON.stringify(msg)}, opts: ${JSON.stringify(opts)}...`);
    const send = tabMessage ? chrome.tabs.sendMessage.bind(this, opts.tabId) : chrome.runtime.sendMessage;
    send(msg, () => {
      if (chrome.runtime.lastError) {
        return reject(chrome.runtime.lastError);
      }
      resolve();
    });
  });
}
;// CONCATENATED MODULE: ./src/scripts/chrome/chrome.ts


async function chrome_sendPageMessageWithRetry(msg, opts = {}) {
  if (msg === undefined) {
    return Promise.resolve();
  }
  return new Promise((resolve, reject) => {
    const iter = (delay = 10, elapsed = 0, attempt = 0) => {
      setTimeout(async () => {
        elapsed += delay;
        attempt += 1;
        log_log('[sendPageMessageWithRetry] Attempting to send page message.', {
          attempt,
          msg,
          delay,
          elapsed
        });
        try {
          resolve(await message_extension_sendPageMessage(msg, opts));
        } catch (e) {
          if (elapsed < 500) {
            log_log('[sendPageMessageWithRetry] Unhandled page message send error within 500ms, will try again.', e);
            iter(delay * 2, elapsed, attempt);
          } else if (elapsed < 3000 && e && e['message'] == 'Could not establish connection. Receiving end does not exist.') {
            iter(delay * 2, elapsed, attempt);
          } else {
            reject(e);
          }
        }
      }, delay);
    };
    iter();
  });
}
;// CONCATENATED MODULE: ./src/scripts/chrome/index.ts



;// CONCATENATED MODULE: ./src/scripts/printdeploy/googleauth.ts

class GoogleOpenIDOAuthProvider {
  getAccessToken() {
    return getGoogleAuthInfo(true).then(authInfo => {
      return {
        accessToken: authInfo.token
      };
    });
  }
  getUserInfo(oauthToken) {
    return getGSuiteUserInfo(oauthToken.accessToken).then(userInfo => {
      return {
        email: userInfo.email
      };
    });
  }
}
;// CONCATENATED MODULE: ./src/scripts/printdeploy/oauth.ts

const oauth_OAuthProviderIDs = {
  Google: 'google'
};
function oauth_toPrintDeployTokenInfo(session) {
  return {
    authMethod: session.providerID,
    token: session.sessionToken
  };
}
const printDeployOauthProviders = new Map();
printDeployOauthProviders.set(oauth_OAuthProviderIDs.Google, new GoogleOpenIDOAuthProvider());
;// CONCATENATED MODULE: ./src/scripts/popup/popup_extension.ts




const maxWindowDimensions = {
  width: 1024,
  height: 768
};
const minWindowDimensions = {
  width: 100,
  height: 100
};
const defaultFrameSize = {
  width: 30,
  height: 30
};
let frameSize;
let displayBounds;
async function popup_extension_showPopup({
  page,
  width = 494,
  height = 610,
  message
}) {
  log('[popup] Displaying popup.', {
    page,
    width,
    height
  });
  await calculateFrameSize();
  const tab = await createTab({
    page,
    windowId: (await createPopupWindow(width, height)).id
  });
  log('[popup] sending page Message', {
    message
  });
  await sendPageMessageWithRetry(message, {
    tabId: tab.id
  });
  log(`[popup] Popup displayed (tab ${tab.id}).`, {
    page
  });
}
async function calculateFrameSize() {
  if (frameSize === undefined) {
    let saveFrameSize = false;
    frameSize = await getLocalStorageData('framesize');
    if (!frameSize || !frameSize.width || !frameSize.height) {
      log('Window frame size not known, calculating...');
      frameSize = await getFrameSize();
      saveFrameSize = true;
    }
    if (frameSize && frameSize.width >= 0 && frameSize.height >= 0) {
      log(`Using window frame size: ${JSON.stringify(frameSize)}`);
      Object.freeze(frameSize);
      if (saveFrameSize) {
        await setLocalStorageData('framesize', frameSize);
      }
    } else {
      warn(`Invalid window frame size, will use default: ${JSON.stringify(frameSize)}`);
      frameSize = defaultFrameSize;
    }
  }
}
async function createTab({
  page,
  windowId
}) {
  return new Promise((resolve, reject) => {
    chrome.tabs.create({
      url: chrome.runtime.getURL(page),
      windowId
    }, tab => {
      if (chrome.runtime.lastError) {
        return reject(chrome.runtime.lastError);
      }
      log(`[popup] Tab '${page}' (id:${tab.id}, window:${tab.windowId}) created.`);
      resolve(tab);
    });
  });
}
async function getFrameSize() {
  return new Promise(async resolve => {
    try {
      log('[popup] Creating page to measure frame size.');
      let timeoutId = undefined;
      const frameSizeCallback = (frame, _s, responseCallback) => {
        var _fs$width, _fs$height;
        if (frame.type !== 'frame-size-response') {
          return;
        }
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
        responseCallback();
        chrome.runtime.onMessage.removeListener(frameSizeCallback);
        const fs = {
          width: frame.width,
          height: frame.height
        };
        fs.width = (_fs$width = fs.width) !== null && _fs$width !== void 0 ? _fs$width : defaultFrameSize.width;
        fs.height = (_fs$height = fs.height) !== null && _fs$height !== void 0 ? _fs$height : defaultFrameSize.height;
        log('[popup] Frame size measured.', fs);
        resolve(fs);
      };
      timeoutId = setTimeout(() => {
        chrome.runtime.onMessage.removeListener(frameSizeCallback);
        log('[popup] Timed out measuring frame size, using default.');
        resolve(defaultFrameSize);
      }, 3000);
      chrome.runtime.onMessage.addListener(frameSizeCallback);
      await createTab({
        page: 'framesize.html',
        windowId: (await createWindow({
          width: minWindowDimensions.width,
          height: minWindowDimensions.height,
          focused: false
        })).id
      });
    } catch (e) {
      log('[popup] Failed to measure frame size, using default.', e);
      resolve(defaultFrameSize);
    }
  });
}
async function createPopupWindow(width, height) {
  if (!displayBounds) {
    displayBounds = await getDisplayBounds(true);
    Object.freeze(displayBounds);
  }
  log('[popup] Display work area dimensions', JSON.stringify({
    displayWidth: displayBounds.width,
    displayHeight: displayBounds.height,
    maxWindowWidth: maxWindowDimensions.width,
    maxWindowHeight: maxWindowDimensions.height
  }));
  try {
    log('[popup] Creating window using screen info:', JSON.stringify({
      availWidth: displayBounds.width,
      availHeight: displayBounds.height,
      frameWidth: frameSize.width,
      frameHeight: frameSize.height
    }));
    return await createWindow({
      width: width + frameSize.width,
      height: height + frameSize.height,
      left: Math.round((displayBounds.width - width) / 2),
      top: Math.round((displayBounds.height - height) / 2)
    });
  } catch (e) {
    error('[popup] Window creation failed:', e);
    log('[popup] Last chance retry without centering.');
    return await createWindow({
      width: width + frameSize.width,
      height: height + frameSize.height,
      left: 0,
      top: 0
    });
  }
}
async function createWindow({
  width,
  height,
  left,
  top,
  focused = true
}) {
  if (displayBounds === undefined) {
    displayBounds = await getDisplayBounds(true);
    Object.freeze(displayBounds);
  }
  return new Promise((resolve, reject) => {
    log(`[popup] Requested window, width:${width}, height:${height}, left:${left}, top:${top}`);
    ({
      left,
      top,
      width,
      height
    } = normalizeWindowBounds({
      left,
      top,
      width,
      height
    }));
    chrome.windows.create({
      type: 'popup',
      focused,
      width,
      height,
      left,
      top
    }, async w => {
      if (chrome.runtime.lastError) {
        return reject(`failed to display popup: ${chrome.runtime.lastError.message}`);
      } else if (!w) {
        return reject('failed to display popup');
      }
      resolve(w);
    });
  });
}
function normalizeWindowBounds(wBounds) {
  const maxWidth = numRange(displayBounds.width, maxWindowDimensions.width, displayBounds.width);
  const maxHeight = numRange(displayBounds.height, maxWindowDimensions.height, displayBounds.height);
  return {
    width: numRange(wBounds.width, minWindowDimensions.width, maxWidth),
    height: numRange(wBounds.height, minWindowDimensions.height, maxHeight),
    left: wBounds.left ? numRange(wBounds.left, 0, Math.round((maxWidth - wBounds.width) / 2)) : undefined,
    top: wBounds.top ? numRange(wBounds.top, 0, Math.round((maxHeight - wBounds.height) / 2)) : undefined
  };
}
function numRange(value, min, max) {
  return Math.max(Math.min(value, max), min);
}
async function getDisplayBounds(isPrimary) {
  return new Promise(resolve => {
    chrome.system.display.getInfo(displays => {
      let display;
      for (const disp of displays) {
        if (disp.isPrimary === isPrimary) {
          display = disp;
        }
      }
      const bounds = display.workArea;
      if (bounds.width <= 0) {
        warn('Invalid display bounds width returned:', bounds.width);
        bounds.width = maxWindowDimensions.width;
      }
      if (bounds.height <= 0) {
        warn('Invalid display bounds height returned:', bounds.height);
        bounds.height = maxWindowDimensions.height;
      }
      resolve(bounds);
    });
  });
}
;// CONCATENATED MODULE: ./src/scripts/control/login.ts



async function login_displayLoginWindow({
  printJob = undefined,
  urlBase = undefined,
  showRememberMe,
  showUsernameLogin = false,
  showGoogleLogin = false,
  useCloudPrint = false,
  usePrintDeploy = false
}) {
  log('[displayLoginWindow]: Displaying sign-in pop-up.', {
    showRememberMe,
    showUsernameLogin,
    showGoogleLogin,
    useCloudPrint,
    usePrintDeploy
  });
  await showPopup({
    page: 'login.html',
    height: 675,
    message: {
      type: 'login-window-init',
      printJob,
      showUsernameLogin,
      showGoogleLogin,
      showRememberMe,
      urlBase,
      useCloudPrint,
      usePrintDeploy
    }
  });
}
async function login_closeLoginDialog() {
  log('[closeLoginDialog] sending message to close login window');
  const closeLoginWindowMessage = {
    type: 'close-login-window',
    msg: 'close window'
  };
  await sendPageMessage(closeLoginWindowMessage);
}
async function login_sendDisplayErrorMessage(errMsg) {
  log('[sendDisplayErrorMessage]: sending error to login window', {
    errMsg
  });
  const displayErrorMessage = {
    type: 'display-error',
    errMsg: errMsg
  };
  await sendPageMessageWithRetry(displayErrorMessage);
}
;// CONCATENATED MODULE: ./src/scripts/control/index.ts

;// CONCATENATED MODULE: ./src/scripts/printdeploy/printdeploy.types.ts
const printdeploy_types_PrintDeployAuthMethods = {
  Username: 'username',
  Google: 'google'
};
;// CONCATENATED MODULE: ./src/scripts/printdeploy/client/encryption.ts


const RSA_STRING_MAXLEN = 245;
class ClientEncryptionService {
  constructor(rsaKey, useAuthHeaderEncryption = false) {
    this.rsaKey = rsaKey;
    this.useAuthHeaderEncryption = useAuthHeaderEncryption;
  }
  encryptRequestBody(body) {
    const jsonBodyStr = JSON.stringify(body);
    if (this.rsaKey) {
      return this.encryptLongString(this.rsaKey, jsonBodyStr);
    }
    return jsonBodyStr;
  }
  encryptAuthHeaderValue(headerValue) {
    if (this.useAuthHeaderEncryption && this.rsaKey) {
      const encryptedHeader = this.encryptLongString(this.rsaKey, headerValue);
      if (encryptedHeader) {
        return encryptedHeader;
      }
    }
    return headerValue;
  }
  encryptLongString(rsaKey, str) {
    if (str.length <= RSA_STRING_MAXLEN) {
      return rsaKey.encrypt(str);
    }
    try {
      const pattern = `.{1,${RSA_STRING_MAXLEN}}`;
      return str.match(new RegExp(pattern, 'g')).map(s => rsaKey.encrypt(s)).reduce((acc, encryptedChunk) => acc + ',' + encryptedChunk);
    } catch (e) {
      console.error('encryption failed', e);
      return undefined;
    }
  }
}
;// CONCATENATED MODULE: ./src/scripts/printdeploy/client/client.ts




const DEFAULT_PRINT_DEPLOY_HTTPS_PORT = 9174;
const DEFAULT_PRINT_DEPLOY_HTTP_PORT = 9173;
class PrintDeployClientBuilder {
  constructor(host) {
    this.useHTTPSEncryption = () => new ClientEncryptionService();
    this.host = host;
  }
  withAccessibleTLSPort(port) {
    this.accessibleTLSPort = port;
    return this;
  }
  withStrictSSL(strictSSL) {
    this.strictSSL = strictSSL;
    return this;
  }
  withOAuthProviders(oauthProviders) {
    this.oauthProviders = oauthProviders;
    return this;
  }
  async build() {
    if (!this.oauthProviders) {
      this.oauthProviders = new Map();
    }
    if (this.hasCustomAccessibleTLSPort() || this.strictSSL) {
      const port = this.accessibleTLSPort || DEFAULT_PRINT_DEPLOY_HTTPS_PORT;
      const serverBaseURL = `https://${this.host}:${port}`;
      const client = new PDClient(serverBaseURL, this.oauthProviders, this.useHTTPSEncryption());
      return Promise.resolve(client);
    }
    const httpsServerBaseURL = `https://${this.host}:${DEFAULT_PRINT_DEPLOY_HTTPS_PORT}`;
    return fetch(httpsServerBaseURL).then(() => {
      const client = new PDClient(httpsServerBaseURL, this.oauthProviders, this.useHTTPSEncryption());
      return Promise.resolve(client);
    }).catch(_ => {
      const httpBaseUrl = `http://${this.host}:${DEFAULT_PRINT_DEPLOY_HTTP_PORT}`;
      return this.useEncryptedHTTP(httpBaseUrl).then(encryptionService => {
        return new PDClient(httpBaseUrl, this.oauthProviders, encryptionService);
      });
    });
  }
  async useEncryptedHTTP(httpBaseUrl) {
    if (httpBaseUrl.startsWith('https://')) {
      return Promise.reject('only use encrypted HTTP if the target host doesn\'t support HTTPS');
    }
    return getRsaPublicKey(httpBaseUrl).then(async rsaKey => {
      const useAuthHeaderEncryption = await this.isAuthHeaderEncryptionSupported(httpBaseUrl);
      return new ClientEncryptionService(rsaKey, useAuthHeaderEncryption);
    });
  }
  async isAuthHeaderEncryptionSupported(httpBaseUrl) {
    return fetch(`${httpBaseUrl}/${PrintDeployPaths.GET_CONFIG}`).then(resp => {
      return resp.status === 200;
    });
  }
  hasCustomAccessibleTLSPort() {
    return this.accessibleTLSPort && this.accessibleTLSPort !== 0 && this.accessibleTLSPort !== DEFAULT_PRINT_DEPLOY_HTTPS_PORT;
  }
}
var PrintDeployPaths;
(function (PrintDeployPaths) {
  PrintDeployPaths["LOGIN"] = "deploy/login";
  PrintDeployPaths["GET_PRINTERS"] = "deploy/printers";
  PrintDeployPaths["GET_CONFIG"] = "deploy/config";
  PrintDeployPaths["CREATE_OAUTH_SESSION"] = "deploy/oauth/session";
})(PrintDeployPaths || (PrintDeployPaths = {}));
const client_PrintDeployUnauthorizedError = 'Unauthorized';
class PDClient {
  constructor(serverBaseURL, oauthProviders, encryptionService) {
    this.encryptionService = encryptionService;
    this.providers = oauthProviders;
    this.serverBaseURL = serverBaseURL;
  }
  async login(credentials) {
    const username = credentials.username;
    const password = credentials.password;
    if (!username || !password) {
      return Promise.reject('missing required username/password to get PaperCut token');
    }
    const request = {
      headers: this.generateHeaders(),
      method: 'POST',
      body: this.encryptionService.encryptRequestBody({
        username,
        password
      })
    };
    return fetch(`${this.serverBaseURL}/${PrintDeployPaths.LOGIN}`, request).then(r => http_getResponseBody(r)).then(body => {
      return {
        authMethod: printdeploy_types_PrintDeployAuthMethods.Username,
        token: body.Token
      };
    });
  }
  async getConfig() {
    const headers = this.generateHeaders();
    return fetch(`${this.serverBaseURL}/${PrintDeployPaths.GET_CONFIG}`, {
      headers
    }).then(r => http_getResponseBody(r));
  }
  async getPrinters(tokenInfo, clientInfo) {
    const fetchPrinters = clientInfo => {
      const headers = this.generateHeaders(tokenInfo);
      const request = {
        headers: headers,
        method: 'POST',
        body: this.encryptionService.encryptRequestBody(clientInfo)
      };
      return fetch(`${this.serverBaseURL}/${PrintDeployPaths.GET_PRINTERS}`, request);
    };
    return fetchPrinters(clientInfo).then(handleInvalidToken).then(resp => http_getResponseBody(resp)).then(body => body.printers);
    function handleInvalidToken(resp) {
      if (resp.status === 401) {
        return Promise.reject(client_PrintDeployUnauthorizedError);
      }
      return Promise.resolve(resp);
    }
  }
  async createOAuthSession(providerID) {
    const oAuthProvider = this.providers.get(providerID);
    if (!oAuthProvider) {
      console.error('no such provider');
      return Promise.reject(`no registered provider for providerID=${providerID}`);
    }
    const oAuthToken = await oAuthProvider.getAccessToken();
    const url = `${this.serverBaseURL}/${PrintDeployPaths.CREATE_OAUTH_SESSION}`;
    const reqBody = {
      providerId: providerID,
      accessToken: oAuthToken.accessToken
    };
    return fetch(url, {
      method: 'POST',
      headers: this.generateHeaders(),
      body: this.encryptionService.encryptRequestBody(reqBody)
    }).then(resp => {
      if (resp.status === 403) {
        return Promise.reject('Unknown user');
      }
      return http_getResponseBody(resp);
    }).then(async body => {
      const sessionInfo = {
        providerID: providerID,
        username: body.username,
        sessionToken: body.sessionToken,
        oauthToken: oAuthToken,
        email: body.email
      };
      return Promise.resolve(sessionInfo);
    });
  }
  getServerBaseURL() {
    return this.serverBaseURL;
  }
  generateHeaders(tokenInfo) {
    const headers = {
      Accept: 'application/json',
      'Content-Type': 'application/json'
    };
    if (tokenInfo) {
      const header = `Bearer ${tokenInfo.token}`;
      headers['Authorization'] = this.encryptionService.encryptAuthHeaderValue(header);
      if (tokenInfo.authMethod !== printdeploy_types_PrintDeployAuthMethods.Username) {
        headers['PrintDeployAuthenticationType'] = tokenInfo.authMethod;
      }
    }
    return headers;
  }
}
;// CONCATENATED MODULE: ./src/scripts/chrome/runtime.ts

function runtime_getChromeOSVersion() {
  const versionString = navigator.userAgent.match(/Chrome\/(\S+)/);
  if (Array.isArray(versionString) && versionString.length === 2) {
    return versionString[1];
  }
  return 'unknown';
}
function runtime_getChromeOSVersionMajor() {
  const chromeOSVersion = runtime_getChromeOSVersion();
  const mVer = chromeOSVersion.indexOf('.');
  return parseInt(chromeOSVersion.substring(0, mVer != -1 ? mVer : chromeOSVersion.length));
}
function runtime_getPlatformInfo() {
  return new Promise(resolve => {
    chrome.runtime.getPlatformInfo(platformInfo => {
      resolve(platformInfo);
    });
  });
}
function getInstanceId() {
  return new Promise(resolve => {
    chrome.instanceID.getID(id => {
      resolve(id);
    });
  });
}
function runtime_getAssetId() {
  return new Promise(resolve => {
    if (chrome.enterprise && chrome.enterprise.deviceAttributes) {
      chrome.enterprise.deviceAttributes.getDeviceAssetId(assetId => {
        resolve(assetId);
      });
    } else {
      log('[getAssetId] enterprise.deviceAttributes not available');
      resolve(undefined);
    }
  });
}
;// CONCATENATED MODULE: ./src/scripts/chrome/network/network_extension.ts



const serviceType = '_banksia._tcp.local';
const minChromeVersion = 114;
const requiredChromeMessage = (/* unused pure expression or super */ null && (`Chrome ${minChromeVersion}+ required. Chrome version: ${getChromeOSVersion()}`));
function isSupportedChromeVersion() {
  return getChromeOSVersionMajor() >= minChromeVersion;
}
async function network_extension_getLocalIPAddresses() {
  return new Promise(async resolve => {
    try {
      if (isSupportedChromeVersion()) {
        chrome.system.network.getNetworkInterfaces(interfaces => {
          const localIPAddresses = interfaces.map(i => i.address).filter(isIPv4);
          log('[localIPAddresses] detected: ', localIPAddresses);
          resolve(localIPAddresses);
        });
        return;
      } else {
        log('[localIPAddresses] Chrome version not supported.', requiredChromeMessage);
      }
    } catch (e) {
      error('[localIPAddresses] chrome.system.network.getNetworkInterfaces failed.', e.message);
    }
    warn('[localIPAddresses] Local IP address unknown falling back to [0.0.0.0].');
    resolve(['0.0.0.0']);
  });
}
function startMDNSListener(onServiceList) {
  try {
    if (isSupportedChromeVersion()) {
      chrome.mdns.onServiceList.addListener(onServiceList, {
        serviceType
      });
      setInterval(() => {
        chrome.mdns.onServiceList.removeListener(onServiceList);
        chrome.mdns.onServiceList.addListener(onServiceList, {
          serviceType
        });
        chrome.mdns.forceDiscovery(() => {
          log('[MDNS:mdnsListener] ran re-discovery...');
        });
      }, 6000 * 1000);
      log('[MDNS:mdnsListener] registered...');
      return;
    } else {
      log('[MDNS:mdnsListener] Chrome version not supported.', requiredChromeMessage);
    }
  } catch (e) {
    error('chrome.mdns.onServiceList failed.', e.message);
  }
  warn('mDNS discovery will not work on this client.');
}
;// CONCATENATED MODULE: ./src/scripts/printdeploy/client/clientinfo.ts




async function clientinfo_getClientInfo() {
  return Promise.all([getClientId(), getPlatformInfo(), getLocalIPAddresses(), getAssetId()]).then(([clientId, platformInfo, ipAddresses, assetID]) => {
    const chromeAppExtVersion = GetClientVersionID();
    const chromeOSVersion = getChromeOSVersion();
    const clientInfo = {
      machine: {
        hostname: clientId,
        os: {
          name: 'chrome',
          version: chromeOSVersion,
          arch: platformInfo.arch
        },
        ipAddresses: ipAddresses,
        activeDirectoryDomainName: '',
        chromeAppExtVersion: chromeAppExtVersion,
        assetID: assetID
      }
    };
    return clientInfo;
  });
}
;// CONCATENATED MODULE: ./src/scripts/printdeploy/client/index.ts



;// CONCATENATED MODULE: ./src/scripts/printdeploy/storage.ts

const OAUTH_SESSION_TOKEN_KEY = 'OauthSession';
const PRINT_DEPLOY_AUTH_REPO = 'printDeployAuthRepo';
const PRINT_DEPLOY_CONFIG_KEY = 'printDeployConfig';
const PAPERCUT_AUTH_KEY = 'papercutAuthCookie';
class PrintDeployLocalStorage {
  async getCachedConfig() {
    return storage_getLocalStorageData(PRINT_DEPLOY_CONFIG_KEY);
  }
  getCachedOAuthSessionToken() {
    return this.getCachedAuthToken(OAUTH_SESSION_TOKEN_KEY);
  }
  getCachedPrintDeployToken() {
    return this.getCachedAuthToken(PAPERCUT_AUTH_KEY);
  }
  async getCachedMobilityPrintServerToken(serverBaseUrl) {
    return this.getCachedAuthToken(serverBaseUrl);
  }
  async cacheConfig(config) {
    return storage_setLocalStorageData(PRINT_DEPLOY_CONFIG_KEY, config);
  }
  async cacheMobilityPrintServerToken(serverBaseUrl, token) {
    return this.cacheAuthToken(serverBaseUrl, token);
  }
  async cachePaperCutToken(token) {
    return this.cacheAuthToken(PAPERCUT_AUTH_KEY, token);
  }
  async cacheOAuthSessionToken(sessionToken) {
    return this.cacheAuthToken(OAUTH_SESSION_TOKEN_KEY, sessionToken);
  }
  async removeMobilityPrintServerToken(server) {
    const authRepo = await storage_getLocalStorageData(PRINT_DEPLOY_AUTH_REPO);
    if (!authRepo) {
      return Promise.resolve({});
    }
    delete authRepo[server];
    return storage_setLocalStorageData(PRINT_DEPLOY_AUTH_REPO, authRepo);
  }
  async cacheAuthToken(key, value) {
    let authRepo = await storage_getLocalStorageData(PRINT_DEPLOY_AUTH_REPO);
    if (!authRepo) {
      authRepo = {};
    }
    authRepo[key] = value;
    await storage_setLocalStorageData(PRINT_DEPLOY_AUTH_REPO, authRepo);
    return Promise.resolve(value);
  }
  async getCachedAuthToken(key) {
    return storage_getLocalStorageData(PRINT_DEPLOY_AUTH_REPO).then(authRepo => {
      if (!authRepo) {
        return undefined;
      }
      return authRepo[key];
    });
  }
  invalidateAllCachedTokens() {
    return storage_setLocalStorageData(PRINT_DEPLOY_AUTH_REPO, {});
  }
}
const storage_printDeployStorage = new PrintDeployLocalStorage();
;// CONCATENATED MODULE: ./src/scripts/printdeploy/printdeploy.ts











var ManagedStorageKeys;
(function (ManagedStorageKeys) {
  ManagedStorageKeys["PrintDeployServerHosts"] = "PrintDeployServerHosts";
  ManagedStorageKeys["AccessiblePrintDeployTLSPort"] = "AccessiblePrintDeployTLSPort";
  ManagedStorageKeys["StrictSSLCheckingEnabled"] = "StrictSSLCheckingEnabled";
})(ManagedStorageKeys || (ManagedStorageKeys = {}));
async function getPrintersFromPrintDeploy() {
  const pdHost = await getPreconfiguredPrintDeployServer();
  if (!pdHost) {
    log('[getPreconfiguredPrintDeployServer] no Print Deploy servers preconfigured');
    return [[], false];
  }
  try {
    log('[getPrintersFromPrintDeploy] found Print Deploy server:', pdHost);
    const printers = await getPrintersFromPrintDeployHost(pdHost);
    return [printers, true];
  } catch (e) {
    log('[getPrintersFromPrintDeployHost] failed to get printers:', e);
    return [[], true];
  }
}
async function getPreconfiguredPrintDeployServer() {
  return getManagedStorageData(ManagedStorageKeys.PrintDeployServerHosts).then(hosts => {
    if (!hosts || hosts.length === 0) {
      return null;
    }
    return hosts[0];
  });
}
async function getPrintDeployClient(pdHost) {
  const strictSSLCheckingEnabled = await getManagedStorageData(ManagedStorageKeys.StrictSSLCheckingEnabled);
  const accessibleTLSPort = await getManagedStorageData(ManagedStorageKeys.AccessiblePrintDeployTLSPort);
  const pdClient = await new PrintDeployClientBuilder(pdHost).withAccessibleTLSPort(accessibleTLSPort).withStrictSSL(strictSSLCheckingEnabled).withOAuthProviders(printDeployOauthProviders).build();
  log_log(`[printDeployClientBuilder] built PDClient with serverBaseURL=${pdClient.getServerBaseURL()}`);
  return Promise.resolve(pdClient);
}
async function getPrintersFromPrintDeployHost(pdHost) {
  const pdClient = await getPrintDeployClient(pdHost);
  let clientConfig;
  try {
    clientConfig = await pdClient.getConfig();
  } catch (e) {
    log('[pdClient.getConfig] failed to fetch config', e);
    return [];
  }
  log('[pdClient.getConfig] received config from server:', clientConfig);
  await printDeployStorage.cacheConfig(clientConfig);
  return getPrintersForClient(pdClient).then(getAndSaveTokensForPrinters).then(mapPrintersForPrintProvider);
}
async function getAndSaveTokensForPrinters(printers) {
  log('[getAndSaveTokensForPrinters]', printers);
  const clientConfig = await printDeployStorage.getCachedConfig();
  const mpServers = printers.map(printer => {
    return getSecureURLForMPServer(getUrlBaseOfPrinterUrl(printer.connection.name), clientConfig);
  });
  const uniqueMPServers = Array.from(new Set(mpServers));
  log(`[printdeploy.uniqueMPServers] found ${uniqueMPServers.length} unique MP servers from the discovered queues`, uniqueMPServers);
  return Promise.all(uniqueMPServers.map(getMobilityPrintTokenIfMissing)).then(() => printers);
  async function getMobilityPrintTokenIfMissing(mpServerURL) {
    return printDeployStorage.getCachedMobilityPrintServerToken(mpServerURL).then(token => token ? token : fetchTokenFromMobilityPrintServer(mpServerURL, inMemoryCreds)).then(token => {
      return inMemoryCreds.rememberMe ? printDeployStorage.cacheMobilityPrintServerToken(mpServerURL, token) : token;
    }).catch(e => {
      log(`[getMobilityPrintToken] failed to get token for MP server ${mpServerURL} via HTTPS. This may happen ` + 'if the MP server isn\'t using a non-zero length CA-signed certificate. We will use encrypted HTTP ' + 'instead. error:', e.message || e);
      return null;
    });
  }
}
function getSecureURLForMPServer(mpServerURL, config) {
  const server = mpServerURL.replace(/http:/gi, 'https:');
  let tlsPort = config === null || config === void 0 ? void 0 : config.AccessibleMobilityPrintTLSPort;
  if (!tlsPort || tlsPort == 0) {
    tlsPort = 9164;
  }
  return server.replace(/:9163/gi, `:${tlsPort}`);
}
async function getPrintersForClient(pdClient) {
  const fetchPrinters = () => {
    log('[fetchPrinters] getting print deploy token');
    return getPrintDeployToken(pdClient).then(tokenInfo => {
      return getClientInfo().then(clientInfo => {
        log(`[getPrinters] getting printers with the following user details: ${JSON.stringify(clientInfo)}`);
        return pdClient.getPrinters(tokenInfo, clientInfo);
      });
    });
  };
  return fetchPrinters().catch(e => {
    if (e === PrintDeployUnauthorizedError) {
      return printDeployStorage.invalidateAllCachedTokens().then(() => fetchPrinters());
    }
    return Promise.reject(e);
  });
}
async function getPrintDeployToken(pdClient) {
  const usernameToken = await printDeployStorage.getCachedPrintDeployToken();
  if (usernameToken) {
    return {
      authMethod: PrintDeployAuthMethods.Username,
      token: usernameToken
    };
  }
  const oauthSessionCreds = await printDeployStorage.getCachedOAuthSessionToken();
  if (oauthSessionCreds) {
    return toPrintDeployTokenInfo(oauthSessionCreds);
  }
  log('[handleMissingPaperCutToken] checking in memory creds');
  if (inMemoryCredsAvailable()) {
    return pdClient.login(inMemoryCreds).catch(() => askUserToAuthenticateForPrintDeploy(pdClient));
  }
  log('[handleMissingPaperCutToken] in memory creds unavailable');
  return askUserToAuthenticateForPrintDeploy(pdClient);
}
async function fetchTokenFromMobilityPrintServer(mpServerBaseUrl, credentials) {
  const {
    username,
    password
  } = credentials;
  if (!username || !password) {
    return Promise.reject('missing required username/password to get token from Mobility Print server');
  }
  if (mpServerBaseUrl.startsWith('http:')) {
    return Promise.reject('cannot get token from MP server using non-HTTPS URL');
  }
  const authUrl = `${mpServerBaseUrl}/token?printerName=none`;
  const requestParams = {
    headers: {
      Authorization: `Basic ${btoa(username + ':' + password)}`
    },
    method: 'GET'
  };
  return fetch(authUrl, requestParams).then(resp => getResponseBody(resp)).then(body => body.token);
}
async function askUserToAuthenticateForPrintDeploy(pdClient) {
  return new Promise(async (resolve, _reject) => {
    chrome.runtime.onMessage.addListener(onCredentialsEnteredForPrintDeployHandler(pdClient, resolve));
    chrome.runtime.onMessage.addListener(onOauthSessionCreatedForPrintDeployHandler(resolve));
    await showLoginWindow();
  });
}
function onCredentialsEnteredForPrintDeployHandler(pdClient, resolve) {
  return (message, sender) => {
    if (message.type === 'on-credentials-entered') {
      log('[onCredentialsEnteredForPrintDeployHandler] message received', {
        message,
        sender
      });
      const credentialsEntered = message;
      onCredentialsEnteredForPrintDeploy(credentialsEntered.credentials, pdClient).then(tokenInfo => {
        log('[onCredentialsEnteredForPrintDeployHandler] succeeded', {
          tokenInfo
        });
        chrome.runtime.onMessage.removeListener(onCredentialsEnteredForPrintDeployHandler(pdClient, resolve));
        resolve(tokenInfo);
        return true;
      }).catch(e => {
        log('error', {
          e
        });
        if (e === PrintDeployUnauthorizedError) {
          printDeployStorage.invalidateAllCachedTokens().then(() => {
            log('[onCredentialsEnteredForPrintDeployHandler] cleared cached print deploy tokens');
          }).catch(e => {
            log('[onCredentialsEnteredForPrintDeployHandler] error clearing print deploy tokens', {
              e
            });
          });
        }
        const errorMessage = resolveErrorToDisplay(e);
        sendDisplayErrorMessage(errorMessage).then(() => {
          log('[onCredentialsEnteredForPrintDeployHandler] sendDisplayErrorMessage');
        }).catch(e => {
          log('[onCredentialsEnteredForPrintDeployHandler]  sendDisplayErrorMessage error:', {
            e
          });
        });
        return true;
      });
    }
  };
}
async function onCredentialsEnteredForPrintDeploy(credentials, pdClient) {
  rememberCredsInMemory(credentials);
  return pdClient.login(credentials).then(async tokenInfo => {
    if (credentials.rememberMe) {
      await printDeployStorage.cachePaperCutToken(tokenInfo.token);
    }
    closeLoginDialog().then(() => {
      log('[onCredentialsEnteredForPrintDeploy] closed login dialog');
    }).catch(e => {
      log('[onCredentialsEnteredForPrintDeploy]  error:', {
        e
      });
    });
    return tokenInfo;
  });
}
function onOauthSessionCreatedForPrintDeployHandler(resolve) {
  return (message, sender) => {
    if (message.type === 'oauth-session-created') {
      log('[onOauthSessionCreatedForPrintDeployHandler] message received from', {
        message,
        sender
      });
      const oauthSessionCreated = message;
      log('[onOauthSessionCreatedForPrintDeployHandler]Received message oauthSessionCreated');
      onOAuthSessionCreatedForPrintDeploy(oauthSessionCreated.rememberMe, oauthSessionCreated.sessionCredentials).then(tokenInfo => {
        log('onOauthSessionCreatedForPrintDeployHandler succeeded', {
          tokenInfo
        });
        chrome.runtime.onMessage.removeListener(onOauthSessionCreatedForPrintDeployHandler(resolve));
        resolve(tokenInfo);
        return true;
      }).catch(e => {
        log('error', {
          e
        });
        return true;
      });
      return true;
    }
  };
}
async function onOAuthSessionCreatedForPrintDeploy(rememberMe, sessionCredentials) {
  log('[onOAuthSessionCreatedForPrintDeploy] onOAuthSessionCreated');
  rememberCredsInMemory({
    ...inMemoryCreds,
    rememberMe
  });
  if (rememberMe) {
    await printDeployStorage.cacheOAuthSessionToken(sessionCredentials);
  }
  closeLoginDialog().then(() => {
    log('[onOAuthSessionCreatedForPrintDeploy] closed login dialog');
  }).catch(e => {
    log('[onOAuthSessionCreatedForPrintDeploy]  error:', {
      e
    });
  });
  log('[onOAuthSessionCreatedForPrintDeploy]  getting token info');
  const printDeployTokenInfo = toPrintDeployTokenInfo(sessionCredentials);
  log('[onOAuthSessionCreatedForPrintDeploy] token info', {
    printDeployTokenInfo
  });
  return printDeployTokenInfo;
}
async function showLoginWindow(onCredentialsEntered) {
  log('[showLoginWindow] called', {
    onCredentialsEntered
  });
  const config = await printDeployStorage.getCachedConfig();
  const showUsernameLogin = config && config.AuthMethods.includes(PrintDeployAuthMethods.Username);
  const showGoogleLogin = config && config.AuthMethods.includes(PrintDeployAuthMethods.Google);
  await displayLoginWindow({
    showRememberMe: true,
    showUsernameLogin,
    showGoogleLogin,
    usePrintDeploy: true
  });
}
function mapPrintersForPrintProvider(printers) {
  return printers.map(({
    name,
    connection
  }) => {
    const displayName = getNormalisedName(name);
    return {
      id: `${connection.name}/printers/${encodeURIComponent(displayName)}`,
      name: displayName,
      description: name,
      authMode: 'per-server',
      capabilities: undefined
    };
  });
}
function getNormalisedName(mpPrinterName) {
  const regex = /(.*)\[.*\]\(Mobility\)$/gm;
  if (!regex.test(mpPrinterName)) {
    return mpPrinterName;
  }
  return mpPrinterName.substring(0, mpPrinterName.lastIndexOf('[')).trim();
}
function resolveErrorToDisplay(e) {
  if (e.message) {
    if (e.message.includes('HTTP 401')) {
      return 'Invalid username and password';
    } else if (e.message.includes('HTTP 500')) {
      return 'An internal server error occurred';
    } else if (e.message.includes('Failed to fetch')) {
      return 'Connection failed';
    }
  }
  return 'Unknown error.';
}
async function getPDAuthForMobilityServer(mpServer) {
  const cachedToken = await printDeployStorage.getCachedMobilityPrintServerToken(mpServer);
  if (cachedToken) {
    log(`[getPrintDeployAuth] found cached token for ${mpServer}`);
    return Promise.resolve({
      token: cachedToken
    });
  }
  return handleMissingToken().catch(_e => {
    log(`[getPrintDeployAuth] did not find any cached tokens or credentials for MP server "${mpServer}. asking ` + 'user to authenticate..."');
    return askUserToAuthenticateForMPServer(mpServer);
  });
  async function handleMissingToken() {
    const oauthSession = await printDeployStorage.getCachedOAuthSessionToken();
    if (oauthSession && oauthSession.providerID === OAuthProviderIDs.Google) {
      return authenticateWithGSuiteHTTP(mpServer, false).then(encryptedCreds => {
        log(`[getPrintDeployAuth] generated encrypted oauth credentials for ${oauthSession.providerID}`);
        return {
          encryptedCreds,
          authOption: OAuthProviderIDs.Google
        };
      });
    }
    if (inMemoryCredsAvailable()) {
      return encryptCredentials(mpServer, inMemoryCreds.username, inMemoryCreds.password).then(encryptedCreds => {
        log('[getPrintDeployAuth] generated encrypted basic credentials');
        return {
          encryptedCreds
        };
      });
    }
    return Promise.reject(PrintDeployUnauthorizedError);
  }
}
function askUserToAuthenticateForMPServer(mpServer) {
  return new Promise(async (resolve, _reject) => {
    chrome.runtime.onMessage.addListener(onCredentialsEnteredForMPServerHandler(mpServer, resolve));
    await showLoginWindow();
  });
}
function onCredentialsEnteredForMPServerHandler(mpServer, resolve) {
  return (message, sender) => {
    if (message.type === 'on-credentials-entered') {
      const credentialsEntered = message;
      log('[onCredentialsEnteredForMPServerHandler] message received', {
        message,
        sender
      });
      onCredentialsEnteredForMPServer(credentialsEntered.credentials, mpServer).then(encryptedCredentials => {
        chrome.runtime.onMessage.removeListener(onCredentialsEnteredForMPServerHandler(mpServer, resolve));
        log('[onCredentialsEnteredForMPServer] succeeded', {
          encryptedCredentials
        });
        resolve(Promise.resolve(encryptedCredentials));
        closeLoginDialog().then(() => {
          log('[onCredentialsEnteredForMPServerHandler] closed login dialog');
        }).catch(e => {
          log('[onCredentialsEnteredForMPServerHandler]  error:', {
            e
          });
        });
        return true;
      }).catch(e => {
        const errorMessage = resolveErrorToDisplay(e);
        sendDisplayErrorMessage(errorMessage).then(() => {
          log('[onCredentialsEnteredForMPServerHandler] sendDisplayErrorMessage');
        }).catch(e => {
          log('[onCredentialsEnteredForMPServerHandler]  sendDisplayErrorMessage error:', {
            e
          });
        });
        return true;
      });
    }
  };
}
function wrapCreds(encryptedCreds) {
  return {
    encryptedCreds: encryptedCreds
  };
}
function onCredentialsEnteredForMPServer(credentials, mpServer) {
  rememberCredsInMemory(credentials);
  return encryptCredentials(mpServer, inMemoryCreds.username, inMemoryCreds.password).then(async encryptedCreds => {
    return wrapCreds(encryptedCreds);
  });
}
;// CONCATENATED MODULE: ./src/scripts/printdeploy/index.ts





;// CONCATENATED MODULE: ./src/scripts/window/window.ts
function windowResizeToInner(w, width, height) {
  w.resizeTo(width + (w.outerWidth - w.innerWidth), height + (w.outerHeight - w.innerHeight));
}
;// CONCATENATED MODULE: ./src/scripts/internationalization.js
/*
 * Copyright Â© 2017-2021 PaperCut Software International Pty. Ltd.
 */




function localizeHtmlPage() {
	log_log(`localizeHtmlPage: ${chrome.i18n.getUILanguage()}`);

	jquery_default()('.translated').each(function() {
		let element = jquery_default()(this);
		let key = element.data('key');
		let newText = key ? chrome.i18n.getMessage(key) : key;

		element.html(newText);
	});
}

localizeHtmlPage();

;// CONCATENATED MODULE: ./src/scripts/login/login.ts










chrome.runtime.onMessage.addListener(async (message, sender, sendResponse) => {
  if (message.type === 'login-window-init') {
    log_log('Received init window message.', {
      message
    });
    initLoginWindow(message);
    sendResponse();
  } else if (message.type === 'close-login-window') {
    log_log('Received close window message');
    exitLoadingState();
    hideErrors();
    sendResponse();
    window.close();
  } else if (message.type === 'display-error') {
    log_log('display-error message received', {
      message
    });
    const displayErrorMessage = message;
    exitLoadingState();
    showMessageForError(displayErrorMessage.errMsg);
    sendResponse();
  } else {
    log_log(`unknown message from '${sender.url}: ${JSON.stringify(message)}`);
    sendResponse();
  }
});
const credentialsResponseHandler = function (response) {
  log_log('[credentialsResponseHandler]');
  exitLoadingState();
  updateUiOnJobSubmissionResponse(response);
};
const updateUiOnJobSubmissionResponse = function (response) {
  exitLoadingState();
  if (response && response.ok) {
    log_log('Authentication successful. Job submitted successfully.');
    hideErrors();
    window.close();
  } else {
    const error = response && response.message ? response.message : 'Failed to log in. Please try again.';
    showMessageForError(error);
  }
};
function initLoginWindow(loginWindow) {
  const loginUsingPaperCutCredentials = function () {
    enterLoadingState();
    const isRemember = jquery_default()('#remember').is(':checked');
    const username = jquery_default()('#username').val();
    const password = jquery_default()('#password').val();
    log_log(`Credentials entered for username="${username}" with ${password.length === 0 ? 'an empty' : 'a non-empty'} password`);
    if (loginWindow.useCloudPrint === true) {
      sendPrintJobMessage({
        username: username,
        password: password
      }, isRemember, loginWindow.useCloudPrint, credentialsResponseHandler);
      return;
    }
    auth_encryptCredentials(loginWindow.urlBase, username, password).then(encryptedCreds => {
      sendPrintJobMessage(encryptedCreds, isRemember, loginWindow.useCloudPrint, credentialsResponseHandler);
    }).catch(e => {
      exitLoadingState();
      e instanceof Error ? showMessageForError(e.message) : showMessageForError(e);
    });
  };
  const loginUsingGSuite = function () {
    enterLoadingState();
    const isRemember = jquery_default()('#remember').is(':checked');
    log_log(`loginUsingGSuite selected: isRemember=${isRemember}`);
    if (loginWindow.usePrintDeploy) {
      return getPreconfiguredPrintDeployServer().then(host => getPrintDeployClient(host)).then(client => client.createOAuthSession(oauth_OAuthProviderIDs.Google)).then(async session => {
        const oauthSessionCreatedMessage = {
          type: 'oauth-session-created',
          sessionCredentials: session,
          rememberMe: isRemember
        };
        await chrome_sendPageMessageWithRetry(oauthSessionCreatedMessage);
      }).catch(e => {
        exitLoadingState();
        e instanceof Error ? showMessageForError(e.message) : showMessageForError(e);
      });
    }
    return authenticateWithGSuite(loginWindow.printJob, true, !loginWindow.useCloudPrint).then(credentials => {
      sendPrintJobMessage(credentials, isRemember, loginWindow.useCloudPrint, handleResponse, 'google');
    }).catch(e => {
      showMessageForError(e, true);
      exitLoadingState();
    });
    function handleResponse(response) {
      log_log('handleResponse:', response);
      if (response && response.message === 'Invalid username or password') {
        response.message = 'Unknown user';
        revokeCachedGSuiteAuthToken(5000).finally(() => {
          updateUiOnJobSubmissionResponse(response);
        });
      } else {
        if (!isRemember) {
          revokeCachedGSuiteAuthToken().finally(() => {
            updateUiOnJobSubmissionResponse(response);
          });
        } else {
          updateUiOnJobSubmissionResponse(response);
        }
      }
    }
  };
  const onLoginClick = function () {
    if (loginWindow.usePrintDeploy) {
      const rememberMe = jquery_default()('#remember').is(':checked');
      const credentials = {
        username: (jquery_default()('#username').val() || '').toString(),
        password: (jquery_default()('#password').val() || '').toString(),
        rememberMe: rememberMe
      };
      const onCredentialsEnteredMessage = {
        type: 'on-credentials-entered',
        credentials: credentials
      };
      chrome_sendPageMessageWithRetry(onCredentialsEnteredMessage).then(() => {
        log_log('credentials message sent');
      }).catch(e => {
        log_log('error sending credentials', {
          e
        });
      });
      enterLoadingState();
    } else {
      loginUsingPaperCutCredentials();
    }
  };
  const initialise = function () {
    log_log('Setting up login options.', {
      showUsernameLogin: loginWindow.showUsernameLogin,
      showGoogleLogin: loginWindow.showGoogleLogin
    });
    if (loginWindow.showUsernameLogin && !loginWindow.showGoogleLogin) {
      const size = {
        width: 494,
        height: 610
      };
      log_log('Resizing window for user/pass only.', size);
      windowResizeToInner(window, size.width, size.height);
    } else if (!loginWindow.showUsernameLogin && loginWindow.showGoogleLogin) {
      const size = {
        width: 494,
        height: 465
      };
      log_log('Resizing window for Sign in with Google only.', size);
      windowResizeToInner(window, size.width, size.height);
    }
    toggleRemember(loginWindow.showRememberMe);
    const loginForm = jquery_default()('#login-form');
    const userPassArea = jquery_default()('#login-form-username');
    const userPassLoginButton = jquery_default()('#login');
    const orArea = jquery_default()('#login-form-or');
    const googleArea = jquery_default()('#login-form-google');
    const googleLoginButton = jquery_default()('#googlelogin');
    if (loginWindow.showUsernameLogin) {
      userPassLoginButton.on('click', function () {
        if (loginForm.valid()) {
          onLoginClick();
        }
      });
    } else {
      userPassArea.hide();
    }
    orArea.css('visibility', loginWindow.showUsernameLogin && loginWindow.showGoogleLogin ? 'visible' : 'hidden');
    if (loginWindow.showGoogleLogin) {
      googleLoginButton.on('click', function () {
        hideErrors();
        loginUsingGSuite().then(() => {
          log_log('[login] loginUsingGSuite returned');
        });
      });
    } else {
      googleArea.hide();
    }
    loginForm.validate({
      errorPlacement: function (error, element) {
        jquery_default()(element).closest('form').find('label[for=\'' + element.attr('id') + '\']').append(error);
      },
      errorElement: 'span',
      messages: {
        username: {
          required: ' (required)'
        },
        password: {
          required: ' (required)'
        }
      }
    });
    jquery_default()('#close').on('click', function () {
      const loginWindowClosedMessage = {
        type: 'login-window-closed',
        msg: 'window closed'
      };
      chrome_sendPageMessageWithRetry(loginWindowClosedMessage).then(() => {
        log_log('sent login window closed message');
      }).catch(e => {
        log_log('no one heard about the windows closing', {
          e
        });
      });
      window.close();
    });
    loginForm.find('input').keypress(function (e) {
      if (e.which == 10 || e.which == 13) {
        if (loginForm.valid()) {
          onLoginClick();
        }
      }
    });
    loginForm.find('input').on('input', function () {
      hideErrors();
    });
    jquery_default()(document).keyup(function (event) {
      if (event.keyCode === 27) {
        window.close();
      }
    });
  };
  initialise();
}
function exitLoadingState() {
  const loginButton = jquery_default()('#login');
  loginButton.removeAttr('disabled').removeClass('loading');
  const googleLoginBtn = jquery_default()('#googlelogin');
  googleLoginBtn.removeAttr('disabled').removeClass('loading');
}
function toggleRemember(showRememberMe) {
  jquery_default()('#remember-me-container').toggle(showRememberMe);
}
function enterLoadingState() {
  const loginButton = jquery_default()('#login');
  loginButton.attr('disabled', 'disabled').addClass('loading');
  const googleLoginBtn = jquery_default()('#googlelogin');
  googleLoginBtn.attr('disabled', 'disabled').addClass('loading');
}
function hideErrors() {
  jquery_default()('span.error-message').each((idx, em) => {
    jquery_default()(em).hide();
  });
}
function isAuthError(err) {
  if (err) {
    return err.includes('user and password') || err.includes('authentication');
  }
  return false;
}
function isConnectionError(err) {
  if (err) {
    return err.includes('Connection failed') || err.includes('Could not connect') || err.includes('Failed to fetch') || isCloudPrintError(err);
  }
  return false;
}
function showMessageForError(err, displayVerbatim) {
  log_log(`showMessageForError: ${err}, displayVerbatim=${displayVerbatim}`);
  if (displayVerbatim) {
    jquery_default()('#error-message-show-verbatim').text(err).show();
  } else if (isAuthError(err)) {
    jquery_default()('#error-message-invalid-creds').show();
  } else if (err === 'The user did not approve access.') {
    jquery_default()('#error-message-grant-access').show();
  } else if (err === 'Unknown user') {
    jquery_default()('#error-message-unknown-g-account').show();
  } else if (err === 'GSuite not supported') {
    jquery_default()('#error-message-gsuite-not-supported').show();
  } else if (isConnectionError(err)) {
    jquery_default()('#error-message-connection-failed').show();
  } else if (err.includes('let third-party apps access Directory data')) {
    jquery_default()('#error-message-gsuite-third-party-access').show();
  } else if (err.includes('Printer access denied by group restriction')) {
    jquery_default()('#error-message-denied-group-restriction').show();
  } else if (err.includes('is not registered')) {
    jquery_default()('#error-message-email-unregistered').show();
  } else {
    jquery_default()('#error-message-invalid-creds').show();
  }
}
function sendPrintJobMessage(credentials, isRemember, useCloudPrint = false, responseHandler, authOption = '') {
  log_log(`sendPrintJobMessage: isRemember=${isRemember}, useCloudPrint=${useCloudPrint}, authOption=${authOption}`);
  const sendPrintJobMessage = {
    type: 'send-print-job-message',
    credentials: credentials,
    remember: isRemember,
    useCloudPrint: useCloudPrint,
    authOption: authOption
  };
  chrome.runtime.sendMessage(sendPrintJobMessage, {}, responseHandler);
}
chrome.runtime.onSuspend.addListener(() => {
  log_log('[login] Suspending.');
});
})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLGVBQWU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdDQUF3QztBQUN4QztBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLE9BQU87QUFDNUI7QUFDQTtBQUNBLEtBQUs7QUFDTCwrREFBK0QsR0FBRztBQUNsRTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLGdCQUFnQixxQkFBcUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsdUJBQXVCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGVBQWU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQ0FBK0MsWUFBWSxFQUFFO0FBQzdELEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2Q0FB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LEVBQUU7O0FBRUY7QUFDQSxtQkFBbUIsb0NBQW9DO0FBQ3ZEO0FBQ0E7O0FBRUEsd0JBQXdCO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7OztBQ25xREQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxNQUFNLEtBQTBCOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsWUFBWTs7QUFFckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGLG9CQUFvQjs7QUFFcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUYsOENBQThDO0FBQzlDO0FBQ0E7QUFDQSxtQkFBbUIsaUNBQWlDO0FBQ3BELEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVUsU0FBUztBQUNuQjtBQUNBOztBQUVBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsWUFBWTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBOzs7QUFHQTs7O0FBR0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxrQ0FBa0MsSUFBSTtBQUN0Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsMkJBQTJCO0FBQzNCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsMENBQTBDLElBQUk7QUFDOUM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUYsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsZUFBZTs7QUFFZixTQUFTOztBQUVUO0FBQ0EsU0FBUyxnQ0FBZ0M7QUFDekMsU0FBUyxtQkFBbUI7QUFDNUIsU0FBUyxxQ0FBcUM7QUFDOUMsU0FBUztBQUNULEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGtFQUFrRTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFROztBQUVSO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLFNBQVM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsU0FBUztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUosU0FBUyxTQUFTO0FBQ2xCO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsaURBQWlEO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBLFdBQVcsNENBQTRDO0FBQ3ZEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QjtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUEsU0FBUyxHQUFHO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsTUFBTTtBQUNOOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQiwyQkFBMkIsd0JBQXdCOztBQUVuRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSwyQ0FBMkM7QUFDM0MsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEseUNBQXlDLHFDQUFxQztBQUM5RSxxQ0FBcUMsc0NBQXNDO0FBQzNFLHFDQUFxQyxxQ0FBcUM7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7O0FBRVo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDO0FBQ3JDLHNDQUFzQztBQUN0QyxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7OztBQUtBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLGFBQWE7QUFDckMsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsU0FBUztBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTs7O0FBR0E7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0EsR0FBRztBQUNILGVBQWU7O0FBRWY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVMsZ0JBQWdCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLEVBQUU7QUFDRjs7QUFFQTs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEdBQUc7QUFDSDs7QUFFQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUyxPQUFPO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLE9BQU87QUFDaEI7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVc7O0FBRVg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsZUFBZSxzQkFBc0I7QUFDckM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsZ0VBQWdFO0FBQ2hFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVyxjQUFjOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHVDQUF1QztBQUNsRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdURBQXVEO0FBQy9FOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxJQUFJO0FBQ0osRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLCtDQUErQztBQUNyRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxlQUFlLG9DQUFvQzs7QUFFbkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsRUFBRTs7O0FBR0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDRDQUE0QyxPQUFPO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCOztBQUU5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLCtCQUErQjtBQUN4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5Q0FBeUMsT0FBTztBQUNoRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVUscUNBQXFDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUEsVUFBVSw4QkFBOEI7QUFDeEM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osRUFBRTs7QUFFRjtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGFBQWEsT0FBTztBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVUsV0FBVztBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOzs7O0FBSUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtDQUErQyxjQUFjLFdBQVc7QUFDeEUsbUJBQW1CLFVBQVU7QUFDN0I7QUFDQSxzQkFBc0IsY0FBYyxzQkFBc0IsZ0JBQWdCO0FBQzFFLGdCQUFnQixXQUFXLFlBQVk7QUFDdkMsY0FBYztBQUNkOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkNBQTZDLGNBQWM7QUFDM0QsK0NBQStDOztBQUUvQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7OztBQUdGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsOERBQThEO0FBQzNFO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUyxPQUFPOztBQUVoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZUFBZTtBQUNsQztBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTs7QUFFQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLFNBQVM7QUFDckI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQSxTQUFTLE9BQU87QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGdCQUFnQjtBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsa0RBQWtELDBCQUEwQjtBQUM1RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7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SUFBSTtBQUNKO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLFlBQVksaUJBQWlCO0FBQzdCLGVBQWU7QUFDZixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLFNBQVMsbUJBQW1CO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7OztBQUtGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7Ozs7QUFLRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQix1QkFBdUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQix1QkFBdUI7QUFDekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQix1QkFBdUI7QUFDeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7Ozs7O0FBS0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxrQ0FBa0M7QUFDbEM7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7OztBQUtGO0FBQ0E7O0FBRUEsY0FBYzs7QUFFZDs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNENBQTRDO0FBQzVDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSixHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsTUFBTTtBQUNOOztBQUVBLFlBQVk7QUFDWixJQUFJO0FBQ0o7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjs7QUFFaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjs7QUFFaEIscURBQXFEO0FBQ3JEOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVU7QUFDVjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7O0FBRW5EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDOztBQUVsQztBQUNBLHNCQUFzQjtBQUN0QiwyQkFBMkI7O0FBRTNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsSUFBSTtBQUNKLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHVCQUF1QjtBQUNuQyxZQUFZLHdCQUF3QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7Ozs7QUFLRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQyxjQUFjLHVDQUF1QztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7OztBQUtGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7Ozs7QUFLRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7O0FBRUE7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxxREFBcUQ7QUFDckQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9COztBQUVwQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsRUFBRTs7QUFFRjtBQUNBLGVBQWUscURBQXFEO0FBQ3BFOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0EsZUFBZSxrQ0FBa0M7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7Ozs7O0FBS0Y7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUssSUFBMEM7QUFDL0MsQ0FBQyxpQ0FBa0Is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ckJDLGNBQWMsRUFBRSxPQUFPO0VBQ3ZCTCxVQUFVLEVBQUUsS0FBSztFQUNqQk0sbUJBQW1CLEVBQUU7QUFDekIsQ0FBQyxFQUNEO0VBQ0lyRCxJQUFJLEVBQUUsUUFBUTtFQUNkbUQsYUFBYSxFQUFFLE1BQU07RUFDckJDLGNBQWMsRUFBRSxNQUFNO0VBQ3RCTCxVQUFVLEVBQUUsS0FBSztFQUNqQk0sbUJBQW1CLEVBQUU7QUFDekIsQ0FBQyxFQUNEO0VBQ0lyRCxJQUFJLEVBQUUsUUFBUTtFQUNkbUQsYUFBYSxFQUFFLE1BQU07RUFDckJDLGNBQWMsRUFBRSxNQUFNO0VBQ3RCTCxVQUFVLEVBQUUsS0FBSztFQUNqQk0sbUJBQW1CLEVBQUU7QUFDekIsQ0FBQyxFQUNEO0VBQ0lyRCxJQUFJLEVBQUUsUUFBUTtFQUNkbUQsYUFBYSxFQUFFLE1BQU07RUFDckJDLGNBQWMsRUFBRSxNQUFNO0VBQ3RCTCxVQUFVLEVBQUUsS0FBSztFQUNqQk0sbUJBQW1CLEVBQUU7QUFDekIsQ0FBQyxFQUNEO0VBQ0lyRCxJQUFJLEVBQUUsUUFBUTtFQUNkbUQsYUFBYSxFQUFFLE1BQU07RUFDckJDLGNBQWMsRUFBRSxNQUFNO0VBQ3RCTCxVQUFVLEVBQUUsS0FBSztFQUNqQk0sbUJBQW1CLEVBQUU7QUFDekIsQ0FBQyxFQUNEO0VBQ0lyRCxJQUFJLEVBQUUsUUFBUTtFQUNkbUQsYUFBYSxFQUFFLE1BQU07RUFDckJDLGNBQWMsRUFBRSxNQUFNO0VBQ3RCTCxVQUFVLEVBQUUsS0FBSztFQUNqQk0sbUJBQW1CLEVBQUU7QUFDekIsQ0FBQyxFQUNEO0VBQ0lyRCxJQUFJLEVBQUUsUUFBUTtFQUNkbUQsYUFBYSxFQUFFLEtBQUs7RUFDcEJDLGNBQWMsRUFBRSxNQUFNO0VBQ3RCTCxVQUFVLEVBQUUsS0FBSztFQUNqQk0sbUJBQW1CLEVBQUU7QUFDekIsQ0FBQyxFQUNEO0VBQ0lyRCxJQUFJLEVBQUUsUUFBUTtFQUNkbUQsYUFBYSxFQUFFLEtBQUs7RUFDcEJDLGNBQWMsRUFBRSxLQUFLO0VBQ3JCTCxVQUFVLEVBQUUsS0FBSztFQUNqQk0sbUJBQW1CLEVBQUU7QUFDekIsQ0FBQyxFQUNEO0VBQ0lyRCxJQUFJLEVBQUUsUUFBUTtFQUNkbUQsYUFBYSxFQUFFLEtBQUs7RUFDcEJDLGNBQWMsRUFBRSxLQUFLO0VBQ3JCTCxVQUFVLEVBQUUsS0FBSztFQUNqQk0sbUJBQW1CLEVBQUU7QUFDekIsQ0FBQyxFQUNEO0VBQ0lyRCxJQUFJLEVBQUUsU0FBUztFQUNmbUQsYUFBYSxFQUFFLEtBQUs7RUFDcEJDLGNBQWMsRUFBRSxLQUFLO0VBQ3JCTCxVQUFVLEVBQUUsS0FBSztFQUNqQk0sbUJBQW1CLEVBQUU7QUFDekIsQ0FBQyxFQUNEO0VBQ0lyRCxJQUFJLEVBQUUsV0FBVztFQUNqQm1ELGFBQWEsRUFBRSxNQUFNO0VBQ3JCQyxjQUFjLEVBQUUsTUFBTTtFQUN0QkwsVUFBVSxFQUFFLEtBQUs7RUFDakJNLG1CQUFtQixFQUFFO0FBQ3pCLENBQUMsRUFDRDtFQUNJckQsSUFBSSxFQUFFLFVBQVU7RUFDaEJtRCxhQUFhLEVBQUUsTUFBTTtFQUNyQkMsY0FBYyxFQUFFLE1BQU07RUFDdEJMLFVBQVUsRUFBRSxLQUFLO0VBQ2pCTSxtQkFBbUIsRUFBRTtBQUN6QixDQUFDLEVBQ0Q7RUFDSXJELElBQUksRUFBRSxRQUFRO0VBQ2RtRCxhQUFhLEVBQUUsTUFBTTtFQUNyQkMsY0FBYyxFQUFFLE1BQU07RUFDdEJMLFVBQVUsRUFBRSxLQUFLO0VBQ2pCTSxtQkFBbUIsRUFBRTtBQUN6QixDQUFDLEVBQ0Q7RUFDSXJELElBQUksRUFBRSxjQUFjO0VBQ3BCbUQsYUFBYSxFQUFFLE1BQU07RUFDckJDLGNBQWMsRUFBRSxNQUFNO0VBQ3RCTCxVQUFVLEVBQUUsS0FBSztFQUNqQk0sbUJBQW1CLEVBQUU7QUFDekIsQ0FBQyxFQUNEO0VBQ0lyRCxJQUFJLEVBQUUsWUFBWTtFQUNsQm1ELGFBQWEsRUFBRSxNQUFNO0VBQ3JCQyxjQUFjLEVBQUUsTUFBTTtFQUN0QkwsVUFBVSxFQUFFLEtBQUs7RUFDakJNLG1CQUFtQixFQUFFO0FBQ3pCLENBQUMsRUFDRDtFQUNJckQsSUFBSSxFQUFFLFdBQVc7RUFDakJtRCxhQUFhLEVBQUUsTUFBTTtFQUNyQkMsY0FBYyxFQUFFLE1BQU07RUFDdEJMLFVBQVUsRUFBRSxLQUFLO0VBQ2pCTSxtQkFBbUIsRUFBRTtBQUN6QixDQUFDLENBQ0o7QUFDTSxTQUFTRSx5QkFBeUJBLENBQUNDLFlBQVksR0FBR1YsbUJBQW1CLEVBQUVXLGFBQWEsR0FBR1Qsb0JBQW9CLEVBQUVVLFVBQVUsR0FBR1IsaUJBQWlCLEVBQUU7RUFDaEosT0FBTztJQUNIM0YsT0FBTyxFQUFFLEtBQUs7SUFDZG9HLE9BQU8sRUFBRTtNQUNMQyxzQkFBc0IsRUFBRSxDQUFDO1FBQUVDLFlBQVksRUFBRTtNQUFrQixDQUFDLENBQUM7TUFDN0RDLEtBQUssRUFBRTtRQUNIQyxNQUFNLEVBQUVQO01BQ1osQ0FBQztNQUNEUSxNQUFNLEVBQUU7UUFDSkQsTUFBTSxFQUFFTjtNQUNaLENBQUM7TUFDRFEsZ0JBQWdCLEVBQUU7UUFDZEYsTUFBTSxFQUFFLENBQ0o7VUFBRTlSLElBQUksRUFBRSxVQUFVO1VBQUU4USxVQUFVLEVBQUU7UUFBSyxDQUFDLEVBQ3RDO1VBQUU5USxJQUFJLEVBQUUsV0FBVztVQUFFOFEsVUFBVSxFQUFFO1FBQU0sQ0FBQyxFQUN4QztVQUFFOVEsSUFBSSxFQUFFLE1BQU07VUFBRThRLFVBQVUsRUFBRTtRQUFNLENBQUM7TUFFM0MsQ0FBQztNQUNEbUIsTUFBTSxFQUFFO1FBQUVDLE9BQU8sRUFBRSxDQUFDO1FBQUU1TixHQUFHLEVBQUU7TUFBSSxDQUFDO01BQ2hDNk4sVUFBVSxFQUFFO1FBQUVMLE1BQU0sRUFBRUw7TUFBVztJQUNyQztFQUNKLENBQUM7QUFDTDtBQUNPLFNBQVNXLDJDQUE4QkEsQ0FBQ0MsWUFBWSxFQUFFO0VBQ3pELE1BQU1aLFVBQVUsR0FBR1ksWUFBWSxDQUFDWixVQUFVLENBQUNhLEdBQUcsQ0FBRUMsQ0FBQyxLQUFNO0lBQ25EeEUsSUFBSSxFQUFFLFFBQVE7SUFDZG1ELGFBQWEsRUFBRXFCLENBQUMsQ0FBQ0MsWUFBWTtJQUM3QnJCLGNBQWMsRUFBRW9CLENBQUMsQ0FBQ0UsYUFBYTtJQUMvQjNCLFVBQVUsRUFBRXlCLENBQUMsQ0FBQ0csU0FBUztJQUN2QnRCLG1CQUFtQixFQUFFbUIsQ0FBQyxDQUFDSSxpQkFBaUIsSUFBSUosQ0FBQyxDQUFDeEU7RUFDbEQsQ0FBQyxDQUFDLENBQUM7RUFDSCxJQUFJMEQsVUFBVSxDQUFDelMsTUFBTSxHQUFHLENBQUMsSUFDckJ5UyxVQUFVLENBQUNtQixLQUFLLENBQUMsVUFBVUwsQ0FBQyxFQUFFO0lBQzFCLE9BQU8sQ0FBQ0EsQ0FBQyxDQUFDekIsVUFBVTtFQUN4QixDQUFDLENBQUMsRUFBRTtJQUNKVyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUNYLFVBQVUsR0FBRyxJQUFJO0VBQ25DO0VBQ0EsTUFBTVMsWUFBWSxHQUFHYyxZQUFZLENBQUNSLEtBQUssQ0FBQ1MsR0FBRyxDQUFDLFVBQVU1VSxDQUFDLEVBQUU7SUFDckQsT0FBTztNQUFFc0MsSUFBSSxFQUFFdEM7SUFBRSxDQUFDO0VBQ3RCLENBQUMsQ0FBQztFQUNGLElBQUk2VCxZQUFZLENBQUN2UyxNQUFNLEdBQUcsQ0FBQyxFQUFFO0lBQ3pCdVMsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDLFlBQVksQ0FBQyxHQUFHLElBQUk7RUFDeEM7RUFDQSxNQUFNQyxhQUFhLEdBQUdhLFlBQVksQ0FBQ04sTUFBTSxDQUFDTyxHQUFHLENBQUMsVUFBVTVVLENBQUMsRUFBRTtJQUN2RCxPQUFPO01BQUVzQyxJQUFJLEVBQUV0QztJQUFFLENBQUM7RUFDdEIsQ0FBQyxDQUFDO0VBQ0YsSUFBSThULGFBQWEsQ0FBQ3hTLE1BQU0sR0FBRyxDQUFDLEVBQUU7SUFDMUJ3UyxhQUFhLENBQUMsQ0FBQyxDQUFDLENBQUMsWUFBWSxDQUFDLEdBQUcsSUFBSTtFQUN6QztFQUNBLE9BQU9GLHlCQUF5QixDQUFDQyxZQUFZLEVBQUVDLGFBQWEsRUFBRUMsVUFBVSxDQUFDO0FBQzdFOztBQzNWTyxlQUFlb0IscUJBQXFCQSxDQUFDQyxHQUFHLEVBQUU7RUFDN0MsT0FBTyxJQUFJOVIsT0FBTyxDQUFDLENBQUNDLE9BQU8sRUFBRWtDLE1BQU0sS0FBSztJQUNwQ2xGLE1BQU0sQ0FBQ0MsT0FBTyxDQUFDNlUsT0FBTyxDQUFDM1UsR0FBRyxDQUFDMFUsR0FBRyxFQUFFLFVBQVU3UyxJQUFJLEVBQUU7TUFDNUMsSUFBSUEsSUFBSSxJQUFJQSxJQUFJLENBQUM2UyxHQUFHLENBQUMsRUFBRTtRQUNuQjdSLE9BQU8sQ0FBQ2hCLElBQUksQ0FBQzZTLEdBQUcsQ0FBQyxDQUFDO01BQ3RCLENBQUMsTUFDSSxJQUFJN1UsTUFBTSxDQUFDNkIsT0FBTyxDQUFDa1QsU0FBUyxFQUFFO1FBQy9CN1AsTUFBTSxDQUFDbEYsTUFBTSxDQUFDNkIsT0FBTyxDQUFDa1QsU0FBUyxDQUFDO01BQ3BDLENBQUMsTUFDSTtRQUNEL1IsT0FBTyxDQUFDbEQsU0FBUyxDQUFDO01BQ3RCO0lBQ0osQ0FBQyxDQUFDO0VBQ04sQ0FBQyxDQUFDO0FBQ047QUFDTyxlQUFlNEMsMkJBQW1CQSxDQUFDbVMsR0FBRyxFQUFFO0VBQzNDLE9BQU8sSUFBSTlSLE9BQU8sQ0FBQyxDQUFDQyxPQUFPLEVBQUVrQyxNQUFNLEtBQUs7SUFDcENsRixNQUFNLENBQUNDLE9BQU8sQ0FBQ0MsS0FBSyxDQUFDQyxHQUFHLENBQUMwVSxHQUFHLEVBQUd4UyxNQUFNLElBQUs7TUFDdEMsSUFBSUEsTUFBTSxJQUFJQSxNQUFNLENBQUN3UyxHQUFHLENBQUMsRUFBRTtRQUN2QjdSLE9BQU8sQ0FBQ1gsTUFBTSxDQUFDd1MsR0FBRyxDQUFDLENBQUM7TUFDeEIsQ0FBQyxNQUNJLElBQUk3VSxNQUFNLENBQUM2QixPQUFPLENBQUNrVCxTQUFTLEVBQUU7UUFDL0I3UCxNQUFNLENBQUNsRixNQUFNLENBQUM2QixPQUFPLENBQUNrVCxTQUFTLENBQUM7TUFDcEMsQ0FBQyxNQUNJO1FBQ0QvUixPQUFPLENBQUNsRCxTQUFTLENBQUM7TUFDdEI7SUFDSixDQUFDLENBQUM7RUFDTixDQUFDLENBQUM7QUFDTjtBQUNPLGVBQWVrVixzQkFBc0JBLENBQUNDLElBQUksRUFBRTtFQUMvQyxPQUFPLElBQUlsUyxPQUFPLENBQUMsQ0FBQ0MsT0FBTyxFQUFFa0MsTUFBTSxLQUFLO0lBQ3BDbEYsTUFBTSxDQUFDQyxPQUFPLENBQUNDLEtBQUssQ0FBQ2dWLE1BQU0sQ0FBQ0QsSUFBSSxFQUFFLE1BQU07TUFDcEMsSUFBSWpWLE1BQU0sQ0FBQzZCLE9BQU8sQ0FBQ2tULFNBQVMsRUFBRTtRQUMxQjdQLE1BQU0sQ0FBQ2xGLE1BQU0sQ0FBQzZCLE9BQU8sQ0FBQ2tULFNBQVMsQ0FBQztNQUNwQyxDQUFDLE1BQ0k7UUFDRC9SLE9BQU8sQ0FBQyxDQUFDO01BQ2I7SUFDSixDQUFDLENBQUM7RUFDTixDQUFDLENBQUM7QUFDTjtBQUNPLGVBQWVMLDJCQUFtQkEsQ0FBQ2tTLEdBQUcsRUFBRTdTLElBQUksRUFBRTtFQUNqRCxPQUFPLElBQUllLE9BQU8sQ0FBQyxDQUFDQyxPQUFPLEVBQUVrQyxNQUFNLEtBQUs7SUFDcENsRixNQUFNLENBQUNDLE9BQU8sQ0FBQ0MsS0FBSyxDQUFDOEosR0FBRyxDQUFDO01BQUUsQ0FBQzZLLEdBQUcsR0FBRzdTO0lBQUssQ0FBQyxFQUFFLE1BQU07TUFDNUMsSUFBSWhDLE1BQU0sQ0FBQzZCLE9BQU8sQ0FBQ2tULFNBQVMsRUFBRTtRQUMxQjdQLE1BQU0sQ0FBQ2xGLE1BQU0sQ0FBQzZCLE9BQU8sQ0FBQ2tULFNBQVMsQ0FBQ3hDLE9BQU8sQ0FBQztNQUM1QyxDQUFDLE1BQ0k7UUFDRHZQLE9BQU8sQ0FBQ2hCLElBQUksQ0FBQztNQUNqQjtJQUNKLENBQUMsQ0FBQztFQUNOLENBQUMsQ0FBQztBQUNOO0FBQ08sZUFBZW1ULE9BQU9BLENBQUNOLEdBQUcsRUFBRVIsR0FBRyxFQUFFO0VBQ3BDLE9BQU8sSUFBSXRSLE9BQU8sQ0FBQyxDQUFDQyxPQUFPLEVBQUVrQyxNQUFNLEtBQUs7SUFDcENsRixNQUFNLENBQUNDLE9BQU8sQ0FBQ0MsS0FBSyxDQUFDOEosR0FBRyxDQUFDO01BQ3JCLENBQUM2SyxHQUFHLEdBQUdPLEtBQUssQ0FBQ0MsSUFBSSxDQUFDaEIsR0FBRyxDQUFDaUIsT0FBTyxDQUFDLENBQUM7SUFDbkMsQ0FBQyxFQUFFLE1BQU07TUFDTCxJQUFJdFYsTUFBTSxDQUFDNkIsT0FBTyxDQUFDa1QsU0FBUyxFQUFFO1FBQzFCN1AsTUFBTSxDQUFDbEYsTUFBTSxDQUFDNkIsT0FBTyxDQUFDa1QsU0FBUyxDQUFDeEMsT0FBTyxDQUFDO01BQzVDLENBQUMsTUFDSTtRQUNEdlAsT0FBTyxDQUFDNlIsR0FBRyxDQUFDO01BQ2hCO0lBQ0osQ0FBQyxDQUFDO0VBQ04sQ0FBQyxDQUFDO0FBQ047QUFDTyxlQUFlVSxlQUFPQSxDQUFDVixHQUFHLEVBQUU7RUFDL0IsT0FBTyxJQUFJOVIsT0FBTyxDQUFDLENBQUNDLE9BQU8sRUFBRWtDLE1BQU0sS0FBSztJQUNwQ2xGLE1BQU0sQ0FBQ0MsT0FBTyxDQUFDQyxLQUFLLENBQUNDLEdBQUcsQ0FBQzBVLEdBQUcsRUFBRy9WLENBQUMsSUFBSztNQUNqQyxJQUFJQSxDQUFDLElBQUlBLENBQUMsQ0FBQytWLEdBQUcsQ0FBQyxFQUFFO1FBQ2IsTUFBTVIsR0FBRyxHQUFHLElBQUloTCxHQUFHLENBQUMsQ0FBQztRQUNyQixLQUFLLE1BQU0sQ0FBQ21NLENBQUMsRUFBRWxULENBQUMsQ0FBQyxJQUFJeEQsQ0FBQyxDQUFDK1YsR0FBRyxDQUFDLEVBQUU7VUFDekJSLEdBQUcsQ0FBQ3JLLEdBQUcsQ0FBQ3dMLENBQUMsRUFBRWxULENBQUMsQ0FBQztRQUNqQjtRQUNBVSxPQUFPLENBQUNxUixHQUFHLENBQUM7TUFDaEIsQ0FBQyxNQUNJLElBQUlyVSxNQUFNLENBQUM2QixPQUFPLENBQUNrVCxTQUFTLEVBQUU7UUFDL0I3UCxNQUFNLENBQUNsRixNQUFNLENBQUM2QixPQUFPLENBQUNrVCxTQUFTLENBQUN4QyxPQUFPLENBQUM7TUFDNUMsQ0FBQyxNQUNJO1FBQ0R2UCxPQUFPLENBQUNsRCxTQUFTLENBQUM7TUFDdEI7SUFDSixDQUFDLENBQUM7RUFDTixDQUFDLENBQUM7QUFDTjs7QUN0RkEsZUFBZTJWLEtBQUtBLENBQUNDLE1BQU0sRUFBRTtFQUN6QixPQUFPLElBQUkzUyxPQUFPLENBQUM0UyxDQUFDLElBQUlySixVQUFVLENBQUNxSixDQUFDLEVBQUVELE1BQU0sQ0FBQyxDQUFDO0FBQ2xEO0FBQ08sZUFBZUUsZ0JBQWdCQSxDQUFDQyxZQUFZLEVBQUVDLFdBQVcsR0FBRyxJQUFJLEVBQUVDLGNBQWMsR0FBRyxLQUFLLEVBQUU7RUFDN0YsTUFBTUMsT0FBTyxHQUFHbEgsV0FBVyxDQUFDckgsR0FBRyxDQUFDLENBQUM7RUFDakMsT0FBTyxDQUFDb08sWUFBWSxDQUFDLENBQUMsRUFBRTtJQUNwQixJQUFJL0csV0FBVyxDQUFDckgsR0FBRyxDQUFDLENBQUMsR0FBR3VPLE9BQU8sR0FBR0QsY0FBYyxFQUFFO01BQzlDLE9BQU8sS0FBSztJQUNoQjtJQUNBLE1BQU1OLEtBQUssQ0FBQ0ssV0FBVyxDQUFDO0VBQzVCO0VBQ0EsT0FBTyxJQUFJO0FBQ2Y7QUFDTyxlQUFlRyxlQUFlQSxDQUFDcFAsT0FBTyxFQUFFO0VBQzNDLE1BQU1xUCxTQUFTLEdBQUdDLFdBQVcsQ0FBQyxZQUFZO0lBQ3RDclksT0FBTyxDQUFDd0MsR0FBRyxDQUFDLFlBQVksQ0FBQztJQUN6Qk4sTUFBTSxDQUFDNkIsT0FBTyxDQUFDdVUsZUFBZSxDQUFDLENBQUM7RUFDcEMsQ0FBQyxFQUFFLEVBQUUsR0FBRyxJQUFJLENBQUM7RUFDYixNQUFNdkgsU0FBUyxHQUFHbk4sSUFBSSxDQUFDK0YsR0FBRyxDQUFDLENBQUM7RUFDNUIsSUFBSTtJQUNBM0osT0FBTyxDQUFDd0MsR0FBRyxDQUFDLDRCQUE0QixDQUFDO0lBQ3pDLE9BQU8sTUFBTXVHLE9BQU87RUFDeEIsQ0FBQyxDQUNELE9BQU96RixDQUFDLEVBQUU7SUFDTnRELE9BQU8sQ0FBQ3dDLEdBQUcsQ0FBQyw0QkFBNEIsRUFBRWMsQ0FBQyxDQUFDO0VBQ2hELENBQUMsU0FDTztJQUNKdEQsT0FBTyxDQUFDd0MsR0FBRyxDQUFFLDhDQUE2QyxDQUFDb0IsSUFBSSxDQUFDK0YsR0FBRyxDQUFDLENBQUMsR0FBR29ILFNBQVMsSUFBSSxJQUFLLFNBQVEsQ0FBQztJQUNuR3dILGFBQWEsQ0FBQ0gsU0FBUyxDQUFDO0VBQzVCO0FBQ0o7OztBQzlCMEM7QUFDK0I7QUFDTjtBQUN4QjtBQUNwQyxNQUFNSSx3QkFBd0IsR0FBRyxJQUFJak4sR0FBRyxDQUFDLENBQUM7QUFDakQsTUFBTWtOLHFCQUFxQixHQUFHLElBQUlsTixHQUFHLENBQUMsQ0FBQztBQUN2QyxNQUFNbU4sNkJBQTZCLEdBQUcscUJBQXFCO0FBQzNELE1BQU1DLG1CQUFtQixHQUFHLElBQUlwTixHQUFHLENBQUMsQ0FBQztBQUNyQyxNQUFNcU4sNEJBQTRCLEdBQUcsb0JBQW9CO0FBQ3pELE1BQU1DLGdDQUFnQyxHQUFHLHdCQUF3QjtBQUNqRSxNQUFNQywwQkFBMEIsR0FBRyxrQkFBa0I7QUFDckQsTUFBTUMseUJBQXlCLEdBQUcsaUJBQWlCO0FBQ25ELE1BQU1DLGtCQUFrQixHQUFHLElBQUl6TixHQUFHLENBQUMsQ0FBQztBQUNwQyxNQUFNME4sMEJBQTBCLEdBQUcsSUFBSTFOLEdBQUcsQ0FBQyxDQUFDO0FBQzVDLE1BQU0yTixlQUFlLEdBQUcsSUFBSTNOLEdBQUcsQ0FBQyxDQUFDO0FBQ2pDLE1BQU00TiwrQkFBK0IsR0FBRyx1QkFBdUI7QUFDL0QsTUFBTUMsOEJBQThCLEdBQUcsc0JBQXNCO0FBQzdELElBQUlDLHFCQUFxQjtBQUN6QixJQUFJQyxvQkFBb0I7QUFDeEIsSUFBSUMsV0FBVyxHQUFHLEtBQUs7QUFDaEIsZUFBZUMseUJBQVNBLENBQUEsRUFBRztFQUM5QixNQUFNLENBQUNDLFlBQVksRUFBRUMsVUFBVSxDQUFDLEdBQUcsTUFBTXpVLE9BQU8sQ0FBQzBQLEdBQUcsQ0FBQyxDQUNqRC9QLG1CQUFtQixDQUFDdVUsK0JBQStCLENBQUMsQ0FBQzFZLElBQUksQ0FBQytELENBQUMsSUFBSUEsQ0FBQyxHQUFHLENBQUNBLENBQUMsR0FBRyxJQUFJLENBQUMsRUFDN0VJLG1CQUFtQixDQUFDd1UsOEJBQThCLENBQUMsQ0FBQzNZLElBQUksQ0FBQytELENBQUMsSUFBSUEsQ0FBQyxHQUFHLENBQUNBLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FDN0UsQ0FBQztFQUNGNlUscUJBQXFCLEdBQUdJLFlBQVk7RUFDcENILG9CQUFvQixHQUFHSSxVQUFVO0VBQ2pDbFgsR0FBRyxDQUFFLHlEQUF3RDZXLHFCQUFzQixRQUFPLEdBQ3JGLHdCQUF1QkMsb0JBQXFCLE9BQU0sQ0FBQztFQUN4REssYUFBYSxDQUFDTixxQkFBcUIsRUFBRUMsb0JBQW9CLENBQUM7QUFDOUQ7QUFDTyxTQUFTTSx3QkFBd0JBLENBQUEsRUFBRztFQUN2QyxPQUFPbkIscUJBQXFCO0FBQ2hDO0FBQ08sU0FBU29CLDRDQUE0QkEsQ0FBQSxFQUFHO0VBQzNDLE9BQU9sQixtQkFBbUI7QUFDOUI7QUFDTyxTQUFTbUIsNkNBQTZCQSxDQUFBLEVBQUc7RUFDNUMsT0FBT2IsMEJBQTBCO0FBQ3JDO0FBQ08sU0FBU2Msa0NBQWtCQSxDQUFBLEVBQUc7RUFDakMsT0FBT2IsZUFBZTtBQUMxQjtBQUNPLFNBQVNjLGdCQUFnQkEsQ0FBQ0MsaUJBQWlCLEVBQUVuSyxVQUFVLEVBQUU7RUFDNUQsSUFBSSxDQUFDQSxVQUFVLEVBQUU7SUFDYmhNLFFBQUksQ0FBQywrQ0FBK0MsQ0FBQztFQUN6RDtFQUNBdEIsT0FBRyxDQUFFLDhDQUE2Q3lYLGlCQUFrQixFQUFDLENBQUM7RUFDdEVGLGtDQUFrQixDQUFDLENBQUMsQ0FBQzdOLEdBQUcsQ0FBQytOLGlCQUFpQixFQUFFbkssVUFBVSxDQUFDO0VBQ3ZEb0ssZ0JBQWdCLENBQUNuQix5QkFBeUIsRUFBRUcsZUFBZSxDQUFDLENBQ3ZEelksSUFBSSxDQUFDLE1BQU0rQixPQUFHLENBQUUsK0NBQThDeVgsaUJBQWtCLEVBQUMsQ0FBQyxDQUFDO0FBQzVGO0FBQ08sU0FBU0UsZ0JBQWdCQSxDQUFDcFMsUUFBUSxFQUFFcVMsVUFBVSxFQUFFO0VBQ25ELE1BQU1DLG1CQUFtQixHQUFHUiw0Q0FBNEIsQ0FBQyxDQUFDO0VBQzFEUSxtQkFBbUIsQ0FBQ25PLEdBQUcsQ0FBQ25FLFFBQVEsRUFBRXFTLFVBQVUsQ0FBQztFQUM3Q0YsZ0JBQWdCLENBQUN4Qiw2QkFBNkIsRUFBRTJCLG1CQUFtQixDQUFDLENBQy9ENVosSUFBSSxDQUFDLE1BQU0rQixPQUFHLENBQUUsNEJBQTJCdUYsUUFBUyxLQUFJdEYsSUFBSSxDQUFDQyxTQUFTLENBQUMwWCxVQUFVLENBQUUsS0FBSSxDQUFDLENBQUM7QUFDbEc7QUFDQSxTQUFTVCxhQUFhQSxDQUFDTixxQkFBcUIsRUFBRUMsb0JBQW9CLEVBQUU7RUFDaEVyVSxPQUFPLENBQUMwUCxHQUFHLENBQUMsQ0FDUjJGLGtCQUFrQixDQUFDMUIsNEJBQTRCLEVBQUVJLGtCQUFrQixDQUFDLEVBQ3BFc0Isa0JBQWtCLENBQUN6QixnQ0FBZ0MsRUFBRUwsd0JBQXdCLENBQUMsRUFDOUU4QixrQkFBa0IsQ0FBQ3hCLDBCQUEwQixFQUFFRywwQkFBMEIsQ0FBQyxFQUMxRXFCLGtCQUFrQixDQUFDdkIseUJBQXlCLEVBQUVHLGVBQWUsQ0FBQyxFQUM5RG9CLGtCQUFrQixDQUFDNUIsNkJBQTZCLEVBQUVDLG1CQUFtQixDQUFDLENBQ3pFLENBQUMsQ0FBQ2xZLElBQUksQ0FBQyxNQUFNO0lBQ1Z5QixNQUFNLENBQUNDLE9BQU8sQ0FBQ0MsS0FBSyxDQUFDbVksYUFBYSxDQUFDQyxVQUFVLElBQUk7TUFDN0NoWSxHQUFHLENBQUUseURBQXdELENBQUNnWSxVQUFVLEdBQUcsSUFBSSxFQUFFakosT0FBTyxDQUFDLENBQUMsQ0FBRSxLQUFJLENBQUM7TUFDakcsSUFBSWlKLFVBQVUsR0FBRyxJQUFJLElBQUluQixxQkFBcUIsRUFBRTtRQUM1Q3ZWLElBQUksQ0FBRSx1Q0FBc0N1VixxQkFBc0I7QUFDbEYscURBQXFEQyxvQkFBcUIsVUFBUyxDQUFDO1FBQ3BFbUIsY0FBYyxDQUFDbkIsb0JBQW9CLENBQUMsQ0FDL0I3WSxJQUFJLENBQUMsTUFBTStCLEdBQUcsQ0FBRSx3Q0FBdUM4VyxvQkFBcUIsT0FBTSxDQUFDLENBQUM7TUFDN0Y7TUFDQUMsV0FBVyxHQUFHLElBQUk7TUFDbEIvVyxHQUFHLENBQUMsNENBQTRDLENBQUM7SUFDckQsQ0FBQyxDQUFDO0VBQ04sQ0FBQyxDQUFDO0FBQ047QUFDQSxlQUFlOFgsa0JBQWtCQSxDQUFDdkQsR0FBRyxFQUFFMkQsS0FBSyxFQUFFO0VBQzFDLElBQUk7SUFDQSxNQUFNbkUsR0FBRyxHQUFHLE1BQU1rQixPQUFPLENBQUNWLEdBQUcsQ0FBQztJQUM5QixJQUFJUixHQUFHLEVBQUU7TUFDTG9FLFNBQVMsQ0FBQ3BFLEdBQUcsRUFBRW1FLEtBQUssQ0FBQztNQUNyQmxZLEdBQUcsQ0FBRSxXQUFVdVUsR0FBSSxVQUFTUixHQUFHLENBQUN0UCxJQUFLLDhCQUE2QixDQUFDO0lBQ3ZFLENBQUMsTUFDSTtNQUNEekUsR0FBRyxDQUFFLG1CQUFrQnVVLEdBQUkseUNBQXdDLENBQUM7SUFDeEU7RUFDSixDQUFDLENBQ0QsT0FBTzZELE1BQU0sRUFBRTtJQUNYLE9BQU8zYSxLQUFLLENBQUUsbUJBQWtCOFcsR0FBSSx5QkFBd0I2RCxNQUFPLEVBQUMsQ0FBQztFQUN6RTtBQUNKO0FBQ0EsZUFBZVYsZ0JBQWdCQSxDQUFDbkQsR0FBRyxFQUFFUixHQUFHLEVBQUU7RUFDdEMsSUFBSTtJQUNBLE1BQU1jLE9BQU8sQ0FBQ04sR0FBRyxFQUFFUixHQUFHLENBQUM7SUFDdkIsT0FBTy9ULE9BQUcsQ0FBRSxVQUFTdVUsR0FBSSxVQUFTUixHQUFHLENBQUN0UCxJQUFLLDRCQUEyQixDQUFDO0VBQzNFLENBQUMsQ0FDRCxPQUFPMlQsTUFBTSxFQUFFO0lBQ1gzYSxTQUFLLENBQUUseUNBQXdDMmEsTUFBTyxFQUFDLENBQUM7SUFDeEQsSUFBSUEsTUFBTSxJQUFJQSxNQUFNLENBQUNDLFdBQVcsQ0FBQyxDQUFDLENBQUNDLFFBQVEsQ0FBQyxPQUFPLENBQUMsRUFBRTtNQUNsREwsY0FBYyxDQUFDbkIsb0JBQW9CLENBQUMsQ0FDL0I3WSxJQUFJLENBQUMsTUFBTStCLE9BQUcsQ0FBRSx3Q0FBdUM4VyxvQkFBcUIsT0FBTSxDQUFDLENBQUM7SUFDN0Y7RUFDSjtBQUNKO0FBQ0EsU0FBU3FCLFNBQVNBLENBQUNJLEdBQUcsRUFBRUMsR0FBRyxFQUFFO0VBQ3pCQSxHQUFHLENBQUNDLEtBQUssQ0FBQyxDQUFDO0VBQ1hGLEdBQUcsQ0FBQ2xKLE9BQU8sQ0FBQyxDQUFDekksS0FBSyxFQUFFMk4sR0FBRyxLQUFLaUUsR0FBRyxDQUFDOU8sR0FBRyxDQUFDNkssR0FBRyxFQUFFM04sS0FBSyxDQUFDLENBQUM7QUFDcEQ7QUFDQSxTQUFTOFIsT0FBT0EsQ0FBQ0MsZUFBZSxFQUFFO0VBQzlCLE1BQU1DLFlBQVksR0FBRyxJQUFJLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFO0VBQ3hDLElBQUlELGVBQWUsS0FBS25aLFNBQVMsRUFBRTtJQUMvQixPQUFPQSxTQUFTO0VBQ3BCO0VBQ0EsT0FBTyxDQUFDNEIsSUFBSSxDQUFDK0YsR0FBRyxDQUFDLENBQUMsR0FBR3dSLGVBQWUsSUFBSUMsWUFBWTtBQUN4RDtBQUNBLGVBQWVYLGNBQWNBLENBQUNuQixvQkFBb0IsRUFBRTtFQUNoRDlXLE9BQUcsQ0FBRSxrRkFBaUY4VyxvQkFBcUIsTUFBSyxDQUFDO0VBQ2pIcFgsTUFBTSxDQUFDQyxPQUFPLENBQUNDLEtBQUssQ0FBQ21ZLGFBQWEsQ0FBQ2MsU0FBUyxJQUFJO0lBQzVDN1ksT0FBRyxDQUFFLHFEQUFvRCxDQUFDNlksU0FBUyxHQUFHLElBQUksRUFBRTlKLE9BQU8sQ0FBQyxDQUFDLENBQUUsVUFBUyxDQUFDO0lBQ2pHL08sT0FBRyxDQUFFLG9DQUFtQ2dXLHdCQUF3QixDQUFDdlIsSUFBSyw4QkFBNkIsQ0FBQztFQUN4RyxDQUFDLENBQUM7RUFDRixLQUFLLE1BQU1rTCxTQUFTLElBQUlxRyx3QkFBd0IsQ0FBQ3JCLElBQUksQ0FBQyxDQUFDLEVBQUU7SUFDckQsTUFBTW1FLFdBQVcsR0FBR0Msa0JBQWtCLENBQUNwSixTQUFTLENBQUM7SUFDakQsTUFBTXFKLGFBQWEsR0FBR0YsV0FBVyxJQUFJdFosU0FBUyxJQUFJLE9BQU15WixxQ0FBcUIsQ0FBQ3RKLFNBQVMsQ0FBQyxNQUFLblEsU0FBUztJQUN0RyxNQUFNMFosV0FBVyxHQUFHUixPQUFPLENBQUNsQyxrQkFBa0IsQ0FBQzNXLEdBQUcsQ0FBQzhQLFNBQVMsQ0FBQyxDQUFDO0lBQzlELElBQUl3SixPQUFPLEdBQUcsS0FBSztJQUNuQixJQUFJSCxhQUFhLEVBQUU7TUFDZmhaLE9BQUcsQ0FBRSwwRUFBeUU4WSxXQUFZLEVBQUMsQ0FBQztNQUM1RkssT0FBTyxHQUFHLElBQUk7SUFDbEIsQ0FBQyxNQUNJLElBQUlELFdBQVcsS0FBSzFaLFNBQVMsSUFBSTBaLFdBQVcsR0FBR3BDLG9CQUFvQixFQUFFO01BQ3RFOVcsT0FBRyxDQUFFLDZFQUE0RThXLG9CQUFxQjtBQUNsSCxLQUFLZ0MsV0FBWSxtQkFBa0JJLFdBQVcsR0FBR0EsV0FBVyxDQUFDbkssT0FBTyxDQUFDLENBQUMsQ0FBQyxHQUFHLFdBQVcsR0FBRyxPQUFRLEVBQUMsQ0FBQztNQUN0Rm9LLE9BQU8sR0FBRyxJQUFJO0lBQ2xCO0lBQ0EsSUFBSUEsT0FBTyxFQUFFO01BQ1QzQyxrQkFBa0IsQ0FBQzRDLE1BQU0sQ0FBQ3pKLFNBQVMsQ0FBQztNQUNwQ3FHLHdCQUF3QixDQUFDb0QsTUFBTSxDQUFDekosU0FBUyxDQUFDO0lBQzlDO0VBQ0o7RUFDQTNQLE9BQUcsQ0FBRSxvQ0FBbUNnVyx3QkFBd0IsQ0FBQ3ZSLElBQUssc0NBQXFDLENBQUM7RUFDNUdoQyxPQUFPLENBQUMwUCxHQUFHLENBQUMsQ0FDUnVGLGdCQUFnQixDQUFDdEIsNEJBQTRCLEVBQUVJLGtCQUFrQixDQUFDLEVBQ2xFa0IsZ0JBQWdCLENBQUNyQixnQ0FBZ0MsRUFBRUwsd0JBQXdCLENBQUMsQ0FDL0UsQ0FBQyxDQUFDL1gsSUFBSSxDQUFDLE1BQU07SUFDVnlCLE1BQU0sQ0FBQ0MsT0FBTyxDQUFDQyxLQUFLLENBQUNtWSxhQUFhLENBQUNDLFVBQVUsSUFBSTtNQUM3Q2hZLE9BQUcsQ0FBRSxzREFBcUQsQ0FBQ2dZLFVBQVUsR0FBRyxJQUFJLEVBQUVqSixPQUFPLENBQUMsQ0FBQyxDQUFFLFVBQVMsQ0FBQztJQUN2RyxDQUFDLENBQUM7RUFDTixDQUFDLENBQUM7QUFDTjtBQUNPLGVBQWVzSyxrQ0FBa0JBLENBQUM5VCxRQUFRLEVBQUU2SixRQUFRLEVBQUU7RUFDekQsS0FBSyxNQUFNK0QsT0FBTyxJQUFJL0QsUUFBUSxFQUFFO0lBQzVCNEcsd0JBQXdCLENBQUN0TSxHQUFHLENBQUN5SixPQUFPLENBQUN4UyxFQUFFLEVBQUV3UyxPQUFPLENBQUNXLFlBQVksQ0FBQztJQUM5RDJDLDBCQUEwQixDQUFDL00sR0FBRyxDQUFDeUosT0FBTyxDQUFDM0QsSUFBSSxFQUFFakssUUFBUSxDQUFDO0VBQzFEO0VBQ0EsTUFBTTlDLE9BQU8sQ0FBQzBQLEdBQUcsQ0FBQyxDQUNkdUYsZ0JBQWdCLENBQUN0Qiw0QkFBNEIsRUFBRUksa0JBQWtCLENBQUMsRUFDbEVrQixnQkFBZ0IsQ0FBQ3JCLGdDQUFnQyxFQUFFTCx3QkFBd0IsQ0FBQyxFQUM1RTBCLGdCQUFnQixDQUFDcEIsMEJBQTBCLEVBQUVHLDBCQUEwQixDQUFDLENBQzNFLENBQUMsQ0FBQzVWLEtBQUssQ0FBQ0MsQ0FBQyxJQUFJO0lBQ1ZyRCxTQUFLLENBQUUsMENBQXlDcUQsQ0FBQyxDQUFDME8sSUFBSyxNQUFLMU8sQ0FBQyxDQUFDbVIsT0FBUSxFQUFDLENBQUM7RUFDNUUsQ0FBQyxDQUFDO0FBQ047QUFDTyxTQUFTcUgsc0JBQXNCQSxDQUFDM0osU0FBUyxFQUFFO0VBQzlDLE1BQU00SixHQUFHLEdBQUd2RCx3QkFBd0IsQ0FBQ25XLEdBQUcsQ0FBQzhQLFNBQVMsQ0FBQztFQUNuRCxJQUFJLENBQUM0SixHQUFHLEVBQUU7SUFDTnZaLEdBQUcsQ0FBRSxrQ0FBaUMyUCxTQUFVLHVCQUFzQixDQUFDO0lBQ3ZFLE9BQU8sSUFBSTtFQUNmO0VBQ0EzUCxHQUFHLENBQUUsMENBQXlDMlAsU0FBVSxPQUFNMVAsSUFBSSxDQUFDQyxTQUFTLENBQUNxWixHQUFHLENBQUUsRUFBQyxDQUFDO0VBQ3BGLE9BQU8xRiw4QkFBOEIsQ0FBQzBGLEdBQUcsQ0FBQztBQUM5QztBQUNPLFNBQVNDLHFDQUFxQkEsQ0FBQ2pNLFVBQVUsRUFBRTtFQUM5Q2lKLGtCQUFrQixDQUFDOU0sR0FBRyxDQUFDNkQsVUFBVSxFQUFFbk0sSUFBSSxDQUFDK0YsR0FBRyxDQUFDLENBQUMsQ0FBQztFQUM5Q3VRLGdCQUFnQixDQUFDdEIsNEJBQTRCLEVBQUVJLGtCQUFrQixDQUFDLENBQzdEdlksSUFBSSxDQUFDLE1BQU07SUFDWitCLEdBQUcsQ0FBRSxnQ0FBK0J1TixVQUFXLEVBQUMsQ0FBQztFQUNyRCxDQUFDLENBQUM7QUFDTjtBQUNPLGVBQWUwTCxxQ0FBcUJBLENBQUMxTCxVQUFVLEVBQUU7RUFDcEQsTUFBTXVMLFdBQVcsR0FBR0Msa0JBQWtCLENBQUN4TCxVQUFVLENBQUM7RUFDbEQsSUFBSSxDQUFDdUwsV0FBVyxFQUFFO0lBQ2QsT0FBT3RaLFNBQVM7RUFDcEI7RUFDQSxNQUFNaWEsS0FBSyxHQUFHLE1BQU1uRSxnQkFBZ0IsQ0FBQyxNQUFNO0lBQ3ZDdFYsT0FBRyxDQUFDLHFGQUFxRixDQUFDO0lBQzFGLE9BQU8rVyxXQUFXO0VBQ3RCLENBQUMsQ0FBQztFQUNGLElBQUksQ0FBQzBDLEtBQUssRUFBRTtJQUNSaGMsU0FBSyxDQUFDLG1GQUFtRixDQUFDO0lBQzFGLE9BQU8rQixTQUFTO0VBQ3BCO0VBQ0EsS0FBSyxNQUFNLENBQUNrYSxpQkFBaUIsRUFBRW5VLFFBQVEsQ0FBQyxJQUFJa1IsMEJBQTBCLEVBQUU7SUFDcEUsSUFBSWlELGlCQUFpQixDQUFDM1osVUFBVSxDQUFDK1ksV0FBVyxDQUFDLEVBQUU7TUFDM0MsT0FBT3ZULFFBQVE7SUFDbkI7RUFDSjtFQUNBLE9BQU8vRixTQUFTO0FBQ3BCO0FBQ0EsU0FBU3VaLGtCQUFrQkEsQ0FBQ3hMLFVBQVUsRUFBRTtFQUNwQyxJQUFJO0lBQ0EsTUFBTW9NLE9BQU8sR0FBRyxJQUFJQyxHQUFHLENBQUNyTSxVQUFVLENBQUMsQ0FBQ3NNLFFBQVE7SUFDNUMsTUFBTUMsU0FBUyxHQUFHSCxPQUFPLENBQUNJLFdBQVcsQ0FBQyxHQUFHLENBQUM7SUFDMUMsT0FBT0Msa0JBQWtCLENBQUNMLE9BQU8sQ0FBQ00sU0FBUyxDQUFDSCxTQUFTLEdBQUcsQ0FBQyxDQUFDLENBQUM7RUFDL0QsQ0FBQyxDQUNELE9BQU9oWixDQUFDLEVBQUU7SUFDTnJELFNBQUssQ0FBRSwyQ0FBMEM4UCxVQUFXLEVBQUMsRUFBRXpNLENBQUMsQ0FBQztJQUNqRSxPQUFPdEIsU0FBUztFQUNwQjtBQUNKOztBQ3BOK0M7QUFDTDtBQUNOO0FBQ1U7QUFDOUMsTUFBTTJhLGlCQUFpQixHQUFHLHVCQUF1QjtBQUNqRCxNQUFNQyxlQUFlLEdBQUcsbUJBQW1CO0FBQ3BDLGVBQWVDLGNBQWNBLENBQUEsRUFBRztFQUNuQ3JhLEdBQUcsQ0FBQyx1Q0FBdUMsQ0FBQztFQUM1QyxNQUFNdUMsV0FBVyxDQUFDLENBQUM7RUFDbkIsT0FBT3lVLFNBQVMsQ0FBQyxDQUFDO0FBQ3RCO0FBQ08sU0FBU3NELGlCQUFpQkEsQ0FBQ3haLENBQUMsRUFBRTtFQUNqQyxJQUFJLE9BQU9BLENBQUMsS0FBSyxRQUFRLEVBQUU7SUFDdkIsT0FBT0EsQ0FBQyxDQUFDd1gsUUFBUSxDQUFDOEIsZUFBZSxDQUFDO0VBQ3RDO0VBQ0EsT0FBT3RaLENBQUMsSUFBSUEsQ0FBQyxDQUFDbVIsT0FBTyxJQUFJblIsQ0FBQyxDQUFDbVIsT0FBTyxDQUFDcUcsUUFBUSxDQUFDOEIsZUFBZSxDQUFDO0FBQ2hFO0FBQ08sZUFBZUcsWUFBWUEsQ0FBQ0MsSUFBSSxFQUFFO0VBQ3JDLE1BQU1DLEtBQUssR0FBRyxNQUFNQyxXQUFXLENBQUMsQ0FBQztFQUNqQyxJQUFJLENBQUNELEtBQUssQ0FBQ25DLFFBQVEsQ0FBQ2tDLElBQUksQ0FBQyxFQUFFO0lBQ3ZCeGEsR0FBRyxDQUFFLG9FQUFtRXdhLElBQUssRUFBQyxDQUFDO0lBQy9FLE1BQU1HLFNBQVMsR0FBRyxNQUFNQyxZQUFZLENBQUMsQ0FBQztJQUN0Q0QsU0FBUyxDQUFDL1AsSUFBSSxDQUFDNFAsSUFBSSxDQUFDO0lBQ3BCOWEsTUFBTSxDQUFDQyxPQUFPLENBQUNDLEtBQUssQ0FBQzhKLEdBQUcsQ0FBQztNQUFFbVIscUJBQXFCLEVBQUVGO0lBQVUsQ0FBQyxDQUFDO0VBQ2xFLENBQUMsTUFDSTtJQUNEM2EsR0FBRyxDQUFDLHFCQUFxQixDQUFDO0VBQzlCO0FBQ0o7QUFDQSxTQUFTNGEsWUFBWUEsQ0FBQSxFQUFHO0VBQ3BCLE9BQU8sSUFBSW5ZLE9BQU8sQ0FBQ29KLEdBQUcsSUFBSTtJQUN0Qm5NLE1BQU0sQ0FBQ0MsT0FBTyxDQUFDQyxLQUFLLENBQUNDLEdBQUcsQ0FBQ3NhLGlCQUFpQixFQUFFelksSUFBSSxJQUFJO01BQ2hELElBQUlBLElBQUksSUFBSUEsSUFBSSxDQUFDeVksaUJBQWlCLENBQUMsRUFBRTtRQUNqQ25hLEdBQUcsQ0FBRSxXQUFVMEIsSUFBSSxDQUFDeVksaUJBQWlCLENBQUMsQ0FBQzFaLE1BQU8sa0JBQWlCLENBQUM7UUFDaEUsT0FBT29MLEdBQUcsQ0FBQ25LLElBQUksQ0FBQ3lZLGlCQUFpQixDQUFDLENBQUM7TUFDdkMsQ0FBQyxNQUNJO1FBQ0RuYSxHQUFHLENBQUMscUJBQXFCLENBQUM7UUFDMUI2TCxHQUFHLENBQUMsRUFBRSxDQUFDO01BQ1g7SUFDSixDQUFDLENBQUM7RUFDTixDQUFDLENBQUM7QUFDTjtBQUNBLFNBQVNpUCxlQUFlQSxDQUFBLEVBQUc7RUFDdkIsT0FBTyxJQUFJclksT0FBTyxDQUFDb0osR0FBRyxJQUFJO0lBQ3RCbk0sTUFBTSxDQUFDQyxPQUFPLENBQUM2VSxPQUFPLENBQUMzVSxHQUFHLENBQUNzYSxpQkFBaUIsRUFBRXpZLElBQUksSUFBSTtNQUNsRCxJQUFJQSxJQUFJLElBQUlBLElBQUksQ0FBQ3lZLGlCQUFpQixDQUFDLEVBQUU7UUFDakNuYSxHQUFHLENBQUUsV0FBVTBCLElBQUksQ0FBQ3lZLGlCQUFpQixDQUFDLENBQUMxWixNQUFPLHFCQUFvQixDQUFDO1FBQ25FLE9BQU9vTCxHQUFHLENBQUNuSyxJQUFJLENBQUN5WSxpQkFBaUIsQ0FBQyxDQUFDO01BQ3ZDLENBQUMsTUFDSTtRQUNEbmEsR0FBRyxDQUFDLHdCQUF3QixDQUFDO1FBQzdCLE9BQU82TCxHQUFHLENBQUMsRUFBRSxDQUFDO01BQ2xCO0lBQ0osQ0FBQyxDQUFDO0VBQ04sQ0FBQyxDQUFDO0FBQ047QUFDQSxlQUFlNk8sV0FBV0EsQ0FBQSxFQUFHO0VBQ3pCLE1BQU1LLFdBQVcsR0FBRyxNQUFNRCxlQUFlLENBQUMsQ0FBQztFQUMzQyxNQUFNSCxTQUFTLEdBQUcsTUFBTUMsWUFBWSxDQUFDLENBQUM7RUFDdEMsT0FBT0csV0FBVyxDQUFDQyxNQUFNLENBQUNMLFNBQVMsQ0FBQztBQUN4QztBQUNPLGVBQWVNLG1DQUFrQkEsQ0FBQSxFQUFHO0VBQ3ZDLE1BQU1DLFFBQVEsR0FBRyxNQUFNUixXQUFXLENBQUMsQ0FBQztFQUNwQyxNQUFNRCxLQUFLLEdBQUdTLFFBQVEsQ0FBQ25ILEdBQUcsQ0FBQzFNLENBQUMsSUFBSTtJQUM1QixJQUFJO01BQ0EsT0FBTzZTLGNBQWMsQ0FBQzVSLEtBQUssQ0FBQ2pCLENBQUMsQ0FBQztJQUNsQyxDQUFDLENBQ0QsT0FBT3ZHLENBQUMsRUFBRTtNQUNOckQsS0FBSyxDQUFDLG1DQUFtQyxFQUFFLE1BQU0sRUFBRTRKLENBQUMsRUFBRXZHLENBQUMsQ0FBQztJQUM1RDtFQUNKLENBQUMsQ0FBQyxDQUFDcWEsTUFBTSxDQUFFdFAsR0FBRyxJQUFLQSxHQUFHLElBQUksSUFBSSxDQUFDO0VBQy9CN0wsR0FBRyxDQUFDLDJCQUEyQixFQUFFeWEsS0FBSyxDQUFDMUcsR0FBRyxDQUFDcUgsQ0FBQyxJQUFJQSxDQUFDLENBQUNDLEtBQUssR0FBRyxHQUFHLEdBQUdELENBQUMsQ0FBQzdWLFFBQVEsR0FBRyxHQUFHLElBQUk2VixDQUFDLENBQUNFLE9BQU8sQ0FBQyxDQUFDLEdBQUksWUFBV0YsQ0FBQyxDQUFDRyxNQUFNLENBQUNDLFdBQVcsQ0FBQyxDQUFFLEdBQUUsR0FBRyxhQUFhLENBQUMsQ0FBQyxDQUFDO0VBQzFKLE9BQU9mLEtBQUs7QUFDaEI7QUFDTyxTQUFTZ0IscUNBQW9CQSxDQUFDbFcsUUFBUSxFQUFFNkksVUFBVSxFQUFFO0VBQ3ZELE9BQU83SSxRQUFRLEdBQUcsR0FBRyxHQUFHNkksVUFBVTtBQUN0QztBQUNPLGVBQWVzTiw4QkFBYUEsQ0FBQ25XLFFBQVEsRUFBRTtFQUMxQyxPQUFPLENBQUMsTUFBTW9XLHdCQUFPLENBQUNwVyxRQUFRLENBQUMsRUFBRTZJLFVBQVU7QUFDL0M7QUFDTyxlQUFldU4sd0JBQU9BLENBQUNwVyxRQUFRLEVBQUU7RUFDcEMsTUFBTWlWLElBQUksR0FBRyxDQUFDLE1BQU1TLG1DQUFrQixDQUFDLENBQUMsRUFBRVcsSUFBSSxDQUFDcEIsSUFBSSxJQUFJQSxJQUFJLENBQUNqVixRQUFRLElBQUlBLFFBQVEsQ0FBQztFQUNqRixJQUFJLENBQUNpVixJQUFJLEVBQUU7SUFDUCxNQUFNLElBQUlyYyxLQUFLLENBQUUsc0JBQXFCb0gsUUFBUyxFQUFDLENBQUM7RUFDckQ7RUFDQSxPQUFPaVYsSUFBSTtBQUNmOzs7OztBQ3ZGNkI7QUFDN0IsTUFBTXFCLHVCQUF1QixHQUFHLGlCQUFpQjtBQUNqRCxJQUFJQyxzQkFBc0IsR0FBR3JaLE9BQU8sQ0FBQ0MsT0FBTyxDQUFDLENBQUM7QUFDOUMsZUFBZXFaLG9CQUFvQkEsQ0FBQSxFQUFHO0VBQ2xDRCxzQkFBc0IsR0FBR0Esc0JBQXNCLENBQUM3ZCxJQUFJLENBQUMsWUFBWTtJQUM3RCxJQUFJLEVBQUUsTUFBTStkLFdBQVcsQ0FBQyxDQUFDLENBQUMsRUFBRTtNQUN4QmhjLEdBQUcsQ0FBQyw0Q0FBNEMsQ0FBQztNQUNqRCxJQUFJO1FBQ0EsTUFBTU4sTUFBTSxDQUFDdWMsU0FBUyxDQUFDQyxjQUFjLENBQUM7VUFDbEM5ZCxHQUFHLEVBQUV5ZCx1QkFBdUI7VUFDNUJNLE9BQU8sRUFBRSxDQUFDemMsTUFBTSxDQUFDdWMsU0FBUyxDQUFDRyxNQUFNLENBQUNDLE9BQU8sQ0FBQztVQUMxQ0MsYUFBYSxFQUFFO1FBQ25CLENBQUMsQ0FBQztNQUNOLENBQUMsQ0FDRCxPQUFPN2UsS0FBSyxFQUFFO1FBQ1YsSUFBSSxDQUFDQSxLQUFLLENBQUN3VSxPQUFPLENBQUNsUyxVQUFVLENBQUMsa0NBQWtDLENBQUMsRUFBRTtVQUMvRCxNQUFNdEMsS0FBSztRQUNmO01BQ0o7SUFDSjtFQUNKLENBQUMsQ0FBQztFQUNGLE9BQU9xZSxzQkFBc0I7QUFDakM7QUFDTyxlQUFlUyxnQ0FBZ0JBLENBQUM3YSxJQUFJLEVBQUU7RUFDekMsTUFBTXFhLG9CQUFvQixDQUFDLENBQUM7RUFDNUIsTUFBTVMsU0FBUyxHQUFHOWMsTUFBTSxDQUFDNkIsT0FBTyxDQUFDa2IsTUFBTSxDQUFDWix1QkFBdUIsQ0FBQztFQUNoRSxNQUFNYSxhQUFhLEdBQUcsQ0FBQyxNQUFNamQsSUFBSSxDQUFDa2QsT0FBTyxDQUFDQyxRQUFRLENBQUM7SUFBRUMsbUJBQW1CLEVBQUU7RUFBSyxDQUFDLENBQUMsRUFDNUVqQixJQUFJLENBQUM5SixDQUFDLElBQUlBLENBQUMsQ0FBQzFULEdBQUcsS0FBS29lLFNBQVMsQ0FBQztFQUNuQyxNQUFNTSxjQUFjLEdBQUcsSUFBSUMsY0FBYyxDQUFDLENBQUM7RUFDM0NMLGFBQWEsQ0FBQ00sV0FBVyxDQUFDdGIsSUFBSSxFQUFFLENBQUNvYixjQUFjLENBQUNHLEtBQUssQ0FBQyxDQUFDO0VBQ3ZELE1BQU07SUFBRXZiLElBQUksRUFBRXdiO0VBQWtCLENBQUMsR0FBRyxNQUFNLElBQUl6YSxPQUFPLENBQUMwYSxFQUFFLElBQUtMLGNBQWMsQ0FBQ00sS0FBSyxDQUFDdFYsU0FBUyxHQUFHcVYsRUFBRyxDQUFDO0VBQ2xHbmQsR0FBRyxDQUFFLGNBQWEwQixJQUFJLENBQUMyYixPQUFRLGdCQUFlLEVBQUVILGlCQUFpQixDQUFDO0VBQ2xFLE9BQU9BLGlCQUFpQjtBQUM1QjtBQUNBLGVBQWVsQixXQUFXQSxDQUFBLEVBQUc7RUFDekIsTUFBTXNCLGFBQWEsR0FBRyxNQUFNN2QsSUFBSSxDQUFDa2QsT0FBTyxDQUFDQyxRQUFRLENBQUMsQ0FBQztFQUNuRDVjLEdBQUcsQ0FBQyw4Q0FBOEMsRUFBRXNkLGFBQWEsQ0FBQztFQUNsRSxLQUFLLE1BQU1DLFlBQVksSUFBSUQsYUFBYSxFQUFFO0lBQ3RDLElBQUlDLFlBQVksQ0FBQ25mLEdBQUcsQ0FBQ29mLFFBQVEsQ0FBQzNCLHVCQUF1QixDQUFDLEVBQUU7TUFDcEQ3YixHQUFHLENBQUMsK0NBQStDLEVBQUV1ZCxZQUFZLENBQUM7TUFDbEUsT0FBTyxJQUFJO0lBQ2Y7RUFDSjtFQUNBdmQsR0FBRyxDQUFDLHdEQUF3RCxDQUFDO0VBQzdELE9BQU8sS0FBSztBQUNoQjtBQUNBLElBQUk7RUFDQU4sTUFBTSxDQUFDNkIsT0FBTyxDQUFDa2MsU0FBUyxDQUFDQyxXQUFXLENBQUMsTUFBTTtJQUN2Q2hlLE1BQU0sQ0FBQ3VjLFNBQVMsQ0FBQzBCLGFBQWEsQ0FBQyxDQUFDLENBQUMxZixJQUFJLENBQUMsTUFBTTtNQUN4QytCLE9BQUcsQ0FBQyxpREFBaUQsQ0FBQztJQUMxRCxDQUFDLENBQUMsQ0FBQ2EsS0FBSyxDQUFFcEQsS0FBSyxJQUFLO01BQ2hCQSxLQUFLLENBQUMsK0NBQStDLEVBQUVBLEtBQUssQ0FBQztJQUNqRSxDQUFDLENBQUM7RUFDTixDQUFDLENBQUM7QUFDTixDQUFDLENBQ0QsT0FBT3FELENBQUMsRUFBRTtFQUNOdEQsT0FBTyxDQUFDd0MsR0FBRyxDQUFFLFVBQVNjLENBQUUsRUFBQyxDQUFDO0FBQzlCOzs7O0FDekQwQztBQUNBO0FBQzREO0FBQ3VGO0FBQ3hJO0FBQ3JELElBQUk7RUFDQXBCLE1BQU0sQ0FBQzZCLE9BQU8sQ0FBQ3NHLFNBQVMsQ0FBQzZWLFdBQVcsQ0FBQ0UsY0FBYyxDQUFDO0FBQ3hELENBQUMsQ0FDRCxPQUFPOWMsQ0FBQyxFQUFFO0VBQ050RCxPQUFPLENBQUN3QyxHQUFHLENBQUUsVUFBU2MsQ0FBRSxFQUFDLENBQUM7QUFDOUI7QUFDQSxlQUFlOGMsY0FBY0EsQ0FBQzNMLE9BQU8sRUFBRTtFQUNuQyxJQUFJQSxPQUFPLENBQUNyUSxNQUFNLEtBQUssWUFBWSxFQUFFO0lBQ2pDO0VBQ0o7RUFDQSxRQUFRcVEsT0FBTyxDQUFDeFEsSUFBSTtJQUNoQixLQUFLLEtBQUs7TUFBRTtRQUNSekIsT0FBRyxDQUFDaVMsT0FBTyxDQUFDdlEsSUFBSSxDQUFDO1FBQ2pCO01BQ0o7SUFDQSxLQUFLLE9BQU87TUFBRTtRQUNWakUsU0FBSyxDQUFDd1UsT0FBTyxDQUFDdlEsSUFBSSxDQUFDO1FBQ25CO01BQ0o7SUFDQSxLQUFLLE1BQU07TUFBRTtRQUNUSixRQUFJLENBQUMyUSxPQUFPLENBQUN2USxJQUFJLENBQUM7UUFDbEI7TUFDSjtJQUNBLEtBQUssbUJBQW1CO01BQUU7UUFDdEIxQixPQUFHLENBQUUsY0FBYWlTLE9BQU8sQ0FBQ3hRLElBQUssd0JBQXVCd1EsT0FBTyxDQUFDdlEsSUFBSSxDQUFDbWMsUUFBUyxFQUFDLENBQUM7UUFDOUVsRyxnQkFBZ0IsQ0FBQzFGLE9BQU8sQ0FBQ3ZRLElBQUksQ0FBQ21jLFFBQVEsRUFBRTVMLE9BQU8sQ0FBQ3ZRLElBQUksQ0FBQ29jLFVBQVUsQ0FBQztRQUNoRTtNQUNKO0lBQ0EsS0FBSywwQkFBMEI7TUFBRTtRQUM3QjlkLE9BQUcsQ0FBRSxjQUFhaVMsT0FBTyxDQUFDeFEsSUFBSyxtQ0FBa0N3USxPQUFPLENBQUN2USxJQUFJLENBQUNtYyxRQUFTLEVBQUMsQ0FBQztRQUN6RnJHLGdCQUFnQixDQUFDaUUscUNBQW9CLENBQUN4SixPQUFPLENBQUN2USxJQUFJLENBQUNtYyxRQUFRLEVBQUU1TCxPQUFPLENBQUN2USxJQUFJLENBQUNxYyxVQUFVLENBQUMsRUFBRTlMLE9BQU8sQ0FBQ3ZRLElBQUksQ0FBQ3NjLFVBQVUsQ0FBQztRQUMvRztNQUNKO0lBQ0EsS0FBSywwQkFBMEI7TUFBRTtRQUM3QmhlLE9BQUcsQ0FBRSxjQUFhaVMsT0FBTyxDQUFDeFEsSUFBSyxvQ0FBbUN3USxPQUFPLENBQUN2USxJQUFJLENBQUNtYyxRQUFTLEVBQUMsQ0FBQztRQUMxRnRHLGtDQUFrQixDQUFDLENBQUMsQ0FBQzZCLE1BQU0sQ0FBQ3FDLHFDQUFvQixDQUFDeEosT0FBTyxDQUFDdlEsSUFBSSxDQUFDbWMsUUFBUSxFQUFFNUwsT0FBTyxDQUFDdlEsSUFBSSxDQUFDcWMsVUFBVSxDQUFDLENBQUM7UUFDakc7TUFDSjtJQUNBLEtBQUssc0JBQXNCO01BQUU7UUFDekIvZCxPQUFHLENBQUUsY0FBYWlTLE9BQU8sQ0FBQ3hRLElBQUssd0NBQXVDd1EsT0FBTyxDQUFDdlEsSUFBSSxDQUFDbWMsUUFBUyxFQUFDLENBQUM7UUFDOUYsTUFBTXhFLGtDQUFrQixDQUFDcEgsT0FBTyxDQUFDdlEsSUFBSSxDQUFDbWMsUUFBUSxFQUFFNUwsT0FBTyxDQUFDdlEsSUFBSSxDQUFDdWMsV0FBVyxDQUFDO1FBQ3pFO01BQ0o7SUFDQTtNQUNJemdCLE9BQU8sQ0FBQzhELElBQUksQ0FBRSx1REFBc0RyQixJQUFJLENBQUNDLFNBQVMsQ0FBQytSLE9BQU8sQ0FBRSxJQUFHLENBQUM7RUFDeEc7QUFDSjtBQUNPLGVBQWVpTSx5QkFBeUJBLENBQUEsRUFBRztFQUM5QyxJQUFJekQsS0FBSztFQUNULElBQUk7SUFDQUEsS0FBSyxHQUFHLE1BQU1RLGtCQUFrQixDQUFDLENBQUM7RUFDdEMsQ0FBQyxDQUNELE9BQU9uYSxDQUFDLEVBQUU7SUFDTnJELEtBQUssQ0FBQyw4REFBOEQsRUFBRXFELENBQUMsQ0FBQztFQUM1RTtFQUNBLElBQUkyWixLQUFLLENBQUNoYSxNQUFNLEtBQUssQ0FBQyxFQUFFO0lBQ3BCVCxHQUFHLENBQUMsOEZBQThGLENBQUM7SUFDbkcsT0FBTyxFQUFFO0VBQ2I7RUFDQUEsR0FBRyxDQUFDLDhDQUE4QyxFQUFFeWEsS0FBSyxDQUFDO0VBQzFELE1BQU0wRCxTQUFTLEdBQUcsSUFBSUMsR0FBRyxDQUFDM0QsS0FBSyxDQUFDMUcsR0FBRyxDQUFDeUcsSUFBSSxJQUFJQSxJQUFJLENBQUNqVixRQUFRLENBQUMsQ0FBQztFQUMzRCxNQUFNa1IsMEJBQTBCLEdBQUdhLDZCQUE2QixDQUFDLENBQUM7RUFDbEUsS0FBSyxNQUFNLENBQUN3QixXQUFXLEVBQUV2VCxRQUFRLENBQUMsSUFBSWtSLDBCQUEwQixDQUFDekIsT0FBTyxDQUFDLENBQUMsRUFBRTtJQUN4RSxJQUFJLENBQUNtSixTQUFTLENBQUNFLEdBQUcsQ0FBQzlZLFFBQVEsQ0FBQyxFQUFFO01BQzFCa1IsMEJBQTBCLENBQUMyQyxNQUFNLENBQUNOLFdBQVcsQ0FBQztJQUNsRDtFQUNKO0VBQ0EsTUFBTXdGLGNBQWMsR0FBRyxDQUFDLEdBQUdILFNBQVMsQ0FBQyxDQUFDcEssR0FBRyxDQUFDLE1BQU94TyxRQUFRLElBQUs7SUFDMUQsSUFBSTtNQUNBLE1BQU02SixRQUFRLEdBQUcsTUFBTW1QLHFCQUFxQixDQUFDaFosUUFBUSxDQUFDO01BQ3REdkYsR0FBRyxDQUFFLDhDQUE2Q29QLFFBQVEsQ0FBQzNPLE1BQU8sbUJBQWtCOEUsUUFBUyxHQUFFLEVBQUU2SixRQUFRLENBQUM7TUFDMUcsT0FBT0EsUUFBUTtJQUNuQixDQUFDLENBQ0QsT0FBT3RPLENBQUMsRUFBRTtNQUNOckQsS0FBSyxDQUFFLHFEQUFvRDhILFFBQVMsSUFBRyxFQUFFekUsQ0FBQyxDQUFDO01BQzNFLE9BQU8sRUFBRTtJQUNiO0VBQ0osQ0FBQyxDQUFDO0VBQ0YsTUFBTWlCLE1BQU0sR0FBRyxDQUFDLE1BQU1VLE9BQU8sQ0FBQzBQLEdBQUcsQ0FBQ21NLGNBQWMsQ0FBQyxFQUFFRSxJQUFJLENBQUNDLFFBQVEsQ0FBQztFQUNqRXplLEdBQUcsQ0FBRSx5REFBd0QrQixNQUFNLENBQUN0QixNQUFPLHdCQUF1QixDQUFDO0VBQ25HLE9BQU9zQixNQUFNO0FBQ2pCO0FBQ08sZUFBZTJjLHFDQUFnQkEsQ0FBQ25aLFFBQVEsRUFBRTtFQUM3Q3ZGLEdBQUcsQ0FBRSx5REFBd0R1RixRQUFTLEVBQUMsQ0FBQztFQUN4RSxNQUFNNkksVUFBVSxHQUFHLE1BQU1zTixhQUFhLENBQUNuVyxRQUFRLENBQUM7RUFDaEQsTUFBTWtTLGlCQUFpQixHQUFHZ0Usb0JBQW9CLENBQUNsVyxRQUFRLEVBQUU2SSxVQUFVLENBQUM7RUFDcEUsTUFBTWQsVUFBVSxHQUFHaUssa0JBQWtCLENBQUMsQ0FBQyxDQUFDMVgsR0FBRyxDQUFDNFgsaUJBQWlCLENBQUM7RUFDOUQsTUFBTWpWLFFBQVEsR0FBRyxNQUFNRCxXQUFXLENBQUMsQ0FBQztFQUNwQyxNQUFNYixJQUFJLEdBQUc7SUFDVG1jLFFBQVEsRUFBRXRZLFFBQVE7SUFDbEJvWixRQUFRLEVBQUVuYyxRQUFRO0lBQ2xCb2MsT0FBTyxFQUFFLENBQUMsTUFBTWpELE9BQU8sQ0FBQ3BXLFFBQVEsQ0FBQyxFQUFFc1osT0FBTztJQUMxQ2QsVUFBVSxFQUFFM1AsVUFBVTtJQUN0QjRQLFVBQVUsRUFBRTFRLFVBQVU7SUFDdEIrUCxPQUFPLEVBQUU7RUFDYixDQUFDO0VBQ0QsTUFBTXpGLFVBQVUsR0FBRyxNQUFNMkUsZ0JBQWdCLENBQUM3YSxJQUFJLENBQUM7RUFDL0MsSUFBSSxDQUFDa1csVUFBVSxDQUFDa0gsU0FBUyxFQUFFO0lBQ3ZCcmhCLEtBQUssQ0FBQyx3REFBd0QsRUFBRW1hLFVBQVUsQ0FBQ21ILFFBQVEsQ0FBQztJQUNwRixNQUFNLElBQUk1Z0IsS0FBSyxDQUFDeVosVUFBVSxDQUFDbUgsUUFBUSxDQUFDO0VBQ3hDO0VBQ0EsT0FBT25ILFVBQVUsQ0FBQ21ILFFBQVE7QUFDOUI7QUFDQSxlQUFlUixxQkFBcUJBLENBQUNoWixRQUFRLEVBQUU7RUFDM0N2RixHQUFHLENBQUUsb0VBQW1FdUYsUUFBUyxNQUFLLENBQUM7RUFDdkYsTUFBTTZJLFVBQVUsR0FBRyxNQUFNc04sYUFBYSxDQUFDblcsUUFBUSxDQUFDO0VBQ2hELE1BQU1rUyxpQkFBaUIsR0FBR2dFLG9CQUFvQixDQUFDbFcsUUFBUSxFQUFFNkksVUFBVSxDQUFDO0VBQ3BFLE1BQU1kLFVBQVUsR0FBR2lLLGtCQUFrQixDQUFDLENBQUMsQ0FBQzFYLEdBQUcsQ0FBQzRYLGlCQUFpQixDQUFDO0VBQzlELE1BQU1qVixRQUFRLEdBQUcsTUFBTUQsV0FBVyxDQUFDLENBQUM7RUFDcEMsTUFBTWIsSUFBSSxHQUFHO0lBQ1RtYyxRQUFRLEVBQUV0WSxRQUFRO0lBQ2xCb1osUUFBUSxFQUFFbmMsUUFBUTtJQUNsQm9jLE9BQU8sRUFBRSxDQUFDLE1BQU1qRCxPQUFPLENBQUNwVyxRQUFRLENBQUMsRUFBRXNaLE9BQU87SUFDMUNkLFVBQVUsRUFBRTNQLFVBQVU7SUFDdEI0UCxVQUFVLEVBQUUxUSxVQUFVO0lBQ3RCK1AsT0FBTyxFQUFFO0VBQ2IsQ0FBQztFQUNELE1BQU0yQixhQUFhLEdBQUcsTUFBTXpDLGdCQUFnQixDQUFDN2EsSUFBSSxDQUFDO0VBQ2xELElBQUksQ0FBQ3NkLGFBQWEsQ0FBQ0YsU0FBUyxFQUFFO0lBQzFCcmhCLEtBQUssQ0FBQyxvRkFBb0YsRUFBRXVoQixhQUFhLENBQUNELFFBQVEsQ0FBQztJQUNuSCxNQUFNLElBQUk1Z0IsS0FBSyxDQUFDNmdCLGFBQWEsQ0FBQ0QsUUFBUSxDQUFDO0VBQzNDO0VBQ0EsTUFBTTFGLGtCQUFrQixDQUFDOVQsUUFBUSxFQUFFeVosYUFBYSxDQUFDRCxRQUFRLENBQUM7RUFDMUQsT0FBT0MsYUFBYSxDQUFDRCxRQUFRO0FBQ2pDO0FBQ08sZUFBZUUsaUJBQWlCQSxDQUFDdFAsU0FBUyxFQUFFO0VBQy9DM1AsR0FBRyxDQUFFLDJEQUEwRDJQLFNBQVUsRUFBQyxDQUFDO0VBQzNFLE1BQU1wSyxRQUFRLEdBQUcsTUFBTTBULHFCQUFxQixDQUFDdEosU0FBUyxDQUFDO0VBQ3ZELElBQUksQ0FBQ3BLLFFBQVEsRUFBRTtJQUNYLE1BQU0sSUFBSXBILEtBQUssQ0FBRSxrQ0FBaUN3UixTQUFVLEVBQUMsQ0FBQztFQUNsRTtFQUNBLE1BQU12QixVQUFVLEdBQUcsTUFBTXNOLGFBQWEsQ0FBQ25XLFFBQVEsQ0FBQztFQUNoRCxNQUFNa1MsaUJBQWlCLEdBQUdnRSxvQkFBb0IsQ0FBQ2xXLFFBQVEsRUFBRTZJLFVBQVUsQ0FBQztFQUNwRSxNQUFNZCxVQUFVLEdBQUdpSyxrQkFBa0IsQ0FBQyxDQUFDLENBQUMxWCxHQUFHLENBQUM0WCxpQkFBaUIsQ0FBQztFQUM5RCxNQUFNalYsUUFBUSxHQUFHLE1BQU1ELFdBQVcsQ0FBQyxDQUFDO0VBQ3BDLE1BQU1iLElBQUksR0FBRztJQUNUd2QsU0FBUyxFQUFFdlAsU0FBUztJQUNwQmtPLFFBQVEsRUFBRXRZLFFBQVE7SUFDbEJvWixRQUFRLEVBQUVuYyxRQUFRO0lBQ2xCb2MsT0FBTyxFQUFFLENBQUMsTUFBTWpELE9BQU8sQ0FBQ3BXLFFBQVEsQ0FBQyxFQUFFc1osT0FBTztJQUMxQ2QsVUFBVSxFQUFFM1AsVUFBVTtJQUN0QjRQLFVBQVUsRUFBRTFRLFVBQVU7SUFDdEIrUCxPQUFPLEVBQUU7RUFDYixDQUFDO0VBQ0QsTUFBTXZKLFlBQVksR0FBRyxNQUFNeUksZ0JBQWdCLENBQUM3YSxJQUFJLENBQUM7RUFDakQsSUFBSSxDQUFDb1MsWUFBWSxDQUFDZ0wsU0FBUyxFQUFFO0lBQ3pCcmhCLEtBQUssQ0FBQyxnRkFBZ0YsRUFBRXFXLFlBQVksQ0FBQ2lMLFFBQVEsQ0FBQztJQUM5RyxNQUFNLElBQUk1Z0IsS0FBSyxDQUFDLDhDQUE4QyxDQUFDO0VBQ25FO0VBQ0E2QixHQUFHLENBQUMsb0RBQW9ELEVBQUU4VCxZQUFZLENBQUNpTCxRQUFRLENBQUM7RUFDaEYsT0FBT2pMLFlBQVksQ0FBQ2lMLFFBQVE7QUFDaEM7QUFDTyxlQUFlSSxpQkFBaUJBLENBQUNuUixJQUFJLEVBQUVULFVBQVUsRUFBRUMsTUFBTSxFQUFFO0VBQzlELE1BQU1qSSxRQUFRLEdBQUcsTUFBTTBULHFCQUFxQixDQUFDMUwsVUFBVSxDQUFDO0VBQ3hELElBQUksQ0FBQ2hJLFFBQVEsRUFBRTtJQUNYLE1BQU0sSUFBSXBILEtBQUssQ0FBRSxpQ0FBZ0NvUCxVQUFXLEVBQUMsQ0FBQztFQUNsRTtFQUNBdk4sR0FBRyxDQUFDLGdDQUFnQyxFQUFFLFVBQVUsRUFBRXVGLFFBQVEsRUFBRSxRQUFRLEVBQUU7SUFDbEUsR0FBR2lJLE1BQU07SUFDVDRSLFdBQVcsRUFBRTtFQUNqQixDQUFDLENBQUM7RUFDRixNQUFNaFIsVUFBVSxHQUFHLE1BQU1zTixhQUFhLENBQUNuVyxRQUFRLENBQUM7RUFDaEQsTUFBTWtTLGlCQUFpQixHQUFHZ0Usb0JBQW9CLENBQUNsVyxRQUFRLEVBQUU2SSxVQUFVLENBQUM7RUFDcEUsTUFBTWQsVUFBVSxHQUFHaUssa0JBQWtCLENBQUMsQ0FBQyxDQUFDMVgsR0FBRyxDQUFDNFgsaUJBQWlCLENBQUM7RUFDOUQsTUFBTWpWLFFBQVEsR0FBRyxNQUFNRCxXQUFXLENBQUMsQ0FBQztFQUNwQyxNQUFNYixJQUFJLEdBQUc7SUFDVDJkLFFBQVEsRUFBRXJSLElBQUk7SUFDZHNSLFVBQVUsRUFBRS9SLFVBQVU7SUFDdEJnUyxNQUFNLEVBQUUvUixNQUFNO0lBQ2RxUSxRQUFRLEVBQUV0WSxRQUFRO0lBQ2xCb1osUUFBUSxFQUFFbmMsUUFBUTtJQUNsQm9jLE9BQU8sRUFBRSxDQUFDLE1BQU1qRCxPQUFPLENBQUNwVyxRQUFRLENBQUMsRUFBRXNaLE9BQU87SUFDMUNkLFVBQVUsRUFBRTNQLFVBQVU7SUFDdEI0UCxVQUFVLEVBQUUxUSxVQUFVO0lBQ3RCK1AsT0FBTyxFQUFFO0VBQ2IsQ0FBQztFQUNELE1BQU1tQyxVQUFVLEdBQUcsTUFBTWpELGdCQUFnQixDQUFDN2EsSUFBSSxDQUFDO0VBQy9DLElBQUksQ0FBQzhkLFVBQVUsQ0FBQ1YsU0FBUyxFQUFFO0lBQ3ZCcmhCLEtBQUssQ0FBQyxnRkFBZ0YsRUFBRStoQixVQUFVLENBQUNULFFBQVEsQ0FBQztJQUM1RyxNQUFNLElBQUk1Z0IsS0FBSyxDQUFDcWhCLFVBQVUsQ0FBQ1QsUUFBUSxDQUFDO0VBQ3hDO0VBQ0EvZSxHQUFHLENBQUMsa0ZBQWtGLEVBQUV3ZixVQUFVLENBQUNULFFBQVEsQ0FBQztFQUM1R3ZGLHFCQUFxQixDQUFDak0sVUFBVSxDQUFDO0VBQ2pDLE9BQU9pUyxVQUFVLENBQUNULFFBQVE7QUFDOUI7O0FDN0xPLFNBQVNVLDhCQUFzQkEsQ0FBQ2xTLFVBQVUsRUFBRTtFQUMvQyxPQUFPQSxVQUFVLENBQUNtUyxPQUFPLENBQUMsaUJBQWlCLEVBQUUsRUFBRSxDQUFDO0FBQ3BEO0FBQ08sU0FBU0MsY0FBY0EsQ0FBQ3BTLFVBQVUsRUFBRTtFQUN2QyxPQUFPQSxVQUFVLENBQUM3SSxLQUFLLENBQUM2SSxVQUFVLENBQUN3TSxXQUFXLENBQUMsWUFBWSxDQUFDLEdBQUcsWUFBWSxDQUFDdFosTUFBTSxDQUFDO0FBQ3ZGOztBQ0xBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN6RGtDO0FBQ2xDO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQkFBbUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0JBQWtCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBOzs7QUMzRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsUUFBUTtBQUNqQztBQUNBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQy9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxjQUFPO0FBQ0o7QUFDUDtBQUNBO0FBQ0EsWUFBWSxjQUFPO0FBQ25CO0FBQ0E7QUFDQSxZQUFZLGNBQU87QUFDbkIsd0JBQXdCLFFBQVE7QUFDaEMsZ0JBQWdCLGNBQU87QUFDdkI7QUFDQSxZQUFZLGNBQU8sWUFBWTtBQUMvQixZQUFZLGNBQU8sWUFBWTtBQUMvQix3QkFBd0IsbUJBQW1CO0FBQzNDLGdCQUFnQixjQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixjQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN2RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFFBQVE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsUUFBUTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ2dCOzs7QUN0RmpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNnQztBQUNoQztBQUNBLDRHQUE0RyxJQUFJO0FBQ2hILGdIQUFnSCxJQUFJO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixTQUFTO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsU0FBUztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsU0FBUztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsS0FBSztBQUN6QixnQ0FBZ0MsU0FBUztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsU0FBUztBQUN6QztBQUNBO0FBQ0EsNEJBQTRCLFdBQVc7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsU0FBUztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsS0FBSztBQUN6QjtBQUNBLDRCQUE0QixTQUFTO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0EscUNBQXFDLEtBQUs7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixLQUFLO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDaUI7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxTQUFTO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSx3QkFBd0IsU0FBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsZ0JBQWdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNlO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0Qyx3QkFBd0IsS0FBSztBQUM3QjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ2tCOzs7QUNwakJuQjtBQUNBO0FBQ0E7QUFDQTtBQUNnRjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLE1BQU07QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixLQUFLO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsTUFBTTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFNBQVM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQSxxQ0FBcUMsSUFBSTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQyxpQkFBaUIsSUFBSTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsS0FBSztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxTQUFTO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLE1BQU07QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsUUFBUTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsUUFBUTtBQUNyQztBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLEtBQUs7QUFDekU7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsT0FBTztBQUMxQztBQUNBO0FBQ0EsdUNBQXVDLE9BQU87QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFNBQVM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFFBQVE7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsY0FBYyxNQUFNO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLEtBQUs7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxhQUFhLE1BQU07QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDcUI7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsY0FBYztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ08saUJBQWlCO0FBQ2pCO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3p0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDa0I7QUFDbkI7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087OztBQzdDUDtBQUNtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFNBQVM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBLDBCQUEwQixTQUFTO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDRCQUE0QjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGVBQWU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ3VCOzs7QUM3RXhCO0FBQ0E7QUFDQTtBQUNzRDtBQUNqQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QjtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQSxJQUFJLFVBQU07QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixXQUFXO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw0QkFBNEI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixXQUFXO0FBQ2hDO0FBQ0EscUJBQXFCLFdBQVc7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFdBQVc7QUFDaEM7QUFDQSxxQkFBcUIsV0FBVztBQUNoQyxxQkFBcUIsV0FBVztBQUNoQyxxQkFBcUIsV0FBVztBQUNoQyx3QkFBd0IsV0FBVztBQUNuQyx3QkFBd0IsV0FBVztBQUNuQyx5QkFBeUIsV0FBVztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEM7QUFDQTtBQUNBLHFCQUFxQixVQUFVO0FBQy9CLGVBQWU7QUFDZixtQkFBbUI7QUFDbkIsNkJBQTZCLFVBQVU7QUFDdkMsb0NBQW9DLFVBQVUsd0JBQXdCLFVBQVU7QUFDaEY7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLDZCQUE2QixVQUFVO0FBQ3ZDLG9DQUFvQyxVQUFVLHdCQUF3QixVQUFVO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsVUFBVTtBQUMvQyxxQ0FBcUMsVUFBVTtBQUMvQztBQUNBLHNDQUFzQyxVQUFVO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixZQUFZO0FBQ2xDO0FBQ0E7QUFDQSxxQkFBcUIsVUFBVTtBQUMvQjtBQUNBLHNGQUFzRjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFVBQVU7QUFDbEQsd0NBQXdDLFVBQVU7QUFDbEQ7QUFDQSwwQ0FBMEMsVUFBVTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGFBQWEsTUFBTTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsR0FBRztBQUMzQjtBQUNBLG1DQUFtQyxVQUFVO0FBQzdDLHdDQUF3QyxVQUFVO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSx3QkFBd0IsR0FBRztBQUMzQjtBQUNBLG1DQUFtQyxVQUFVO0FBQzdDLHdDQUF3QyxVQUFVO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNpQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBOzs7QUNwWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsVUFBVTtBQUN6QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFVBQVU7QUFDakMsdUJBQXVCLFVBQVU7QUFDakM7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxnQkFBZ0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzBDO0FBQ1Y7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGlCQUFpQjtBQUN6QixRQUFRLHNCQUFzQjtBQUM5QixRQUFRLG1CQUFtQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDJCQUEyQjtBQUN4QyxhQUFhLDJCQUEyQjtBQUN4QyxhQUFhLDZCQUE2QjtBQUMxQyxhQUFhLCtCQUErQjtBQUM1QyxhQUFhLHdCQUF3QjtBQUNyQyxhQUFhLG9DQUFvQztBQUNqRCxhQUFhLDhCQUE4QjtBQUMzQyxhQUFhLDhCQUE4QjtBQUMzQyxhQUFhLGlDQUFpQztBQUM5QyxhQUFhLG1DQUFtQztBQUNoRCxhQUFhLGlDQUFpQztBQUM5QyxhQUFhLDZCQUE2QjtBQUMxQyxhQUFhLDJCQUEyQjtBQUN4QyxhQUFhLG1DQUFtQztBQUNoRCxhQUFhLDRCQUE0QjtBQUN6QyxhQUFhLHVCQUF1QjtBQUNwQztBQUNBO0FBQ0E7QUFDQSxRQUFRLDJCQUEyQjtBQUNuQyxRQUFRLGtDQUFrQztBQUMxQyxRQUFRLGdDQUFnQztBQUN4QyxRQUFRLHNDQUFzQztBQUM5QyxRQUFRLGdDQUFnQztBQUN4QztBQUNBO0FBQ0E7QUFDQSxRQUFRLHVCQUF1QjtBQUMvQixRQUFRLHFCQUFxQjtBQUM3QixRQUFRLHFCQUFxQjtBQUM3QixRQUFRLHFCQUFxQjtBQUM3QixRQUFRLHNCQUFzQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixZQUFZO0FBQ3hDO0FBQ0E7QUFDQSw2QkFBNkIsVUFBVTtBQUN2Qyx3REFBd0QsVUFBVTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixnQkFBZ0Isc0JBQXNCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEMsa0JBQWtCLFNBQVMsU0FBUyxHQUFHLGdCQUFnQixFQUFFO0FBQ3pEO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQSxrQ0FBa0MsU0FBUyxTQUFTLEdBQUcsZ0JBQWdCLElBQUk7QUFDM0U7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSwyQkFBMkI7QUFDM0IsNkJBQTZCLFNBQVM7QUFDdEMsNkJBQTZCLGdCQUFnQjtBQUM3QywyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsc0JBQXNCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxZQUFZO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHNCQUFzQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsWUFBWTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZ0JBQWdCO0FBQ25DO0FBQ0Esc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFVBQVU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFVBQVU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU8sNkNBQTZDLGFBQWE7QUFDNUUsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTyw2Q0FBNkMsdUJBQXVCO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixlQUFlLFFBQVE7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0EscUJBQXFCLFVBQVU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFdBQVc7QUFDNUMsaUNBQWlDLGNBQWM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixjQUFjO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFNBQVM7QUFDekMsZ0NBQWdDLFlBQVk7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBLHFCQUFxQixVQUFVO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTyw2Q0FBNkMs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SyxRQUFRLENBQUMsNENBQTRDLENBQUMsRUFBRTtJQUNqRTRkLGdCQUFDLENBQUMseUNBQXlDLENBQUMsQ0FBQzhELElBQUksQ0FBQyxDQUFDO0VBQ3ZELENBQUMsTUFDSSxJQUFJdlgsR0FBRyxDQUFDbkssUUFBUSxDQUFDLG1CQUFtQixDQUFDLEVBQUU7SUFDeEM0ZCxnQkFBQyxDQUFDLG1DQUFtQyxDQUFDLENBQUM4RCxJQUFJLENBQUMsQ0FBQztFQUNqRCxDQUFDLE1BQ0k7SUFDRDlELGdCQUFDLENBQUMsOEJBQThCLENBQUMsQ0FBQzhELElBQUksQ0FBQyxDQUFDO0VBQzVDO0FBQ0o7QUFDQSxTQUFTL0MsbUJBQW1CQSxDQUFDN1gsV0FBVyxFQUFFMFgsVUFBVSxFQUFFeE4sYUFBYSxHQUFHLEtBQUssRUFBRTJRLGVBQWUsRUFBRTFFLFVBQVUsR0FBRyxFQUFFLEVBQUU7RUFDM0d2MUIsT0FBRyxDQUFFLG1DQUFrQzgyQixVQUFXLG1CQUFrQnhOLGFBQWMsZ0JBQWVpTSxVQUFXLEVBQUMsQ0FBQztFQUM5RyxNQUFNMEIsbUJBQW1CLEdBQUc7SUFDeEJ4MUIsSUFBSSxFQUFFLHdCQUF3QjtJQUM5QjJkLFdBQVcsRUFBRUEsV0FBVztJQUN4QjhhLFFBQVEsRUFBRXBELFVBQVU7SUFDcEJ4TixhQUFhLEVBQUVBLGFBQWE7SUFDNUJpTSxVQUFVLEVBQUVBO0VBQ2hCLENBQUM7RUFDRDcxQixNQUFNLENBQUM2QixPQUFPLENBQUNJLFdBQVcsQ0FBQ3MxQixtQkFBbUIsRUFBRSxDQUFDLENBQUMsRUFBRWdELGVBQWUsQ0FBQztBQUN4RTtBQUNBdjZCLE1BQU0sQ0FBQzZCLE9BQU8sQ0FBQ2tjLFNBQVMsQ0FBQ0MsV0FBVyxDQUFDLE1BQU07RUFDdkMxZCxPQUFHLENBQUMscUJBQXFCLENBQUM7QUFDOUIsQ0FBQyxDQUFDLEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wYXBlcmN1dC1tb2JpbGl0eS1jaHJvbWUvLi9ub2RlX21vZHVsZXMvanF1ZXJ5LXZhbGlkYXRpb24vZGlzdC9qcXVlcnkudmFsaWRhdGUuanMiLCJ3ZWJwYWNrOi8vcGFwZXJjdXQtbW9iaWxpdHktY2hyb21lLy4vbm9kZV9tb2R1bGVzL2pxdWVyeS9kaXN0L2pxdWVyeS5qcyIsIndlYnBhY2s6Ly9wYXBlcmN1dC1tb2JpbGl0eS1jaHJvbWUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYS1jYWxsYWJsZS5qcyIsIndlYnBhY2s6Ly9wYXBlcmN1dC1tb2JpbGl0eS1jaHJvbWUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYS1jb25zdHJ1Y3Rvci5qcyIsIndlYnBhY2s6Ly9wYXBlcmN1dC1tb2JpbGl0eS1jaHJvbWUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYS1wb3NzaWJsZS1wcm90b3R5cGUuanMiLCJ3ZWJwYWNrOi8vcGFwZXJjdXQtbW9iaWxpdHktY2hyb21lLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FkZC10by11bnNjb3BhYmxlcy5qcyIsIndlYnBhY2s6Ly9wYXBlcmN1dC1tb2JpbGl0eS1jaHJvbWUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYWR2YW5jZS1zdHJpbmctaW5kZXguanMiLCJ3ZWJwYWNrOi8vcGFwZXJjdXQtbW9iaWxpdHktY2hyb21lLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FuLW9iamVjdC5qcyIsIndlYnBhY2s6Ly9wYXBlcmN1dC1tb2JpbGl0eS1jaHJvbWUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktYnVmZmVyLWJhc2ljLWRldGVjdGlvbi5qcyIsIndlYnBhY2s6Ly9wYXBlcmN1dC1tb2JpbGl0eS1jaHJvbWUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktYnVmZmVyLXZpZXctY29yZS5qcyIsIndlYnBhY2s6Ly9wYXBlcmN1dC1tb2JpbGl0eS1jaHJvbWUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktaW5jbHVkZXMuanMiLCJ3ZWJwYWNrOi8vcGFwZXJjdXQtbW9iaWxpdHktY2hyb21lLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LW1ldGhvZC1pcy1zdHJpY3QuanMiLCJ3ZWJwYWNrOi8vcGFwZXJjdXQtbW9iaWxpdHktY2hyb21lLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LXJlZHVjZS5qcyIsIndlYnBhY2s6Ly9wYXBlcmN1dC1tb2JpbGl0eS1jaHJvbWUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktc2xpY2UuanMiLCJ3ZWJwYWNrOi8vcGFwZXJjdXQtbW9iaWxpdHktY2hyb21lLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LXNvcnQuanMiLCJ3ZWJwYWNrOi8vcGFwZXJjdXQtbW9iaWxpdHktY2hyb21lLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NsYXNzb2YtcmF3LmpzIiwid2VicGFjazovL3BhcGVyY3V0LW1vYmlsaXR5LWNocm9tZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jbGFzc29mLmpzIiwid2VicGFjazovL3BhcGVyY3V0LW1vYmlsaXR5LWNocm9tZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jb3B5LWNvbnN0cnVjdG9yLXByb3BlcnRpZXMuanMiLCJ3ZWJwYWNrOi8vcGFwZXJjdXQtbW9iaWxpdHktY2hyb21lLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NvcnJlY3QtcHJvdG90eXBlLWdldHRlci5qcyIsIndlYnBhY2s6Ly9wYXBlcmN1dC1tb2JpbGl0eS1jaHJvbWUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLWl0ZXItcmVzdWx0LW9iamVjdC5qcyIsIndlYnBhY2s6Ly9wYXBlcmN1dC1tb2JpbGl0eS1jaHJvbWUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLW5vbi1lbnVtZXJhYmxlLXByb3BlcnR5LmpzIiwid2VicGFjazovL3BhcGVyY3V0LW1vYmlsaXR5LWNocm9tZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHktZGVzY3JpcHRvci5qcyIsIndlYnBhY2s6Ly9wYXBlcmN1dC1tb2JpbGl0eS1jaHJvbWUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZGVmaW5lLWJ1aWx0LWluLWFjY2Vzc29yLmpzIiwid2VicGFjazovL3BhcGVyY3V0LW1vYmlsaXR5LWNocm9tZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZWZpbmUtYnVpbHQtaW4uanMiLCJ3ZWJwYWNrOi8vcGFwZXJjdXQtbW9iaWxpdHktY2hyb21lLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2RlZmluZS1nbG9iYWwtcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vcGFwZXJjdXQtbW9iaWxpdHktY2hyb21lLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Rlc2NyaXB0b3JzLmpzIiwid2VicGFjazovL3BhcGVyY3V0LW1vYmlsaXR5LWNocm9tZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kb2N1bWVudC1jcmVhdGUtZWxlbWVudC5qcyIsIndlYnBhY2s6Ly9wYXBlcmN1dC1tb2JpbGl0eS1jaHJvbWUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZW5naW5lLWZmLXZlcnNpb24uanMiLCJ3ZWJwYWNrOi8vcGFwZXJjdXQtbW9iaWxpdHktY2hyb21lLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2VuZ2luZS1pcy1pZS1vci1lZGdlLmpzIiwid2VicGFjazovL3BhcGVyY3V0LW1vYmlsaXR5LWNocm9tZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9lbmdpbmUtaXMtbm9kZS5qcyIsIndlYnBhY2s6Ly9wYXBlcmN1dC1tb2JpbGl0eS1jaHJvbWUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZW5naW5lLXVzZXItYWdlbnQuanMiLCJ3ZWJwYWNrOi8vcGFwZXJjdXQtbW9iaWxpdHktY2hyb21lLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2VuZ2luZS12OC12ZXJzaW9uLmpzIiwid2VicGFjazovL3BhcGVyY3V0LW1vYmlsaXR5LWNocm9tZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9lbmdpbmUtd2Via2l0LXZlcnNpb24uanMiLCJ3ZWJwYWNrOi8vcGFwZXJjdXQtbW9iaWxpdHktY2hyb21lLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2VudW0tYnVnLWtleXMuanMiLCJ3ZWJwYWNrOi8vcGFwZXJjdXQtbW9iaWxpdHktY2hyb21lLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2V4cG9ydC5qcyIsIndlYnBhY2s6Ly9wYXBlcmN1dC1tb2JpbGl0eS1jaHJvbWUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZmFpbHMuanMiLCJ3ZWJwYWNrOi8vcGFwZXJjdXQtbW9iaWxpdHktY2hyb21lLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLWFwcGx5LmpzIiwid2VicGFjazovL3BhcGVyY3V0LW1vYmlsaXR5LWNocm9tZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi1iaW5kLW5hdGl2ZS5qcyIsIndlYnBhY2s6Ly9wYXBlcmN1dC1tb2JpbGl0eS1jaHJvbWUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZnVuY3Rpb24tY2FsbC5qcyIsIndlYnBhY2s6Ly9wYXBlcmN1dC1tb2JpbGl0eS1jaHJvbWUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZnVuY3Rpb24tbmFtZS5qcyIsIndlYnBhY2s6Ly9wYXBlcmN1dC1tb2JpbGl0eS1jaHJvbWUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzLWFjY2Vzc29yLmpzIiwid2VicGFjazovL3BhcGVyY3V0LW1vYmlsaXR5LWNocm9tZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMtY2xhdXNlLmpzIiwid2VicGFjazovL3BhcGVyY3V0LW1vYmlsaXR5LWNocm9tZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMuanMiLCJ3ZWJwYWNrOi8vcGFwZXJjdXQtbW9iaWxpdHktY2hyb21lLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dldC1idWlsdC1pbi5qcyIsIndlYnBhY2s6Ly9wYXBlcmN1dC1tb2JpbGl0eS1jaHJvbWUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2V0LWpzb24tcmVwbGFjZXItZnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vcGFwZXJjdXQtbW9iaWxpdHktY2hyb21lLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dldC1tZXRob2QuanMiLCJ3ZWJwYWNrOi8vcGFwZXJjdXQtbW9iaWxpdHktY2hyb21lLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dsb2JhbC5qcyIsIndlYnBhY2s6Ly9wYXBlcmN1dC1tb2JpbGl0eS1jaHJvbWUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaGFzLW93bi1wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly9wYXBlcmN1dC1tb2JpbGl0eS1jaHJvbWUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaGlkZGVuLWtleXMuanMiLCJ3ZWJwYWNrOi8vcGFwZXJjdXQtbW9iaWxpdHktY2hyb21lLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2h0bWwuanMiLCJ3ZWJwYWNrOi8vcGFwZXJjdXQtbW9iaWxpdHktY2hyb21lLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2llOC1kb20tZGVmaW5lLmpzIiwid2VicGFjazovL3BhcGVyY3V0LW1vYmlsaXR5LWNocm9tZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbmRleGVkLW9iamVjdC5qcyIsIndlYnBhY2s6Ly9wYXBlcmN1dC1tb2JpbGl0eS1jaHJvbWUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW5zcGVjdC1zb3VyY2UuanMiLCJ3ZWJwYWNrOi8vcGFwZXJjdXQtbW9iaWxpdHktY2hyb21lLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2ludGVybmFsLXN0YXRlLmpzIiwid2VicGFjazovL3BhcGVyY3V0LW1vYmlsaXR5LWNocm9tZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1hcnJheS5qcyIsIndlYnBhY2s6Ly9wYXBlcmN1dC1tb2JpbGl0eS1jaHJvbWUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtY2FsbGFibGUuanMiLCJ3ZWJwYWNrOi8vcGFwZXJjdXQtbW9iaWxpdHktY2hyb21lLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLWNvbnN0cnVjdG9yLmpzIiwid2VicGFjazovL3BhcGVyY3V0LW1vYmlsaXR5LWNocm9tZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1mb3JjZWQuanMiLCJ3ZWJwYWNrOi8vcGFwZXJjdXQtbW9iaWxpdHktY2hyb21lLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLW51bGwtb3ItdW5kZWZpbmVkLmpzIiwid2VicGFjazovL3BhcGVyY3V0LW1vYmlsaXR5LWNocm9tZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1vYmplY3QuanMiLCJ3ZWJwYWNrOi8vcGFwZXJjdXQtbW9iaWxpdHktY2hyb21lLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLXBvc3NpYmxlLXByb3RvdHlwZS5qcyIsIndlYnBhY2s6Ly9wYXBlcmN1dC1tb2JpbGl0eS1jaHJvbWUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtcHVyZS5qcyIsIndlYnBhY2s6Ly9wYXBlcmN1dC1tb2JpbGl0eS1jaHJvbWUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtcmVnZXhwLmpzIiwid2VicGFjazovL3BhcGVyY3V0LW1vYmlsaXR5LWNocm9tZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1zeW1ib2wuanMiLCJ3ZWJwYWNrOi8vcGFwZXJjdXQtbW9iaWxpdHktY2hyb21lLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2l0ZXJhdG9yLWNyZWF0ZS1jb25zdHJ1Y3Rvci5qcyIsIndlYnBhY2s6Ly9wYXBlcmN1dC1tb2JpbGl0eS1jaHJvbWUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXRlcmF0b3JzLWNvcmUuanMiLCJ3ZWJwYWNrOi8vcGFwZXJjdXQtbW9iaWxpdHktY2hyb21lLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2l0ZXJhdG9ycy5qcyIsIndlYnBhY2s6Ly9wYXBlcmN1dC1tb2JpbGl0eS1jaHJvbWUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvbGVuZ3RoLW9mLWFycmF5LWxpa2UuanMiLCJ3ZWJwYWNrOi8vcGFwZXJjdXQtbW9iaWxpdHktY2hyb21lLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL21ha2UtYnVpbHQtaW4uanMiLCJ3ZWJwYWNrOi8vcGFwZXJjdXQtbW9iaWxpdHktY2hyb21lLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL21hdGgtdHJ1bmMuanMiLCJ3ZWJwYWNrOi8vcGFwZXJjdXQtbW9iaWxpdHktY2hyb21lLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vcGFwZXJjdXQtbW9iaWxpdHktY2hyb21lLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydGllcy5qcyIsIndlYnBhY2s6Ly9wYXBlcmN1dC1tb2JpbGl0eS1jaHJvbWUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly9wYXBlcmN1dC1tb2JpbGl0eS1jaHJvbWUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qcyIsIndlYnBhY2s6Ly9wYXBlcmN1dC1tb2JpbGl0eS1jaHJvbWUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktbmFtZXMuanMiLCJ3ZWJwYWNrOi8vcGFwZXJjdXQtbW9iaWxpdHktY2hyb21lLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LXN5bWJvbHMuanMiLCJ3ZWJwYWNrOi8vcGFwZXJjdXQtbW9iaWxpdHktY2hyb21lLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtcHJvdG90eXBlLW9mLmpzIiwid2VicGFjazovL3BhcGVyY3V0LW1vYmlsaXR5LWNocm9tZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtaXMtcHJvdG90eXBlLW9mLmpzIiwid2VicGFjazovL3BhcGVyY3V0LW1vYmlsaXR5LWNocm9tZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3Qta2V5cy1pbnRlcm5hbC5qcyIsIndlYnBhY2s6Ly9wYXBlcmN1dC1tb2JpbGl0eS1jaHJvbWUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWtleXMuanMiLCJ3ZWJwYWNrOi8vcGFwZXJjdXQtbW9iaWxpdHktY2hyb21lLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1wcm9wZXJ0eS1pcy1lbnVtZXJhYmxlLmpzIiwid2VicGFjazovL3BhcGVyY3V0LW1vYmlsaXR5LWNocm9tZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3Qtc2V0LXByb3RvdHlwZS1vZi5qcyIsIndlYnBhY2s6Ly9wYXBlcmN1dC1tb2JpbGl0eS1jaHJvbWUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb3JkaW5hcnktdG8tcHJpbWl0aXZlLmpzIiwid2VicGFjazovL3BhcGVyY3V0LW1vYmlsaXR5LWNocm9tZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vd24ta2V5cy5qcyIsIndlYnBhY2s6Ly9wYXBlcmN1dC1tb2JpbGl0eS1jaHJvbWUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcmVnZXhwLWV4ZWMtYWJzdHJhY3QuanMiLCJ3ZWJwYWNrOi8vcGFwZXJjdXQtbW9iaWxpdHktY2hyb21lLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3JlZ2V4cC1leGVjLmpzIiwid2VicGFjazovL3BhcGVyY3V0LW1vYmlsaXR5LWNocm9tZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9yZWdleHAtZmxhZ3MuanMiLCJ3ZWJwYWNrOi8vcGFwZXJjdXQtbW9iaWxpdHktY2hyb21lLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3JlZ2V4cC1nZXQtZmxhZ3MuanMiLCJ3ZWJwYWNrOi8vcGFwZXJjdXQtbW9iaWxpdHktY2hyb21lLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3JlZ2V4cC1zdGlja3ktaGVscGVycy5qcyIsIndlYnBhY2s6Ly9wYXBlcmN1dC1tb2JpbGl0eS1jaHJvbWUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcmVnZXhwLXVuc3VwcG9ydGVkLWRvdC1hbGwuanMiLCJ3ZWJwYWNrOi8vcGFwZXJjdXQtbW9iaWxpdHktY2hyb21lLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3JlZ2V4cC11bnN1cHBvcnRlZC1uY2cuanMiLCJ3ZWJwYWNrOi8vcGFwZXJjdXQtbW9iaWxpdHktY2hyb21lLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZS5qcyIsIndlYnBhY2s6Ly9wYXBlcmN1dC1tb2JpbGl0eS1jaHJvbWUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2V0LXRvLXN0cmluZy10YWcuanMiLCJ3ZWJwYWNrOi8vcGFwZXJjdXQtbW9iaWxpdHktY2hyb21lLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NoYXJlZC1rZXkuanMiLCJ3ZWJwYWNrOi8vcGFwZXJjdXQtbW9iaWxpdHktY2hyb21lLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NoYXJlZC1zdG9yZS5qcyIsIndlYnBhY2s6Ly9wYXBlcmN1dC1tb2JpbGl0eS1jaHJvbWUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2hhcmVkLmpzIiwid2VicGFjazovL3BhcGVyY3V0LW1vYmlsaXR5LWNocm9tZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zcGVjaWVzLWNvbnN0cnVjdG9yLmpzIiwid2VicGFjazovL3BhcGVyY3V0LW1vYmlsaXR5LWNocm9tZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zdHJpbmctbXVsdGlieXRlLmpzIiwid2VicGFjazovL3BhcGVyY3V0LW1vYmlsaXR5LWNocm9tZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zeW1ib2wtY29uc3RydWN0b3ItZGV0ZWN0aW9uLmpzIiwid2VicGFjazovL3BhcGVyY3V0LW1vYmlsaXR5LWNocm9tZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1hYnNvbHV0ZS1pbmRleC5qcyIsIndlYnBhY2s6Ly9wYXBlcmN1dC1tb2JpbGl0eS1jaHJvbWUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QuanMiLCJ3ZWJwYWNrOi8vcGFwZXJjdXQtbW9iaWxpdHktY2hyb21lLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLWludGVnZXItb3ItaW5maW5pdHkuanMiLCJ3ZWJwYWNrOi8vcGFwZXJjdXQtbW9iaWxpdHktY2hyb21lLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLWxlbmd0aC5qcyIsIndlYnBhY2s6Ly9wYXBlcmN1dC1tb2JpbGl0eS1jaHJvbWUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tb2JqZWN0LmpzIiwid2VicGFjazovL3BhcGVyY3V0LW1vYmlsaXR5LWNocm9tZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1vZmZzZXQuanMiLCJ3ZWJwYWNrOi8vcGFwZXJjdXQtbW9iaWxpdHktY2hyb21lLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLXBvc2l0aXZlLWludGVnZXIuanMiLCJ3ZWJwYWNrOi8vcGFwZXJjdXQtbW9iaWxpdHktY2hyb21lLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLXByaW1pdGl2ZS5qcyIsIndlYnBhY2s6Ly9wYXBlcmN1dC1tb2JpbGl0eS1jaHJvbWUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tcHJvcGVydHkta2V5LmpzIiwid2VicGFjazovL3BhcGVyY3V0LW1vYmlsaXR5LWNocm9tZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1zdHJpbmctdGFnLXN1cHBvcnQuanMiLCJ3ZWJwYWNrOi8vcGFwZXJjdXQtbW9iaWxpdHktY2hyb21lLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLXN0cmluZy5qcyIsIndlYnBhY2s6Ly9wYXBlcmN1dC1tb2JpbGl0eS1jaHJvbWUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdHJ5LXRvLXN0cmluZy5qcyIsIndlYnBhY2s6Ly9wYXBlcmN1dC1tb2JpbGl0eS1jaHJvbWUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdWlkLmpzIiwid2VicGFjazovL3BhcGVyY3V0LW1vYmlsaXR5LWNocm9tZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy91c2Utc3ltYm9sLWFzLXVpZC5qcyIsIndlYnBhY2s6Ly9wYXBlcmN1dC1tb2JpbGl0eS1jaHJvbWUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdjgtcHJvdG90eXBlLWRlZmluZS1idWcuanMiLCJ3ZWJwYWNrOi8vcGFwZXJjdXQtbW9iaWxpdHktY2hyb21lLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3dlYWstbWFwLWJhc2ljLWRldGVjdGlvbi5qcyIsIndlYnBhY2s6Ly9wYXBlcmN1dC1tb2JpbGl0eS1jaHJvbWUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wuanMiLCJ3ZWJwYWNrOi8vcGFwZXJjdXQtbW9iaWxpdHktY2hyb21lLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5yZWR1Y2UuanMiLCJ3ZWJwYWNrOi8vcGFwZXJjdXQtbW9iaWxpdHktY2hyb21lLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS51bnNjb3BhYmxlcy5mbGF0LmpzIiwid2VicGFjazovL3BhcGVyY3V0LW1vYmlsaXR5LWNocm9tZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuanNvbi5zdHJpbmdpZnkuanMiLCJ3ZWJwYWNrOi8vcGFwZXJjdXQtbW9iaWxpdHktY2hyb21lLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcubWF0Y2gtYWxsLmpzIiwid2VicGFjazovL3BhcGVyY3V0LW1vYmlsaXR5LWNocm9tZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmRlc2NyaXB0aW9uLmpzIiwid2VicGFjazovL3BhcGVyY3V0LW1vYmlsaXR5LWNocm9tZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc2V0LmpzIiwid2VicGFjazovL3BhcGVyY3V0LW1vYmlsaXR5LWNocm9tZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc29ydC5qcyIsIndlYnBhY2s6Ly9wYXBlcmN1dC1tb2JpbGl0eS1jaHJvbWUvd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vcGFwZXJjdXQtbW9iaWxpdHktY2hyb21lL3dlYnBhY2svcnVudGltZS9jb21wYXQgZ2V0IGRlZmF1bHQgZXhwb3J0Iiwid2VicGFjazovL3BhcGVyY3V0LW1vYmlsaXR5LWNocm9tZS93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vcGFwZXJjdXQtbW9iaWxpdHktY2hyb21lL3dlYnBhY2svcnVudGltZS9nbG9iYWwiLCJ3ZWJwYWNrOi8vcGFwZXJjdXQtbW9iaWxpdHktY2hyb21lL3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vcGFwZXJjdXQtbW9iaWxpdHktY2hyb21lLy4vc3JjL3NjcmlwdHMvZ2xvYmFscy50cyIsIndlYnBhY2s6Ly9wYXBlcmN1dC1tb2JpbGl0eS1jaHJvbWUvLi9zcmMvc2NyaXB0cy9odHRwL2h0dHAudHMiLCJ3ZWJwYWNrOi8vcGFwZXJjdXQtbW9iaWxpdHktY2hyb21lLy4vc3JjL3NjcmlwdHMvdGltZS9mb3JtYXQudHMiLCJ3ZWJwYWNrOi8vcGFwZXJjdXQtbW9iaWxpdHktY2hyb21lLy4vc3JjL3NjcmlwdHMvbG9nL2xvZy50cyIsIndlYnBhY2s6Ly9wYXBlcmN1dC1tb2JpbGl0eS1jaHJvbWUvLi9zcmMvc2NyaXB0cy9sb2cvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vcGFwZXJjdXQtbW9iaWxpdHktY2hyb21lLy4vc3JjL3NjcmlwdHMvcmFuZG9tL3N0cmluZy50cyIsIndlYnBhY2s6Ly9wYXBlcmN1dC1tb2JpbGl0eS1jaHJvbWUvLi9zcmMvc2NyaXB0cy9yYW5kb20vaW5kZXgudHMiLCJ3ZWJwYWNrOi8vcGFwZXJjdXQtbW9iaWxpdHktY2hyb21lLy4vc3JjL3NjcmlwdHMvaWRlbnRpdHkvY2xpZW50SWQudHMiLCJ3ZWJwYWNrOi8vcGFwZXJjdXQtbW9iaWxpdHktY2hyb21lLy4vc3JjL3NjcmlwdHMvaWRlbnRpdHkvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vcGFwZXJjdXQtbW9iaWxpdHktY2hyb21lLy4vbm9kZV9tb2R1bGVzL3BjLW1vYmlsaXR5LWNsb3VkL2NsaWVudC90cy9zZXNzaW9uLnRzIiwid2VicGFjazovL3BhcGVyY3V0LW1vYmlsaXR5LWNocm9tZS8uL25vZGVfbW9kdWxlcy9wYy1tb2JpbGl0eS1jbG91ZC9jbGllbnQvdHMvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vcGFwZXJjdXQtbW9iaWxpdHktY2hyb21lLy4vc3JjL3NjcmlwdHMvcGVlci9ibG9iLnRzIiwid2VicGFjazovL3BhcGVyY3V0LW1vYmlsaXR5LWNocm9tZS8uL3NyYy9zY3JpcHRzL3BlZXIvZGF0YWNoYW5uZWwudHMiLCJ3ZWJwYWNrOi8vcGFwZXJjdXQtbW9iaWxpdHktY2hyb21lLy4vc3JjL3NjcmlwdHMvcGVlci9zaWduYWwudHMiLCJ3ZWJwYWNrOi8vcGFwZXJjdXQtbW9iaWxpdHktY2hyb21lLy4vc3JjL3NjcmlwdHMvcGVlci9wZWVyLnRzIiwid2VicGFjazovL3BhcGVyY3V0LW1vYmlsaXR5LWNocm9tZS8uL3NyYy9zY3JpcHRzL3BlZXIvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vcGFwZXJjdXQtbW9iaWxpdHktY2hyb21lLy4vc3JjL3NjcmlwdHMvY2xvdWRwcmludC9jbGllbnQudHMiLCJ3ZWJwYWNrOi8vcGFwZXJjdXQtbW9iaWxpdHktY2hyb21lLy4vc3JjL3NjcmlwdHMvY2xvdWRwcmludC9jbGllbnRidWlsZGVyLnRzIiwid2VicGFjazovL3BhcGVyY3V0LW1vYmlsaXR5LWNocm9tZS8uL3NyYy9zY3JpcHRzL2Nsb3VkcHJpbnQvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vcGFwZXJjdXQtbW9iaWxpdHktY2hyb21lLy4vc3JjL3NjcmlwdHMvcHJpbnRlci9jYXBhYmlsaXRpZXMudHMiLCJ3ZWJwYWNrOi8vcGFwZXJjdXQtbW9iaWxpdHktY2hyb21lLy4vc3JjL3NjcmlwdHMvc3RvcmFnZS9zdG9yYWdlLnRzIiwid2VicGFjazovL3BhcGVyY3V0LW1vYmlsaXR5LWNocm9tZS8uL3NyYy9zY3JpcHRzL3dhaXQudHMiLCJ3ZWJwYWNrOi8vcGFwZXJjdXQtbW9iaWxpdHktY2hyb21lLy4vc3JjL3NjcmlwdHMvb2ZmbmV0d29yay9vZmZuZXR3b3JrY2FjaGUudHMiLCJ3ZWJwYWNrOi8vcGFwZXJjdXQtbW9iaWxpdHktY2hyb21lLy4vc3JjL3NjcmlwdHMvb2ZmbmV0d29yay9vZmZuZXR3b3JrLXV0aWxzLnRzIiwid2VicGFjazovL3BhcGVyY3V0LW1vYmlsaXR5LWNocm9tZS8uL3NyYy9zY3JpcHRzL29mZm5ldHdvcmsvb2Zmc2NyZWVuLXV0aWxzLnRzIiwid2VicGFjazovL3BhcGVyY3V0LW1vYmlsaXR5LWNocm9tZS8uL3NyYy9zY3JpcHRzL29mZm5ldHdvcmsvb2ZmbmV0d29ya19leHRlbnNpb24udHMiLCJ3ZWJwYWNrOi8vcGFwZXJjdXQtbW9iaWxpdHktY2hyb21lLy4vc3JjL3NjcmlwdHMvcHJpbnRlci9wcmludGVyLnRzIiwid2VicGFjazovL3BhcGVyY3V0LW1vYmlsaXR5LWNocm9tZS8uL25vZGVfbW9kdWxlcy9qc2VuY3J5cHQvbGliL2xpYi9qc2JuL3V0aWwuanMiLCJ3ZWJwYWNrOi8vcGFwZXJjdXQtbW9iaWxpdHktY2hyb21lLy4vbm9kZV9tb2R1bGVzL2pzZW5jcnlwdC9saWIvbGliL2pzYm4vYmFzZTY0LmpzIiwid2VicGFjazovL3BhcGVyY3V0LW1vYmlsaXR5LWNocm9tZS8uL25vZGVfbW9kdWxlcy9qc2VuY3J5cHQvbGliL2xpYi9hc24xanMvaGV4LmpzIiwid2VicGFjazovL3BhcGVyY3V0LW1vYmlsaXR5LWNocm9tZS8uL25vZGVfbW9kdWxlcy9qc2VuY3J5cHQvbGliL2xpYi9hc24xanMvYmFzZTY0LmpzIiwid2VicGFjazovL3BhcGVyY3V0LW1vYmlsaXR5LWNocm9tZS8uL25vZGVfbW9kdWxlcy9qc2VuY3J5cHQvbGliL2xpYi9hc24xanMvaW50MTAuanMiLCJ3ZWJwYWNrOi8vcGFwZXJjdXQtbW9iaWxpdHktY2hyb21lLy4vbm9kZV9tb2R1bGVzL2pzZW5jcnlwdC9saWIvbGliL2FzbjFqcy9hc24xLmpzIiwid2VicGFjazovL3BhcGVyY3V0LW1vYmlsaXR5LWNocm9tZS8uL25vZGVfbW9kdWxlcy9qc2VuY3J5cHQvbGliL2xpYi9qc2JuL2pzYm4uanMiLCJ3ZWJwYWNrOi8vcGFwZXJjdXQtbW9iaWxpdHktY2hyb21lLy4vbm9kZV9tb2R1bGVzL2pzZW5jcnlwdC9saWIvbGliL2pzYm4vcHJuZzQuanMiLCJ3ZWJwYWNrOi8vcGFwZXJjdXQtbW9iaWxpdHktY2hyb21lLy4vbm9kZV9tb2R1bGVzL2pzZW5jcnlwdC9saWIvbGliL2pzYm4vcm5nLmpzIiwid2VicGFjazovL3BhcGVyY3V0LW1vYmlsaXR5LWNocm9tZS8uL25vZGVfbW9kdWxlcy9qc2VuY3J5cHQvbGliL2xpYi9qc2JuL3JzYS5qcyIsIndlYnBhY2s6Ly9wYXBlcmN1dC1tb2JpbGl0eS1jaHJvbWUvLi9ub2RlX21vZHVsZXMvanNlbmNyeXB0L2xpYi9saWIvanNyc2FzaWduL3lhaG9vLmpzIiwid2VicGFjazovL3BhcGVyY3V0LW1vYmlsaXR5LWNocm9tZS8uL25vZGVfbW9kdWxlcy9qc2VuY3J5cHQvbGliL2xpYi9qc3JzYXNpZ24vYXNuMS0xLjAuanMiLCJ3ZWJwYWNrOi8vcGFwZXJjdXQtbW9iaWxpdHktY2hyb21lLy4vbm9kZV9tb2R1bGVzL2pzZW5jcnlwdC9saWIvSlNFbmNyeXB0UlNBS2V5LmpzIiwid2VicGFjazovL3BhcGVyY3V0LW1vYmlsaXR5LWNocm9tZS8uL25vZGVfbW9kdWxlcy9qc2VuY3J5cHQvbGliL0pTRW5jcnlwdC5qcyIsIndlYnBhY2s6Ly9wYXBlcmN1dC1tb2JpbGl0eS1jaHJvbWUvLi9ub2RlX21vZHVsZXMvanNlbmNyeXB0L2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly9wYXBlcmN1dC1tb2JpbGl0eS1jaHJvbWUvLi9zcmMvc2NyaXB0cy9yc2EudHMiLCJ3ZWJwYWNrOi8vcGFwZXJjdXQtbW9iaWxpdHktY2hyb21lLy4vc3JjL3NjcmlwdHMvYXV0aC50cyIsIndlYnBhY2s6Ly9wYXBlcmN1dC1tb2JpbGl0eS1jaHJvbWUvLi9zcmMvc2NyaXB0cy9jaHJvbWUvbWVzc2FnZS9tZXNzYWdlX2V4dGVuc2lvbi50cyIsIndlYnBhY2s6Ly9wYXBlcmN1dC1tb2JpbGl0eS1jaHJvbWUvLi9zcmMvc2NyaXB0cy9jaHJvbWUvY2hyb21lLnRzIiwid2VicGFjazovL3BhcGVyY3V0LW1vYmlsaXR5LWNocm9tZS8uL3NyYy9zY3JpcHRzL2Nocm9tZS9pbmRleC50cyIsIndlYnBhY2s6Ly9wYXBlcmN1dC1tb2JpbGl0eS1jaHJvbWUvLi9zcmMvc2NyaXB0cy9wcmludGRlcGxveS9nb29nbGVhdXRoLnRzIiwid2VicGFjazovL3BhcGVyY3V0LW1vYmlsaXR5LWNocm9tZS8uL3NyYy9zY3JpcHRzL3ByaW50ZGVwbG95L29hdXRoLnRzIiwid2VicGFjazovL3BhcGVyY3V0LW1vYmlsaXR5LWNocm9tZS8uL3NyYy9zY3JpcHRzL3BvcHVwL3BvcHVwX2V4dGVuc2lvbi50cyIsIndlYnBhY2s6Ly9wYXBlcmN1dC1tb2JpbGl0eS1jaHJvbWUvLi9zcmMvc2NyaXB0cy9jb250cm9sL2xvZ2luLnRzIiwid2VicGFjazovL3BhcGVyY3V0LW1vYmlsaXR5LWNocm9tZS8uL3NyYy9zY3JpcHRzL2NvbnRyb2wvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vcGFwZXJjdXQtbW9iaWxpdHktY2hyb21lLy4vc3JjL3NjcmlwdHMvcHJpbnRkZXBsb3kvcHJpbnRkZXBsb3kudHlwZXMudHMiLCJ3ZWJwYWNrOi8vcGFwZXJjdXQtbW9iaWxpdHktY2hyb21lLy4vc3JjL3NjcmlwdHMvcHJpbnRkZXBsb3kvY2xpZW50L2VuY3J5cHRpb24udHMiLCJ3ZWJwYWNrOi8vcGFwZXJjdXQtbW9iaWxpdHktY2hyb21lLy4vc3JjL3NjcmlwdHMvcHJpbnRkZXBsb3kvY2xpZW50L2NsaWVudC50cyIsIndlYnBhY2s6Ly9wYXBlcmN1dC1tb2JpbGl0eS1jaHJvbWUvLi9zcmMvc2NyaXB0cy9jaHJvbWUvcnVudGltZS50cyIsIndlYnBhY2s6Ly9wYXBlcmN1dC1tb2JpbGl0eS1jaHJvbWUvLi9zcmMvc2NyaXB0cy9jaHJvbWUvbmV0d29yay9uZXR3b3JrX2V4dGVuc2lvbi50cyIsIndlYnBhY2s6Ly9wYXBlcmN1dC1tb2JpbGl0eS1jaHJvbWUvLi9zcmMvc2NyaXB0cy9wcmludGRlcGxveS9jbGllbnQvY2xpZW50aW5mby50cyIsIndlYnBhY2s6Ly9wYXBlcmN1dC1tb2JpbGl0eS1jaHJvbWUvLi9zcmMvc2NyaXB0cy9wcmludGRlcGxveS9jbGllbnQvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vcGFwZXJjdXQtbW9iaWxpdHktY2hyb21lLy4vc3JjL3NjcmlwdHMvcHJpbnRkZXBsb3kvc3RvcmFnZS50cyIsIndlYnBhY2s6Ly9wYXBlcmN1dC1tb2JpbGl0eS1jaHJvbWUvLi9zcmMvc2NyaXB0cy9wcmludGRlcGxveS9wcmludGRlcGxveS50cyIsIndlYnBhY2s6Ly9wYXBlcmN1dC1tb2JpbGl0eS1jaHJvbWUvLi9zcmMvc2NyaXB0cy9wcmludGRlcGxveS9pbmRleC50cyIsIndlYnBhY2s6Ly9wYXBlcmN1dC1tb2JpbGl0eS1jaHJvbWUvLi9zcmMvc2NyaXB0cy93aW5kb3cvd2luZG93LnRzIiwid2VicGFjazovL3BhcGVyY3V0LW1vYmlsaXR5LWNocm9tZS8uL3NyYy9zY3JpcHRzL2ludGVybmF0aW9uYWxpemF0aW9uLmpzIiwid2VicGFjazovL3BhcGVyY3V0LW1vYmlsaXR5LWNocm9tZS8uL3NyYy9zY3JpcHRzL2xvZ2luL2xvZ2luLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogalF1ZXJ5IFZhbGlkYXRpb24gUGx1Z2luIHYxLjIwLjBcbiAqXG4gKiBodHRwczovL2pxdWVyeXZhbGlkYXRpb24ub3JnL1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAyMyBKw7ZybiBaYWVmZmVyZXJcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG4oZnVuY3Rpb24oIGZhY3RvcnkgKSB7XG5cdGlmICggdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQgKSB7XG5cdFx0ZGVmaW5lKCBbXCJqcXVlcnlcIl0sIGZhY3RvcnkgKTtcblx0fSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIG1vZHVsZS5leHBvcnRzKSB7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCByZXF1aXJlKCBcImpxdWVyeVwiICkgKTtcblx0fSBlbHNlIHtcblx0XHRmYWN0b3J5KCBqUXVlcnkgKTtcblx0fVxufShmdW5jdGlvbiggJCApIHtcblxuJC5leHRlbmQoICQuZm4sIHtcblxuXHQvLyBodHRwczovL2pxdWVyeXZhbGlkYXRpb24ub3JnL3ZhbGlkYXRlL1xuXHR2YWxpZGF0ZTogZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cblx0XHQvLyBJZiBub3RoaW5nIGlzIHNlbGVjdGVkLCByZXR1cm4gbm90aGluZzsgY2FuJ3QgY2hhaW4gYW55d2F5XG5cdFx0aWYgKCAhdGhpcy5sZW5ndGggKSB7XG5cdFx0XHRpZiAoIG9wdGlvbnMgJiYgb3B0aW9ucy5kZWJ1ZyAmJiB3aW5kb3cuY29uc29sZSApIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCBcIk5vdGhpbmcgc2VsZWN0ZWQsIGNhbid0IHZhbGlkYXRlLCByZXR1cm5pbmcgbm90aGluZy5cIiApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIENoZWNrIGlmIGEgdmFsaWRhdG9yIGZvciB0aGlzIGZvcm0gd2FzIGFscmVhZHkgY3JlYXRlZFxuXHRcdHZhciB2YWxpZGF0b3IgPSAkLmRhdGEoIHRoaXNbIDAgXSwgXCJ2YWxpZGF0b3JcIiApO1xuXHRcdGlmICggdmFsaWRhdG9yICkge1xuXHRcdFx0cmV0dXJuIHZhbGlkYXRvcjtcblx0XHR9XG5cblx0XHQvLyBBZGQgbm92YWxpZGF0ZSB0YWcgaWYgSFRNTDUuXG5cdFx0dGhpcy5hdHRyKCBcIm5vdmFsaWRhdGVcIiwgXCJub3ZhbGlkYXRlXCIgKTtcblxuXHRcdHZhbGlkYXRvciA9IG5ldyAkLnZhbGlkYXRvciggb3B0aW9ucywgdGhpc1sgMCBdICk7XG5cdFx0JC5kYXRhKCB0aGlzWyAwIF0sIFwidmFsaWRhdG9yXCIsIHZhbGlkYXRvciApO1xuXG5cdFx0aWYgKCB2YWxpZGF0b3Iuc2V0dGluZ3Mub25zdWJtaXQgKSB7XG5cblx0XHRcdHRoaXMub24oIFwiY2xpY2sudmFsaWRhdGVcIiwgXCI6c3VibWl0XCIsIGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdFx0XHQvLyBUcmFjayB0aGUgdXNlZCBzdWJtaXQgYnV0dG9uIHRvIHByb3Blcmx5IGhhbmRsZSBzY3JpcHRlZFxuXHRcdFx0XHQvLyBzdWJtaXRzIGxhdGVyLlxuXHRcdFx0XHR2YWxpZGF0b3Iuc3VibWl0QnV0dG9uID0gZXZlbnQuY3VycmVudFRhcmdldDtcblxuXHRcdFx0XHQvLyBBbGxvdyBzdXBwcmVzc2luZyB2YWxpZGF0aW9uIGJ5IGFkZGluZyBhIGNhbmNlbCBjbGFzcyB0byB0aGUgc3VibWl0IGJ1dHRvblxuXHRcdFx0XHRpZiAoICQoIHRoaXMgKS5oYXNDbGFzcyggXCJjYW5jZWxcIiApICkge1xuXHRcdFx0XHRcdHZhbGlkYXRvci5jYW5jZWxTdWJtaXQgPSB0cnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQWxsb3cgc3VwcHJlc3NpbmcgdmFsaWRhdGlvbiBieSBhZGRpbmcgdGhlIGh0bWw1IGZvcm1ub3ZhbGlkYXRlIGF0dHJpYnV0ZSB0byB0aGUgc3VibWl0IGJ1dHRvblxuXHRcdFx0XHRpZiAoICQoIHRoaXMgKS5hdHRyKCBcImZvcm1ub3ZhbGlkYXRlXCIgKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHZhbGlkYXRvci5jYW5jZWxTdWJtaXQgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cblx0XHRcdC8vIFZhbGlkYXRlIHRoZSBmb3JtIG9uIHN1Ym1pdFxuXHRcdFx0dGhpcy5vbiggXCJzdWJtaXQudmFsaWRhdGVcIiwgZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRpZiAoIHZhbGlkYXRvci5zZXR0aW5ncy5kZWJ1ZyApIHtcblxuXHRcdFx0XHRcdC8vIFByZXZlbnQgZm9ybSBzdWJtaXQgdG8gYmUgYWJsZSB0byBzZWUgY29uc29sZSBvdXRwdXRcblx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZnVuY3Rpb24gaGFuZGxlKCkge1xuXHRcdFx0XHRcdHZhciBoaWRkZW4sIHJlc3VsdDtcblxuXHRcdFx0XHRcdC8vIEluc2VydCBhIGhpZGRlbiBpbnB1dCBhcyBhIHJlcGxhY2VtZW50IGZvciB0aGUgbWlzc2luZyBzdWJtaXQgYnV0dG9uXG5cdFx0XHRcdFx0Ly8gVGhlIGhpZGRlbiBpbnB1dCBpcyBpbnNlcnRlZCBpbiB0d28gY2FzZXM6XG5cdFx0XHRcdFx0Ly8gICAtIEEgdXNlciBkZWZpbmVkIGEgYHN1Ym1pdEhhbmRsZXJgXG5cdFx0XHRcdFx0Ly8gICAtIFRoZXJlIHdhcyBhIHBlbmRpbmcgcmVxdWVzdCBkdWUgdG8gYHJlbW90ZWAgbWV0aG9kIGFuZCBgc3RvcFJlcXVlc3QoKWBcblx0XHRcdFx0XHQvLyAgICAgd2FzIGNhbGxlZCB0byBzdWJtaXQgdGhlIGZvcm0gaW4gY2FzZSBpdCdzIHZhbGlkXG5cdFx0XHRcdFx0aWYgKCB2YWxpZGF0b3Iuc3VibWl0QnV0dG9uICYmICggdmFsaWRhdG9yLnNldHRpbmdzLnN1Ym1pdEhhbmRsZXIgfHwgdmFsaWRhdG9yLmZvcm1TdWJtaXR0ZWQgKSApIHtcblx0XHRcdFx0XHRcdGhpZGRlbiA9ICQoIFwiPGlucHV0IHR5cGU9J2hpZGRlbicvPlwiIClcblx0XHRcdFx0XHRcdFx0LmF0dHIoIFwibmFtZVwiLCB2YWxpZGF0b3Iuc3VibWl0QnV0dG9uLm5hbWUgKVxuXHRcdFx0XHRcdFx0XHQudmFsKCAkKCB2YWxpZGF0b3Iuc3VibWl0QnV0dG9uICkudmFsKCkgKVxuXHRcdFx0XHRcdFx0XHQuYXBwZW5kVG8oIHZhbGlkYXRvci5jdXJyZW50Rm9ybSApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggdmFsaWRhdG9yLnNldHRpbmdzLnN1Ym1pdEhhbmRsZXIgJiYgIXZhbGlkYXRvci5zZXR0aW5ncy5kZWJ1ZyApIHtcblx0XHRcdFx0XHRcdHJlc3VsdCA9IHZhbGlkYXRvci5zZXR0aW5ncy5zdWJtaXRIYW5kbGVyLmNhbGwoIHZhbGlkYXRvciwgdmFsaWRhdG9yLmN1cnJlbnRGb3JtLCBldmVudCApO1xuXHRcdFx0XHRcdFx0aWYgKCBoaWRkZW4gKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQW5kIGNsZWFuIHVwIGFmdGVyd2FyZHM7IHRoYW5rcyB0byBuby1ibG9jay1zY29wZSwgaGlkZGVuIGNhbiBiZSByZWZlcmVuY2VkXG5cdFx0XHRcdFx0XHRcdGhpZGRlbi5yZW1vdmUoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICggcmVzdWx0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUHJldmVudCBzdWJtaXQgZm9yIGludmFsaWQgZm9ybXMgb3IgY3VzdG9tIHN1Ym1pdCBoYW5kbGVyc1xuXHRcdFx0XHRpZiAoIHZhbGlkYXRvci5jYW5jZWxTdWJtaXQgKSB7XG5cdFx0XHRcdFx0dmFsaWRhdG9yLmNhbmNlbFN1Ym1pdCA9IGZhbHNlO1xuXHRcdFx0XHRcdHJldHVybiBoYW5kbGUoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIHZhbGlkYXRvci5mb3JtKCkgKSB7XG5cdFx0XHRcdFx0aWYgKCB2YWxpZGF0b3IucGVuZGluZ1JlcXVlc3QgKSB7XG5cdFx0XHRcdFx0XHR2YWxpZGF0b3IuZm9ybVN1Ym1pdHRlZCA9IHRydWU7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBoYW5kbGUoKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2YWxpZGF0b3IuZm9jdXNJbnZhbGlkKCk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZhbGlkYXRvcjtcblx0fSxcblxuXHQvLyBodHRwczovL2pxdWVyeXZhbGlkYXRpb24ub3JnL3ZhbGlkL1xuXHR2YWxpZDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHZhbGlkLCB2YWxpZGF0b3IsIGVycm9yTGlzdDtcblxuXHRcdGlmICggJCggdGhpc1sgMCBdICkuaXMoIFwiZm9ybVwiICkgKSB7XG5cdFx0XHR2YWxpZCA9IHRoaXMudmFsaWRhdGUoKS5mb3JtKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGVycm9yTGlzdCA9IFtdO1xuXHRcdFx0dmFsaWQgPSB0cnVlO1xuXHRcdFx0dmFsaWRhdG9yID0gJCggdGhpc1sgMCBdLmZvcm0gKS52YWxpZGF0ZSgpO1xuXHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFsaWQgPSB2YWxpZGF0b3IuZWxlbWVudCggdGhpcyApICYmIHZhbGlkO1xuXHRcdFx0XHRpZiAoICF2YWxpZCApIHtcblx0XHRcdFx0XHRlcnJvckxpc3QgPSBlcnJvckxpc3QuY29uY2F0KCB2YWxpZGF0b3IuZXJyb3JMaXN0ICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHRcdHZhbGlkYXRvci5lcnJvckxpc3QgPSBlcnJvckxpc3Q7XG5cdFx0fVxuXHRcdHJldHVybiB2YWxpZDtcblx0fSxcblxuXHQvLyBodHRwczovL2pxdWVyeXZhbGlkYXRpb24ub3JnL3J1bGVzL1xuXHRydWxlczogZnVuY3Rpb24oIGNvbW1hbmQsIGFyZ3VtZW50ICkge1xuXHRcdHZhciBlbGVtZW50ID0gdGhpc1sgMCBdLFxuXHRcdFx0aXNDb250ZW50RWRpdGFibGUgPSB0eXBlb2YgdGhpcy5hdHRyKCBcImNvbnRlbnRlZGl0YWJsZVwiICkgIT09IFwidW5kZWZpbmVkXCIgJiYgdGhpcy5hdHRyKCBcImNvbnRlbnRlZGl0YWJsZVwiICkgIT09IFwiZmFsc2VcIixcblx0XHRcdHNldHRpbmdzLCBzdGF0aWNSdWxlcywgZXhpc3RpbmdSdWxlcywgZGF0YSwgcGFyYW0sIGZpbHRlcmVkO1xuXG5cdFx0Ly8gSWYgbm90aGluZyBpcyBzZWxlY3RlZCwgcmV0dXJuIGVtcHR5IG9iamVjdDsgY2FuJ3QgY2hhaW4gYW55d2F5XG5cdFx0aWYgKCBlbGVtZW50ID09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCAhZWxlbWVudC5mb3JtICYmIGlzQ29udGVudEVkaXRhYmxlICkge1xuXHRcdFx0ZWxlbWVudC5mb3JtID0gdGhpcy5jbG9zZXN0KCBcImZvcm1cIiApWyAwIF07XG5cdFx0XHRlbGVtZW50Lm5hbWUgPSB0aGlzLmF0dHIoIFwibmFtZVwiICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBlbGVtZW50LmZvcm0gPT0gbnVsbCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIGNvbW1hbmQgKSB7XG5cdFx0XHRzZXR0aW5ncyA9ICQuZGF0YSggZWxlbWVudC5mb3JtLCBcInZhbGlkYXRvclwiICkuc2V0dGluZ3M7XG5cdFx0XHRzdGF0aWNSdWxlcyA9IHNldHRpbmdzLnJ1bGVzO1xuXHRcdFx0ZXhpc3RpbmdSdWxlcyA9ICQudmFsaWRhdG9yLnN0YXRpY1J1bGVzKCBlbGVtZW50ICk7XG5cdFx0XHRzd2l0Y2ggKCBjb21tYW5kICkge1xuXHRcdFx0Y2FzZSBcImFkZFwiOlxuXHRcdFx0XHQkLmV4dGVuZCggZXhpc3RpbmdSdWxlcywgJC52YWxpZGF0b3Iubm9ybWFsaXplUnVsZSggYXJndW1lbnQgKSApO1xuXG5cdFx0XHRcdC8vIFJlbW92ZSBtZXNzYWdlcyBmcm9tIHJ1bGVzLCBidXQgYWxsb3cgdGhlbSB0byBiZSBzZXQgc2VwYXJhdGVseVxuXHRcdFx0XHRkZWxldGUgZXhpc3RpbmdSdWxlcy5tZXNzYWdlcztcblx0XHRcdFx0c3RhdGljUnVsZXNbIGVsZW1lbnQubmFtZSBdID0gZXhpc3RpbmdSdWxlcztcblx0XHRcdFx0aWYgKCBhcmd1bWVudC5tZXNzYWdlcyApIHtcblx0XHRcdFx0XHRzZXR0aW5ncy5tZXNzYWdlc1sgZWxlbWVudC5uYW1lIF0gPSAkLmV4dGVuZCggc2V0dGluZ3MubWVzc2FnZXNbIGVsZW1lbnQubmFtZSBdLCBhcmd1bWVudC5tZXNzYWdlcyApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBcInJlbW92ZVwiOlxuXHRcdFx0XHRpZiAoICFhcmd1bWVudCApIHtcblx0XHRcdFx0XHRkZWxldGUgc3RhdGljUnVsZXNbIGVsZW1lbnQubmFtZSBdO1xuXHRcdFx0XHRcdHJldHVybiBleGlzdGluZ1J1bGVzO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZpbHRlcmVkID0ge307XG5cdFx0XHRcdCQuZWFjaCggYXJndW1lbnQuc3BsaXQoIC9cXHMvICksIGZ1bmN0aW9uKCBpbmRleCwgbWV0aG9kICkge1xuXHRcdFx0XHRcdGZpbHRlcmVkWyBtZXRob2QgXSA9IGV4aXN0aW5nUnVsZXNbIG1ldGhvZCBdO1xuXHRcdFx0XHRcdGRlbGV0ZSBleGlzdGluZ1J1bGVzWyBtZXRob2QgXTtcblx0XHRcdFx0fSApO1xuXHRcdFx0XHRyZXR1cm4gZmlsdGVyZWQ7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZGF0YSA9ICQudmFsaWRhdG9yLm5vcm1hbGl6ZVJ1bGVzKFxuXHRcdCQuZXh0ZW5kKFxuXHRcdFx0e30sXG5cdFx0XHQkLnZhbGlkYXRvci5jbGFzc1J1bGVzKCBlbGVtZW50ICksXG5cdFx0XHQkLnZhbGlkYXRvci5hdHRyaWJ1dGVSdWxlcyggZWxlbWVudCApLFxuXHRcdFx0JC52YWxpZGF0b3IuZGF0YVJ1bGVzKCBlbGVtZW50ICksXG5cdFx0XHQkLnZhbGlkYXRvci5zdGF0aWNSdWxlcyggZWxlbWVudCApXG5cdFx0KSwgZWxlbWVudCApO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIHJlcXVpcmVkIGlzIGF0IGZyb250XG5cdFx0aWYgKCBkYXRhLnJlcXVpcmVkICkge1xuXHRcdFx0cGFyYW0gPSBkYXRhLnJlcXVpcmVkO1xuXHRcdFx0ZGVsZXRlIGRhdGEucmVxdWlyZWQ7XG5cdFx0XHRkYXRhID0gJC5leHRlbmQoIHsgcmVxdWlyZWQ6IHBhcmFtIH0sIGRhdGEgKTtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgcmVtb3RlIGlzIGF0IGJhY2tcblx0XHRpZiAoIGRhdGEucmVtb3RlICkge1xuXHRcdFx0cGFyYW0gPSBkYXRhLnJlbW90ZTtcblx0XHRcdGRlbGV0ZSBkYXRhLnJlbW90ZTtcblx0XHRcdGRhdGEgPSAkLmV4dGVuZCggZGF0YSwgeyByZW1vdGU6IHBhcmFtIH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZGF0YTtcblx0fVxufSApO1xuXG4vLyBKUXVlcnkgdHJpbSBpcyBkZXByZWNhdGVkLCBwcm92aWRlIGEgdHJpbSBtZXRob2QgYmFzZWQgb24gU3RyaW5nLnByb3RvdHlwZS50cmltXG52YXIgdHJpbSA9IGZ1bmN0aW9uKCBzdHIgKSB7XG5cblx0Ly8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL3RyaW0jUG9seWZpbGxcblx0cmV0dXJuIHN0ci5yZXBsYWNlKCAvXltcXHNcXHVGRUZGXFx4QTBdK3xbXFxzXFx1RkVGRlxceEEwXSskL2csIFwiXCIgKTtcbn07XG5cbi8vIEN1c3RvbSBzZWxlY3RvcnNcbiQuZXh0ZW5kKCAkLmV4cHIucHNldWRvcyB8fCAkLmV4cHJbIFwiOlwiIF0sIHtcdFx0Ly8gJ3x8ICQuZXhwclsgXCI6XCIgXScgaGVyZSBlbmFibGVzIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHRvIGpRdWVyeSAxLjcuIENhbiBiZSByZW1vdmVkIHdoZW4gZHJvcHBpbmcgalEgMS43Lnggc3VwcG9ydFxuXG5cdC8vIGh0dHBzOi8vanF1ZXJ5dmFsaWRhdGlvbi5vcmcvYmxhbmstc2VsZWN0b3IvXG5cdGJsYW5rOiBmdW5jdGlvbiggYSApIHtcblx0XHRyZXR1cm4gIXRyaW0oIFwiXCIgKyAkKCBhICkudmFsKCkgKTtcblx0fSxcblxuXHQvLyBodHRwczovL2pxdWVyeXZhbGlkYXRpb24ub3JnL2ZpbGxlZC1zZWxlY3Rvci9cblx0ZmlsbGVkOiBmdW5jdGlvbiggYSApIHtcblx0XHR2YXIgdmFsID0gJCggYSApLnZhbCgpO1xuXHRcdHJldHVybiB2YWwgIT09IG51bGwgJiYgISF0cmltKCBcIlwiICsgdmFsICk7XG5cdH0sXG5cblx0Ly8gaHR0cHM6Ly9qcXVlcnl2YWxpZGF0aW9uLm9yZy91bmNoZWNrZWQtc2VsZWN0b3IvXG5cdHVuY2hlY2tlZDogZnVuY3Rpb24oIGEgKSB7XG5cdFx0cmV0dXJuICEkKCBhICkucHJvcCggXCJjaGVja2VkXCIgKTtcblx0fVxufSApO1xuXG4vLyBDb25zdHJ1Y3RvciBmb3IgdmFsaWRhdG9yXG4kLnZhbGlkYXRvciA9IGZ1bmN0aW9uKCBvcHRpb25zLCBmb3JtICkge1xuXHR0aGlzLnNldHRpbmdzID0gJC5leHRlbmQoIHRydWUsIHt9LCAkLnZhbGlkYXRvci5kZWZhdWx0cywgb3B0aW9ucyApO1xuXHR0aGlzLmN1cnJlbnRGb3JtID0gZm9ybTtcblx0dGhpcy5pbml0KCk7XG59O1xuXG4vLyBodHRwczovL2pxdWVyeXZhbGlkYXRpb24ub3JnL2pRdWVyeS52YWxpZGF0b3IuZm9ybWF0L1xuJC52YWxpZGF0b3IuZm9ybWF0ID0gZnVuY3Rpb24oIHNvdXJjZSwgcGFyYW1zICkge1xuXHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGFyZ3MgPSAkLm1ha2VBcnJheSggYXJndW1lbnRzICk7XG5cdFx0XHRhcmdzLnVuc2hpZnQoIHNvdXJjZSApO1xuXHRcdFx0cmV0dXJuICQudmFsaWRhdG9yLmZvcm1hdC5hcHBseSggdGhpcywgYXJncyApO1xuXHRcdH07XG5cdH1cblx0aWYgKCBwYXJhbXMgPT09IHVuZGVmaW5lZCApIHtcblx0XHRyZXR1cm4gc291cmNlO1xuXHR9XG5cdGlmICggYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgcGFyYW1zLmNvbnN0cnVjdG9yICE9PSBBcnJheSAgKSB7XG5cdFx0cGFyYW1zID0gJC5tYWtlQXJyYXkoIGFyZ3VtZW50cyApLnNsaWNlKCAxICk7XG5cdH1cblx0aWYgKCBwYXJhbXMuY29uc3RydWN0b3IgIT09IEFycmF5ICkge1xuXHRcdHBhcmFtcyA9IFsgcGFyYW1zIF07XG5cdH1cblx0JC5lYWNoKCBwYXJhbXMsIGZ1bmN0aW9uKCBpLCBuICkge1xuXHRcdHNvdXJjZSA9IHNvdXJjZS5yZXBsYWNlKCBuZXcgUmVnRXhwKCBcIlxcXFx7XCIgKyBpICsgXCJcXFxcfVwiLCBcImdcIiApLCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBuO1xuXHRcdH0gKTtcblx0fSApO1xuXHRyZXR1cm4gc291cmNlO1xufTtcblxuJC5leHRlbmQoICQudmFsaWRhdG9yLCB7XG5cblx0ZGVmYXVsdHM6IHtcblx0XHRtZXNzYWdlczoge30sXG5cdFx0Z3JvdXBzOiB7fSxcblx0XHRydWxlczoge30sXG5cdFx0ZXJyb3JDbGFzczogXCJlcnJvclwiLFxuXHRcdHBlbmRpbmdDbGFzczogXCJwZW5kaW5nXCIsXG5cdFx0dmFsaWRDbGFzczogXCJ2YWxpZFwiLFxuXHRcdGVycm9yRWxlbWVudDogXCJsYWJlbFwiLFxuXHRcdGZvY3VzQ2xlYW51cDogZmFsc2UsXG5cdFx0Zm9jdXNJbnZhbGlkOiB0cnVlLFxuXHRcdGVycm9yQ29udGFpbmVyOiAkKCBbXSApLFxuXHRcdGVycm9yTGFiZWxDb250YWluZXI6ICQoIFtdICksXG5cdFx0b25zdWJtaXQ6IHRydWUsXG5cdFx0aWdub3JlOiBcIjpoaWRkZW5cIixcblx0XHRpZ25vcmVUaXRsZTogZmFsc2UsXG5cdFx0b25mb2N1c2luOiBmdW5jdGlvbiggZWxlbWVudCApIHtcblx0XHRcdHRoaXMubGFzdEFjdGl2ZSA9IGVsZW1lbnQ7XG5cblx0XHRcdC8vIEhpZGUgZXJyb3IgbGFiZWwgYW5kIHJlbW92ZSBlcnJvciBjbGFzcyBvbiBmb2N1cyBpZiBlbmFibGVkXG5cdFx0XHRpZiAoIHRoaXMuc2V0dGluZ3MuZm9jdXNDbGVhbnVwICkge1xuXHRcdFx0XHRpZiAoIHRoaXMuc2V0dGluZ3MudW5oaWdobGlnaHQgKSB7XG5cdFx0XHRcdFx0dGhpcy5zZXR0aW5ncy51bmhpZ2hsaWdodC5jYWxsKCB0aGlzLCBlbGVtZW50LCB0aGlzLnNldHRpbmdzLmVycm9yQ2xhc3MsIHRoaXMuc2V0dGluZ3MudmFsaWRDbGFzcyApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuaGlkZVRoZXNlKCB0aGlzLmVycm9yc0ZvciggZWxlbWVudCApICk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRvbmZvY3Vzb3V0OiBmdW5jdGlvbiggZWxlbWVudCApIHtcblx0XHRcdGlmICggIXRoaXMuY2hlY2thYmxlKCBlbGVtZW50ICkgJiYgKCBlbGVtZW50Lm5hbWUgaW4gdGhpcy5zdWJtaXR0ZWQgfHwgIXRoaXMub3B0aW9uYWwoIGVsZW1lbnQgKSApICkge1xuXHRcdFx0XHR0aGlzLmVsZW1lbnQoIGVsZW1lbnQgKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdG9ua2V5dXA6IGZ1bmN0aW9uKCBlbGVtZW50LCBldmVudCApIHtcblxuXHRcdFx0Ly8gQXZvaWQgcmV2YWxpZGF0ZSB0aGUgZmllbGQgd2hlbiBwcmVzc2luZyBvbmUgb2YgdGhlIGZvbGxvd2luZyBrZXlzXG5cdFx0XHQvLyBTaGlmdCAgICAgICA9PiAxNlxuXHRcdFx0Ly8gQ3RybCAgICAgICAgPT4gMTdcblx0XHRcdC8vIEFsdCAgICAgICAgID0+IDE4XG5cdFx0XHQvLyBDYXBzIGxvY2sgICA9PiAyMFxuXHRcdFx0Ly8gRW5kICAgICAgICAgPT4gMzVcblx0XHRcdC8vIEhvbWUgICAgICAgID0+IDM2XG5cdFx0XHQvLyBMZWZ0IGFycm93ICA9PiAzN1xuXHRcdFx0Ly8gVXAgYXJyb3cgICAgPT4gMzhcblx0XHRcdC8vIFJpZ2h0IGFycm93ID0+IDM5XG5cdFx0XHQvLyBEb3duIGFycm93ICA9PiA0MFxuXHRcdFx0Ly8gSW5zZXJ0ICAgICAgPT4gNDVcblx0XHRcdC8vIE51bSBsb2NrICAgID0+IDE0NFxuXHRcdFx0Ly8gQWx0R3Iga2V5ICAgPT4gMjI1XG5cdFx0XHR2YXIgZXhjbHVkZWRLZXlzID0gW1xuXHRcdFx0XHQxNiwgMTcsIDE4LCAyMCwgMzUsIDM2LCAzNyxcblx0XHRcdFx0MzgsIDM5LCA0MCwgNDUsIDE0NCwgMjI1XG5cdFx0XHRdO1xuXG5cdFx0XHRpZiAoIGV2ZW50LndoaWNoID09PSA5ICYmIHRoaXMuZWxlbWVudFZhbHVlKCBlbGVtZW50ICkgPT09IFwiXCIgfHwgJC5pbkFycmF5KCBldmVudC5rZXlDb2RlLCBleGNsdWRlZEtleXMgKSAhPT0gLTEgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH0gZWxzZSBpZiAoIGVsZW1lbnQubmFtZSBpbiB0aGlzLnN1Ym1pdHRlZCB8fCBlbGVtZW50Lm5hbWUgaW4gdGhpcy5pbnZhbGlkICkge1xuXHRcdFx0XHR0aGlzLmVsZW1lbnQoIGVsZW1lbnQgKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdG9uY2xpY2s6IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuXG5cdFx0XHQvLyBDbGljayBvbiBzZWxlY3RzLCByYWRpb2J1dHRvbnMgYW5kIGNoZWNrYm94ZXNcblx0XHRcdGlmICggZWxlbWVudC5uYW1lIGluIHRoaXMuc3VibWl0dGVkICkge1xuXHRcdFx0XHR0aGlzLmVsZW1lbnQoIGVsZW1lbnQgKTtcblxuXHRcdFx0Ly8gT3Igb3B0aW9uIGVsZW1lbnRzLCBjaGVjayBwYXJlbnQgc2VsZWN0IGluIHRoYXQgY2FzZVxuXHRcdFx0fSBlbHNlIGlmICggZWxlbWVudC5wYXJlbnROb2RlLm5hbWUgaW4gdGhpcy5zdWJtaXR0ZWQgKSB7XG5cdFx0XHRcdHRoaXMuZWxlbWVudCggZWxlbWVudC5wYXJlbnROb2RlICk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRoaWdobGlnaHQ6IGZ1bmN0aW9uKCBlbGVtZW50LCBlcnJvckNsYXNzLCB2YWxpZENsYXNzICkge1xuXHRcdFx0aWYgKCBlbGVtZW50LnR5cGUgPT09IFwicmFkaW9cIiApIHtcblx0XHRcdFx0dGhpcy5maW5kQnlOYW1lKCBlbGVtZW50Lm5hbWUgKS5hZGRDbGFzcyggZXJyb3JDbGFzcyApLnJlbW92ZUNsYXNzKCB2YWxpZENsYXNzICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQkKCBlbGVtZW50ICkuYWRkQ2xhc3MoIGVycm9yQ2xhc3MgKS5yZW1vdmVDbGFzcyggdmFsaWRDbGFzcyApO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0dW5oaWdobGlnaHQ6IGZ1bmN0aW9uKCBlbGVtZW50LCBlcnJvckNsYXNzLCB2YWxpZENsYXNzICkge1xuXHRcdFx0aWYgKCBlbGVtZW50LnR5cGUgPT09IFwicmFkaW9cIiApIHtcblx0XHRcdFx0dGhpcy5maW5kQnlOYW1lKCBlbGVtZW50Lm5hbWUgKS5yZW1vdmVDbGFzcyggZXJyb3JDbGFzcyApLmFkZENsYXNzKCB2YWxpZENsYXNzICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQkKCBlbGVtZW50ICkucmVtb3ZlQ2xhc3MoIGVycm9yQ2xhc3MgKS5hZGRDbGFzcyggdmFsaWRDbGFzcyApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvLyBodHRwczovL2pxdWVyeXZhbGlkYXRpb24ub3JnL2pRdWVyeS52YWxpZGF0b3Iuc2V0RGVmYXVsdHMvXG5cdHNldERlZmF1bHRzOiBmdW5jdGlvbiggc2V0dGluZ3MgKSB7XG5cdFx0JC5leHRlbmQoICQudmFsaWRhdG9yLmRlZmF1bHRzLCBzZXR0aW5ncyApO1xuXHR9LFxuXG5cdG1lc3NhZ2VzOiB7XG5cdFx0cmVxdWlyZWQ6IFwiVGhpcyBmaWVsZCBpcyByZXF1aXJlZC5cIixcblx0XHRyZW1vdGU6IFwiUGxlYXNlIGZpeCB0aGlzIGZpZWxkLlwiLFxuXHRcdGVtYWlsOiBcIlBsZWFzZSBlbnRlciBhIHZhbGlkIGVtYWlsIGFkZHJlc3MuXCIsXG5cdFx0dXJsOiBcIlBsZWFzZSBlbnRlciBhIHZhbGlkIFVSTC5cIixcblx0XHRkYXRlOiBcIlBsZWFzZSBlbnRlciBhIHZhbGlkIGRhdGUuXCIsXG5cdFx0ZGF0ZUlTTzogXCJQbGVhc2UgZW50ZXIgYSB2YWxpZCBkYXRlIChJU08pLlwiLFxuXHRcdG51bWJlcjogXCJQbGVhc2UgZW50ZXIgYSB2YWxpZCBudW1iZXIuXCIsXG5cdFx0ZGlnaXRzOiBcIlBsZWFzZSBlbnRlciBvbmx5IGRpZ2l0cy5cIixcblx0XHRlcXVhbFRvOiBcIlBsZWFzZSBlbnRlciB0aGUgc2FtZSB2YWx1ZSBhZ2Fpbi5cIixcblx0XHRtYXhsZW5ndGg6ICQudmFsaWRhdG9yLmZvcm1hdCggXCJQbGVhc2UgZW50ZXIgbm8gbW9yZSB0aGFuIHswfSBjaGFyYWN0ZXJzLlwiICksXG5cdFx0bWlubGVuZ3RoOiAkLnZhbGlkYXRvci5mb3JtYXQoIFwiUGxlYXNlIGVudGVyIGF0IGxlYXN0IHswfSBjaGFyYWN0ZXJzLlwiICksXG5cdFx0cmFuZ2VsZW5ndGg6ICQudmFsaWRhdG9yLmZvcm1hdCggXCJQbGVhc2UgZW50ZXIgYSB2YWx1ZSBiZXR3ZWVuIHswfSBhbmQgezF9IGNoYXJhY3RlcnMgbG9uZy5cIiApLFxuXHRcdHJhbmdlOiAkLnZhbGlkYXRvci5mb3JtYXQoIFwiUGxlYXNlIGVudGVyIGEgdmFsdWUgYmV0d2VlbiB7MH0gYW5kIHsxfS5cIiApLFxuXHRcdG1heDogJC52YWxpZGF0b3IuZm9ybWF0KCBcIlBsZWFzZSBlbnRlciBhIHZhbHVlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB7MH0uXCIgKSxcblx0XHRtaW46ICQudmFsaWRhdG9yLmZvcm1hdCggXCJQbGVhc2UgZW50ZXIgYSB2YWx1ZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gezB9LlwiICksXG5cdFx0c3RlcDogJC52YWxpZGF0b3IuZm9ybWF0KCBcIlBsZWFzZSBlbnRlciBhIG11bHRpcGxlIG9mIHswfS5cIiApXG5cdH0sXG5cblx0YXV0b0NyZWF0ZVJhbmdlczogZmFsc2UsXG5cblx0cHJvdG90eXBlOiB7XG5cblx0XHRpbml0OiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMubGFiZWxDb250YWluZXIgPSAkKCB0aGlzLnNldHRpbmdzLmVycm9yTGFiZWxDb250YWluZXIgKTtcblx0XHRcdHRoaXMuZXJyb3JDb250ZXh0ID0gdGhpcy5sYWJlbENvbnRhaW5lci5sZW5ndGggJiYgdGhpcy5sYWJlbENvbnRhaW5lciB8fCAkKCB0aGlzLmN1cnJlbnRGb3JtICk7XG5cdFx0XHR0aGlzLmNvbnRhaW5lcnMgPSAkKCB0aGlzLnNldHRpbmdzLmVycm9yQ29udGFpbmVyICkuYWRkKCB0aGlzLnNldHRpbmdzLmVycm9yTGFiZWxDb250YWluZXIgKTtcblx0XHRcdHRoaXMuc3VibWl0dGVkID0ge307XG5cdFx0XHR0aGlzLnZhbHVlQ2FjaGUgPSB7fTtcblx0XHRcdHRoaXMucGVuZGluZ1JlcXVlc3QgPSAwO1xuXHRcdFx0dGhpcy5wZW5kaW5nID0ge307XG5cdFx0XHR0aGlzLmludmFsaWQgPSB7fTtcblx0XHRcdHRoaXMucmVzZXQoKTtcblxuXHRcdFx0dmFyIGN1cnJlbnRGb3JtID0gdGhpcy5jdXJyZW50Rm9ybSxcblx0XHRcdFx0Z3JvdXBzID0gKCB0aGlzLmdyb3VwcyA9IHt9ICksXG5cdFx0XHRcdHJ1bGVzO1xuXHRcdFx0JC5lYWNoKCB0aGlzLnNldHRpbmdzLmdyb3VwcywgZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0XHRcdGlmICggdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0XHRcdHZhbHVlID0gdmFsdWUuc3BsaXQoIC9cXHMvICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0JC5lYWNoKCB2YWx1ZSwgZnVuY3Rpb24oIGluZGV4LCBuYW1lICkge1xuXHRcdFx0XHRcdGdyb3Vwc1sgbmFtZSBdID0ga2V5O1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9ICk7XG5cdFx0XHRydWxlcyA9IHRoaXMuc2V0dGluZ3MucnVsZXM7XG5cdFx0XHQkLmVhY2goIHJ1bGVzLCBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblx0XHRcdFx0cnVsZXNbIGtleSBdID0gJC52YWxpZGF0b3Iubm9ybWFsaXplUnVsZSggdmFsdWUgKTtcblx0XHRcdH0gKTtcblxuXHRcdFx0ZnVuY3Rpb24gZGVsZWdhdGUoIGV2ZW50ICkge1xuXHRcdFx0XHR2YXIgaXNDb250ZW50RWRpdGFibGUgPSB0eXBlb2YgJCggdGhpcyApLmF0dHIoIFwiY29udGVudGVkaXRhYmxlXCIgKSAhPT0gXCJ1bmRlZmluZWRcIiAmJiAkKCB0aGlzICkuYXR0ciggXCJjb250ZW50ZWRpdGFibGVcIiApICE9PSBcImZhbHNlXCI7XG5cblx0XHRcdFx0Ly8gU2V0IGZvcm0gZXhwYW5kbyBvbiBjb250ZW50ZWRpdGFibGVcblx0XHRcdFx0aWYgKCAhdGhpcy5mb3JtICYmIGlzQ29udGVudEVkaXRhYmxlICkge1xuXHRcdFx0XHRcdHRoaXMuZm9ybSA9ICQoIHRoaXMgKS5jbG9zZXN0KCBcImZvcm1cIiApWyAwIF07XG5cdFx0XHRcdFx0dGhpcy5uYW1lID0gJCggdGhpcyApLmF0dHIoIFwibmFtZVwiICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBJZ25vcmUgdGhlIGVsZW1lbnQgaWYgaXQgYmVsb25ncyB0byBhbm90aGVyIGZvcm0uIFRoaXMgd2lsbCBoYXBwZW4gbWFpbmx5XG5cdFx0XHRcdC8vIHdoZW4gc2V0dGluZyB0aGUgYGZvcm1gIGF0dHJpYnV0ZSBvZiBhbiBpbnB1dCB0byB0aGUgaWQgb2YgYW5vdGhlciBmb3JtLlxuXHRcdFx0XHRpZiAoIGN1cnJlbnRGb3JtICE9PSB0aGlzLmZvcm0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIHZhbGlkYXRvciA9ICQuZGF0YSggdGhpcy5mb3JtLCBcInZhbGlkYXRvclwiICksXG5cdFx0XHRcdFx0ZXZlbnRUeXBlID0gXCJvblwiICsgZXZlbnQudHlwZS5yZXBsYWNlKCAvXnZhbGlkYXRlLywgXCJcIiApLFxuXHRcdFx0XHRcdHNldHRpbmdzID0gdmFsaWRhdG9yLnNldHRpbmdzO1xuXHRcdFx0XHRpZiAoIHNldHRpbmdzWyBldmVudFR5cGUgXSAmJiAhJCggdGhpcyApLmlzKCBzZXR0aW5ncy5pZ25vcmUgKSApIHtcblx0XHRcdFx0XHRzZXR0aW5nc1sgZXZlbnRUeXBlIF0uY2FsbCggdmFsaWRhdG9yLCB0aGlzLCBldmVudCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdCQoIHRoaXMuY3VycmVudEZvcm0gKVxuXHRcdFx0XHQub24oIFwiZm9jdXNpbi52YWxpZGF0ZSBmb2N1c291dC52YWxpZGF0ZSBrZXl1cC52YWxpZGF0ZVwiLFxuXHRcdFx0XHRcdFwiOnRleHQsIFt0eXBlPSdwYXNzd29yZCddLCBbdHlwZT0nZmlsZSddLCBzZWxlY3QsIHRleHRhcmVhLCBbdHlwZT0nbnVtYmVyJ10sIFt0eXBlPSdzZWFyY2gnXSwgXCIgK1xuXHRcdFx0XHRcdFwiW3R5cGU9J3RlbCddLCBbdHlwZT0ndXJsJ10sIFt0eXBlPSdlbWFpbCddLCBbdHlwZT0nZGF0ZXRpbWUnXSwgW3R5cGU9J2RhdGUnXSwgW3R5cGU9J21vbnRoJ10sIFwiICtcblx0XHRcdFx0XHRcIlt0eXBlPSd3ZWVrJ10sIFt0eXBlPSd0aW1lJ10sIFt0eXBlPSdkYXRldGltZS1sb2NhbCddLCBbdHlwZT0ncmFuZ2UnXSwgW3R5cGU9J2NvbG9yJ10sIFwiICtcblx0XHRcdFx0XHRcIlt0eXBlPSdyYWRpbyddLCBbdHlwZT0nY2hlY2tib3gnXSwgW2NvbnRlbnRlZGl0YWJsZV0sIFt0eXBlPSdidXR0b24nXVwiLCBkZWxlZ2F0ZSApXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lLCBvbGRJRVxuXHRcdFx0XHQvLyBcInNlbGVjdFwiIGlzIHByb3ZpZGVkIGFzIGV2ZW50LnRhcmdldCB3aGVuIGNsaWNraW5nIGEgb3B0aW9uXG5cdFx0XHRcdC5vbiggXCJjbGljay52YWxpZGF0ZVwiLCBcInNlbGVjdCwgb3B0aW9uLCBbdHlwZT0ncmFkaW8nXSwgW3R5cGU9J2NoZWNrYm94J11cIiwgZGVsZWdhdGUgKTtcblxuXHRcdFx0aWYgKCB0aGlzLnNldHRpbmdzLmludmFsaWRIYW5kbGVyICkge1xuXHRcdFx0XHQkKCB0aGlzLmN1cnJlbnRGb3JtICkub24oIFwiaW52YWxpZC1mb3JtLnZhbGlkYXRlXCIsIHRoaXMuc2V0dGluZ3MuaW52YWxpZEhhbmRsZXIgKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Ly8gaHR0cHM6Ly9qcXVlcnl2YWxpZGF0aW9uLm9yZy9WYWxpZGF0b3IuZm9ybS9cblx0XHRmb3JtOiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuY2hlY2tGb3JtKCk7XG5cdFx0XHQkLmV4dGVuZCggdGhpcy5zdWJtaXR0ZWQsIHRoaXMuZXJyb3JNYXAgKTtcblx0XHRcdHRoaXMuaW52YWxpZCA9ICQuZXh0ZW5kKCB7fSwgdGhpcy5lcnJvck1hcCApO1xuXHRcdFx0aWYgKCAhdGhpcy52YWxpZCgpICkge1xuXHRcdFx0XHQkKCB0aGlzLmN1cnJlbnRGb3JtICkudHJpZ2dlckhhbmRsZXIoIFwiaW52YWxpZC1mb3JtXCIsIFsgdGhpcyBdICk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnNob3dFcnJvcnMoKTtcblx0XHRcdHJldHVybiB0aGlzLnZhbGlkKCk7XG5cdFx0fSxcblxuXHRcdGNoZWNrRm9ybTogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLnByZXBhcmVGb3JtKCk7XG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGVsZW1lbnRzID0gKCB0aGlzLmN1cnJlbnRFbGVtZW50cyA9IHRoaXMuZWxlbWVudHMoKSApOyBlbGVtZW50c1sgaSBdOyBpKysgKSB7XG5cdFx0XHRcdHRoaXMuY2hlY2soIGVsZW1lbnRzWyBpIF0gKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLnZhbGlkKCk7XG5cdFx0fSxcblxuXHRcdC8vIGh0dHBzOi8vanF1ZXJ5dmFsaWRhdGlvbi5vcmcvVmFsaWRhdG9yLmVsZW1lbnQvXG5cdFx0ZWxlbWVudDogZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG5cdFx0XHR2YXIgY2xlYW5FbGVtZW50ID0gdGhpcy5jbGVhbiggZWxlbWVudCApLFxuXHRcdFx0XHRjaGVja0VsZW1lbnQgPSB0aGlzLnZhbGlkYXRpb25UYXJnZXRGb3IoIGNsZWFuRWxlbWVudCApLFxuXHRcdFx0XHR2ID0gdGhpcyxcblx0XHRcdFx0cmVzdWx0ID0gdHJ1ZSxcblx0XHRcdFx0cnMsIGdyb3VwO1xuXG5cdFx0XHRpZiAoIGNoZWNrRWxlbWVudCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRkZWxldGUgdGhpcy5pbnZhbGlkWyBjbGVhbkVsZW1lbnQubmFtZSBdO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5wcmVwYXJlRWxlbWVudCggY2hlY2tFbGVtZW50ICk7XG5cdFx0XHRcdHRoaXMuY3VycmVudEVsZW1lbnRzID0gJCggY2hlY2tFbGVtZW50ICk7XG5cblx0XHRcdFx0Ly8gSWYgdGhpcyBlbGVtZW50IGlzIGdyb3VwZWQsIHRoZW4gdmFsaWRhdGUgYWxsIGdyb3VwIGVsZW1lbnRzIGFscmVhZHlcblx0XHRcdFx0Ly8gY29udGFpbmluZyBhIHZhbHVlXG5cdFx0XHRcdGdyb3VwID0gdGhpcy5ncm91cHNbIGNoZWNrRWxlbWVudC5uYW1lIF07XG5cdFx0XHRcdGlmICggZ3JvdXAgKSB7XG5cdFx0XHRcdFx0JC5lYWNoKCB0aGlzLmdyb3VwcywgZnVuY3Rpb24oIG5hbWUsIHRlc3Rncm91cCApIHtcblx0XHRcdFx0XHRcdGlmICggdGVzdGdyb3VwID09PSBncm91cCAmJiBuYW1lICE9PSBjaGVja0VsZW1lbnQubmFtZSApIHtcblx0XHRcdFx0XHRcdFx0Y2xlYW5FbGVtZW50ID0gdi52YWxpZGF0aW9uVGFyZ2V0Rm9yKCB2LmNsZWFuKCB2LmZpbmRCeU5hbWUoIG5hbWUgKSApICk7XG5cdFx0XHRcdFx0XHRcdGlmICggY2xlYW5FbGVtZW50ICYmIGNsZWFuRWxlbWVudC5uYW1lIGluIHYuaW52YWxpZCApIHtcblx0XHRcdFx0XHRcdFx0XHR2LmN1cnJlbnRFbGVtZW50cy5wdXNoKCBjbGVhbkVsZW1lbnQgKTtcblx0XHRcdFx0XHRcdFx0XHRyZXN1bHQgPSB2LmNoZWNrKCBjbGVhbkVsZW1lbnQgKSAmJiByZXN1bHQ7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRycyA9IHRoaXMuY2hlY2soIGNoZWNrRWxlbWVudCApICE9PSBmYWxzZTtcblx0XHRcdFx0cmVzdWx0ID0gcmVzdWx0ICYmIHJzO1xuXHRcdFx0XHRpZiAoIHJzICkge1xuXHRcdFx0XHRcdHRoaXMuaW52YWxpZFsgY2hlY2tFbGVtZW50Lm5hbWUgXSA9IGZhbHNlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuaW52YWxpZFsgY2hlY2tFbGVtZW50Lm5hbWUgXSA9IHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoICF0aGlzLm51bWJlck9mSW52YWxpZHMoKSApIHtcblxuXHRcdFx0XHRcdC8vIEhpZGUgZXJyb3IgY29udGFpbmVycyBvbiBsYXN0IGVycm9yXG5cdFx0XHRcdFx0dGhpcy50b0hpZGUgPSB0aGlzLnRvSGlkZS5hZGQoIHRoaXMuY29udGFpbmVycyApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuc2hvd0Vycm9ycygpO1xuXG5cdFx0XHRcdC8vIEFkZCBhcmlhLWludmFsaWQgc3RhdHVzIGZvciBzY3JlZW4gcmVhZGVyc1xuXHRcdFx0XHQkKCBlbGVtZW50ICkuYXR0ciggXCJhcmlhLWludmFsaWRcIiwgIXJzICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fSxcblxuXHRcdC8vIGh0dHBzOi8vanF1ZXJ5dmFsaWRhdGlvbi5vcmcvVmFsaWRhdG9yLnNob3dFcnJvcnMvXG5cdFx0c2hvd0Vycm9yczogZnVuY3Rpb24oIGVycm9ycyApIHtcblx0XHRcdGlmICggZXJyb3JzICkge1xuXHRcdFx0XHR2YXIgdmFsaWRhdG9yID0gdGhpcztcblxuXHRcdFx0XHQvLyBBZGQgaXRlbXMgdG8gZXJyb3IgbGlzdCBhbmQgbWFwXG5cdFx0XHRcdCQuZXh0ZW5kKCB0aGlzLmVycm9yTWFwLCBlcnJvcnMgKTtcblx0XHRcdFx0dGhpcy5lcnJvckxpc3QgPSAkLm1hcCggdGhpcy5lcnJvck1hcCwgZnVuY3Rpb24oIG1lc3NhZ2UsIG5hbWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdG1lc3NhZ2U6IG1lc3NhZ2UsXG5cdFx0XHRcdFx0XHRlbGVtZW50OiB2YWxpZGF0b3IuZmluZEJ5TmFtZSggbmFtZSApWyAwIF1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0Ly8gUmVtb3ZlIGl0ZW1zIGZyb20gc3VjY2VzcyBsaXN0XG5cdFx0XHRcdHRoaXMuc3VjY2Vzc0xpc3QgPSAkLmdyZXAoIHRoaXMuc3VjY2Vzc0xpc3QsIGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuXHRcdFx0XHRcdHJldHVybiAhKCBlbGVtZW50Lm5hbWUgaW4gZXJyb3JzICk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHRcdGlmICggdGhpcy5zZXR0aW5ncy5zaG93RXJyb3JzICkge1xuXHRcdFx0XHR0aGlzLnNldHRpbmdzLnNob3dFcnJvcnMuY2FsbCggdGhpcywgdGhpcy5lcnJvck1hcCwgdGhpcy5lcnJvckxpc3QgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuZGVmYXVsdFNob3dFcnJvcnMoKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Ly8gaHR0cHM6Ly9qcXVlcnl2YWxpZGF0aW9uLm9yZy9WYWxpZGF0b3IucmVzZXRGb3JtL1xuXHRcdHJlc2V0Rm9ybTogZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoICQuZm4ucmVzZXRGb3JtICkge1xuXHRcdFx0XHQkKCB0aGlzLmN1cnJlbnRGb3JtICkucmVzZXRGb3JtKCk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmludmFsaWQgPSB7fTtcblx0XHRcdHRoaXMuc3VibWl0dGVkID0ge307XG5cdFx0XHR0aGlzLnByZXBhcmVGb3JtKCk7XG5cdFx0XHR0aGlzLmhpZGVFcnJvcnMoKTtcblx0XHRcdHZhciBlbGVtZW50cyA9IHRoaXMuZWxlbWVudHMoKVxuXHRcdFx0XHQucmVtb3ZlRGF0YSggXCJwcmV2aW91c1ZhbHVlXCIgKVxuXHRcdFx0XHQucmVtb3ZlQXR0ciggXCJhcmlhLWludmFsaWRcIiApO1xuXG5cdFx0XHR0aGlzLnJlc2V0RWxlbWVudHMoIGVsZW1lbnRzICk7XG5cdFx0fSxcblxuXHRcdHJlc2V0RWxlbWVudHM6IGZ1bmN0aW9uKCBlbGVtZW50cyApIHtcblx0XHRcdHZhciBpO1xuXG5cdFx0XHRpZiAoIHRoaXMuc2V0dGluZ3MudW5oaWdobGlnaHQgKSB7XG5cdFx0XHRcdGZvciAoIGkgPSAwOyBlbGVtZW50c1sgaSBdOyBpKysgKSB7XG5cdFx0XHRcdFx0dGhpcy5zZXR0aW5ncy51bmhpZ2hsaWdodC5jYWxsKCB0aGlzLCBlbGVtZW50c1sgaSBdLFxuXHRcdFx0XHRcdFx0dGhpcy5zZXR0aW5ncy5lcnJvckNsYXNzLCBcIlwiICk7XG5cdFx0XHRcdFx0dGhpcy5maW5kQnlOYW1lKCBlbGVtZW50c1sgaSBdLm5hbWUgKS5yZW1vdmVDbGFzcyggdGhpcy5zZXR0aW5ncy52YWxpZENsYXNzICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1lbnRzXG5cdFx0XHRcdFx0LnJlbW92ZUNsYXNzKCB0aGlzLnNldHRpbmdzLmVycm9yQ2xhc3MgKVxuXHRcdFx0XHRcdC5yZW1vdmVDbGFzcyggdGhpcy5zZXR0aW5ncy52YWxpZENsYXNzICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdG51bWJlck9mSW52YWxpZHM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMub2JqZWN0TGVuZ3RoKCB0aGlzLmludmFsaWQgKTtcblx0XHR9LFxuXG5cdFx0b2JqZWN0TGVuZ3RoOiBmdW5jdGlvbiggb2JqICkge1xuXHRcdFx0LyoganNoaW50IHVudXNlZDogZmFsc2UgKi9cblx0XHRcdHZhciBjb3VudCA9IDAsXG5cdFx0XHRcdGk7XG5cdFx0XHRmb3IgKCBpIGluIG9iaiApIHtcblxuXHRcdFx0XHQvLyBUaGlzIGNoZWNrIGFsbG93cyBjb3VudGluZyBlbGVtZW50cyB3aXRoIGVtcHR5IGVycm9yXG5cdFx0XHRcdC8vIG1lc3NhZ2UgYXMgaW52YWxpZCBlbGVtZW50c1xuXHRcdFx0XHRpZiAoIG9ialsgaSBdICE9PSB1bmRlZmluZWQgJiYgb2JqWyBpIF0gIT09IG51bGwgJiYgb2JqWyBpIF0gIT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGNvdW50Kys7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBjb3VudDtcblx0XHR9LFxuXG5cdFx0aGlkZUVycm9yczogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLmhpZGVUaGVzZSggdGhpcy50b0hpZGUgKTtcblx0XHR9LFxuXG5cdFx0aGlkZVRoZXNlOiBmdW5jdGlvbiggZXJyb3JzICkge1xuXHRcdFx0ZXJyb3JzLm5vdCggdGhpcy5jb250YWluZXJzICkudGV4dCggXCJcIiApO1xuXHRcdFx0dGhpcy5hZGRXcmFwcGVyKCBlcnJvcnMgKS5oaWRlKCk7XG5cdFx0fSxcblxuXHRcdHZhbGlkOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLnNpemUoKSA9PT0gMDtcblx0XHR9LFxuXG5cdFx0c2l6ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lcnJvckxpc3QubGVuZ3RoO1xuXHRcdH0sXG5cblx0XHRmb2N1c0ludmFsaWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCB0aGlzLnNldHRpbmdzLmZvY3VzSW52YWxpZCApIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHQkKCB0aGlzLmZpbmRMYXN0QWN0aXZlKCkgfHwgdGhpcy5lcnJvckxpc3QubGVuZ3RoICYmIHRoaXMuZXJyb3JMaXN0WyAwIF0uZWxlbWVudCB8fCBbXSApXG5cdFx0XHRcdFx0LmZpbHRlciggXCI6dmlzaWJsZVwiIClcblx0XHRcdFx0XHQudHJpZ2dlciggXCJmb2N1c1wiIClcblxuXHRcdFx0XHRcdC8vIE1hbnVhbGx5IHRyaWdnZXIgZm9jdXNpbiBldmVudDsgd2l0aG91dCBpdCwgZm9jdXNpbiBoYW5kbGVyIGlzbid0IGNhbGxlZCwgZmluZExhc3RBY3RpdmUgd29uJ3QgaGF2ZSBhbnl0aGluZyB0byBmaW5kXG5cdFx0XHRcdFx0LnRyaWdnZXIoIFwiZm9jdXNpblwiICk7XG5cdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdFx0Ly8gSWdub3JlIElFIHRocm93aW5nIGVycm9ycyB3aGVuIGZvY3VzaW5nIGhpZGRlbiBlbGVtZW50c1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGZpbmRMYXN0QWN0aXZlOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBsYXN0QWN0aXZlID0gdGhpcy5sYXN0QWN0aXZlO1xuXHRcdFx0cmV0dXJuIGxhc3RBY3RpdmUgJiYgJC5ncmVwKCB0aGlzLmVycm9yTGlzdCwgZnVuY3Rpb24oIG4gKSB7XG5cdFx0XHRcdHJldHVybiBuLmVsZW1lbnQubmFtZSA9PT0gbGFzdEFjdGl2ZS5uYW1lO1xuXHRcdFx0fSApLmxlbmd0aCA9PT0gMSAmJiBsYXN0QWN0aXZlO1xuXHRcdH0sXG5cblx0XHRlbGVtZW50czogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdmFsaWRhdG9yID0gdGhpcyxcblx0XHRcdFx0cnVsZXNDYWNoZSA9IHt9O1xuXG5cdFx0XHQvLyBTZWxlY3QgYWxsIHZhbGlkIGlucHV0cyBpbnNpZGUgdGhlIGZvcm0gKG5vIHN1Ym1pdCBvciByZXNldCBidXR0b25zKVxuXHRcdFx0cmV0dXJuICQoIHRoaXMuY3VycmVudEZvcm0gKVxuXHRcdFx0LmZpbmQoIFwiaW5wdXQsIHNlbGVjdCwgdGV4dGFyZWEsIFtjb250ZW50ZWRpdGFibGVdXCIgKVxuXHRcdFx0Lm5vdCggXCI6c3VibWl0LCA6cmVzZXQsIDppbWFnZSwgOmRpc2FibGVkXCIgKVxuXHRcdFx0Lm5vdCggdGhpcy5zZXR0aW5ncy5pZ25vcmUgKVxuXHRcdFx0LmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBuYW1lID0gdGhpcy5uYW1lIHx8ICQoIHRoaXMgKS5hdHRyKCBcIm5hbWVcIiApOyAvLyBGb3IgY29udGVudGVkaXRhYmxlXG5cdFx0XHRcdHZhciBpc0NvbnRlbnRFZGl0YWJsZSA9IHR5cGVvZiAkKCB0aGlzICkuYXR0ciggXCJjb250ZW50ZWRpdGFibGVcIiApICE9PSBcInVuZGVmaW5lZFwiICYmICQoIHRoaXMgKS5hdHRyKCBcImNvbnRlbnRlZGl0YWJsZVwiICkgIT09IFwiZmFsc2VcIjtcblxuXHRcdFx0XHRpZiAoICFuYW1lICYmIHZhbGlkYXRvci5zZXR0aW5ncy5kZWJ1ZyAmJiB3aW5kb3cuY29uc29sZSApIHtcblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCBcIiVvIGhhcyBubyBuYW1lIGFzc2lnbmVkXCIsIHRoaXMgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFNldCBmb3JtIGV4cGFuZG8gb24gY29udGVudGVkaXRhYmxlXG5cdFx0XHRcdGlmICggaXNDb250ZW50RWRpdGFibGUgKSB7XG5cdFx0XHRcdFx0dGhpcy5mb3JtID0gJCggdGhpcyApLmNsb3Nlc3QoIFwiZm9ybVwiIClbIDAgXTtcblx0XHRcdFx0XHR0aGlzLm5hbWUgPSBuYW1lO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSWdub3JlIGVsZW1lbnRzIHRoYXQgYmVsb25nIHRvIG90aGVyL25lc3RlZCBmb3Jtc1xuXHRcdFx0XHRpZiAoIHRoaXMuZm9ybSAhPT0gdmFsaWRhdG9yLmN1cnJlbnRGb3JtICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFNlbGVjdCBvbmx5IHRoZSBmaXJzdCBlbGVtZW50IGZvciBlYWNoIG5hbWUsIGFuZCBvbmx5IHRob3NlIHdpdGggcnVsZXMgc3BlY2lmaWVkXG5cdFx0XHRcdGlmICggbmFtZSBpbiBydWxlc0NhY2hlIHx8ICF2YWxpZGF0b3Iub2JqZWN0TGVuZ3RoKCAkKCB0aGlzICkucnVsZXMoKSApICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJ1bGVzQ2FjaGVbIG5hbWUgXSA9IHRydWU7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fSApO1xuXHRcdH0sXG5cblx0XHRjbGVhbjogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdFx0cmV0dXJuICQoIHNlbGVjdG9yIClbIDAgXTtcblx0XHR9LFxuXG5cdFx0ZXJyb3JzOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBlcnJvckNsYXNzID0gdGhpcy5zZXR0aW5ncy5lcnJvckNsYXNzLnNwbGl0KCBcIiBcIiApLmpvaW4oIFwiLlwiICk7XG5cdFx0XHRyZXR1cm4gJCggdGhpcy5zZXR0aW5ncy5lcnJvckVsZW1lbnQgKyBcIi5cIiArIGVycm9yQ2xhc3MsIHRoaXMuZXJyb3JDb250ZXh0ICk7XG5cdFx0fSxcblxuXHRcdHJlc2V0SW50ZXJuYWxzOiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuc3VjY2Vzc0xpc3QgPSBbXTtcblx0XHRcdHRoaXMuZXJyb3JMaXN0ID0gW107XG5cdFx0XHR0aGlzLmVycm9yTWFwID0ge307XG5cdFx0XHR0aGlzLnRvU2hvdyA9ICQoIFtdICk7XG5cdFx0XHR0aGlzLnRvSGlkZSA9ICQoIFtdICk7XG5cdFx0fSxcblxuXHRcdHJlc2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMucmVzZXRJbnRlcm5hbHMoKTtcblx0XHRcdHRoaXMuY3VycmVudEVsZW1lbnRzID0gJCggW10gKTtcblx0XHR9LFxuXG5cdFx0cHJlcGFyZUZvcm06IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5yZXNldCgpO1xuXHRcdFx0dGhpcy50b0hpZGUgPSB0aGlzLmVycm9ycygpLmFkZCggdGhpcy5jb250YWluZXJzICk7XG5cdFx0fSxcblxuXHRcdHByZXBhcmVFbGVtZW50OiBmdW5jdGlvbiggZWxlbWVudCApIHtcblx0XHRcdHRoaXMucmVzZXQoKTtcblx0XHRcdHRoaXMudG9IaWRlID0gdGhpcy5lcnJvcnNGb3IoIGVsZW1lbnQgKTtcblx0XHR9LFxuXG5cdFx0ZWxlbWVudFZhbHVlOiBmdW5jdGlvbiggZWxlbWVudCApIHtcblx0XHRcdHZhciAkZWxlbWVudCA9ICQoIGVsZW1lbnQgKSxcblx0XHRcdFx0dHlwZSA9IGVsZW1lbnQudHlwZSxcblx0XHRcdFx0aXNDb250ZW50RWRpdGFibGUgPSB0eXBlb2YgJGVsZW1lbnQuYXR0ciggXCJjb250ZW50ZWRpdGFibGVcIiApICE9PSBcInVuZGVmaW5lZFwiICYmICRlbGVtZW50LmF0dHIoIFwiY29udGVudGVkaXRhYmxlXCIgKSAhPT0gXCJmYWxzZVwiLFxuXHRcdFx0XHR2YWwsIGlkeDtcblxuXHRcdFx0aWYgKCB0eXBlID09PSBcInJhZGlvXCIgfHwgdHlwZSA9PT0gXCJjaGVja2JveFwiICkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5maW5kQnlOYW1lKCBlbGVtZW50Lm5hbWUgKS5maWx0ZXIoIFwiOmNoZWNrZWRcIiApLnZhbCgpO1xuXHRcdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gXCJudW1iZXJcIiAmJiB0eXBlb2YgZWxlbWVudC52YWxpZGl0eSAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRcdFx0cmV0dXJuIGVsZW1lbnQudmFsaWRpdHkuYmFkSW5wdXQgPyBcIk5hTlwiIDogJGVsZW1lbnQudmFsKCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggaXNDb250ZW50RWRpdGFibGUgKSB7XG5cdFx0XHRcdHZhbCA9ICRlbGVtZW50LnRleHQoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhbCA9ICRlbGVtZW50LnZhbCgpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwiZmlsZVwiICkge1xuXG5cdFx0XHRcdC8vIE1vZGVybiBicm93c2VyIChjaHJvbWUgJiBzYWZhcmkpXG5cdFx0XHRcdGlmICggdmFsLnN1YnN0ciggMCwgMTIgKSA9PT0gXCJDOlxcXFxmYWtlcGF0aFxcXFxcIiApIHtcblx0XHRcdFx0XHRyZXR1cm4gdmFsLnN1YnN0ciggMTIgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIExlZ2FjeSBicm93c2Vyc1xuXHRcdFx0XHQvLyBVbml4LWJhc2VkIHBhdGhcblx0XHRcdFx0aWR4ID0gdmFsLmxhc3RJbmRleE9mKCBcIi9cIiApO1xuXHRcdFx0XHRpZiAoIGlkeCA+PSAwICkge1xuXHRcdFx0XHRcdHJldHVybiB2YWwuc3Vic3RyKCBpZHggKyAxICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBXaW5kb3dzLWJhc2VkIHBhdGhcblx0XHRcdFx0aWR4ID0gdmFsLmxhc3RJbmRleE9mKCBcIlxcXFxcIiApO1xuXHRcdFx0XHRpZiAoIGlkeCA+PSAwICkge1xuXHRcdFx0XHRcdHJldHVybiB2YWwuc3Vic3RyKCBpZHggKyAxICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBKdXN0IHRoZSBmaWxlIG5hbWVcblx0XHRcdFx0cmV0dXJuIHZhbDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB0eXBlb2YgdmFsID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0XHRyZXR1cm4gdmFsLnJlcGxhY2UoIC9cXHIvZywgXCJcIiApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHZhbDtcblx0XHR9LFxuXG5cdFx0Y2hlY2s6IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuXHRcdFx0ZWxlbWVudCA9IHRoaXMudmFsaWRhdGlvblRhcmdldEZvciggdGhpcy5jbGVhbiggZWxlbWVudCApICk7XG5cblx0XHRcdHZhciBydWxlcyA9ICQoIGVsZW1lbnQgKS5ydWxlcygpLFxuXHRcdFx0XHRydWxlc0NvdW50ID0gJC5tYXAoIHJ1bGVzLCBmdW5jdGlvbiggbiwgaSApIHtcblx0XHRcdFx0XHRyZXR1cm4gaTtcblx0XHRcdFx0fSApLmxlbmd0aCxcblx0XHRcdFx0ZGVwZW5kZW5jeU1pc21hdGNoID0gZmFsc2UsXG5cdFx0XHRcdHZhbCA9IHRoaXMuZWxlbWVudFZhbHVlKCBlbGVtZW50ICksXG5cdFx0XHRcdHJlc3VsdCwgbWV0aG9kLCBydWxlLCBub3JtYWxpemVyO1xuXG5cdFx0XHQvLyBBYm9ydCBhbnkgcGVuZGluZyBBamF4IHJlcXVlc3QgZnJvbSBhIHByZXZpb3VzIGNhbGwgdG8gdGhpcyBtZXRob2QuXG5cdFx0XHR0aGlzLmFib3J0UmVxdWVzdCggZWxlbWVudCApO1xuXG5cdFx0XHQvLyBQcmlvcml0aXplIHRoZSBsb2NhbCBub3JtYWxpemVyIGRlZmluZWQgZm9yIHRoaXMgZWxlbWVudCBvdmVyIHRoZSBnbG9iYWwgb25lXG5cdFx0XHQvLyBpZiB0aGUgZm9ybWVyIGV4aXN0cywgb3RoZXJ3aXNlIHVzZXIgdGhlIGdsb2JhbCBvbmUgaW4gY2FzZSBpdCBleGlzdHMuXG5cdFx0XHRpZiAoIHR5cGVvZiBydWxlcy5ub3JtYWxpemVyID09PSBcImZ1bmN0aW9uXCIgKSB7XG5cdFx0XHRcdG5vcm1hbGl6ZXIgPSBydWxlcy5ub3JtYWxpemVyO1xuXHRcdFx0fSBlbHNlIGlmIChcdHR5cGVvZiB0aGlzLnNldHRpbmdzLm5vcm1hbGl6ZXIgPT09IFwiZnVuY3Rpb25cIiApIHtcblx0XHRcdFx0bm9ybWFsaXplciA9IHRoaXMuc2V0dGluZ3Mubm9ybWFsaXplcjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgbm9ybWFsaXplciBpcyBkZWZpbmVkLCB0aGVuIGNhbGwgaXQgdG8gcmV0cmVpdmUgdGhlIGNoYW5nZWQgdmFsdWUgaW5zdGVhZFxuXHRcdFx0Ly8gb2YgdXNpbmcgdGhlIHJlYWwgb25lLlxuXHRcdFx0Ly8gTm90ZSB0aGF0IGB0aGlzYCBpbiB0aGUgbm9ybWFsaXplciBpcyBgZWxlbWVudGAuXG5cdFx0XHRpZiAoIG5vcm1hbGl6ZXIgKSB7XG5cdFx0XHRcdHZhbCA9IG5vcm1hbGl6ZXIuY2FsbCggZWxlbWVudCwgdmFsICk7XG5cblx0XHRcdFx0Ly8gRGVsZXRlIHRoZSBub3JtYWxpemVyIGZyb20gcnVsZXMgdG8gYXZvaWQgdHJlYXRpbmcgaXQgYXMgYSBwcmUtZGVmaW5lZCBtZXRob2QuXG5cdFx0XHRcdGRlbGV0ZSBydWxlcy5ub3JtYWxpemVyO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCBtZXRob2QgaW4gcnVsZXMgKSB7XG5cdFx0XHRcdHJ1bGUgPSB7IG1ldGhvZDogbWV0aG9kLCBwYXJhbWV0ZXJzOiBydWxlc1sgbWV0aG9kIF0gfTtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRyZXN1bHQgPSAkLnZhbGlkYXRvci5tZXRob2RzWyBtZXRob2QgXS5jYWxsKCB0aGlzLCB2YWwsIGVsZW1lbnQsIHJ1bGUucGFyYW1ldGVycyApO1xuXG5cdFx0XHRcdFx0Ly8gSWYgYSBtZXRob2QgaW5kaWNhdGVzIHRoYXQgdGhlIGZpZWxkIGlzIG9wdGlvbmFsIGFuZCB0aGVyZWZvcmUgdmFsaWQsXG5cdFx0XHRcdFx0Ly8gZG9uJ3QgbWFyayBpdCBhcyB2YWxpZCB3aGVuIHRoZXJlIGFyZSBubyBvdGhlciBydWxlc1xuXHRcdFx0XHRcdGlmICggcmVzdWx0ID09PSBcImRlcGVuZGVuY3ktbWlzbWF0Y2hcIiAmJiBydWxlc0NvdW50ID09PSAxICkge1xuXHRcdFx0XHRcdFx0ZGVwZW5kZW5jeU1pc21hdGNoID0gdHJ1ZTtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkZXBlbmRlbmN5TWlzbWF0Y2ggPSBmYWxzZTtcblxuXHRcdFx0XHRcdGlmICggcmVzdWx0ID09PSBcInBlbmRpbmdcIiApIHtcblx0XHRcdFx0XHRcdHRoaXMudG9IaWRlID0gdGhpcy50b0hpZGUubm90KCB0aGlzLmVycm9yc0ZvciggZWxlbWVudCApICk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCAhcmVzdWx0ICkge1xuXHRcdFx0XHRcdFx0dGhpcy5mb3JtYXRBbmRBZGQoIGVsZW1lbnQsIHJ1bGUgKTtcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5zZXR0aW5ncy5kZWJ1ZyAmJiB3aW5kb3cuY29uc29sZSApIHtcblx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKCBcIkV4Y2VwdGlvbiBvY2N1cnJlZCB3aGVuIGNoZWNraW5nIGVsZW1lbnQgXCIgKyBlbGVtZW50LmlkICsgXCIsIGNoZWNrIHRoZSAnXCIgKyBydWxlLm1ldGhvZCArIFwiJyBtZXRob2QuXCIsIGUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBlIGluc3RhbmNlb2YgVHlwZUVycm9yICkge1xuXHRcdFx0XHRcdFx0ZS5tZXNzYWdlICs9IFwiLiAgRXhjZXB0aW9uIG9jY3VycmVkIHdoZW4gY2hlY2tpbmcgZWxlbWVudCBcIiArIGVsZW1lbnQuaWQgKyBcIiwgY2hlY2sgdGhlICdcIiArIHJ1bGUubWV0aG9kICsgXCInIG1ldGhvZC5cIjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR0aHJvdyBlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGRlcGVuZGVuY3lNaXNtYXRjaCApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB0aGlzLm9iamVjdExlbmd0aCggcnVsZXMgKSApIHtcblx0XHRcdFx0dGhpcy5zdWNjZXNzTGlzdC5wdXNoKCBlbGVtZW50ICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0Ly8gUmV0dXJuIHRoZSBjdXN0b20gbWVzc2FnZSBmb3IgdGhlIGdpdmVuIGVsZW1lbnQgYW5kIHZhbGlkYXRpb24gbWV0aG9kXG5cdFx0Ly8gc3BlY2lmaWVkIGluIHRoZSBlbGVtZW50J3MgSFRNTDUgZGF0YSBhdHRyaWJ1dGVcblx0XHQvLyByZXR1cm4gdGhlIGdlbmVyaWMgbWVzc2FnZSBpZiBwcmVzZW50IGFuZCBubyBtZXRob2Qgc3BlY2lmaWMgbWVzc2FnZSBpcyBwcmVzZW50XG5cdFx0Y3VzdG9tRGF0YU1lc3NhZ2U6IGZ1bmN0aW9uKCBlbGVtZW50LCBtZXRob2QgKSB7XG5cdFx0XHRyZXR1cm4gJCggZWxlbWVudCApLmRhdGEoIFwibXNnXCIgKyBtZXRob2QuY2hhckF0KCAwICkudG9VcHBlckNhc2UoKSArXG5cdFx0XHRcdG1ldGhvZC5zdWJzdHJpbmcoIDEgKS50b0xvd2VyQ2FzZSgpICkgfHwgJCggZWxlbWVudCApLmRhdGEoIFwibXNnXCIgKTtcblx0XHR9LFxuXG5cdFx0Ly8gUmV0dXJuIHRoZSBjdXN0b20gbWVzc2FnZSBmb3IgdGhlIGdpdmVuIGVsZW1lbnQgbmFtZSBhbmQgdmFsaWRhdGlvbiBtZXRob2Rcblx0XHRjdXN0b21NZXNzYWdlOiBmdW5jdGlvbiggbmFtZSwgbWV0aG9kICkge1xuXHRcdFx0dmFyIG0gPSB0aGlzLnNldHRpbmdzLm1lc3NhZ2VzWyBuYW1lIF07XG5cdFx0XHRyZXR1cm4gbSAmJiAoIG0uY29uc3RydWN0b3IgPT09IFN0cmluZyA/IG0gOiBtWyBtZXRob2QgXSApO1xuXHRcdH0sXG5cblx0XHQvLyBSZXR1cm4gdGhlIGZpcnN0IGRlZmluZWQgYXJndW1lbnQsIGFsbG93aW5nIGVtcHR5IHN0cmluZ3Ncblx0XHRmaW5kRGVmaW5lZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdGlmICggYXJndW1lbnRzWyBpIF0gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gYXJndW1lbnRzWyBpIF07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0fSxcblxuXHRcdC8vIFRoZSBzZWNvbmQgcGFyYW1ldGVyICdydWxlJyB1c2VkIHRvIGJlIGEgc3RyaW5nLCBhbmQgZXh0ZW5kZWQgdG8gYW4gb2JqZWN0IGxpdGVyYWxcblx0XHQvLyBvZiB0aGUgZm9sbG93aW5nIGZvcm06XG5cdFx0Ly8gcnVsZSA9IHtcblx0XHQvLyAgICAgbWV0aG9kOiBcIm1ldGhvZCBuYW1lXCIsXG5cdFx0Ly8gICAgIHBhcmFtZXRlcnM6IFwidGhlIGdpdmVuIG1ldGhvZCBwYXJhbWV0ZXJzXCJcblx0XHQvLyB9XG5cdFx0Ly9cblx0XHQvLyBUaGUgb2xkIGJlaGF2aW9yIHN0aWxsIHN1cHBvcnRlZCwga2VwdCB0byBtYWludGFpbiBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IHdpdGhcblx0XHQvLyBvbGQgY29kZSwgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlLlxuXHRcdGRlZmF1bHRNZXNzYWdlOiBmdW5jdGlvbiggZWxlbWVudCwgcnVsZSApIHtcblx0XHRcdGlmICggdHlwZW9mIHJ1bGUgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRcdHJ1bGUgPSB7IG1ldGhvZDogcnVsZSB9O1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgbWVzc2FnZSA9IHRoaXMuZmluZERlZmluZWQoXG5cdFx0XHRcdFx0dGhpcy5jdXN0b21NZXNzYWdlKCBlbGVtZW50Lm5hbWUsIHJ1bGUubWV0aG9kICksXG5cdFx0XHRcdFx0dGhpcy5jdXN0b21EYXRhTWVzc2FnZSggZWxlbWVudCwgcnVsZS5tZXRob2QgKSxcblxuXHRcdFx0XHRcdC8vICd0aXRsZScgaXMgbmV2ZXIgdW5kZWZpbmVkLCBzbyBoYW5kbGUgZW1wdHkgc3RyaW5nIGFzIHVuZGVmaW5lZFxuXHRcdFx0XHRcdCF0aGlzLnNldHRpbmdzLmlnbm9yZVRpdGxlICYmIGVsZW1lbnQudGl0bGUgfHwgdW5kZWZpbmVkLFxuXHRcdFx0XHRcdCQudmFsaWRhdG9yLm1lc3NhZ2VzWyBydWxlLm1ldGhvZCBdLFxuXHRcdFx0XHRcdFwiPHN0cm9uZz5XYXJuaW5nOiBObyBtZXNzYWdlIGRlZmluZWQgZm9yIFwiICsgZWxlbWVudC5uYW1lICsgXCI8L3N0cm9uZz5cIlxuXHRcdFx0XHQpLFxuXHRcdFx0XHR0aGVyZWdleCA9IC9cXCQ/XFx7KFxcZCspXFx9L2c7XG5cdFx0XHRpZiAoIHR5cGVvZiBtZXNzYWdlID09PSBcImZ1bmN0aW9uXCIgKSB7XG5cdFx0XHRcdG1lc3NhZ2UgPSBtZXNzYWdlLmNhbGwoIHRoaXMsIHJ1bGUucGFyYW1ldGVycywgZWxlbWVudCApO1xuXHRcdFx0fSBlbHNlIGlmICggdGhlcmVnZXgudGVzdCggbWVzc2FnZSApICkge1xuXHRcdFx0XHRtZXNzYWdlID0gJC52YWxpZGF0b3IuZm9ybWF0KCBtZXNzYWdlLnJlcGxhY2UoIHRoZXJlZ2V4LCBcInskMX1cIiApLCBydWxlLnBhcmFtZXRlcnMgKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1lc3NhZ2U7XG5cdFx0fSxcblxuXHRcdGZvcm1hdEFuZEFkZDogZnVuY3Rpb24oIGVsZW1lbnQsIHJ1bGUgKSB7XG5cdFx0XHR2YXIgbWVzc2FnZSA9IHRoaXMuZGVmYXVsdE1lc3NhZ2UoIGVsZW1lbnQsIHJ1bGUgKTtcblxuXHRcdFx0dGhpcy5lcnJvckxpc3QucHVzaCgge1xuXHRcdFx0XHRtZXNzYWdlOiBtZXNzYWdlLFxuXHRcdFx0XHRlbGVtZW50OiBlbGVtZW50LFxuXHRcdFx0XHRtZXRob2Q6IHJ1bGUubWV0aG9kXG5cdFx0XHR9ICk7XG5cblx0XHRcdHRoaXMuZXJyb3JNYXBbIGVsZW1lbnQubmFtZSBdID0gbWVzc2FnZTtcblx0XHRcdHRoaXMuc3VibWl0dGVkWyBlbGVtZW50Lm5hbWUgXSA9IG1lc3NhZ2U7XG5cdFx0fSxcblxuXHRcdGFkZFdyYXBwZXI6IGZ1bmN0aW9uKCB0b1RvZ2dsZSApIHtcblx0XHRcdGlmICggdGhpcy5zZXR0aW5ncy53cmFwcGVyICkge1xuXHRcdFx0XHR0b1RvZ2dsZSA9IHRvVG9nZ2xlLmFkZCggdG9Ub2dnbGUucGFyZW50KCB0aGlzLnNldHRpbmdzLndyYXBwZXIgKSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRvVG9nZ2xlO1xuXHRcdH0sXG5cblx0XHRkZWZhdWx0U2hvd0Vycm9yczogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaSwgZWxlbWVudHMsIGVycm9yO1xuXHRcdFx0Zm9yICggaSA9IDA7IHRoaXMuZXJyb3JMaXN0WyBpIF07IGkrKyApIHtcblx0XHRcdFx0ZXJyb3IgPSB0aGlzLmVycm9yTGlzdFsgaSBdO1xuXHRcdFx0XHRpZiAoIHRoaXMuc2V0dGluZ3MuaGlnaGxpZ2h0ICkge1xuXHRcdFx0XHRcdHRoaXMuc2V0dGluZ3MuaGlnaGxpZ2h0LmNhbGwoIHRoaXMsIGVycm9yLmVsZW1lbnQsIHRoaXMuc2V0dGluZ3MuZXJyb3JDbGFzcywgdGhpcy5zZXR0aW5ncy52YWxpZENsYXNzICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5zaG93TGFiZWwoIGVycm9yLmVsZW1lbnQsIGVycm9yLm1lc3NhZ2UgKTtcblx0XHRcdH1cblx0XHRcdGlmICggdGhpcy5lcnJvckxpc3QubGVuZ3RoICkge1xuXHRcdFx0XHR0aGlzLnRvU2hvdyA9IHRoaXMudG9TaG93LmFkZCggdGhpcy5jb250YWluZXJzICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHRoaXMuc2V0dGluZ3Muc3VjY2VzcyApIHtcblx0XHRcdFx0Zm9yICggaSA9IDA7IHRoaXMuc3VjY2Vzc0xpc3RbIGkgXTsgaSsrICkge1xuXHRcdFx0XHRcdHRoaXMuc2hvd0xhYmVsKCB0aGlzLnN1Y2Nlc3NMaXN0WyBpIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCB0aGlzLnNldHRpbmdzLnVuaGlnaGxpZ2h0ICkge1xuXHRcdFx0XHRmb3IgKCBpID0gMCwgZWxlbWVudHMgPSB0aGlzLnZhbGlkRWxlbWVudHMoKTsgZWxlbWVudHNbIGkgXTsgaSsrICkge1xuXHRcdFx0XHRcdHRoaXMuc2V0dGluZ3MudW5oaWdobGlnaHQuY2FsbCggdGhpcywgZWxlbWVudHNbIGkgXSwgdGhpcy5zZXR0aW5ncy5lcnJvckNsYXNzLCB0aGlzLnNldHRpbmdzLnZhbGlkQ2xhc3MgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGhpcy50b0hpZGUgPSB0aGlzLnRvSGlkZS5ub3QoIHRoaXMudG9TaG93ICk7XG5cdFx0XHR0aGlzLmhpZGVFcnJvcnMoKTtcblx0XHRcdHRoaXMuYWRkV3JhcHBlciggdGhpcy50b1Nob3cgKS5zaG93KCk7XG5cdFx0fSxcblxuXHRcdHZhbGlkRWxlbWVudHM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuY3VycmVudEVsZW1lbnRzLm5vdCggdGhpcy5pbnZhbGlkRWxlbWVudHMoKSApO1xuXHRcdH0sXG5cblx0XHRpbnZhbGlkRWxlbWVudHM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuICQoIHRoaXMuZXJyb3JMaXN0ICkubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZWxlbWVudDtcblx0XHRcdH0gKTtcblx0XHR9LFxuXG5cdFx0c2hvd0xhYmVsOiBmdW5jdGlvbiggZWxlbWVudCwgbWVzc2FnZSApIHtcblx0XHRcdHZhciBwbGFjZSwgZ3JvdXAsIGVycm9ySUQsIHYsXG5cdFx0XHRcdGVycm9yID0gdGhpcy5lcnJvcnNGb3IoIGVsZW1lbnQgKSxcblx0XHRcdFx0ZWxlbWVudElEID0gdGhpcy5pZE9yTmFtZSggZWxlbWVudCApLFxuXHRcdFx0XHRkZXNjcmliZWRCeSA9ICQoIGVsZW1lbnQgKS5hdHRyKCBcImFyaWEtZGVzY3JpYmVkYnlcIiApO1xuXG5cdFx0XHRpZiAoIGVycm9yLmxlbmd0aCApIHtcblxuXHRcdFx0XHQvLyBSZWZyZXNoIGVycm9yL3N1Y2Nlc3MgY2xhc3Ncblx0XHRcdFx0ZXJyb3IucmVtb3ZlQ2xhc3MoIHRoaXMuc2V0dGluZ3MudmFsaWRDbGFzcyApLmFkZENsYXNzKCB0aGlzLnNldHRpbmdzLmVycm9yQ2xhc3MgKTtcblxuXHRcdFx0XHQvLyBSZXBsYWNlIG1lc3NhZ2Ugb24gZXhpc3RpbmcgbGFiZWxcblx0XHRcdFx0aWYgKCB0aGlzLnNldHRpbmdzICYmIHRoaXMuc2V0dGluZ3MuZXNjYXBlSHRtbCApIHtcblx0XHRcdFx0XHRlcnJvci50ZXh0KCBtZXNzYWdlIHx8IFwiXCIgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRlcnJvci5odG1sKCBtZXNzYWdlIHx8IFwiXCIgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBDcmVhdGUgZXJyb3IgZWxlbWVudFxuXHRcdFx0XHRlcnJvciA9ICQoIFwiPFwiICsgdGhpcy5zZXR0aW5ncy5lcnJvckVsZW1lbnQgKyBcIj5cIiApXG5cdFx0XHRcdFx0LmF0dHIoIFwiaWRcIiwgZWxlbWVudElEICsgXCItZXJyb3JcIiApXG5cdFx0XHRcdFx0LmFkZENsYXNzKCB0aGlzLnNldHRpbmdzLmVycm9yQ2xhc3MgKTtcblxuXHRcdFx0XHRpZiAoIHRoaXMuc2V0dGluZ3MgJiYgdGhpcy5zZXR0aW5ncy5lc2NhcGVIdG1sICkge1xuXHRcdFx0XHRcdGVycm9yLnRleHQoIG1lc3NhZ2UgfHwgXCJcIiApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGVycm9yLmh0bWwoIG1lc3NhZ2UgfHwgXCJcIiApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gTWFpbnRhaW4gcmVmZXJlbmNlIHRvIHRoZSBlbGVtZW50IHRvIGJlIHBsYWNlZCBpbnRvIHRoZSBET01cblx0XHRcdFx0cGxhY2UgPSBlcnJvcjtcblx0XHRcdFx0aWYgKCB0aGlzLnNldHRpbmdzLndyYXBwZXIgKSB7XG5cblx0XHRcdFx0XHQvLyBNYWtlIHN1cmUgdGhlIGVsZW1lbnQgaXMgdmlzaWJsZSwgZXZlbiBpbiBJRVxuXHRcdFx0XHRcdC8vIGFjdHVhbGx5IHNob3dpbmcgdGhlIHdyYXBwZWQgZWxlbWVudCBpcyBoYW5kbGVkIGVsc2V3aGVyZVxuXHRcdFx0XHRcdHBsYWNlID0gZXJyb3IuaGlkZSgpLnNob3coKS53cmFwKCBcIjxcIiArIHRoaXMuc2V0dGluZ3Mud3JhcHBlciArIFwiLz5cIiApLnBhcmVudCgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggdGhpcy5sYWJlbENvbnRhaW5lci5sZW5ndGggKSB7XG5cdFx0XHRcdFx0dGhpcy5sYWJlbENvbnRhaW5lci5hcHBlbmQoIHBsYWNlICk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoIHRoaXMuc2V0dGluZ3MuZXJyb3JQbGFjZW1lbnQgKSB7XG5cdFx0XHRcdFx0dGhpcy5zZXR0aW5ncy5lcnJvclBsYWNlbWVudC5jYWxsKCB0aGlzLCBwbGFjZSwgJCggZWxlbWVudCApICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cGxhY2UuaW5zZXJ0QWZ0ZXIoIGVsZW1lbnQgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIExpbmsgZXJyb3IgYmFjayB0byB0aGUgZWxlbWVudFxuXHRcdFx0XHRpZiAoIGVycm9yLmlzKCBcImxhYmVsXCIgKSApIHtcblxuXHRcdFx0XHRcdC8vIElmIHRoZSBlcnJvciBpcyBhIGxhYmVsLCB0aGVuIGFzc29jaWF0ZSB1c2luZyAnZm9yJ1xuXHRcdFx0XHRcdGVycm9yLmF0dHIoIFwiZm9yXCIsIGVsZW1lbnRJRCApO1xuXG5cdFx0XHRcdFx0Ly8gSWYgdGhlIGVsZW1lbnQgaXMgbm90IGEgY2hpbGQgb2YgYW4gYXNzb2NpYXRlZCBsYWJlbCwgdGhlbiBpdCdzIG5lY2Vzc2FyeVxuXHRcdFx0XHRcdC8vIHRvIGV4cGxpY2l0bHkgYXBwbHkgYXJpYS1kZXNjcmliZWRieVxuXHRcdFx0XHR9IGVsc2UgaWYgKCBlcnJvci5wYXJlbnRzKCBcImxhYmVsW2Zvcj0nXCIgKyB0aGlzLmVzY2FwZUNzc01ldGEoIGVsZW1lbnRJRCApICsgXCInXVwiICkubGVuZ3RoID09PSAwICkge1xuXHRcdFx0XHRcdGVycm9ySUQgPSBlcnJvci5hdHRyKCBcImlkXCIgKTtcblxuXHRcdFx0XHRcdC8vIFJlc3BlY3QgZXhpc3Rpbmcgbm9uLWVycm9yIGFyaWEtZGVzY3JpYmVkYnlcblx0XHRcdFx0XHRpZiAoICFkZXNjcmliZWRCeSApIHtcblx0XHRcdFx0XHRcdGRlc2NyaWJlZEJ5ID0gZXJyb3JJRDtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCAhZGVzY3JpYmVkQnkubWF0Y2goIG5ldyBSZWdFeHAoIFwiXFxcXGJcIiArIHRoaXMuZXNjYXBlQ3NzTWV0YSggZXJyb3JJRCApICsgXCJcXFxcYlwiICkgKSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gQWRkIHRvIGVuZCBvZiBsaXN0IGlmIG5vdCBhbHJlYWR5IHByZXNlbnRcblx0XHRcdFx0XHRcdGRlc2NyaWJlZEJ5ICs9IFwiIFwiICsgZXJyb3JJRDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0JCggZWxlbWVudCApLmF0dHIoIFwiYXJpYS1kZXNjcmliZWRieVwiLCBkZXNjcmliZWRCeSApO1xuXG5cdFx0XHRcdFx0Ly8gSWYgdGhpcyBlbGVtZW50IGlzIGdyb3VwZWQsIHRoZW4gYXNzaWduIHRvIGFsbCBlbGVtZW50cyBpbiB0aGUgc2FtZSBncm91cFxuXHRcdFx0XHRcdGdyb3VwID0gdGhpcy5ncm91cHNbIGVsZW1lbnQubmFtZSBdO1xuXHRcdFx0XHRcdGlmICggZ3JvdXAgKSB7XG5cdFx0XHRcdFx0XHR2ID0gdGhpcztcblx0XHRcdFx0XHRcdCQuZWFjaCggdi5ncm91cHMsIGZ1bmN0aW9uKCBuYW1lLCB0ZXN0Z3JvdXAgKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggdGVzdGdyb3VwID09PSBncm91cCApIHtcblx0XHRcdFx0XHRcdFx0XHQkKCBcIltuYW1lPSdcIiArIHYuZXNjYXBlQ3NzTWV0YSggbmFtZSApICsgXCInXVwiLCB2LmN1cnJlbnRGb3JtIClcblx0XHRcdFx0XHRcdFx0XHRcdC5hdHRyKCBcImFyaWEtZGVzY3JpYmVkYnlcIiwgZXJyb3IuYXR0ciggXCJpZFwiICkgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCAhbWVzc2FnZSAmJiB0aGlzLnNldHRpbmdzLnN1Y2Nlc3MgKSB7XG5cdFx0XHRcdGVycm9yLnRleHQoIFwiXCIgKTtcblx0XHRcdFx0aWYgKCB0eXBlb2YgdGhpcy5zZXR0aW5ncy5zdWNjZXNzID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0XHRcdGVycm9yLmFkZENsYXNzKCB0aGlzLnNldHRpbmdzLnN1Y2Nlc3MgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLnNldHRpbmdzLnN1Y2Nlc3MoIGVycm9yLCBlbGVtZW50ICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRoaXMudG9TaG93ID0gdGhpcy50b1Nob3cuYWRkKCBlcnJvciApO1xuXHRcdH0sXG5cblx0XHRlcnJvcnNGb3I6IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuXHRcdFx0dmFyIG5hbWUgPSB0aGlzLmVzY2FwZUNzc01ldGEoIHRoaXMuaWRPck5hbWUoIGVsZW1lbnQgKSApLFxuXHRcdFx0XHRkZXNjcmliZXIgPSAkKCBlbGVtZW50ICkuYXR0ciggXCJhcmlhLWRlc2NyaWJlZGJ5XCIgKSxcblx0XHRcdFx0c2VsZWN0b3IgPSBcImxhYmVsW2Zvcj0nXCIgKyBuYW1lICsgXCInXSwgbGFiZWxbZm9yPSdcIiArIG5hbWUgKyBcIiddICpcIjtcblxuXHRcdFx0Ly8gJ2FyaWEtZGVzY3JpYmVkYnknIHNob3VsZCBkaXJlY3RseSByZWZlcmVuY2UgdGhlIGVycm9yIGVsZW1lbnRcblx0XHRcdGlmICggZGVzY3JpYmVyICkge1xuXHRcdFx0XHRzZWxlY3RvciA9IHNlbGVjdG9yICsgXCIsICNcIiArIHRoaXMuZXNjYXBlQ3NzTWV0YSggZGVzY3JpYmVyIClcblx0XHRcdFx0XHQucmVwbGFjZSggL1xccysvZywgXCIsICNcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpc1xuXHRcdFx0XHQuZXJyb3JzKClcblx0XHRcdFx0LmZpbHRlciggc2VsZWN0b3IgKTtcblx0XHR9LFxuXG5cdFx0Ly8gU2VlIGh0dHBzOi8vYXBpLmpxdWVyeS5jb20vY2F0ZWdvcnkvc2VsZWN0b3JzLywgZm9yIENTU1xuXHRcdC8vIG1ldGEtY2hhcmFjdGVycyB0aGF0IHNob3VsZCBiZSBlc2NhcGVkIGluIG9yZGVyIHRvIGJlIHVzZWQgd2l0aCBKUXVlcnlcblx0XHQvLyBhcyBhIGxpdGVyYWwgcGFydCBvZiBhIG5hbWUvaWQgb3IgYW55IHNlbGVjdG9yLlxuXHRcdGVzY2FwZUNzc01ldGE6IGZ1bmN0aW9uKCBzdHJpbmcgKSB7XG5cdFx0XHRpZiAoIHN0cmluZyA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gXCJcIjtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHN0cmluZy5yZXBsYWNlKCAvKFtcXFxcIVwiIyQlJicoKSorLC4vOjs8PT4/QFxcW1xcXV5ge3x9fl0pL2csIFwiXFxcXCQxXCIgKTtcblx0XHR9LFxuXG5cdFx0aWRPck5hbWU6IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZ3JvdXBzWyBlbGVtZW50Lm5hbWUgXSB8fCAoIHRoaXMuY2hlY2thYmxlKCBlbGVtZW50ICkgPyBlbGVtZW50Lm5hbWUgOiBlbGVtZW50LmlkIHx8IGVsZW1lbnQubmFtZSApO1xuXHRcdH0sXG5cblx0XHR2YWxpZGF0aW9uVGFyZ2V0Rm9yOiBmdW5jdGlvbiggZWxlbWVudCApIHtcblxuXHRcdFx0Ly8gSWYgcmFkaW8vY2hlY2tib3gsIHZhbGlkYXRlIGZpcnN0IGVsZW1lbnQgaW4gZ3JvdXAgaW5zdGVhZFxuXHRcdFx0aWYgKCB0aGlzLmNoZWNrYWJsZSggZWxlbWVudCApICkge1xuXHRcdFx0XHRlbGVtZW50ID0gdGhpcy5maW5kQnlOYW1lKCBlbGVtZW50Lm5hbWUgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWx3YXlzIGFwcGx5IGlnbm9yZSBmaWx0ZXJcblx0XHRcdHJldHVybiAkKCBlbGVtZW50ICkubm90KCB0aGlzLnNldHRpbmdzLmlnbm9yZSApWyAwIF07XG5cdFx0fSxcblxuXHRcdGNoZWNrYWJsZTogZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG5cdFx0XHRyZXR1cm4gKCAvcmFkaW98Y2hlY2tib3gvaSApLnRlc3QoIGVsZW1lbnQudHlwZSApO1xuXHRcdH0sXG5cblx0XHRmaW5kQnlOYW1lOiBmdW5jdGlvbiggbmFtZSApIHtcblx0XHRcdHJldHVybiAkKCB0aGlzLmN1cnJlbnRGb3JtICkuZmluZCggXCJbbmFtZT0nXCIgKyB0aGlzLmVzY2FwZUNzc01ldGEoIG5hbWUgKSArIFwiJ11cIiApO1xuXHRcdH0sXG5cblx0XHRnZXRMZW5ndGg6IGZ1bmN0aW9uKCB2YWx1ZSwgZWxlbWVudCApIHtcblx0XHRcdHN3aXRjaCAoIGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSApIHtcblx0XHRcdGNhc2UgXCJzZWxlY3RcIjpcblx0XHRcdFx0cmV0dXJuICQoIFwib3B0aW9uOnNlbGVjdGVkXCIsIGVsZW1lbnQgKS5sZW5ndGg7XG5cdFx0XHRjYXNlIFwiaW5wdXRcIjpcblx0XHRcdFx0aWYgKCB0aGlzLmNoZWNrYWJsZSggZWxlbWVudCApICkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLmZpbmRCeU5hbWUoIGVsZW1lbnQubmFtZSApLmZpbHRlciggXCI6Y2hlY2tlZFwiICkubGVuZ3RoO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdmFsdWUubGVuZ3RoO1xuXHRcdH0sXG5cblx0XHRkZXBlbmQ6IGZ1bmN0aW9uKCBwYXJhbSwgZWxlbWVudCApIHtcblx0XHRcdHJldHVybiB0aGlzLmRlcGVuZFR5cGVzWyB0eXBlb2YgcGFyYW0gXSA/IHRoaXMuZGVwZW5kVHlwZXNbIHR5cGVvZiBwYXJhbSBdKCBwYXJhbSwgZWxlbWVudCApIDogdHJ1ZTtcblx0XHR9LFxuXG5cdFx0ZGVwZW5kVHlwZXM6IHtcblx0XHRcdFwiYm9vbGVhblwiOiBmdW5jdGlvbiggcGFyYW0gKSB7XG5cdFx0XHRcdHJldHVybiBwYXJhbTtcblx0XHRcdH0sXG5cdFx0XHRcInN0cmluZ1wiOiBmdW5jdGlvbiggcGFyYW0sIGVsZW1lbnQgKSB7XG5cdFx0XHRcdHJldHVybiAhISQoIHBhcmFtLCBlbGVtZW50LmZvcm0gKS5sZW5ndGg7XG5cdFx0XHR9LFxuXHRcdFx0XCJmdW5jdGlvblwiOiBmdW5jdGlvbiggcGFyYW0sIGVsZW1lbnQgKSB7XG5cdFx0XHRcdHJldHVybiBwYXJhbSggZWxlbWVudCApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRvcHRpb25hbDogZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG5cdFx0XHR2YXIgdmFsID0gdGhpcy5lbGVtZW50VmFsdWUoIGVsZW1lbnQgKTtcblx0XHRcdHJldHVybiAhJC52YWxpZGF0b3IubWV0aG9kcy5yZXF1aXJlZC5jYWxsKCB0aGlzLCB2YWwsIGVsZW1lbnQgKSAmJiBcImRlcGVuZGVuY3ktbWlzbWF0Y2hcIjtcblx0XHR9LFxuXG5cdFx0ZWxlbWVudEFqYXhQb3J0OiBmdW5jdGlvbiggZWxlbWVudCApIHtcblx0XHRcdHJldHVybiBcInZhbGlkYXRlXCIgKyBlbGVtZW50Lm5hbWU7XG5cdFx0fSxcblxuXHRcdHN0YXJ0UmVxdWVzdDogZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG5cdFx0XHRpZiAoICF0aGlzLnBlbmRpbmdbIGVsZW1lbnQubmFtZSBdICkge1xuXHRcdFx0XHR0aGlzLnBlbmRpbmdSZXF1ZXN0Kys7XG5cdFx0XHRcdCQoIGVsZW1lbnQgKS5hZGRDbGFzcyggdGhpcy5zZXR0aW5ncy5wZW5kaW5nQ2xhc3MgKTtcblx0XHRcdFx0dGhpcy5wZW5kaW5nWyBlbGVtZW50Lm5hbWUgXSA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHN0b3BSZXF1ZXN0OiBmdW5jdGlvbiggZWxlbWVudCwgdmFsaWQgKSB7XG5cdFx0XHR0aGlzLnBlbmRpbmdSZXF1ZXN0LS07XG5cblx0XHRcdC8vIFNvbWV0aW1lcyBzeW5jaHJvbml6YXRpb24gZmFpbHMsIG1ha2Ugc3VyZSBwZW5kaW5nUmVxdWVzdCBpcyBuZXZlciA8IDBcblx0XHRcdGlmICggdGhpcy5wZW5kaW5nUmVxdWVzdCA8IDAgKSB7XG5cdFx0XHRcdHRoaXMucGVuZGluZ1JlcXVlc3QgPSAwO1xuXHRcdFx0fVxuXHRcdFx0ZGVsZXRlIHRoaXMucGVuZGluZ1sgZWxlbWVudC5uYW1lIF07XG5cdFx0XHQkKCBlbGVtZW50ICkucmVtb3ZlQ2xhc3MoIHRoaXMuc2V0dGluZ3MucGVuZGluZ0NsYXNzICk7XG5cdFx0XHRpZiAoIHZhbGlkICYmIHRoaXMucGVuZGluZ1JlcXVlc3QgPT09IDAgJiYgdGhpcy5mb3JtU3VibWl0dGVkICYmIHRoaXMuZm9ybSgpICYmIHRoaXMucGVuZGluZ1JlcXVlc3QgPT09IDAgKSB7XG5cdFx0XHRcdCQoIHRoaXMuY3VycmVudEZvcm0gKS50cmlnZ2VyKCBcInN1Ym1pdFwiICk7XG5cblx0XHRcdFx0Ly8gUmVtb3ZlIHRoZSBoaWRkZW4gaW5wdXQgdGhhdCB3YXMgdXNlZCBhcyBhIHJlcGxhY2VtZW50IGZvciB0aGVcblx0XHRcdFx0Ly8gbWlzc2luZyBzdWJtaXQgYnV0dG9uLiBUaGUgaGlkZGVuIGlucHV0IGlzIGFkZGVkIGJ5IGBoYW5kbGUoKWBcblx0XHRcdFx0Ly8gdG8gZW5zdXJlIHRoYXQgdGhlIHZhbHVlIG9mIHRoZSB1c2VkIHN1Ym1pdCBidXR0b24gaXMgcGFzc2VkIG9uXG5cdFx0XHRcdC8vIGZvciBzY3JpcHRlZCBzdWJtaXRzIHRyaWdnZXJlZCBieSB0aGlzIG1ldGhvZFxuXHRcdFx0XHRpZiAoIHRoaXMuc3VibWl0QnV0dG9uICkge1xuXHRcdFx0XHRcdCQoIFwiaW5wdXQ6aGlkZGVuW25hbWU9J1wiICsgdGhpcy5zdWJtaXRCdXR0b24ubmFtZSArIFwiJ11cIiwgdGhpcy5jdXJyZW50Rm9ybSApLnJlbW92ZSgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5mb3JtU3VibWl0dGVkID0gZmFsc2U7XG5cdFx0XHR9IGVsc2UgaWYgKCAhdmFsaWQgJiYgdGhpcy5wZW5kaW5nUmVxdWVzdCA9PT0gMCAmJiB0aGlzLmZvcm1TdWJtaXR0ZWQgKSB7XG5cdFx0XHRcdCQoIHRoaXMuY3VycmVudEZvcm0gKS50cmlnZ2VySGFuZGxlciggXCJpbnZhbGlkLWZvcm1cIiwgWyB0aGlzIF0gKTtcblx0XHRcdFx0dGhpcy5mb3JtU3VibWl0dGVkID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGFib3J0UmVxdWVzdDogZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG5cdFx0XHR2YXIgcG9ydDtcblxuXHRcdFx0aWYgKCB0aGlzLnBlbmRpbmdbIGVsZW1lbnQubmFtZSBdICkge1xuXHRcdFx0XHRwb3J0ID0gdGhpcy5lbGVtZW50QWpheFBvcnQoIGVsZW1lbnQgKTtcblx0XHRcdFx0JC5hamF4QWJvcnQoIHBvcnQgKTtcblxuXHRcdFx0XHR0aGlzLnBlbmRpbmdSZXF1ZXN0LS07XG5cblx0XHRcdFx0Ly8gU29tZXRpbWVzIHN5bmNocm9uaXphdGlvbiBmYWlscywgbWFrZSBzdXJlIHBlbmRpbmdSZXF1ZXN0IGlzIG5ldmVyIDwgMFxuXHRcdFx0XHRpZiAoIHRoaXMucGVuZGluZ1JlcXVlc3QgPCAwICkge1xuXHRcdFx0XHRcdHRoaXMucGVuZGluZ1JlcXVlc3QgPSAwO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGVsZXRlIHRoaXMucGVuZGluZ1sgZWxlbWVudC5uYW1lIF07XG5cdFx0XHRcdCQoIGVsZW1lbnQgKS5yZW1vdmVDbGFzcyggdGhpcy5zZXR0aW5ncy5wZW5kaW5nQ2xhc3MgKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0cHJldmlvdXNWYWx1ZTogZnVuY3Rpb24oIGVsZW1lbnQsIG1ldGhvZCApIHtcblx0XHRcdG1ldGhvZCA9IHR5cGVvZiBtZXRob2QgPT09IFwic3RyaW5nXCIgJiYgbWV0aG9kIHx8IFwicmVtb3RlXCI7XG5cblx0XHRcdHJldHVybiAkLmRhdGEoIGVsZW1lbnQsIFwicHJldmlvdXNWYWx1ZVwiICkgfHwgJC5kYXRhKCBlbGVtZW50LCBcInByZXZpb3VzVmFsdWVcIiwge1xuXHRcdFx0XHRvbGQ6IG51bGwsXG5cdFx0XHRcdHZhbGlkOiB0cnVlLFxuXHRcdFx0XHRtZXNzYWdlOiB0aGlzLmRlZmF1bHRNZXNzYWdlKCBlbGVtZW50LCB7IG1ldGhvZDogbWV0aG9kIH0gKVxuXHRcdFx0fSApO1xuXHRcdH0sXG5cblx0XHQvLyBDbGVhbnMgdXAgYWxsIGZvcm1zIGFuZCBlbGVtZW50cywgcmVtb3ZlcyB2YWxpZGF0b3Itc3BlY2lmaWMgZXZlbnRzXG5cdFx0ZGVzdHJveTogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLnJlc2V0Rm9ybSgpO1xuXG5cdFx0XHQkKCB0aGlzLmN1cnJlbnRGb3JtIClcblx0XHRcdFx0Lm9mZiggXCIudmFsaWRhdGVcIiApXG5cdFx0XHRcdC5yZW1vdmVEYXRhKCBcInZhbGlkYXRvclwiIClcblx0XHRcdFx0LmZpbmQoIFwiLnZhbGlkYXRlLWVxdWFsVG8tYmx1clwiIClcblx0XHRcdFx0XHQub2ZmKCBcIi52YWxpZGF0ZS1lcXVhbFRvXCIgKVxuXHRcdFx0XHRcdC5yZW1vdmVDbGFzcyggXCJ2YWxpZGF0ZS1lcXVhbFRvLWJsdXJcIiApXG5cdFx0XHRcdC5maW5kKCBcIi52YWxpZGF0ZS1sZXNzVGhhbi1ibHVyXCIgKVxuXHRcdFx0XHRcdC5vZmYoIFwiLnZhbGlkYXRlLWxlc3NUaGFuXCIgKVxuXHRcdFx0XHRcdC5yZW1vdmVDbGFzcyggXCJ2YWxpZGF0ZS1sZXNzVGhhbi1ibHVyXCIgKVxuXHRcdFx0XHQuZmluZCggXCIudmFsaWRhdGUtbGVzc1RoYW5FcXVhbC1ibHVyXCIgKVxuXHRcdFx0XHRcdC5vZmYoIFwiLnZhbGlkYXRlLWxlc3NUaGFuRXF1YWxcIiApXG5cdFx0XHRcdFx0LnJlbW92ZUNsYXNzKCBcInZhbGlkYXRlLWxlc3NUaGFuRXF1YWwtYmx1clwiIClcblx0XHRcdFx0LmZpbmQoIFwiLnZhbGlkYXRlLWdyZWF0ZXJUaGFuRXF1YWwtYmx1clwiIClcblx0XHRcdFx0XHQub2ZmKCBcIi52YWxpZGF0ZS1ncmVhdGVyVGhhbkVxdWFsXCIgKVxuXHRcdFx0XHRcdC5yZW1vdmVDbGFzcyggXCJ2YWxpZGF0ZS1ncmVhdGVyVGhhbkVxdWFsLWJsdXJcIiApXG5cdFx0XHRcdC5maW5kKCBcIi52YWxpZGF0ZS1ncmVhdGVyVGhhbi1ibHVyXCIgKVxuXHRcdFx0XHRcdC5vZmYoIFwiLnZhbGlkYXRlLWdyZWF0ZXJUaGFuXCIgKVxuXHRcdFx0XHRcdC5yZW1vdmVDbGFzcyggXCJ2YWxpZGF0ZS1ncmVhdGVyVGhhbi1ibHVyXCIgKTtcblx0XHR9XG5cblx0fSxcblxuXHRjbGFzc1J1bGVTZXR0aW5nczoge1xuXHRcdHJlcXVpcmVkOiB7IHJlcXVpcmVkOiB0cnVlIH0sXG5cdFx0ZW1haWw6IHsgZW1haWw6IHRydWUgfSxcblx0XHR1cmw6IHsgdXJsOiB0cnVlIH0sXG5cdFx0ZGF0ZTogeyBkYXRlOiB0cnVlIH0sXG5cdFx0ZGF0ZUlTTzogeyBkYXRlSVNPOiB0cnVlIH0sXG5cdFx0bnVtYmVyOiB7IG51bWJlcjogdHJ1ZSB9LFxuXHRcdGRpZ2l0czogeyBkaWdpdHM6IHRydWUgfSxcblx0XHRjcmVkaXRjYXJkOiB7IGNyZWRpdGNhcmQ6IHRydWUgfVxuXHR9LFxuXG5cdGFkZENsYXNzUnVsZXM6IGZ1bmN0aW9uKCBjbGFzc05hbWUsIHJ1bGVzICkge1xuXHRcdGlmICggY2xhc3NOYW1lLmNvbnN0cnVjdG9yID09PSBTdHJpbmcgKSB7XG5cdFx0XHR0aGlzLmNsYXNzUnVsZVNldHRpbmdzWyBjbGFzc05hbWUgXSA9IHJ1bGVzO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQkLmV4dGVuZCggdGhpcy5jbGFzc1J1bGVTZXR0aW5ncywgY2xhc3NOYW1lICk7XG5cdFx0fVxuXHR9LFxuXG5cdGNsYXNzUnVsZXM6IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuXHRcdHZhciBydWxlcyA9IHt9LFxuXHRcdFx0Y2xhc3NlcyA9ICQoIGVsZW1lbnQgKS5hdHRyKCBcImNsYXNzXCIgKTtcblxuXHRcdGlmICggY2xhc3NlcyApIHtcblx0XHRcdCQuZWFjaCggY2xhc3Nlcy5zcGxpdCggXCIgXCIgKSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggdGhpcyBpbiAkLnZhbGlkYXRvci5jbGFzc1J1bGVTZXR0aW5ncyApIHtcblx0XHRcdFx0XHQkLmV4dGVuZCggcnVsZXMsICQudmFsaWRhdG9yLmNsYXNzUnVsZVNldHRpbmdzWyB0aGlzIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH1cblx0XHRyZXR1cm4gcnVsZXM7XG5cdH0sXG5cblx0bm9ybWFsaXplQXR0cmlidXRlUnVsZTogZnVuY3Rpb24oIHJ1bGVzLCB0eXBlLCBtZXRob2QsIHZhbHVlICkge1xuXG5cdFx0Ly8gQ29udmVydCB0aGUgdmFsdWUgdG8gYSBudW1iZXIgZm9yIG51bWJlciBpbnB1dHMsIGFuZCBmb3IgdGV4dCBmb3IgYmFja3dhcmRzIGNvbXBhYmlsaXR5XG5cdFx0Ly8gYWxsb3dzIHR5cGU9XCJkYXRlXCIgYW5kIG90aGVycyB0byBiZSBjb21wYXJlZCBhcyBzdHJpbmdzXG5cdFx0aWYgKCAvbWlufG1heHxzdGVwLy50ZXN0KCBtZXRob2QgKSAmJiAoIHR5cGUgPT09IG51bGwgfHwgL251bWJlcnxyYW5nZXx0ZXh0Ly50ZXN0KCB0eXBlICkgKSApIHtcblx0XHRcdHZhbHVlID0gTnVtYmVyKCB2YWx1ZSApO1xuXG5cdFx0XHQvLyBTdXBwb3J0IE9wZXJhIE1pbmksIHdoaWNoIHJldHVybnMgTmFOIGZvciB1bmRlZmluZWQgbWlubGVuZ3RoXG5cdFx0XHRpZiAoIGlzTmFOKCB2YWx1ZSApICkge1xuXHRcdFx0XHR2YWx1ZSA9IHVuZGVmaW5lZDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIHZhbHVlIHx8IHZhbHVlID09PSAwICkge1xuXHRcdFx0cnVsZXNbIG1ldGhvZCBdID0gdmFsdWU7XG5cdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gbWV0aG9kICYmIHR5cGUgIT09IFwicmFuZ2VcIiApIHtcblxuXHRcdFx0Ly8gRXhjZXB0aW9uOiB0aGUganF1ZXJ5IHZhbGlkYXRlICdyYW5nZScgbWV0aG9kXG5cdFx0XHQvLyBkb2VzIG5vdCB0ZXN0IGZvciB0aGUgaHRtbDUgJ3JhbmdlJyB0eXBlXG5cdFx0XHRydWxlc1sgdHlwZSA9PT0gXCJkYXRlXCIgPyBcImRhdGVJU09cIiA6IG1ldGhvZCBdID0gdHJ1ZTtcblx0XHR9XG5cdH0sXG5cblx0YXR0cmlidXRlUnVsZXM6IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuXHRcdHZhciBydWxlcyA9IHt9LFxuXHRcdFx0JGVsZW1lbnQgPSAkKCBlbGVtZW50ICksXG5cdFx0XHR0eXBlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoIFwidHlwZVwiICksXG5cdFx0XHRtZXRob2QsIHZhbHVlO1xuXG5cdFx0Zm9yICggbWV0aG9kIGluICQudmFsaWRhdG9yLm1ldGhvZHMgKSB7XG5cblx0XHRcdC8vIFN1cHBvcnQgZm9yIDxpbnB1dCByZXF1aXJlZD4gaW4gYm90aCBodG1sNSBhbmQgb2xkZXIgYnJvd3NlcnNcblx0XHRcdGlmICggbWV0aG9kID09PSBcInJlcXVpcmVkXCIgKSB7XG5cdFx0XHRcdHZhbHVlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoIG1ldGhvZCApO1xuXG5cdFx0XHRcdC8vIFNvbWUgYnJvd3NlcnMgcmV0dXJuIGFuIGVtcHR5IHN0cmluZyBmb3IgdGhlIHJlcXVpcmVkIGF0dHJpYnV0ZVxuXHRcdFx0XHQvLyBhbmQgbm9uLUhUTUw1IGJyb3dzZXJzIG1pZ2h0IGhhdmUgcmVxdWlyZWQ9XCJcIiBtYXJrdXBcblx0XHRcdFx0aWYgKCB2YWx1ZSA9PT0gXCJcIiApIHtcblx0XHRcdFx0XHR2YWx1ZSA9IHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBGb3JjZSBub24tSFRNTDUgYnJvd3NlcnMgdG8gcmV0dXJuIGJvb2xcblx0XHRcdFx0dmFsdWUgPSAhIXZhbHVlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFsdWUgPSAkZWxlbWVudC5hdHRyKCBtZXRob2QgKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5ub3JtYWxpemVBdHRyaWJ1dGVSdWxlKCBydWxlcywgdHlwZSwgbWV0aG9kLCB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdC8vICdtYXhsZW5ndGgnIG1heSBiZSByZXR1cm5lZCBhcyAtMSwgMjE0NzQ4MzY0NyAoIElFICkgYW5kIDUyNDI4OCAoIHNhZmFyaSApIGZvciB0ZXh0IGlucHV0c1xuXHRcdGlmICggcnVsZXMubWF4bGVuZ3RoICYmIC8tMXwyMTQ3NDgzNjQ3fDUyNDI4OC8udGVzdCggcnVsZXMubWF4bGVuZ3RoICkgKSB7XG5cdFx0XHRkZWxldGUgcnVsZXMubWF4bGVuZ3RoO1xuXHRcdH1cblxuXHRcdHJldHVybiBydWxlcztcblx0fSxcblxuXHRkYXRhUnVsZXM6IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuXHRcdHZhciBydWxlcyA9IHt9LFxuXHRcdFx0JGVsZW1lbnQgPSAkKCBlbGVtZW50ICksXG5cdFx0XHR0eXBlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoIFwidHlwZVwiICksXG5cdFx0XHRtZXRob2QsIHZhbHVlO1xuXG5cdFx0Zm9yICggbWV0aG9kIGluICQudmFsaWRhdG9yLm1ldGhvZHMgKSB7XG5cdFx0XHR2YWx1ZSA9ICRlbGVtZW50LmRhdGEoIFwicnVsZVwiICsgbWV0aG9kLmNoYXJBdCggMCApLnRvVXBwZXJDYXNlKCkgKyBtZXRob2Quc3Vic3RyaW5nKCAxICkudG9Mb3dlckNhc2UoKSApO1xuXG5cdFx0XHQvLyBDYXN0IGVtcHR5IGF0dHJpYnV0ZXMgbGlrZSBgZGF0YS1ydWxlLXJlcXVpcmVkYCB0byBgdHJ1ZWBcblx0XHRcdGlmICggdmFsdWUgPT09IFwiXCIgKSB7XG5cdFx0XHRcdHZhbHVlID0gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5ub3JtYWxpemVBdHRyaWJ1dGVSdWxlKCBydWxlcywgdHlwZSwgbWV0aG9kLCB2YWx1ZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gcnVsZXM7XG5cdH0sXG5cblx0c3RhdGljUnVsZXM6IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuXHRcdHZhciBydWxlcyA9IHt9LFxuXHRcdFx0dmFsaWRhdG9yID0gJC5kYXRhKCBlbGVtZW50LmZvcm0sIFwidmFsaWRhdG9yXCIgKTtcblxuXHRcdGlmICggdmFsaWRhdG9yLnNldHRpbmdzLnJ1bGVzICkge1xuXHRcdFx0cnVsZXMgPSAkLnZhbGlkYXRvci5ub3JtYWxpemVSdWxlKCB2YWxpZGF0b3Iuc2V0dGluZ3MucnVsZXNbIGVsZW1lbnQubmFtZSBdICkgfHwge307XG5cdFx0fVxuXHRcdHJldHVybiBydWxlcztcblx0fSxcblxuXHRub3JtYWxpemVSdWxlczogZnVuY3Rpb24oIHJ1bGVzLCBlbGVtZW50ICkge1xuXG5cdFx0Ly8gSGFuZGxlIGRlcGVuZGVuY3kgY2hlY2tcblx0XHQkLmVhY2goIHJ1bGVzLCBmdW5jdGlvbiggcHJvcCwgdmFsICkge1xuXG5cdFx0XHQvLyBJZ25vcmUgcnVsZSB3aGVuIHBhcmFtIGlzIGV4cGxpY2l0bHkgZmFsc2UsIGVnLiByZXF1aXJlZDpmYWxzZVxuXHRcdFx0aWYgKCB2YWwgPT09IGZhbHNlICkge1xuXHRcdFx0XHRkZWxldGUgcnVsZXNbIHByb3AgXTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB2YWwucGFyYW0gfHwgdmFsLmRlcGVuZHMgKSB7XG5cdFx0XHRcdHZhciBrZWVwUnVsZSA9IHRydWU7XG5cdFx0XHRcdHN3aXRjaCAoIHR5cGVvZiB2YWwuZGVwZW5kcyApIHtcblx0XHRcdFx0Y2FzZSBcInN0cmluZ1wiOlxuXHRcdFx0XHRcdGtlZXBSdWxlID0gISEkKCB2YWwuZGVwZW5kcywgZWxlbWVudC5mb3JtICkubGVuZ3RoO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIFwiZnVuY3Rpb25cIjpcblx0XHRcdFx0XHRrZWVwUnVsZSA9IHZhbC5kZXBlbmRzLmNhbGwoIGVsZW1lbnQsIGVsZW1lbnQgKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIGtlZXBSdWxlICkge1xuXHRcdFx0XHRcdHJ1bGVzWyBwcm9wIF0gPSB2YWwucGFyYW0gIT09IHVuZGVmaW5lZCA/IHZhbC5wYXJhbSA6IHRydWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0JC5kYXRhKCBlbGVtZW50LmZvcm0sIFwidmFsaWRhdG9yXCIgKS5yZXNldEVsZW1lbnRzKCAkKCBlbGVtZW50ICkgKTtcblx0XHRcdFx0XHRkZWxldGUgcnVsZXNbIHByb3AgXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblxuXHRcdC8vIEV2YWx1YXRlIHBhcmFtZXRlcnNcblx0XHQkLmVhY2goIHJ1bGVzLCBmdW5jdGlvbiggcnVsZSwgcGFyYW1ldGVyICkge1xuXHRcdFx0cnVsZXNbIHJ1bGUgXSA9IHR5cGVvZiBwYXJhbWV0ZXIgPT09IFwiZnVuY3Rpb25cIiAmJiBydWxlICE9PSBcIm5vcm1hbGl6ZXJcIiA/IHBhcmFtZXRlciggZWxlbWVudCApIDogcGFyYW1ldGVyO1xuXHRcdH0gKTtcblxuXHRcdC8vIENsZWFuIG51bWJlciBwYXJhbWV0ZXJzXG5cdFx0JC5lYWNoKCBbIFwibWlubGVuZ3RoXCIsIFwibWF4bGVuZ3RoXCIgXSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIHJ1bGVzWyB0aGlzIF0gKSB7XG5cdFx0XHRcdHJ1bGVzWyB0aGlzIF0gPSBOdW1iZXIoIHJ1bGVzWyB0aGlzIF0gKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdFx0JC5lYWNoKCBbIFwicmFuZ2VsZW5ndGhcIiwgXCJyYW5nZVwiIF0sIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHBhcnRzO1xuXHRcdFx0aWYgKCBydWxlc1sgdGhpcyBdICkge1xuXHRcdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHJ1bGVzWyB0aGlzIF0gKSApIHtcblx0XHRcdFx0XHRydWxlc1sgdGhpcyBdID0gWyBOdW1iZXIoIHJ1bGVzWyB0aGlzIF1bIDAgXSApLCBOdW1iZXIoIHJ1bGVzWyB0aGlzIF1bIDEgXSApIF07XG5cdFx0XHRcdH0gZWxzZSBpZiAoIHR5cGVvZiBydWxlc1sgdGhpcyBdID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0XHRcdHBhcnRzID0gcnVsZXNbIHRoaXMgXS5yZXBsYWNlKCAvW1xcW1xcXV0vZywgXCJcIiApLnNwbGl0KCAvW1xccyxdKy8gKTtcblx0XHRcdFx0XHRydWxlc1sgdGhpcyBdID0gWyBOdW1iZXIoIHBhcnRzWyAwIF0gKSwgTnVtYmVyKCBwYXJ0c1sgMSBdICkgXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblxuXHRcdGlmICggJC52YWxpZGF0b3IuYXV0b0NyZWF0ZVJhbmdlcyApIHtcblxuXHRcdFx0Ly8gQXV0by1jcmVhdGUgcmFuZ2VzXG5cdFx0XHRpZiAoIHJ1bGVzLm1pbiAhPSBudWxsICYmIHJ1bGVzLm1heCAhPSBudWxsICkge1xuXHRcdFx0XHRydWxlcy5yYW5nZSA9IFsgcnVsZXMubWluLCBydWxlcy5tYXggXTtcblx0XHRcdFx0ZGVsZXRlIHJ1bGVzLm1pbjtcblx0XHRcdFx0ZGVsZXRlIHJ1bGVzLm1heDtcblx0XHRcdH1cblx0XHRcdGlmICggcnVsZXMubWlubGVuZ3RoICE9IG51bGwgJiYgcnVsZXMubWF4bGVuZ3RoICE9IG51bGwgKSB7XG5cdFx0XHRcdHJ1bGVzLnJhbmdlbGVuZ3RoID0gWyBydWxlcy5taW5sZW5ndGgsIHJ1bGVzLm1heGxlbmd0aCBdO1xuXHRcdFx0XHRkZWxldGUgcnVsZXMubWlubGVuZ3RoO1xuXHRcdFx0XHRkZWxldGUgcnVsZXMubWF4bGVuZ3RoO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBydWxlcztcblx0fSxcblxuXHQvLyBDb252ZXJ0cyBhIHNpbXBsZSBzdHJpbmcgdG8gYSB7c3RyaW5nOiB0cnVlfSBydWxlLCBlLmcuLCBcInJlcXVpcmVkXCIgdG8ge3JlcXVpcmVkOnRydWV9XG5cdG5vcm1hbGl6ZVJ1bGU6IGZ1bmN0aW9uKCBkYXRhICkge1xuXHRcdGlmICggdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHR2YXIgdHJhbnNmb3JtZWQgPSB7fTtcblx0XHRcdCQuZWFjaCggZGF0YS5zcGxpdCggL1xccy8gKSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRyYW5zZm9ybWVkWyB0aGlzIF0gPSB0cnVlO1xuXHRcdFx0fSApO1xuXHRcdFx0ZGF0YSA9IHRyYW5zZm9ybWVkO1xuXHRcdH1cblx0XHRyZXR1cm4gZGF0YTtcblx0fSxcblxuXHQvLyBodHRwczovL2pxdWVyeXZhbGlkYXRpb24ub3JnL2pRdWVyeS52YWxpZGF0b3IuYWRkTWV0aG9kL1xuXHRhZGRNZXRob2Q6IGZ1bmN0aW9uKCBuYW1lLCBtZXRob2QsIG1lc3NhZ2UgKSB7XG5cdFx0JC52YWxpZGF0b3IubWV0aG9kc1sgbmFtZSBdID0gbWV0aG9kO1xuXHRcdCQudmFsaWRhdG9yLm1lc3NhZ2VzWyBuYW1lIF0gPSBtZXNzYWdlICE9PSB1bmRlZmluZWQgPyBtZXNzYWdlIDogJC52YWxpZGF0b3IubWVzc2FnZXNbIG5hbWUgXTtcblx0XHRpZiAoIG1ldGhvZC5sZW5ndGggPCAzICkge1xuXHRcdFx0JC52YWxpZGF0b3IuYWRkQ2xhc3NSdWxlcyggbmFtZSwgJC52YWxpZGF0b3Iubm9ybWFsaXplUnVsZSggbmFtZSApICk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIGh0dHBzOi8vanF1ZXJ5dmFsaWRhdGlvbi5vcmcvalF1ZXJ5LnZhbGlkYXRvci5tZXRob2RzL1xuXHRtZXRob2RzOiB7XG5cblx0XHQvLyBodHRwczovL2pxdWVyeXZhbGlkYXRpb24ub3JnL3JlcXVpcmVkLW1ldGhvZC9cblx0XHRyZXF1aXJlZDogZnVuY3Rpb24oIHZhbHVlLCBlbGVtZW50LCBwYXJhbSApIHtcblxuXHRcdFx0Ly8gQ2hlY2sgaWYgZGVwZW5kZW5jeSBpcyBtZXRcblx0XHRcdGlmICggIXRoaXMuZGVwZW5kKCBwYXJhbSwgZWxlbWVudCApICkge1xuXHRcdFx0XHRyZXR1cm4gXCJkZXBlbmRlbmN5LW1pc21hdGNoXCI7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJzZWxlY3RcIiApIHtcblxuXHRcdFx0XHQvLyBDb3VsZCBiZSBhbiBhcnJheSBmb3Igc2VsZWN0LW11bHRpcGxlIG9yIGEgc3RyaW5nLCBib3RoIGFyZSBmaW5lIHRoaXMgd2F5XG5cdFx0XHRcdHZhciB2YWwgPSAkKCBlbGVtZW50ICkudmFsKCk7XG5cdFx0XHRcdHJldHVybiB2YWwgJiYgdmFsLmxlbmd0aCA+IDA7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHRoaXMuY2hlY2thYmxlKCBlbGVtZW50ICkgKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmdldExlbmd0aCggdmFsdWUsIGVsZW1lbnQgKSA+IDA7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZS5sZW5ndGggPiAwO1xuXHRcdH0sXG5cblx0XHQvLyBodHRwczovL2pxdWVyeXZhbGlkYXRpb24ub3JnL2VtYWlsLW1ldGhvZC9cblx0XHRlbWFpbDogZnVuY3Rpb24oIHZhbHVlLCBlbGVtZW50ICkge1xuXG5cdFx0XHQvLyBGcm9tIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjdmFsaWQtZS1tYWlsLWFkZHJlc3Ncblx0XHRcdC8vIFJldHJpZXZlZCAyMDE0LTAxLTE0XG5cdFx0XHQvLyBJZiB5b3UgaGF2ZSBhIHByb2JsZW0gd2l0aCB0aGlzIGltcGxlbWVudGF0aW9uLCByZXBvcnQgYSBidWcgYWdhaW5zdCB0aGUgYWJvdmUgc3BlY1xuXHRcdFx0Ly8gT3IgdXNlIGN1c3RvbSBtZXRob2RzIHRvIGltcGxlbWVudCB5b3VyIG93biBlbWFpbCB2YWxpZGF0aW9uXG5cdFx0XHRyZXR1cm4gdGhpcy5vcHRpb25hbCggZWxlbWVudCApIHx8IC9eW2EtekEtWjAtOS4hIyQlJicqK1xcLz0/Xl9ge3x9fi1dK0BbYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8oPzpcXC5bYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8pKiQvLnRlc3QoIHZhbHVlICk7XG5cdFx0fSxcblxuXHRcdC8vIGh0dHBzOi8vanF1ZXJ5dmFsaWRhdGlvbi5vcmcvdXJsLW1ldGhvZC9cblx0XHR1cmw6IGZ1bmN0aW9uKCB2YWx1ZSwgZWxlbWVudCApIHtcblxuXHRcdFx0Ly8gQ29weXJpZ2h0IChjKSAyMDEwLTIwMTMgRGllZ28gUGVyaW5pLCBNSVQgbGljZW5zZWRcblx0XHRcdC8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL2RwZXJpbmkvNzI5Mjk0XG5cdFx0XHQvLyBzZWUgYWxzbyBodHRwczovL21hdGhpYXNieW5lbnMuYmUvZGVtby91cmwtcmVnZXhcblx0XHRcdC8vIG1vZGlmaWVkIHRvIGFsbG93IHByb3RvY29sLXJlbGF0aXZlIFVSTHNcblx0XHRcdHJldHVybiB0aGlzLm9wdGlvbmFsKCBlbGVtZW50ICkgfHwgL14oPzooPzooPzpodHRwcz98ZnRwKTopP1xcL1xcLykoPzooPzpbXlxcXVxcWz9cXC88fiNgIUAkXiYqKCkrPX18OlwiOycsPnsgXXwlWzAtOUEtRmEtZl17Mn0pKyg/OjooPzpbXlxcXVxcWz9cXC88fiNgIUAkXiYqKCkrPX18OlwiOycsPnsgXXwlWzAtOUEtRmEtZl17Mn0pKik/QCk/KD86KD8hKD86MTB8MTI3KSg/OlxcLlxcZHsxLDN9KXszfSkoPyEoPzoxNjlcXC4yNTR8MTkyXFwuMTY4KSg/OlxcLlxcZHsxLDN9KXsyfSkoPyExNzJcXC4oPzoxWzYtOV18MlxcZHwzWzAtMV0pKD86XFwuXFxkezEsM30pezJ9KSg/OlsxLTldXFxkP3wxXFxkXFxkfDJbMDFdXFxkfDIyWzAtM10pKD86XFwuKD86MT9cXGR7MSwyfXwyWzAtNF1cXGR8MjVbMC01XSkpezJ9KD86XFwuKD86WzEtOV1cXGQ/fDFcXGRcXGR8MlswLTRdXFxkfDI1WzAtNF0pKXwoPzooPzpbYS16MC05XFx1MDBhMS1cXHVmZmZmXVthLXowLTlcXHUwMGExLVxcdWZmZmZfLV17MCw2Mn0pP1thLXowLTlcXHUwMGExLVxcdWZmZmZdXFwuKSsoPzpbYS16XFx1MDBhMS1cXHVmZmZmXXsyLH1cXC4/KSkoPzo6XFxkezIsNX0pPyg/OlsvPyNdXFxTKik/JC9pLnRlc3QoIHZhbHVlICk7XG5cdFx0fSxcblxuXHRcdC8vIGh0dHBzOi8vanF1ZXJ5dmFsaWRhdGlvbi5vcmcvZGF0ZS1tZXRob2QvXG5cdFx0ZGF0ZTogKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBjYWxsZWQgPSBmYWxzZTtcblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCB2YWx1ZSwgZWxlbWVudCApIHtcblx0XHRcdFx0aWYgKCAhY2FsbGVkICkge1xuXHRcdFx0XHRcdGNhbGxlZCA9IHRydWU7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLnNldHRpbmdzLmRlYnVnICYmIHdpbmRvdy5jb25zb2xlICkge1xuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKFxuXHRcdFx0XHRcdFx0XHRcIlRoZSBgZGF0ZWAgbWV0aG9kIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB2ZXJzaW9uICcyLjAuMCcuXFxuXCIgK1xuXHRcdFx0XHRcdFx0XHRcIlBsZWFzZSBkb24ndCB1c2UgaXQsIHNpbmNlIGl0IHJlbGllcyBvbiB0aGUgRGF0ZSBjb25zdHJ1Y3Rvciwgd2hpY2hcXG5cIiArXG5cdFx0XHRcdFx0XHRcdFwiYmVoYXZlcyB2ZXJ5IGRpZmZlcmVudGx5IGFjcm9zcyBicm93c2VycyBhbmQgbG9jYWxlcy4gVXNlIGBkYXRlSVNPYFxcblwiICtcblx0XHRcdFx0XHRcdFx0XCJpbnN0ZWFkIG9yIG9uZSBvZiB0aGUgbG9jYWxlIHNwZWNpZmljIG1ldGhvZHMgaW4gYGxvY2FsaXphdGlvbnMvYFxcblwiICtcblx0XHRcdFx0XHRcdFx0XCJhbmQgYGFkZGl0aW9uYWwtbWV0aG9kcy5qc2AuXCJcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHRoaXMub3B0aW9uYWwoIGVsZW1lbnQgKSB8fCAhL0ludmFsaWR8TmFOLy50ZXN0KCBuZXcgRGF0ZSggdmFsdWUgKS50b1N0cmluZygpICk7XG5cdFx0XHR9O1xuXHRcdH0oKSApLFxuXG5cdFx0Ly8gaHR0cHM6Ly9qcXVlcnl2YWxpZGF0aW9uLm9yZy9kYXRlSVNPLW1ldGhvZC9cblx0XHRkYXRlSVNPOiBmdW5jdGlvbiggdmFsdWUsIGVsZW1lbnQgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5vcHRpb25hbCggZWxlbWVudCApIHx8IC9eXFxkezR9W1xcL1xcLV0oMD9bMS05XXwxWzAxMl0pW1xcL1xcLV0oMD9bMS05XXxbMTJdWzAtOV18M1swMV0pJC8udGVzdCggdmFsdWUgKTtcblx0XHR9LFxuXG5cdFx0Ly8gaHR0cHM6Ly9qcXVlcnl2YWxpZGF0aW9uLm9yZy9udW1iZXItbWV0aG9kL1xuXHRcdG51bWJlcjogZnVuY3Rpb24oIHZhbHVlLCBlbGVtZW50ICkge1xuXHRcdFx0cmV0dXJuIHRoaXMub3B0aW9uYWwoIGVsZW1lbnQgKSB8fCAvXig/Oi0/XFxkK3wtP1xcZHsxLDN9KD86LFxcZHszfSkrKT8oPzpcXC5cXGQrKT8kLy50ZXN0KCB2YWx1ZSApO1xuXHRcdH0sXG5cblx0XHQvLyBodHRwczovL2pxdWVyeXZhbGlkYXRpb24ub3JnL2RpZ2l0cy1tZXRob2QvXG5cdFx0ZGlnaXRzOiBmdW5jdGlvbiggdmFsdWUsIGVsZW1lbnQgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5vcHRpb25hbCggZWxlbWVudCApIHx8IC9eXFxkKyQvLnRlc3QoIHZhbHVlICk7XG5cdFx0fSxcblxuXHRcdC8vIGh0dHBzOi8vanF1ZXJ5dmFsaWRhdGlvbi5vcmcvbWlubGVuZ3RoLW1ldGhvZC9cblx0XHRtaW5sZW5ndGg6IGZ1bmN0aW9uKCB2YWx1ZSwgZWxlbWVudCwgcGFyYW0gKSB7XG5cdFx0XHR2YXIgbGVuZ3RoID0gQXJyYXkuaXNBcnJheSggdmFsdWUgKSA/IHZhbHVlLmxlbmd0aCA6IHRoaXMuZ2V0TGVuZ3RoKCB2YWx1ZSwgZWxlbWVudCApO1xuXHRcdFx0cmV0dXJuIHRoaXMub3B0aW9uYWwoIGVsZW1lbnQgKSB8fCBsZW5ndGggPj0gcGFyYW07XG5cdFx0fSxcblxuXHRcdC8vIGh0dHBzOi8vanF1ZXJ5dmFsaWRhdGlvbi5vcmcvbWF4bGVuZ3RoLW1ldGhvZC9cblx0XHRtYXhsZW5ndGg6IGZ1bmN0aW9uKCB2YWx1ZSwgZWxlbWVudCwgcGFyYW0gKSB7XG5cdFx0XHR2YXIgbGVuZ3RoID0gQXJyYXkuaXNBcnJheSggdmFsdWUgKSA/IHZhbHVlLmxlbmd0aCA6IHRoaXMuZ2V0TGVuZ3RoKCB2YWx1ZSwgZWxlbWVudCApO1xuXHRcdFx0cmV0dXJuIHRoaXMub3B0aW9uYWwoIGVsZW1lbnQgKSB8fCBsZW5ndGggPD0gcGFyYW07XG5cdFx0fSxcblxuXHRcdC8vIGh0dHBzOi8vanF1ZXJ5dmFsaWRhdGlvbi5vcmcvcmFuZ2VsZW5ndGgtbWV0aG9kL1xuXHRcdHJhbmdlbGVuZ3RoOiBmdW5jdGlvbiggdmFsdWUsIGVsZW1lbnQsIHBhcmFtICkge1xuXHRcdFx0dmFyIGxlbmd0aCA9IEFycmF5LmlzQXJyYXkoIHZhbHVlICkgPyB2YWx1ZS5sZW5ndGggOiB0aGlzLmdldExlbmd0aCggdmFsdWUsIGVsZW1lbnQgKTtcblx0XHRcdHJldHVybiB0aGlzLm9wdGlvbmFsKCBlbGVtZW50ICkgfHwgKCBsZW5ndGggPj0gcGFyYW1bIDAgXSAmJiBsZW5ndGggPD0gcGFyYW1bIDEgXSApO1xuXHRcdH0sXG5cblx0XHQvLyBodHRwczovL2pxdWVyeXZhbGlkYXRpb24ub3JnL21pbi1tZXRob2QvXG5cdFx0bWluOiBmdW5jdGlvbiggdmFsdWUsIGVsZW1lbnQsIHBhcmFtICkge1xuXHRcdFx0cmV0dXJuIHRoaXMub3B0aW9uYWwoIGVsZW1lbnQgKSB8fCB2YWx1ZSA+PSBwYXJhbTtcblx0XHR9LFxuXG5cdFx0Ly8gaHR0cHM6Ly9qcXVlcnl2YWxpZGF0aW9uLm9yZy9tYXgtbWV0aG9kL1xuXHRcdG1heDogZnVuY3Rpb24oIHZhbHVlLCBlbGVtZW50LCBwYXJhbSApIHtcblx0XHRcdHJldHVybiB0aGlzLm9wdGlvbmFsKCBlbGVtZW50ICkgfHwgdmFsdWUgPD0gcGFyYW07XG5cdFx0fSxcblxuXHRcdC8vIGh0dHBzOi8vanF1ZXJ5dmFsaWRhdGlvbi5vcmcvcmFuZ2UtbWV0aG9kL1xuXHRcdHJhbmdlOiBmdW5jdGlvbiggdmFsdWUsIGVsZW1lbnQsIHBhcmFtICkge1xuXHRcdFx0cmV0dXJuIHRoaXMub3B0aW9uYWwoIGVsZW1lbnQgKSB8fCAoIHZhbHVlID49IHBhcmFtWyAwIF0gJiYgdmFsdWUgPD0gcGFyYW1bIDEgXSApO1xuXHRcdH0sXG5cblx0XHQvLyBodHRwczovL2pxdWVyeXZhbGlkYXRpb24ub3JnL3N0ZXAtbWV0aG9kL1xuXHRcdHN0ZXA6IGZ1bmN0aW9uKCB2YWx1ZSwgZWxlbWVudCwgcGFyYW0gKSB7XG5cdFx0XHR2YXIgdHlwZSA9ICQoIGVsZW1lbnQgKS5hdHRyKCBcInR5cGVcIiApLFxuXHRcdFx0XHRlcnJvck1lc3NhZ2UgPSBcIlN0ZXAgYXR0cmlidXRlIG9uIGlucHV0IHR5cGUgXCIgKyB0eXBlICsgXCIgaXMgbm90IHN1cHBvcnRlZC5cIixcblx0XHRcdFx0c3VwcG9ydGVkVHlwZXMgPSBbIFwidGV4dFwiLCBcIm51bWJlclwiLCBcInJhbmdlXCIgXSxcblx0XHRcdFx0cmUgPSBuZXcgUmVnRXhwKCBcIlxcXFxiXCIgKyB0eXBlICsgXCJcXFxcYlwiICksXG5cdFx0XHRcdG5vdFN1cHBvcnRlZCA9IHR5cGUgJiYgIXJlLnRlc3QoIHN1cHBvcnRlZFR5cGVzLmpvaW4oKSApLFxuXHRcdFx0XHRkZWNpbWFsUGxhY2VzID0gZnVuY3Rpb24oIG51bSApIHtcblx0XHRcdFx0XHR2YXIgbWF0Y2ggPSAoIFwiXCIgKyBudW0gKS5tYXRjaCggLyg/OlxcLihcXGQrKSk/JC8gKTtcblx0XHRcdFx0XHRpZiAoICFtYXRjaCApIHtcblx0XHRcdFx0XHRcdHJldHVybiAwO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE51bWJlciBvZiBkaWdpdHMgcmlnaHQgb2YgZGVjaW1hbCBwb2ludC5cblx0XHRcdFx0XHRyZXR1cm4gbWF0Y2hbIDEgXSA/IG1hdGNoWyAxIF0ubGVuZ3RoIDogMDtcblx0XHRcdFx0fSxcblx0XHRcdFx0dG9JbnQgPSBmdW5jdGlvbiggbnVtICkge1xuXHRcdFx0XHRcdHJldHVybiBNYXRoLnJvdW5kKCBudW0gKiBNYXRoLnBvdyggMTAsIGRlY2ltYWxzICkgKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0dmFsaWQgPSB0cnVlLFxuXHRcdFx0XHRkZWNpbWFscztcblxuXHRcdFx0Ly8gV29ya3Mgb25seSBmb3IgdGV4dCwgbnVtYmVyIGFuZCByYW5nZSBpbnB1dCB0eXBlc1xuXHRcdFx0Ly8gVE9ETyBmaW5kIGEgd2F5IHRvIHN1cHBvcnQgaW5wdXQgdHlwZXMgZGF0ZSwgZGF0ZXRpbWUsIGRhdGV0aW1lLWxvY2FsLCBtb250aCwgdGltZSBhbmQgd2Vla1xuXHRcdFx0aWYgKCBub3RTdXBwb3J0ZWQgKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggZXJyb3JNZXNzYWdlICk7XG5cdFx0XHR9XG5cblx0XHRcdGRlY2ltYWxzID0gZGVjaW1hbFBsYWNlcyggcGFyYW0gKTtcblxuXHRcdFx0Ly8gVmFsdWUgY2FuJ3QgaGF2ZSB0b28gbWFueSBkZWNpbWFsc1xuXHRcdFx0aWYgKCBkZWNpbWFsUGxhY2VzKCB2YWx1ZSApID4gZGVjaW1hbHMgfHwgdG9JbnQoIHZhbHVlICkgJSB0b0ludCggcGFyYW0gKSAhPT0gMCApIHtcblx0XHRcdFx0dmFsaWQgPSBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXMub3B0aW9uYWwoIGVsZW1lbnQgKSB8fCB2YWxpZDtcblx0XHR9LFxuXG5cdFx0Ly8gaHR0cHM6Ly9qcXVlcnl2YWxpZGF0aW9uLm9yZy9lcXVhbFRvLW1ldGhvZC9cblx0XHRlcXVhbFRvOiBmdW5jdGlvbiggdmFsdWUsIGVsZW1lbnQsIHBhcmFtICkge1xuXG5cdFx0XHQvLyBCaW5kIHRvIHRoZSBibHVyIGV2ZW50IG9mIHRoZSB0YXJnZXQgaW4gb3JkZXIgdG8gcmV2YWxpZGF0ZSB3aGVuZXZlciB0aGUgdGFyZ2V0IGZpZWxkIGlzIHVwZGF0ZWRcblx0XHRcdHZhciB0YXJnZXQgPSAkKCBwYXJhbSApO1xuXHRcdFx0aWYgKCB0aGlzLnNldHRpbmdzLm9uZm9jdXNvdXQgJiYgdGFyZ2V0Lm5vdCggXCIudmFsaWRhdGUtZXF1YWxUby1ibHVyXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHRhcmdldC5hZGRDbGFzcyggXCJ2YWxpZGF0ZS1lcXVhbFRvLWJsdXJcIiApLm9uKCBcImJsdXIudmFsaWRhdGUtZXF1YWxUb1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHQkKCBlbGVtZW50ICkudmFsaWQoKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHZhbHVlID09PSB0YXJnZXQudmFsKCk7XG5cdFx0fSxcblxuXHRcdC8vIGh0dHBzOi8vanF1ZXJ5dmFsaWRhdGlvbi5vcmcvcmVtb3RlLW1ldGhvZC9cblx0XHRyZW1vdGU6IGZ1bmN0aW9uKCB2YWx1ZSwgZWxlbWVudCwgcGFyYW0sIG1ldGhvZCApIHtcblx0XHRcdGlmICggdGhpcy5vcHRpb25hbCggZWxlbWVudCApICkge1xuXHRcdFx0XHRyZXR1cm4gXCJkZXBlbmRlbmN5LW1pc21hdGNoXCI7XG5cdFx0XHR9XG5cblx0XHRcdG1ldGhvZCA9IHR5cGVvZiBtZXRob2QgPT09IFwic3RyaW5nXCIgJiYgbWV0aG9kIHx8IFwicmVtb3RlXCI7XG5cblx0XHRcdHZhciBwcmV2aW91cyA9IHRoaXMucHJldmlvdXNWYWx1ZSggZWxlbWVudCwgbWV0aG9kICksXG5cdFx0XHRcdHZhbGlkYXRvciwgZGF0YSwgb3B0aW9uRGF0YVN0cmluZztcblxuXHRcdFx0aWYgKCAhdGhpcy5zZXR0aW5ncy5tZXNzYWdlc1sgZWxlbWVudC5uYW1lIF0gKSB7XG5cdFx0XHRcdHRoaXMuc2V0dGluZ3MubWVzc2FnZXNbIGVsZW1lbnQubmFtZSBdID0ge307XG5cdFx0XHR9XG5cdFx0XHRwcmV2aW91cy5vcmlnaW5hbE1lc3NhZ2UgPSBwcmV2aW91cy5vcmlnaW5hbE1lc3NhZ2UgfHwgdGhpcy5zZXR0aW5ncy5tZXNzYWdlc1sgZWxlbWVudC5uYW1lIF1bIG1ldGhvZCBdO1xuXHRcdFx0dGhpcy5zZXR0aW5ncy5tZXNzYWdlc1sgZWxlbWVudC5uYW1lIF1bIG1ldGhvZCBdID0gcHJldmlvdXMubWVzc2FnZTtcblxuXHRcdFx0cGFyYW0gPSB0eXBlb2YgcGFyYW0gPT09IFwic3RyaW5nXCIgJiYgeyB1cmw6IHBhcmFtIH0gfHwgcGFyYW07XG5cdFx0XHRvcHRpb25EYXRhU3RyaW5nID0gJC5wYXJhbSggJC5leHRlbmQoIHsgZGF0YTogdmFsdWUgfSwgcGFyYW0uZGF0YSApICk7XG5cdFx0XHRpZiAoIHByZXZpb3VzLm9sZCA9PT0gb3B0aW9uRGF0YVN0cmluZyApIHtcblx0XHRcdFx0cmV0dXJuIHByZXZpb3VzLnZhbGlkO1xuXHRcdFx0fVxuXG5cdFx0XHRwcmV2aW91cy5vbGQgPSBvcHRpb25EYXRhU3RyaW5nO1xuXHRcdFx0dmFsaWRhdG9yID0gdGhpcztcblx0XHRcdHRoaXMuc3RhcnRSZXF1ZXN0KCBlbGVtZW50ICk7XG5cdFx0XHRkYXRhID0ge307XG5cdFx0XHRkYXRhWyBlbGVtZW50Lm5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0JC5hamF4KCAkLmV4dGVuZCggdHJ1ZSwge1xuXHRcdFx0XHRtb2RlOiBcImFib3J0XCIsXG5cdFx0XHRcdHBvcnQ6IHRoaXMuZWxlbWVudEFqYXhQb3J0KCBlbGVtZW50ICksXG5cdFx0XHRcdGRhdGFUeXBlOiBcImpzb25cIixcblx0XHRcdFx0ZGF0YTogZGF0YSxcblx0XHRcdFx0Y29udGV4dDogdmFsaWRhdG9yLmN1cnJlbnRGb3JtLFxuXHRcdFx0XHRzdWNjZXNzOiBmdW5jdGlvbiggcmVzcG9uc2UgKSB7XG5cdFx0XHRcdFx0dmFyIHZhbGlkID0gcmVzcG9uc2UgPT09IHRydWUgfHwgcmVzcG9uc2UgPT09IFwidHJ1ZVwiLFxuXHRcdFx0XHRcdFx0ZXJyb3JzLCBtZXNzYWdlLCBzdWJtaXR0ZWQ7XG5cblx0XHRcdFx0XHR2YWxpZGF0b3Iuc2V0dGluZ3MubWVzc2FnZXNbIGVsZW1lbnQubmFtZSBdWyBtZXRob2QgXSA9IHByZXZpb3VzLm9yaWdpbmFsTWVzc2FnZTtcblx0XHRcdFx0XHRpZiAoIHZhbGlkICkge1xuXHRcdFx0XHRcdFx0c3VibWl0dGVkID0gdmFsaWRhdG9yLmZvcm1TdWJtaXR0ZWQ7XG5cdFx0XHRcdFx0XHR2YWxpZGF0b3IudG9IaWRlID0gdmFsaWRhdG9yLmVycm9yc0ZvciggZWxlbWVudCApO1xuXHRcdFx0XHRcdFx0dmFsaWRhdG9yLmZvcm1TdWJtaXR0ZWQgPSBzdWJtaXR0ZWQ7XG5cdFx0XHRcdFx0XHR2YWxpZGF0b3Iuc3VjY2Vzc0xpc3QucHVzaCggZWxlbWVudCApO1xuXHRcdFx0XHRcdFx0dmFsaWRhdG9yLmludmFsaWRbIGVsZW1lbnQubmFtZSBdID0gZmFsc2U7XG5cdFx0XHRcdFx0XHR2YWxpZGF0b3Iuc2hvd0Vycm9ycygpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRlcnJvcnMgPSB7fTtcblx0XHRcdFx0XHRcdG1lc3NhZ2UgPSByZXNwb25zZSB8fCB2YWxpZGF0b3IuZGVmYXVsdE1lc3NhZ2UoIGVsZW1lbnQsIHsgbWV0aG9kOiBtZXRob2QsIHBhcmFtZXRlcnM6IHZhbHVlIH0gKTtcblx0XHRcdFx0XHRcdGVycm9yc1sgZWxlbWVudC5uYW1lIF0gPSBwcmV2aW91cy5tZXNzYWdlID0gbWVzc2FnZTtcblx0XHRcdFx0XHRcdHZhbGlkYXRvci5pbnZhbGlkWyBlbGVtZW50Lm5hbWUgXSA9IHRydWU7XG5cdFx0XHRcdFx0XHR2YWxpZGF0b3Iuc2hvd0Vycm9ycyggZXJyb3JzICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHByZXZpb3VzLnZhbGlkID0gdmFsaWQ7XG5cdFx0XHRcdFx0dmFsaWRhdG9yLnN0b3BSZXF1ZXN0KCBlbGVtZW50LCB2YWxpZCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9LCBwYXJhbSApICk7XG5cdFx0XHRyZXR1cm4gXCJwZW5kaW5nXCI7XG5cdFx0fVxuXHR9XG5cbn0gKTtcblxuLy8gQWpheCBtb2RlOiBhYm9ydFxuLy8gdXNhZ2U6ICQuYWpheCh7IG1vZGU6IFwiYWJvcnRcIlssIHBvcnQ6IFwidW5pcXVlcG9ydFwiXX0pO1xuLy8gICAgICAgICQuYWpheEFib3J0KCBwb3J0ICk7XG4vLyBpZiBtb2RlOlwiYWJvcnRcIiBpcyB1c2VkLCB0aGUgcHJldmlvdXMgcmVxdWVzdCBvbiB0aGF0IHBvcnQgKHBvcnQgY2FuIGJlIHVuZGVmaW5lZCkgaXMgYWJvcnRlZCB2aWEgWE1MSHR0cFJlcXVlc3QuYWJvcnQoKVxuXG52YXIgcGVuZGluZ1JlcXVlc3RzID0ge30sXG5cdGFqYXg7XG5cbi8vIFVzZSBhIHByZWZpbHRlciBpZiBhdmFpbGFibGUgKDEuNSspXG5pZiAoICQuYWpheFByZWZpbHRlciApIHtcblx0JC5hamF4UHJlZmlsdGVyKCBmdW5jdGlvbiggc2V0dGluZ3MsIF8sIHhociApIHtcblx0XHR2YXIgcG9ydCA9IHNldHRpbmdzLnBvcnQ7XG5cdFx0aWYgKCBzZXR0aW5ncy5tb2RlID09PSBcImFib3J0XCIgKSB7XG5cdFx0XHQkLmFqYXhBYm9ydCggcG9ydCApO1xuXHRcdFx0cGVuZGluZ1JlcXVlc3RzWyBwb3J0IF0gPSB4aHI7XG5cdFx0fVxuXHR9ICk7XG59IGVsc2Uge1xuXG5cdC8vIFByb3h5IGFqYXhcblx0YWpheCA9ICQuYWpheDtcblx0JC5hamF4ID0gZnVuY3Rpb24oIHNldHRpbmdzICkge1xuXHRcdHZhciBtb2RlID0gKCBcIm1vZGVcIiBpbiBzZXR0aW5ncyA/IHNldHRpbmdzIDogJC5hamF4U2V0dGluZ3MgKS5tb2RlLFxuXHRcdFx0cG9ydCA9ICggXCJwb3J0XCIgaW4gc2V0dGluZ3MgPyBzZXR0aW5ncyA6ICQuYWpheFNldHRpbmdzICkucG9ydDtcblx0XHRpZiAoIG1vZGUgPT09IFwiYWJvcnRcIiApIHtcblx0XHRcdCQuYWpheEFib3J0KCBwb3J0ICk7XG5cdFx0XHRwZW5kaW5nUmVxdWVzdHNbIHBvcnQgXSA9IGFqYXguYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0cmV0dXJuIHBlbmRpbmdSZXF1ZXN0c1sgcG9ydCBdO1xuXHRcdH1cblx0XHRyZXR1cm4gYWpheC5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdH07XG59XG5cbi8vIEFib3J0IHRoZSBwcmV2aW91cyByZXF1ZXN0IHdpdGhvdXQgc2VuZGluZyBhIG5ldyBvbmVcbiQuYWpheEFib3J0ID0gZnVuY3Rpb24oIHBvcnQgKSB7XG5cdGlmICggcGVuZGluZ1JlcXVlc3RzWyBwb3J0IF0gKSB7XG5cdFx0cGVuZGluZ1JlcXVlc3RzWyBwb3J0IF0uYWJvcnQoKTtcblx0XHRkZWxldGUgcGVuZGluZ1JlcXVlc3RzWyBwb3J0IF07XG5cdH1cbn07XG5yZXR1cm4gJDtcbn0pKTsiLCIvKiFcbiAqIGpRdWVyeSBKYXZhU2NyaXB0IExpYnJhcnkgdjMuNy4xXG4gKiBodHRwczovL2pxdWVyeS5jb20vXG4gKlxuICogQ29weXJpZ2h0IE9wZW5KUyBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cHM6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBEYXRlOiAyMDIzLTA4LTI4VDEzOjM3WlxuICovXG4oIGZ1bmN0aW9uKCBnbG9iYWwsIGZhY3RvcnkgKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0aWYgKCB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdC8vIEZvciBDb21tb25KUyBhbmQgQ29tbW9uSlMtbGlrZSBlbnZpcm9ubWVudHMgd2hlcmUgYSBwcm9wZXIgYHdpbmRvd2Bcblx0XHQvLyBpcyBwcmVzZW50LCBleGVjdXRlIHRoZSBmYWN0b3J5IGFuZCBnZXQgalF1ZXJ5LlxuXHRcdC8vIEZvciBlbnZpcm9ubWVudHMgdGhhdCBkbyBub3QgaGF2ZSBhIGB3aW5kb3dgIHdpdGggYSBgZG9jdW1lbnRgXG5cdFx0Ly8gKHN1Y2ggYXMgTm9kZS5qcyksIGV4cG9zZSBhIGZhY3RvcnkgYXMgbW9kdWxlLmV4cG9ydHMuXG5cdFx0Ly8gVGhpcyBhY2NlbnR1YXRlcyB0aGUgbmVlZCBmb3IgdGhlIGNyZWF0aW9uIG9mIGEgcmVhbCBgd2luZG93YC5cblx0XHQvLyBlLmcuIHZhciBqUXVlcnkgPSByZXF1aXJlKFwianF1ZXJ5XCIpKHdpbmRvdyk7XG5cdFx0Ly8gU2VlIHRpY2tldCB0cmFjLTE0NTQ5IGZvciBtb3JlIGluZm8uXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBnbG9iYWwuZG9jdW1lbnQgP1xuXHRcdFx0ZmFjdG9yeSggZ2xvYmFsLCB0cnVlICkgOlxuXHRcdFx0ZnVuY3Rpb24oIHcgKSB7XG5cdFx0XHRcdGlmICggIXcuZG9jdW1lbnQgKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBcImpRdWVyeSByZXF1aXJlcyBhIHdpbmRvdyB3aXRoIGEgZG9jdW1lbnRcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBmYWN0b3J5KCB3ICk7XG5cdFx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdGZhY3RvcnkoIGdsb2JhbCApO1xuXHR9XG5cbi8vIFBhc3MgdGhpcyBpZiB3aW5kb3cgaXMgbm90IGRlZmluZWQgeWV0XG59ICkoIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0aGlzLCBmdW5jdGlvbiggd2luZG93LCBub0dsb2JhbCApIHtcblxuLy8gRWRnZSA8PSAxMiAtIDEzKywgRmlyZWZveCA8PTE4IC0gNDUrLCBJRSAxMCAtIDExLCBTYWZhcmkgNS4xIC0gOSssIGlPUyA2IC0gOS4xXG4vLyB0aHJvdyBleGNlcHRpb25zIHdoZW4gbm9uLXN0cmljdCBjb2RlIChlLmcuLCBBU1AuTkVUIDQuNSkgYWNjZXNzZXMgc3RyaWN0IG1vZGVcbi8vIGFyZ3VtZW50cy5jYWxsZWUuY2FsbGVyICh0cmFjLTEzMzM1KS4gQnV0IGFzIG9mIGpRdWVyeSAzLjAgKDIwMTYpLCBzdHJpY3QgbW9kZSBzaG91bGQgYmUgY29tbW9uXG4vLyBlbm91Z2ggdGhhdCBhbGwgc3VjaCBhdHRlbXB0cyBhcmUgZ3VhcmRlZCBpbiBhIHRyeSBibG9jay5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgYXJyID0gW107XG5cbnZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcblxudmFyIHNsaWNlID0gYXJyLnNsaWNlO1xuXG52YXIgZmxhdCA9IGFyci5mbGF0ID8gZnVuY3Rpb24oIGFycmF5ICkge1xuXHRyZXR1cm4gYXJyLmZsYXQuY2FsbCggYXJyYXkgKTtcbn0gOiBmdW5jdGlvbiggYXJyYXkgKSB7XG5cdHJldHVybiBhcnIuY29uY2F0LmFwcGx5KCBbXSwgYXJyYXkgKTtcbn07XG5cblxudmFyIHB1c2ggPSBhcnIucHVzaDtcblxudmFyIGluZGV4T2YgPSBhcnIuaW5kZXhPZjtcblxudmFyIGNsYXNzMnR5cGUgPSB7fTtcblxudmFyIHRvU3RyaW5nID0gY2xhc3MydHlwZS50b1N0cmluZztcblxudmFyIGhhc093biA9IGNsYXNzMnR5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBmblRvU3RyaW5nID0gaGFzT3duLnRvU3RyaW5nO1xuXG52YXIgT2JqZWN0RnVuY3Rpb25TdHJpbmcgPSBmblRvU3RyaW5nLmNhbGwoIE9iamVjdCApO1xuXG52YXIgc3VwcG9ydCA9IHt9O1xuXG52YXIgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uIGlzRnVuY3Rpb24oIG9iaiApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTU3LCBGaXJlZm94IDw9NTJcblx0XHQvLyBJbiBzb21lIGJyb3dzZXJzLCB0eXBlb2YgcmV0dXJucyBcImZ1bmN0aW9uXCIgZm9yIEhUTUwgPG9iamVjdD4gZWxlbWVudHNcblx0XHQvLyAoaS5lLiwgYHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcIm9iamVjdFwiICkgPT09IFwiZnVuY3Rpb25cImApLlxuXHRcdC8vIFdlIGRvbid0IHdhbnQgdG8gY2xhc3NpZnkgKmFueSogRE9NIG5vZGUgYXMgYSBmdW5jdGlvbi5cblx0XHQvLyBTdXBwb3J0OiBRdFdlYiA8PTMuOC41LCBXZWJLaXQgPD01MzQuMzQsIHdraHRtbHRvcGRmIHRvb2wgPD0wLjEyLjVcblx0XHQvLyBQbHVzIGZvciBvbGQgV2ViS2l0LCB0eXBlb2YgcmV0dXJucyBcImZ1bmN0aW9uXCIgZm9yIEhUTUwgY29sbGVjdGlvbnNcblx0XHQvLyAoZS5nLiwgYHR5cGVvZiBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImRpdlwiKSA9PT0gXCJmdW5jdGlvblwiYCkuIChnaC00NzU2KVxuXHRcdHJldHVybiB0eXBlb2Ygb2JqID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIG9iai5ub2RlVHlwZSAhPT0gXCJudW1iZXJcIiAmJlxuXHRcdFx0dHlwZW9mIG9iai5pdGVtICE9PSBcImZ1bmN0aW9uXCI7XG5cdH07XG5cblxudmFyIGlzV2luZG93ID0gZnVuY3Rpb24gaXNXaW5kb3coIG9iaiApIHtcblx0XHRyZXR1cm4gb2JqICE9IG51bGwgJiYgb2JqID09PSBvYmoud2luZG93O1xuXHR9O1xuXG5cbnZhciBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudDtcblxuXG5cblx0dmFyIHByZXNlcnZlZFNjcmlwdEF0dHJpYnV0ZXMgPSB7XG5cdFx0dHlwZTogdHJ1ZSxcblx0XHRzcmM6IHRydWUsXG5cdFx0bm9uY2U6IHRydWUsXG5cdFx0bm9Nb2R1bGU6IHRydWVcblx0fTtcblxuXHRmdW5jdGlvbiBET01FdmFsKCBjb2RlLCBub2RlLCBkb2MgKSB7XG5cdFx0ZG9jID0gZG9jIHx8IGRvY3VtZW50O1xuXG5cdFx0dmFyIGksIHZhbCxcblx0XHRcdHNjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KCBcInNjcmlwdFwiICk7XG5cblx0XHRzY3JpcHQudGV4dCA9IGNvZGU7XG5cdFx0aWYgKCBub2RlICkge1xuXHRcdFx0Zm9yICggaSBpbiBwcmVzZXJ2ZWRTY3JpcHRBdHRyaWJ1dGVzICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggNjQrLCBFZGdlIDE4K1xuXHRcdFx0XHQvLyBTb21lIGJyb3dzZXJzIGRvbid0IHN1cHBvcnQgdGhlIFwibm9uY2VcIiBwcm9wZXJ0eSBvbiBzY3JpcHRzLlxuXHRcdFx0XHQvLyBPbiB0aGUgb3RoZXIgaGFuZCwganVzdCB1c2luZyBgZ2V0QXR0cmlidXRlYCBpcyBub3QgZW5vdWdoIGFzXG5cdFx0XHRcdC8vIHRoZSBgbm9uY2VgIGF0dHJpYnV0ZSBpcyByZXNldCB0byBhbiBlbXB0eSBzdHJpbmcgd2hlbmV2ZXIgaXRcblx0XHRcdFx0Ly8gYmVjb21lcyBicm93c2luZy1jb250ZXh0IGNvbm5lY3RlZC5cblx0XHRcdFx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93aGF0d2cvaHRtbC9pc3N1ZXMvMjM2OVxuXHRcdFx0XHQvLyBTZWUgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jbm9uY2UtYXR0cmlidXRlc1xuXHRcdFx0XHQvLyBUaGUgYG5vZGUuZ2V0QXR0cmlidXRlYCBjaGVjayB3YXMgYWRkZWQgZm9yIHRoZSBzYWtlIG9mXG5cdFx0XHRcdC8vIGBqUXVlcnkuZ2xvYmFsRXZhbGAgc28gdGhhdCBpdCBjYW4gZmFrZSBhIG5vbmNlLWNvbnRhaW5pbmcgbm9kZVxuXHRcdFx0XHQvLyB2aWEgYW4gb2JqZWN0LlxuXHRcdFx0XHR2YWwgPSBub2RlWyBpIF0gfHwgbm9kZS5nZXRBdHRyaWJ1dGUgJiYgbm9kZS5nZXRBdHRyaWJ1dGUoIGkgKTtcblx0XHRcdFx0aWYgKCB2YWwgKSB7XG5cdFx0XHRcdFx0c2NyaXB0LnNldEF0dHJpYnV0ZSggaSwgdmFsICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0ZG9jLmhlYWQuYXBwZW5kQ2hpbGQoIHNjcmlwdCApLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIHNjcmlwdCApO1xuXHR9XG5cblxuZnVuY3Rpb24gdG9UeXBlKCBvYmogKSB7XG5cdGlmICggb2JqID09IG51bGwgKSB7XG5cdFx0cmV0dXJuIG9iaiArIFwiXCI7XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9Mi4zIG9ubHkgKGZ1bmN0aW9uaXNoIFJlZ0V4cClcblx0cmV0dXJuIHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIG9iaiA9PT0gXCJmdW5jdGlvblwiID9cblx0XHRjbGFzczJ0eXBlWyB0b1N0cmluZy5jYWxsKCBvYmogKSBdIHx8IFwib2JqZWN0XCIgOlxuXHRcdHR5cGVvZiBvYmo7XG59XG4vKiBnbG9iYWwgU3ltYm9sICovXG4vLyBEZWZpbmluZyB0aGlzIGdsb2JhbCBpbiAuZXNsaW50cmMuanNvbiB3b3VsZCBjcmVhdGUgYSBkYW5nZXIgb2YgdXNpbmcgdGhlIGdsb2JhbFxuLy8gdW5ndWFyZGVkIGluIGFub3RoZXIgcGxhY2UsIGl0IHNlZW1zIHNhZmVyIHRvIGRlZmluZSBnbG9iYWwgb25seSBmb3IgdGhpcyBtb2R1bGVcblxuXG5cbnZhciB2ZXJzaW9uID0gXCIzLjcuMVwiLFxuXG5cdHJodG1sU3VmZml4ID0gL0hUTUwkL2ksXG5cblx0Ly8gRGVmaW5lIGEgbG9jYWwgY29weSBvZiBqUXVlcnlcblx0alF1ZXJ5ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0ICkge1xuXG5cdFx0Ly8gVGhlIGpRdWVyeSBvYmplY3QgaXMgYWN0dWFsbHkganVzdCB0aGUgaW5pdCBjb25zdHJ1Y3RvciAnZW5oYW5jZWQnXG5cdFx0Ly8gTmVlZCBpbml0IGlmIGpRdWVyeSBpcyBjYWxsZWQgKGp1c3QgYWxsb3cgZXJyb3IgdG8gYmUgdGhyb3duIGlmIG5vdCBpbmNsdWRlZClcblx0XHRyZXR1cm4gbmV3IGpRdWVyeS5mbi5pbml0KCBzZWxlY3RvciwgY29udGV4dCApO1xuXHR9O1xuXG5qUXVlcnkuZm4gPSBqUXVlcnkucHJvdG90eXBlID0ge1xuXG5cdC8vIFRoZSBjdXJyZW50IHZlcnNpb24gb2YgalF1ZXJ5IGJlaW5nIHVzZWRcblx0anF1ZXJ5OiB2ZXJzaW9uLFxuXG5cdGNvbnN0cnVjdG9yOiBqUXVlcnksXG5cblx0Ly8gVGhlIGRlZmF1bHQgbGVuZ3RoIG9mIGEgalF1ZXJ5IG9iamVjdCBpcyAwXG5cdGxlbmd0aDogMCxcblxuXHR0b0FycmF5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2xpY2UuY2FsbCggdGhpcyApO1xuXHR9LFxuXG5cdC8vIEdldCB0aGUgTnRoIGVsZW1lbnQgaW4gdGhlIG1hdGNoZWQgZWxlbWVudCBzZXQgT1Jcblx0Ly8gR2V0IHRoZSB3aG9sZSBtYXRjaGVkIGVsZW1lbnQgc2V0IGFzIGEgY2xlYW4gYXJyYXlcblx0Z2V0OiBmdW5jdGlvbiggbnVtICkge1xuXG5cdFx0Ly8gUmV0dXJuIGFsbCB0aGUgZWxlbWVudHMgaW4gYSBjbGVhbiBhcnJheVxuXHRcdGlmICggbnVtID09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gc2xpY2UuY2FsbCggdGhpcyApO1xuXHRcdH1cblxuXHRcdC8vIFJldHVybiBqdXN0IHRoZSBvbmUgZWxlbWVudCBmcm9tIHRoZSBzZXRcblx0XHRyZXR1cm4gbnVtIDwgMCA/IHRoaXNbIG51bSArIHRoaXMubGVuZ3RoIF0gOiB0aGlzWyBudW0gXTtcblx0fSxcblxuXHQvLyBUYWtlIGFuIGFycmF5IG9mIGVsZW1lbnRzIGFuZCBwdXNoIGl0IG9udG8gdGhlIHN0YWNrXG5cdC8vIChyZXR1cm5pbmcgdGhlIG5ldyBtYXRjaGVkIGVsZW1lbnQgc2V0KVxuXHRwdXNoU3RhY2s6IGZ1bmN0aW9uKCBlbGVtcyApIHtcblxuXHRcdC8vIEJ1aWxkIGEgbmV3IGpRdWVyeSBtYXRjaGVkIGVsZW1lbnQgc2V0XG5cdFx0dmFyIHJldCA9IGpRdWVyeS5tZXJnZSggdGhpcy5jb25zdHJ1Y3RvcigpLCBlbGVtcyApO1xuXG5cdFx0Ly8gQWRkIHRoZSBvbGQgb2JqZWN0IG9udG8gdGhlIHN0YWNrIChhcyBhIHJlZmVyZW5jZSlcblx0XHRyZXQucHJldk9iamVjdCA9IHRoaXM7XG5cblx0XHQvLyBSZXR1cm4gdGhlIG5ld2x5LWZvcm1lZCBlbGVtZW50IHNldFxuXHRcdHJldHVybiByZXQ7XG5cdH0sXG5cblx0Ly8gRXhlY3V0ZSBhIGNhbGxiYWNrIGZvciBldmVyeSBlbGVtZW50IGluIHRoZSBtYXRjaGVkIHNldC5cblx0ZWFjaDogZnVuY3Rpb24oIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZWFjaCggdGhpcywgY2FsbGJhY2sgKTtcblx0fSxcblxuXHRtYXA6IGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGpRdWVyeS5tYXAoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBpICkge1xuXHRcdFx0cmV0dXJuIGNhbGxiYWNrLmNhbGwoIGVsZW0sIGksIGVsZW0gKTtcblx0XHR9ICkgKTtcblx0fSxcblxuXHRzbGljZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBzbGljZS5hcHBseSggdGhpcywgYXJndW1lbnRzICkgKTtcblx0fSxcblxuXHRmaXJzdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZXEoIDAgKTtcblx0fSxcblxuXHRsYXN0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5lcSggLTEgKTtcblx0fSxcblxuXHRldmVuOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGpRdWVyeS5ncmVwKCB0aGlzLCBmdW5jdGlvbiggX2VsZW0sIGkgKSB7XG5cdFx0XHRyZXR1cm4gKCBpICsgMSApICUgMjtcblx0XHR9ICkgKTtcblx0fSxcblxuXHRvZGQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5LmdyZXAoIHRoaXMsIGZ1bmN0aW9uKCBfZWxlbSwgaSApIHtcblx0XHRcdHJldHVybiBpICUgMjtcblx0XHR9ICkgKTtcblx0fSxcblxuXHRlcTogZnVuY3Rpb24oIGkgKSB7XG5cdFx0dmFyIGxlbiA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0aiA9ICtpICsgKCBpIDwgMCA/IGxlbiA6IDAgKTtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGogPj0gMCAmJiBqIDwgbGVuID8gWyB0aGlzWyBqIF0gXSA6IFtdICk7XG5cdH0sXG5cblx0ZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wcmV2T2JqZWN0IHx8IHRoaXMuY29uc3RydWN0b3IoKTtcblx0fSxcblxuXHQvLyBGb3IgaW50ZXJuYWwgdXNlIG9ubHkuXG5cdC8vIEJlaGF2ZXMgbGlrZSBhbiBBcnJheSdzIG1ldGhvZCwgbm90IGxpa2UgYSBqUXVlcnkgbWV0aG9kLlxuXHRwdXNoOiBwdXNoLFxuXHRzb3J0OiBhcnIuc29ydCxcblx0c3BsaWNlOiBhcnIuc3BsaWNlXG59O1xuXG5qUXVlcnkuZXh0ZW5kID0galF1ZXJ5LmZuLmV4dGVuZCA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgb3B0aW9ucywgbmFtZSwgc3JjLCBjb3B5LCBjb3B5SXNBcnJheSwgY2xvbmUsXG5cdFx0dGFyZ2V0ID0gYXJndW1lbnRzWyAwIF0gfHwge30sXG5cdFx0aSA9IDEsXG5cdFx0bGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcblx0XHRkZWVwID0gZmFsc2U7XG5cblx0Ly8gSGFuZGxlIGEgZGVlcCBjb3B5IHNpdHVhdGlvblxuXHRpZiAoIHR5cGVvZiB0YXJnZXQgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdGRlZXAgPSB0YXJnZXQ7XG5cblx0XHQvLyBTa2lwIHRoZSBib29sZWFuIGFuZCB0aGUgdGFyZ2V0XG5cdFx0dGFyZ2V0ID0gYXJndW1lbnRzWyBpIF0gfHwge307XG5cdFx0aSsrO1xuXHR9XG5cblx0Ly8gSGFuZGxlIGNhc2Ugd2hlbiB0YXJnZXQgaXMgYSBzdHJpbmcgb3Igc29tZXRoaW5nIChwb3NzaWJsZSBpbiBkZWVwIGNvcHkpXG5cdGlmICggdHlwZW9mIHRhcmdldCAhPT0gXCJvYmplY3RcIiAmJiAhaXNGdW5jdGlvbiggdGFyZ2V0ICkgKSB7XG5cdFx0dGFyZ2V0ID0ge307XG5cdH1cblxuXHQvLyBFeHRlbmQgalF1ZXJ5IGl0c2VsZiBpZiBvbmx5IG9uZSBhcmd1bWVudCBpcyBwYXNzZWRcblx0aWYgKCBpID09PSBsZW5ndGggKSB7XG5cdFx0dGFyZ2V0ID0gdGhpcztcblx0XHRpLS07XG5cdH1cblxuXHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblxuXHRcdC8vIE9ubHkgZGVhbCB3aXRoIG5vbi1udWxsL3VuZGVmaW5lZCB2YWx1ZXNcblx0XHRpZiAoICggb3B0aW9ucyA9IGFyZ3VtZW50c1sgaSBdICkgIT0gbnVsbCApIHtcblxuXHRcdFx0Ly8gRXh0ZW5kIHRoZSBiYXNlIG9iamVjdFxuXHRcdFx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdFx0XHRjb3B5ID0gb3B0aW9uc1sgbmFtZSBdO1xuXG5cdFx0XHRcdC8vIFByZXZlbnQgT2JqZWN0LnByb3RvdHlwZSBwb2xsdXRpb25cblx0XHRcdFx0Ly8gUHJldmVudCBuZXZlci1lbmRpbmcgbG9vcFxuXHRcdFx0XHRpZiAoIG5hbWUgPT09IFwiX19wcm90b19fXCIgfHwgdGFyZ2V0ID09PSBjb3B5ICkge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmVjdXJzZSBpZiB3ZSdyZSBtZXJnaW5nIHBsYWluIG9iamVjdHMgb3IgYXJyYXlzXG5cdFx0XHRcdGlmICggZGVlcCAmJiBjb3B5ICYmICggalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGNvcHkgKSB8fFxuXHRcdFx0XHRcdCggY29weUlzQXJyYXkgPSBBcnJheS5pc0FycmF5KCBjb3B5ICkgKSApICkge1xuXHRcdFx0XHRcdHNyYyA9IHRhcmdldFsgbmFtZSBdO1xuXG5cdFx0XHRcdFx0Ly8gRW5zdXJlIHByb3BlciB0eXBlIGZvciB0aGUgc291cmNlIHZhbHVlXG5cdFx0XHRcdFx0aWYgKCBjb3B5SXNBcnJheSAmJiAhQXJyYXkuaXNBcnJheSggc3JjICkgKSB7XG5cdFx0XHRcdFx0XHRjbG9uZSA9IFtdO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoICFjb3B5SXNBcnJheSAmJiAhalF1ZXJ5LmlzUGxhaW5PYmplY3QoIHNyYyApICkge1xuXHRcdFx0XHRcdFx0Y2xvbmUgPSB7fTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y2xvbmUgPSBzcmM7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNvcHlJc0FycmF5ID0gZmFsc2U7XG5cblx0XHRcdFx0XHQvLyBOZXZlciBtb3ZlIG9yaWdpbmFsIG9iamVjdHMsIGNsb25lIHRoZW1cblx0XHRcdFx0XHR0YXJnZXRbIG5hbWUgXSA9IGpRdWVyeS5leHRlbmQoIGRlZXAsIGNsb25lLCBjb3B5ICk7XG5cblx0XHRcdFx0Ly8gRG9uJ3QgYnJpbmcgaW4gdW5kZWZpbmVkIHZhbHVlc1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBjb3B5ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0dGFyZ2V0WyBuYW1lIF0gPSBjb3B5O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSBtb2RpZmllZCBvYmplY3Rcblx0cmV0dXJuIHRhcmdldDtcbn07XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBVbmlxdWUgZm9yIGVhY2ggY29weSBvZiBqUXVlcnkgb24gdGhlIHBhZ2Vcblx0ZXhwYW5kbzogXCJqUXVlcnlcIiArICggdmVyc2lvbiArIE1hdGgucmFuZG9tKCkgKS5yZXBsYWNlKCAvXFxEL2csIFwiXCIgKSxcblxuXHQvLyBBc3N1bWUgalF1ZXJ5IGlzIHJlYWR5IHdpdGhvdXQgdGhlIHJlYWR5IG1vZHVsZVxuXHRpc1JlYWR5OiB0cnVlLFxuXG5cdGVycm9yOiBmdW5jdGlvbiggbXNnICkge1xuXHRcdHRocm93IG5ldyBFcnJvciggbXNnICk7XG5cdH0sXG5cblx0bm9vcDogZnVuY3Rpb24oKSB7fSxcblxuXHRpc1BsYWluT2JqZWN0OiBmdW5jdGlvbiggb2JqICkge1xuXHRcdHZhciBwcm90bywgQ3RvcjtcblxuXHRcdC8vIERldGVjdCBvYnZpb3VzIG5lZ2F0aXZlc1xuXHRcdC8vIFVzZSB0b1N0cmluZyBpbnN0ZWFkIG9mIGpRdWVyeS50eXBlIHRvIGNhdGNoIGhvc3Qgb2JqZWN0c1xuXHRcdGlmICggIW9iaiB8fCB0b1N0cmluZy5jYWxsKCBvYmogKSAhPT0gXCJbb2JqZWN0IE9iamVjdF1cIiApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRwcm90byA9IGdldFByb3RvKCBvYmogKTtcblxuXHRcdC8vIE9iamVjdHMgd2l0aCBubyBwcm90b3R5cGUgKGUuZy4sIGBPYmplY3QuY3JlYXRlKCBudWxsIClgKSBhcmUgcGxhaW5cblx0XHRpZiAoICFwcm90byApIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdC8vIE9iamVjdHMgd2l0aCBwcm90b3R5cGUgYXJlIHBsYWluIGlmZiB0aGV5IHdlcmUgY29uc3RydWN0ZWQgYnkgYSBnbG9iYWwgT2JqZWN0IGZ1bmN0aW9uXG5cdFx0Q3RvciA9IGhhc093bi5jYWxsKCBwcm90bywgXCJjb25zdHJ1Y3RvclwiICkgJiYgcHJvdG8uY29uc3RydWN0b3I7XG5cdFx0cmV0dXJuIHR5cGVvZiBDdG9yID09PSBcImZ1bmN0aW9uXCIgJiYgZm5Ub1N0cmluZy5jYWxsKCBDdG9yICkgPT09IE9iamVjdEZ1bmN0aW9uU3RyaW5nO1xuXHR9LFxuXG5cdGlzRW1wdHlPYmplY3Q6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0dmFyIG5hbWU7XG5cblx0XHRmb3IgKCBuYW1lIGluIG9iaiApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0Ly8gRXZhbHVhdGVzIGEgc2NyaXB0IGluIGEgcHJvdmlkZWQgY29udGV4dDsgZmFsbHMgYmFjayB0byB0aGUgZ2xvYmFsIG9uZVxuXHQvLyBpZiBub3Qgc3BlY2lmaWVkLlxuXHRnbG9iYWxFdmFsOiBmdW5jdGlvbiggY29kZSwgb3B0aW9ucywgZG9jICkge1xuXHRcdERPTUV2YWwoIGNvZGUsIHsgbm9uY2U6IG9wdGlvbnMgJiYgb3B0aW9ucy5ub25jZSB9LCBkb2MgKTtcblx0fSxcblxuXHRlYWNoOiBmdW5jdGlvbiggb2JqLCBjYWxsYmFjayApIHtcblx0XHR2YXIgbGVuZ3RoLCBpID0gMDtcblxuXHRcdGlmICggaXNBcnJheUxpa2UoIG9iaiApICkge1xuXHRcdFx0bGVuZ3RoID0gb2JqLmxlbmd0aDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrLmNhbGwoIG9ialsgaSBdLCBpLCBvYmpbIGkgXSApID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKCBpIGluIG9iaiApIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjay5jYWxsKCBvYmpbIGkgXSwgaSwgb2JqWyBpIF0gKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gb2JqO1xuXHR9LFxuXG5cblx0Ly8gUmV0cmlldmUgdGhlIHRleHQgdmFsdWUgb2YgYW4gYXJyYXkgb2YgRE9NIG5vZGVzXG5cdHRleHQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBub2RlLFxuXHRcdFx0cmV0ID0gXCJcIixcblx0XHRcdGkgPSAwLFxuXHRcdFx0bm9kZVR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdFx0aWYgKCAhbm9kZVR5cGUgKSB7XG5cblx0XHRcdC8vIElmIG5vIG5vZGVUeXBlLCB0aGlzIGlzIGV4cGVjdGVkIHRvIGJlIGFuIGFycmF5XG5cdFx0XHR3aGlsZSAoICggbm9kZSA9IGVsZW1bIGkrKyBdICkgKSB7XG5cblx0XHRcdFx0Ly8gRG8gbm90IHRyYXZlcnNlIGNvbW1lbnQgbm9kZXNcblx0XHRcdFx0cmV0ICs9IGpRdWVyeS50ZXh0KCBub2RlICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmICggbm9kZVR5cGUgPT09IDEgfHwgbm9kZVR5cGUgPT09IDExICkge1xuXHRcdFx0cmV0dXJuIGVsZW0udGV4dENvbnRlbnQ7XG5cdFx0fVxuXHRcdGlmICggbm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5kb2N1bWVudEVsZW1lbnQudGV4dENvbnRlbnQ7XG5cdFx0fVxuXHRcdGlmICggbm9kZVR5cGUgPT09IDMgfHwgbm9kZVR5cGUgPT09IDQgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5ub2RlVmFsdWU7XG5cdFx0fVxuXG5cdFx0Ly8gRG8gbm90IGluY2x1ZGUgY29tbWVudCBvciBwcm9jZXNzaW5nIGluc3RydWN0aW9uIG5vZGVzXG5cblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXG5cdC8vIHJlc3VsdHMgaXMgZm9yIGludGVybmFsIHVzYWdlIG9ubHlcblx0bWFrZUFycmF5OiBmdW5jdGlvbiggYXJyLCByZXN1bHRzICkge1xuXHRcdHZhciByZXQgPSByZXN1bHRzIHx8IFtdO1xuXG5cdFx0aWYgKCBhcnIgIT0gbnVsbCApIHtcblx0XHRcdGlmICggaXNBcnJheUxpa2UoIE9iamVjdCggYXJyICkgKSApIHtcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCByZXQsXG5cdFx0XHRcdFx0dHlwZW9mIGFyciA9PT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdFx0XHRbIGFyciBdIDogYXJyXG5cdFx0XHRcdCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwdXNoLmNhbGwoIHJldCwgYXJyICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblxuXHRpbkFycmF5OiBmdW5jdGlvbiggZWxlbSwgYXJyLCBpICkge1xuXHRcdHJldHVybiBhcnIgPT0gbnVsbCA/IC0xIDogaW5kZXhPZi5jYWxsKCBhcnIsIGVsZW0sIGkgKTtcblx0fSxcblxuXHRpc1hNTERvYzogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIG5hbWVzcGFjZSA9IGVsZW0gJiYgZWxlbS5uYW1lc3BhY2VVUkksXG5cdFx0XHRkb2NFbGVtID0gZWxlbSAmJiAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtICkuZG9jdW1lbnRFbGVtZW50O1xuXG5cdFx0Ly8gQXNzdW1lIEhUTUwgd2hlbiBkb2N1bWVudEVsZW1lbnQgZG9lc24ndCB5ZXQgZXhpc3QsIHN1Y2ggYXMgaW5zaWRlXG5cdFx0Ly8gZG9jdW1lbnQgZnJhZ21lbnRzLlxuXHRcdHJldHVybiAhcmh0bWxTdWZmaXgudGVzdCggbmFtZXNwYWNlIHx8IGRvY0VsZW0gJiYgZG9jRWxlbS5ub2RlTmFtZSB8fCBcIkhUTUxcIiApO1xuXHR9LFxuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdG1lcmdlOiBmdW5jdGlvbiggZmlyc3QsIHNlY29uZCApIHtcblx0XHR2YXIgbGVuID0gK3NlY29uZC5sZW5ndGgsXG5cdFx0XHRqID0gMCxcblx0XHRcdGkgPSBmaXJzdC5sZW5ndGg7XG5cblx0XHRmb3IgKCA7IGogPCBsZW47IGorKyApIHtcblx0XHRcdGZpcnN0WyBpKysgXSA9IHNlY29uZFsgaiBdO1xuXHRcdH1cblxuXHRcdGZpcnN0Lmxlbmd0aCA9IGk7XG5cblx0XHRyZXR1cm4gZmlyc3Q7XG5cdH0sXG5cblx0Z3JlcDogZnVuY3Rpb24oIGVsZW1zLCBjYWxsYmFjaywgaW52ZXJ0ICkge1xuXHRcdHZhciBjYWxsYmFja0ludmVyc2UsXG5cdFx0XHRtYXRjaGVzID0gW10sXG5cdFx0XHRpID0gMCxcblx0XHRcdGxlbmd0aCA9IGVsZW1zLmxlbmd0aCxcblx0XHRcdGNhbGxiYWNrRXhwZWN0ID0gIWludmVydDtcblxuXHRcdC8vIEdvIHRocm91Z2ggdGhlIGFycmF5LCBvbmx5IHNhdmluZyB0aGUgaXRlbXNcblx0XHQvLyB0aGF0IHBhc3MgdGhlIHZhbGlkYXRvciBmdW5jdGlvblxuXHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0Y2FsbGJhY2tJbnZlcnNlID0gIWNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpICk7XG5cdFx0XHRpZiAoIGNhbGxiYWNrSW52ZXJzZSAhPT0gY2FsbGJhY2tFeHBlY3QgKSB7XG5cdFx0XHRcdG1hdGNoZXMucHVzaCggZWxlbXNbIGkgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBtYXRjaGVzO1xuXHR9LFxuXG5cdC8vIGFyZyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxuXHRtYXA6IGZ1bmN0aW9uKCBlbGVtcywgY2FsbGJhY2ssIGFyZyApIHtcblx0XHR2YXIgbGVuZ3RoLCB2YWx1ZSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0cmV0ID0gW107XG5cblx0XHQvLyBHbyB0aHJvdWdoIHRoZSBhcnJheSwgdHJhbnNsYXRpbmcgZWFjaCBvZiB0aGUgaXRlbXMgdG8gdGhlaXIgbmV3IHZhbHVlc1xuXHRcdGlmICggaXNBcnJheUxpa2UoIGVsZW1zICkgKSB7XG5cdFx0XHRsZW5ndGggPSBlbGVtcy5sZW5ndGg7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjayggZWxlbXNbIGkgXSwgaSwgYXJnICk7XG5cblx0XHRcdFx0aWYgKCB2YWx1ZSAhPSBudWxsICkge1xuXHRcdFx0XHRcdHJldC5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBHbyB0aHJvdWdoIGV2ZXJ5IGtleSBvbiB0aGUgb2JqZWN0LFxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKCBpIGluIGVsZW1zICkge1xuXHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpLCBhcmcgKTtcblxuXHRcdFx0XHRpZiAoIHZhbHVlICE9IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0LnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBGbGF0dGVuIGFueSBuZXN0ZWQgYXJyYXlzXG5cdFx0cmV0dXJuIGZsYXQoIHJldCApO1xuXHR9LFxuXG5cdC8vIEEgZ2xvYmFsIEdVSUQgY291bnRlciBmb3Igb2JqZWN0c1xuXHRndWlkOiAxLFxuXG5cdC8vIGpRdWVyeS5zdXBwb3J0IGlzIG5vdCB1c2VkIGluIENvcmUgYnV0IG90aGVyIHByb2plY3RzIGF0dGFjaCB0aGVpclxuXHQvLyBwcm9wZXJ0aWVzIHRvIGl0IHNvIGl0IG5lZWRzIHRvIGV4aXN0LlxuXHRzdXBwb3J0OiBzdXBwb3J0XG59ICk7XG5cbmlmICggdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICkge1xuXHRqUXVlcnkuZm5bIFN5bWJvbC5pdGVyYXRvciBdID0gYXJyWyBTeW1ib2wuaXRlcmF0b3IgXTtcbn1cblxuLy8gUG9wdWxhdGUgdGhlIGNsYXNzMnR5cGUgbWFwXG5qUXVlcnkuZWFjaCggXCJCb29sZWFuIE51bWJlciBTdHJpbmcgRnVuY3Rpb24gQXJyYXkgRGF0ZSBSZWdFeHAgT2JqZWN0IEVycm9yIFN5bWJvbFwiLnNwbGl0KCBcIiBcIiApLFxuXHRmdW5jdGlvbiggX2ksIG5hbWUgKSB7XG5cdFx0Y2xhc3MydHlwZVsgXCJbb2JqZWN0IFwiICsgbmFtZSArIFwiXVwiIF0gPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cdH0gKTtcblxuZnVuY3Rpb24gaXNBcnJheUxpa2UoIG9iaiApIHtcblxuXHQvLyBTdXBwb3J0OiByZWFsIGlPUyA4LjIgb25seSAobm90IHJlcHJvZHVjaWJsZSBpbiBzaW11bGF0b3IpXG5cdC8vIGBpbmAgY2hlY2sgdXNlZCB0byBwcmV2ZW50IEpJVCBlcnJvciAoZ2gtMjE0NSlcblx0Ly8gaGFzT3duIGlzbid0IHVzZWQgaGVyZSBkdWUgdG8gZmFsc2UgbmVnYXRpdmVzXG5cdC8vIHJlZ2FyZGluZyBOb2RlbGlzdCBsZW5ndGggaW4gSUVcblx0dmFyIGxlbmd0aCA9ICEhb2JqICYmIFwibGVuZ3RoXCIgaW4gb2JqICYmIG9iai5sZW5ndGgsXG5cdFx0dHlwZSA9IHRvVHlwZSggb2JqICk7XG5cblx0aWYgKCBpc0Z1bmN0aW9uKCBvYmogKSB8fCBpc1dpbmRvdyggb2JqICkgKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0cmV0dXJuIHR5cGUgPT09IFwiYXJyYXlcIiB8fCBsZW5ndGggPT09IDAgfHxcblx0XHR0eXBlb2YgbGVuZ3RoID09PSBcIm51bWJlclwiICYmIGxlbmd0aCA+IDAgJiYgKCBsZW5ndGggLSAxICkgaW4gb2JqO1xufVxuXG5cbmZ1bmN0aW9uIG5vZGVOYW1lKCBlbGVtLCBuYW1lICkge1xuXG5cdHJldHVybiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXG59XG52YXIgcG9wID0gYXJyLnBvcDtcblxuXG52YXIgc29ydCA9IGFyci5zb3J0O1xuXG5cbnZhciBzcGxpY2UgPSBhcnIuc3BsaWNlO1xuXG5cbnZhciB3aGl0ZXNwYWNlID0gXCJbXFxcXHgyMFxcXFx0XFxcXHJcXFxcblxcXFxmXVwiO1xuXG5cbnZhciBydHJpbUNTUyA9IG5ldyBSZWdFeHAoXG5cdFwiXlwiICsgd2hpdGVzcGFjZSArIFwiK3woKD86XnxbXlxcXFxcXFxcXSkoPzpcXFxcXFxcXC4pKilcIiArIHdoaXRlc3BhY2UgKyBcIiskXCIsXG5cdFwiZ1wiXG4pO1xuXG5cblxuXG4vLyBOb3RlOiBhbiBlbGVtZW50IGRvZXMgbm90IGNvbnRhaW4gaXRzZWxmXG5qUXVlcnkuY29udGFpbnMgPSBmdW5jdGlvbiggYSwgYiApIHtcblx0dmFyIGJ1cCA9IGIgJiYgYi5wYXJlbnROb2RlO1xuXG5cdHJldHVybiBhID09PSBidXAgfHwgISEoIGJ1cCAmJiBidXAubm9kZVR5cGUgPT09IDEgJiYgKFxuXG5cdFx0Ly8gU3VwcG9ydDogSUUgOSAtIDExK1xuXHRcdC8vIElFIGRvZXNuJ3QgaGF2ZSBgY29udGFpbnNgIG9uIFNWRy5cblx0XHRhLmNvbnRhaW5zID9cblx0XHRcdGEuY29udGFpbnMoIGJ1cCApIDpcblx0XHRcdGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gJiYgYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYnVwICkgJiAxNlxuXHQpICk7XG59O1xuXG5cblxuXG4vLyBDU1Mgc3RyaW5nL2lkZW50aWZpZXIgc2VyaWFsaXphdGlvblxuLy8gaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzc29tLyNjb21tb24tc2VyaWFsaXppbmctaWRpb21zXG52YXIgcmNzc2VzY2FwZSA9IC8oW1xcMC1cXHgxZlxceDdmXXxeLT9cXGQpfF4tJHxbXlxceDgwLVxcdUZGRkZcXHctXS9nO1xuXG5mdW5jdGlvbiBmY3NzZXNjYXBlKCBjaCwgYXNDb2RlUG9pbnQgKSB7XG5cdGlmICggYXNDb2RlUG9pbnQgKSB7XG5cblx0XHQvLyBVKzAwMDAgTlVMTCBiZWNvbWVzIFUrRkZGRCBSRVBMQUNFTUVOVCBDSEFSQUNURVJcblx0XHRpZiAoIGNoID09PSBcIlxcMFwiICkge1xuXHRcdFx0cmV0dXJuIFwiXFx1RkZGRFwiO1xuXHRcdH1cblxuXHRcdC8vIENvbnRyb2wgY2hhcmFjdGVycyBhbmQgKGRlcGVuZGVudCB1cG9uIHBvc2l0aW9uKSBudW1iZXJzIGdldCBlc2NhcGVkIGFzIGNvZGUgcG9pbnRzXG5cdFx0cmV0dXJuIGNoLnNsaWNlKCAwLCAtMSApICsgXCJcXFxcXCIgKyBjaC5jaGFyQ29kZUF0KCBjaC5sZW5ndGggLSAxICkudG9TdHJpbmcoIDE2ICkgKyBcIiBcIjtcblx0fVxuXG5cdC8vIE90aGVyIHBvdGVudGlhbGx5LXNwZWNpYWwgQVNDSUkgY2hhcmFjdGVycyBnZXQgYmFja3NsYXNoLWVzY2FwZWRcblx0cmV0dXJuIFwiXFxcXFwiICsgY2g7XG59XG5cbmpRdWVyeS5lc2NhcGVTZWxlY3RvciA9IGZ1bmN0aW9uKCBzZWwgKSB7XG5cdHJldHVybiAoIHNlbCArIFwiXCIgKS5yZXBsYWNlKCByY3NzZXNjYXBlLCBmY3NzZXNjYXBlICk7XG59O1xuXG5cblxuXG52YXIgcHJlZmVycmVkRG9jID0gZG9jdW1lbnQsXG5cdHB1c2hOYXRpdmUgPSBwdXNoO1xuXG4oIGZ1bmN0aW9uKCkge1xuXG52YXIgaSxcblx0RXhwcixcblx0b3V0ZXJtb3N0Q29udGV4dCxcblx0c29ydElucHV0LFxuXHRoYXNEdXBsaWNhdGUsXG5cdHB1c2ggPSBwdXNoTmF0aXZlLFxuXG5cdC8vIExvY2FsIGRvY3VtZW50IHZhcnNcblx0ZG9jdW1lbnQsXG5cdGRvY3VtZW50RWxlbWVudCxcblx0ZG9jdW1lbnRJc0hUTUwsXG5cdHJidWdneVFTQSxcblx0bWF0Y2hlcyxcblxuXHQvLyBJbnN0YW5jZS1zcGVjaWZpYyBkYXRhXG5cdGV4cGFuZG8gPSBqUXVlcnkuZXhwYW5kbyxcblx0ZGlycnVucyA9IDAsXG5cdGRvbmUgPSAwLFxuXHRjbGFzc0NhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0dG9rZW5DYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdGNvbXBpbGVyQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHRub25uYXRpdmVTZWxlY3RvckNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0c29ydE9yZGVyID0gZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIDA7XG5cdH0sXG5cblx0Ym9vbGVhbnMgPSBcImNoZWNrZWR8c2VsZWN0ZWR8YXN5bmN8YXV0b2ZvY3VzfGF1dG9wbGF5fGNvbnRyb2xzfGRlZmVyfGRpc2FibGVkfGhpZGRlbnxpc21hcHxcIiArXG5cdFx0XCJsb29wfG11bHRpcGxlfG9wZW58cmVhZG9ubHl8cmVxdWlyZWR8c2NvcGVkXCIsXG5cblx0Ly8gUmVndWxhciBleHByZXNzaW9uc1xuXG5cdC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9jc3Mtc3ludGF4LTMvI2lkZW50LXRva2VuLWRpYWdyYW1cblx0aWRlbnRpZmllciA9IFwiKD86XFxcXFxcXFxbXFxcXGRhLWZBLUZdezEsNn1cIiArIHdoaXRlc3BhY2UgK1xuXHRcdFwiP3xcXFxcXFxcXFteXFxcXHJcXFxcblxcXFxmXXxbXFxcXHctXXxbXlxcMC1cXFxceDdmXSkrXCIsXG5cblx0Ly8gQXR0cmlidXRlIHNlbGVjdG9yczogaHR0cHM6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jYXR0cmlidXRlLXNlbGVjdG9yc1xuXHRhdHRyaWJ1dGVzID0gXCJcXFxcW1wiICsgd2hpdGVzcGFjZSArIFwiKihcIiArIGlkZW50aWZpZXIgKyBcIikoPzpcIiArIHdoaXRlc3BhY2UgK1xuXG5cdFx0Ly8gT3BlcmF0b3IgKGNhcHR1cmUgMilcblx0XHRcIiooWypeJHwhfl0/PSlcIiArIHdoaXRlc3BhY2UgK1xuXG5cdFx0Ly8gXCJBdHRyaWJ1dGUgdmFsdWVzIG11c3QgYmUgQ1NTIGlkZW50aWZpZXJzIFtjYXB0dXJlIDVdIG9yIHN0cmluZ3MgW2NhcHR1cmUgMyBvciBjYXB0dXJlIDRdXCJcblx0XHRcIiooPzonKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcJ10pKiknfFxcXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFxcXFwiXSkqKVxcXCJ8KFwiICsgaWRlbnRpZmllciArIFwiKSl8KVwiICtcblx0XHR3aGl0ZXNwYWNlICsgXCIqXFxcXF1cIixcblxuXHRwc2V1ZG9zID0gXCI6KFwiICsgaWRlbnRpZmllciArIFwiKSg/OlxcXFwoKFwiICtcblxuXHRcdC8vIFRvIHJlZHVjZSB0aGUgbnVtYmVyIG9mIHNlbGVjdG9ycyBuZWVkaW5nIHRva2VuaXplIGluIHRoZSBwcmVGaWx0ZXIsIHByZWZlciBhcmd1bWVudHM6XG5cdFx0Ly8gMS4gcXVvdGVkIChjYXB0dXJlIDM7IGNhcHR1cmUgNCBvciBjYXB0dXJlIDUpXG5cdFx0XCIoJygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwiKXxcIiArXG5cblx0XHQvLyAyLiBzaW1wbGUgKGNhcHR1cmUgNilcblx0XHRcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpW1xcXFxdXXxcIiArIGF0dHJpYnV0ZXMgKyBcIikqKXxcIiArXG5cblx0XHQvLyAzLiBhbnl0aGluZyBlbHNlIChjYXB0dXJlIDIpXG5cdFx0XCIuKlwiICtcblx0XHRcIilcXFxcKXwpXCIsXG5cblx0Ly8gTGVhZGluZyBhbmQgbm9uLWVzY2FwZWQgdHJhaWxpbmcgd2hpdGVzcGFjZSwgY2FwdHVyaW5nIHNvbWUgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVycyBwcmVjZWRpbmcgdGhlIGxhdHRlclxuXHRyd2hpdGVzcGFjZSA9IG5ldyBSZWdFeHAoIHdoaXRlc3BhY2UgKyBcIitcIiwgXCJnXCIgKSxcblxuXHRyY29tbWEgPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIiosXCIgKyB3aGl0ZXNwYWNlICsgXCIqXCIgKSxcblx0cmxlYWRpbmdDb21iaW5hdG9yID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqKFs+K35dfFwiICsgd2hpdGVzcGFjZSArIFwiKVwiICtcblx0XHR3aGl0ZXNwYWNlICsgXCIqXCIgKSxcblx0cmRlc2NlbmQgPSBuZXcgUmVnRXhwKCB3aGl0ZXNwYWNlICsgXCJ8PlwiICksXG5cblx0cnBzZXVkbyA9IG5ldyBSZWdFeHAoIHBzZXVkb3MgKSxcblx0cmlkZW50aWZpZXIgPSBuZXcgUmVnRXhwKCBcIl5cIiArIGlkZW50aWZpZXIgKyBcIiRcIiApLFxuXG5cdG1hdGNoRXhwciA9IHtcblx0XHRJRDogbmV3IFJlZ0V4cCggXCJeIyhcIiArIGlkZW50aWZpZXIgKyBcIilcIiApLFxuXHRcdENMQVNTOiBuZXcgUmVnRXhwKCBcIl5cXFxcLihcIiArIGlkZW50aWZpZXIgKyBcIilcIiApLFxuXHRcdFRBRzogbmV3IFJlZ0V4cCggXCJeKFwiICsgaWRlbnRpZmllciArIFwifFsqXSlcIiApLFxuXHRcdEFUVFI6IG5ldyBSZWdFeHAoIFwiXlwiICsgYXR0cmlidXRlcyApLFxuXHRcdFBTRVVETzogbmV3IFJlZ0V4cCggXCJeXCIgKyBwc2V1ZG9zICksXG5cdFx0Q0hJTEQ6IG5ldyBSZWdFeHAoXG5cdFx0XHRcIl46KG9ubHl8Zmlyc3R8bGFzdHxudGh8bnRoLWxhc3QpLShjaGlsZHxvZi10eXBlKSg/OlxcXFwoXCIgK1xuXHRcdFx0XHR3aGl0ZXNwYWNlICsgXCIqKGV2ZW58b2RkfCgoWystXXwpKFxcXFxkKilufClcIiArIHdoaXRlc3BhY2UgKyBcIiooPzooWystXXwpXCIgK1xuXHRcdFx0XHR3aGl0ZXNwYWNlICsgXCIqKFxcXFxkKyl8KSlcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcKXwpXCIsIFwiaVwiICksXG5cdFx0Ym9vbDogbmV3IFJlZ0V4cCggXCJeKD86XCIgKyBib29sZWFucyArIFwiKSRcIiwgXCJpXCIgKSxcblxuXHRcdC8vIEZvciB1c2UgaW4gbGlicmFyaWVzIGltcGxlbWVudGluZyAuaXMoKVxuXHRcdC8vIFdlIHVzZSB0aGlzIGZvciBQT1MgbWF0Y2hpbmcgaW4gYHNlbGVjdGBcblx0XHRuZWVkc0NvbnRleHQ6IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArXG5cdFx0XHRcIipbPit+XXw6KGV2ZW58b2RkfGVxfGd0fGx0fG50aHxmaXJzdHxsYXN0KSg/OlxcXFwoXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcdFwiKigoPzotXFxcXGQpP1xcXFxkKilcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcKXwpKD89W14tXXwkKVwiLCBcImlcIiApXG5cdH0sXG5cblx0cmlucHV0cyA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbikkL2ksXG5cdHJoZWFkZXIgPSAvXmhcXGQkL2ksXG5cblx0Ly8gRWFzaWx5LXBhcnNlYWJsZS9yZXRyaWV2YWJsZSBJRCBvciBUQUcgb3IgQ0xBU1Mgc2VsZWN0b3JzXG5cdHJxdWlja0V4cHIgPSAvXig/OiMoW1xcdy1dKyl8KFxcdyspfFxcLihbXFx3LV0rKSkkLyxcblxuXHRyc2libGluZyA9IC9bK35dLyxcblxuXHQvLyBDU1MgZXNjYXBlc1xuXHQvLyBodHRwczovL3d3dy53My5vcmcvVFIvQ1NTMjEvc3luZGF0YS5odG1sI2VzY2FwZWQtY2hhcmFjdGVyc1xuXHRydW5lc2NhcGUgPSBuZXcgUmVnRXhwKCBcIlxcXFxcXFxcW1xcXFxkYS1mQS1GXXsxLDZ9XCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcIj98XFxcXFxcXFwoW15cXFxcclxcXFxuXFxcXGZdKVwiLCBcImdcIiApLFxuXHRmdW5lc2NhcGUgPSBmdW5jdGlvbiggZXNjYXBlLCBub25IZXggKSB7XG5cdFx0dmFyIGhpZ2ggPSBcIjB4XCIgKyBlc2NhcGUuc2xpY2UoIDEgKSAtIDB4MTAwMDA7XG5cblx0XHRpZiAoIG5vbkhleCApIHtcblxuXHRcdFx0Ly8gU3RyaXAgdGhlIGJhY2tzbGFzaCBwcmVmaXggZnJvbSBhIG5vbi1oZXggZXNjYXBlIHNlcXVlbmNlXG5cdFx0XHRyZXR1cm4gbm9uSGV4O1xuXHRcdH1cblxuXHRcdC8vIFJlcGxhY2UgYSBoZXhhZGVjaW1hbCBlc2NhcGUgc2VxdWVuY2Ugd2l0aCB0aGUgZW5jb2RlZCBVbmljb2RlIGNvZGUgcG9pbnRcblx0XHQvLyBTdXBwb3J0OiBJRSA8PTExK1xuXHRcdC8vIEZvciB2YWx1ZXMgb3V0c2lkZSB0aGUgQmFzaWMgTXVsdGlsaW5ndWFsIFBsYW5lIChCTVApLCBtYW51YWxseSBjb25zdHJ1Y3QgYVxuXHRcdC8vIHN1cnJvZ2F0ZSBwYWlyXG5cdFx0cmV0dXJuIGhpZ2ggPCAwID9cblx0XHRcdFN0cmluZy5mcm9tQ2hhckNvZGUoIGhpZ2ggKyAweDEwMDAwICkgOlxuXHRcdFx0U3RyaW5nLmZyb21DaGFyQ29kZSggaGlnaCA+PiAxMCB8IDB4RDgwMCwgaGlnaCAmIDB4M0ZGIHwgMHhEQzAwICk7XG5cdH0sXG5cblx0Ly8gVXNlZCBmb3IgaWZyYW1lczsgc2VlIGBzZXREb2N1bWVudGAuXG5cdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSssIEVkZ2UgMTIgLSAxOCtcblx0Ly8gUmVtb3ZpbmcgdGhlIGZ1bmN0aW9uIHdyYXBwZXIgY2F1c2VzIGEgXCJQZXJtaXNzaW9uIERlbmllZFwiXG5cdC8vIGVycm9yIGluIElFL0VkZ2UuXG5cdHVubG9hZEhhbmRsZXIgPSBmdW5jdGlvbigpIHtcblx0XHRzZXREb2N1bWVudCgpO1xuXHR9LFxuXG5cdGluRGlzYWJsZWRGaWVsZHNldCA9IGFkZENvbWJpbmF0b3IoXG5cdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gdHJ1ZSAmJiBub2RlTmFtZSggZWxlbSwgXCJmaWVsZHNldFwiICk7XG5cdFx0fSxcblx0XHR7IGRpcjogXCJwYXJlbnROb2RlXCIsIG5leHQ6IFwibGVnZW5kXCIgfVxuXHQpO1xuXG4vLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuLy8gQWNjZXNzaW5nIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgY2FuIHRocm93IHVuZXhwZWN0ZWRseVxuLy8gaHR0cHM6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEzMzkzXG5mdW5jdGlvbiBzYWZlQWN0aXZlRWxlbWVudCgpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcblx0fSBjYXRjaCAoIGVyciApIHsgfVxufVxuXG4vLyBPcHRpbWl6ZSBmb3IgcHVzaC5hcHBseSggXywgTm9kZUxpc3QgKVxudHJ5IHtcblx0cHVzaC5hcHBseShcblx0XHQoIGFyciA9IHNsaWNlLmNhbGwoIHByZWZlcnJlZERvYy5jaGlsZE5vZGVzICkgKSxcblx0XHRwcmVmZXJyZWREb2MuY2hpbGROb2Rlc1xuXHQpO1xuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjBcblx0Ly8gRGV0ZWN0IHNpbGVudGx5IGZhaWxpbmcgcHVzaC5hcHBseVxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zXG5cdGFyclsgcHJlZmVycmVkRG9jLmNoaWxkTm9kZXMubGVuZ3RoIF0ubm9kZVR5cGU7XG59IGNhdGNoICggZSApIHtcblx0cHVzaCA9IHtcblx0XHRhcHBseTogZnVuY3Rpb24oIHRhcmdldCwgZWxzICkge1xuXHRcdFx0cHVzaE5hdGl2ZS5hcHBseSggdGFyZ2V0LCBzbGljZS5jYWxsKCBlbHMgKSApO1xuXHRcdH0sXG5cdFx0Y2FsbDogZnVuY3Rpb24oIHRhcmdldCApIHtcblx0XHRcdHB1c2hOYXRpdmUuYXBwbHkoIHRhcmdldCwgc2xpY2UuY2FsbCggYXJndW1lbnRzLCAxICkgKTtcblx0XHR9XG5cdH07XG59XG5cbmZ1bmN0aW9uIGZpbmQoIHNlbGVjdG9yLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICkge1xuXHR2YXIgbSwgaSwgZWxlbSwgbmlkLCBtYXRjaCwgZ3JvdXBzLCBuZXdTZWxlY3Rvcixcblx0XHRuZXdDb250ZXh0ID0gY29udGV4dCAmJiBjb250ZXh0Lm93bmVyRG9jdW1lbnQsXG5cblx0XHQvLyBub2RlVHlwZSBkZWZhdWx0cyB0byA5LCBzaW5jZSBjb250ZXh0IGRlZmF1bHRzIHRvIGRvY3VtZW50XG5cdFx0bm9kZVR5cGUgPSBjb250ZXh0ID8gY29udGV4dC5ub2RlVHlwZSA6IDk7XG5cblx0cmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG5cblx0Ly8gUmV0dXJuIGVhcmx5IGZyb20gY2FsbHMgd2l0aCBpbnZhbGlkIHNlbGVjdG9yIG9yIGNvbnRleHRcblx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgfHwgIXNlbGVjdG9yIHx8XG5cdFx0bm9kZVR5cGUgIT09IDEgJiYgbm9kZVR5cGUgIT09IDkgJiYgbm9kZVR5cGUgIT09IDExICkge1xuXG5cdFx0cmV0dXJuIHJlc3VsdHM7XG5cdH1cblxuXHQvLyBUcnkgdG8gc2hvcnRjdXQgZmluZCBvcGVyYXRpb25zIChhcyBvcHBvc2VkIHRvIGZpbHRlcnMpIGluIEhUTUwgZG9jdW1lbnRzXG5cdGlmICggIXNlZWQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGNvbnRleHQgKTtcblx0XHRjb250ZXh0ID0gY29udGV4dCB8fCBkb2N1bWVudDtcblxuXHRcdGlmICggZG9jdW1lbnRJc0hUTUwgKSB7XG5cblx0XHRcdC8vIElmIHRoZSBzZWxlY3RvciBpcyBzdWZmaWNpZW50bHkgc2ltcGxlLCB0cnkgdXNpbmcgYSBcImdldCpCeSpcIiBET00gbWV0aG9kXG5cdFx0XHQvLyAoZXhjZXB0aW5nIERvY3VtZW50RnJhZ21lbnQgY29udGV4dCwgd2hlcmUgdGhlIG1ldGhvZHMgZG9uJ3QgZXhpc3QpXG5cdFx0XHRpZiAoIG5vZGVUeXBlICE9PSAxMSAmJiAoIG1hdGNoID0gcnF1aWNrRXhwci5leGVjKCBzZWxlY3RvciApICkgKSB7XG5cblx0XHRcdFx0Ly8gSUQgc2VsZWN0b3Jcblx0XHRcdFx0aWYgKCAoIG0gPSBtYXRjaFsgMSBdICkgKSB7XG5cblx0XHRcdFx0XHQvLyBEb2N1bWVudCBjb250ZXh0XG5cdFx0XHRcdFx0aWYgKCBub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0XHRcdGlmICggKCBlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggbSApICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgOSBvbmx5XG5cdFx0XHRcdFx0XHRcdC8vIGdldEVsZW1lbnRCeUlkIGNhbiBtYXRjaCBlbGVtZW50cyBieSBuYW1lIGluc3RlYWQgb2YgSURcblx0XHRcdFx0XHRcdFx0aWYgKCBlbGVtLmlkID09PSBtICkge1xuXHRcdFx0XHRcdFx0XHRcdHB1c2guY2FsbCggcmVzdWx0cywgZWxlbSApO1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIEVsZW1lbnQgY29udGV4dFxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDkgb25seVxuXHRcdFx0XHRcdFx0Ly8gZ2V0RWxlbWVudEJ5SWQgY2FuIG1hdGNoIGVsZW1lbnRzIGJ5IG5hbWUgaW5zdGVhZCBvZiBJRFxuXHRcdFx0XHRcdFx0aWYgKCBuZXdDb250ZXh0ICYmICggZWxlbSA9IG5ld0NvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIG0gKSApICYmXG5cdFx0XHRcdFx0XHRcdGZpbmQuY29udGFpbnMoIGNvbnRleHQsIGVsZW0gKSAmJlxuXHRcdFx0XHRcdFx0XHRlbGVtLmlkID09PSBtICkge1xuXG5cdFx0XHRcdFx0XHRcdHB1c2guY2FsbCggcmVzdWx0cywgZWxlbSApO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVHlwZSBzZWxlY3RvclxuXHRcdFx0XHR9IGVsc2UgaWYgKCBtYXRjaFsgMiBdICkge1xuXHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHNlbGVjdG9yICkgKTtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblxuXHRcdFx0XHQvLyBDbGFzcyBzZWxlY3RvclxuXHRcdFx0XHR9IGVsc2UgaWYgKCAoIG0gPSBtYXRjaFsgMyBdICkgJiYgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICkge1xuXHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSggbSApICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gVGFrZSBhZHZhbnRhZ2Ugb2YgcXVlcnlTZWxlY3RvckFsbFxuXHRcdFx0aWYgKCAhbm9ubmF0aXZlU2VsZWN0b3JDYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdICYmXG5cdFx0XHRcdCggIXJidWdneVFTQSB8fCAhcmJ1Z2d5UVNBLnRlc3QoIHNlbGVjdG9yICkgKSApIHtcblxuXHRcdFx0XHRuZXdTZWxlY3RvciA9IHNlbGVjdG9yO1xuXHRcdFx0XHRuZXdDb250ZXh0ID0gY29udGV4dDtcblxuXHRcdFx0XHQvLyBxU0EgY29uc2lkZXJzIGVsZW1lbnRzIG91dHNpZGUgYSBzY29waW5nIHJvb3Qgd2hlbiBldmFsdWF0aW5nIGNoaWxkIG9yXG5cdFx0XHRcdC8vIGRlc2NlbmRhbnQgY29tYmluYXRvcnMsIHdoaWNoIGlzIG5vdCB3aGF0IHdlIHdhbnQuXG5cdFx0XHRcdC8vIEluIHN1Y2ggY2FzZXMsIHdlIHdvcmsgYXJvdW5kIHRoZSBiZWhhdmlvciBieSBwcmVmaXhpbmcgZXZlcnkgc2VsZWN0b3IgaW4gdGhlXG5cdFx0XHRcdC8vIGxpc3Qgd2l0aCBhbiBJRCBzZWxlY3RvciByZWZlcmVuY2luZyB0aGUgc2NvcGUgY29udGV4dC5cblx0XHRcdFx0Ly8gVGhlIHRlY2huaXF1ZSBoYXMgdG8gYmUgdXNlZCBhcyB3ZWxsIHdoZW4gYSBsZWFkaW5nIGNvbWJpbmF0b3IgaXMgdXNlZFxuXHRcdFx0XHQvLyBhcyBzdWNoIHNlbGVjdG9ycyBhcmUgbm90IHJlY29nbml6ZWQgYnkgcXVlcnlTZWxlY3RvckFsbC5cblx0XHRcdFx0Ly8gVGhhbmtzIHRvIEFuZHJldyBEdXBvbnQgZm9yIHRoaXMgdGVjaG5pcXVlLlxuXHRcdFx0XHRpZiAoIG5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdFx0KCByZGVzY2VuZC50ZXN0KCBzZWxlY3RvciApIHx8IHJsZWFkaW5nQ29tYmluYXRvci50ZXN0KCBzZWxlY3RvciApICkgKSB7XG5cblx0XHRcdFx0XHQvLyBFeHBhbmQgY29udGV4dCBmb3Igc2libGluZyBzZWxlY3RvcnNcblx0XHRcdFx0XHRuZXdDb250ZXh0ID0gcnNpYmxpbmcudGVzdCggc2VsZWN0b3IgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHxcblx0XHRcdFx0XHRcdGNvbnRleHQ7XG5cblx0XHRcdFx0XHQvLyBXZSBjYW4gdXNlIDpzY29wZSBpbnN0ZWFkIG9mIHRoZSBJRCBoYWNrIGlmIHRoZSBicm93c2VyXG5cdFx0XHRcdFx0Ly8gc3VwcG9ydHMgaXQgJiBpZiB3ZSdyZSBub3QgY2hhbmdpbmcgdGhlIGNvbnRleHQuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXG5cdFx0XHRcdFx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlblxuXHRcdFx0XHRcdC8vIHN0cmljdC1jb21wYXJpbmcgdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHRcdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblx0XHRcdFx0XHRpZiAoIG5ld0NvbnRleHQgIT0gY29udGV4dCB8fCAhc3VwcG9ydC5zY29wZSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gQ2FwdHVyZSB0aGUgY29udGV4dCBJRCwgc2V0dGluZyBpdCBmaXJzdCBpZiBuZWNlc3Nhcnlcblx0XHRcdFx0XHRcdGlmICggKCBuaWQgPSBjb250ZXh0LmdldEF0dHJpYnV0ZSggXCJpZFwiICkgKSApIHtcblx0XHRcdFx0XHRcdFx0bmlkID0galF1ZXJ5LmVzY2FwZVNlbGVjdG9yKCBuaWQgKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGNvbnRleHQuc2V0QXR0cmlidXRlKCBcImlkXCIsICggbmlkID0gZXhwYW5kbyApICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gUHJlZml4IGV2ZXJ5IHNlbGVjdG9yIGluIHRoZSBsaXN0XG5cdFx0XHRcdFx0Z3JvdXBzID0gdG9rZW5pemUoIHNlbGVjdG9yICk7XG5cdFx0XHRcdFx0aSA9IGdyb3Vwcy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRncm91cHNbIGkgXSA9ICggbmlkID8gXCIjXCIgKyBuaWQgOiBcIjpzY29wZVwiICkgKyBcIiBcIiArXG5cdFx0XHRcdFx0XHRcdHRvU2VsZWN0b3IoIGdyb3Vwc1sgaSBdICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG5ld1NlbGVjdG9yID0gZ3JvdXBzLmpvaW4oIFwiLFwiICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsXG5cdFx0XHRcdFx0XHRuZXdDb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIG5ld1NlbGVjdG9yIClcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHR9IGNhdGNoICggcXNhRXJyb3IgKSB7XG5cdFx0XHRcdFx0bm9ubmF0aXZlU2VsZWN0b3JDYWNoZSggc2VsZWN0b3IsIHRydWUgKTtcblx0XHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0XHRpZiAoIG5pZCA9PT0gZXhwYW5kbyApIHtcblx0XHRcdFx0XHRcdGNvbnRleHQucmVtb3ZlQXR0cmlidXRlKCBcImlkXCIgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBBbGwgb3RoZXJzXG5cdHJldHVybiBzZWxlY3QoIHNlbGVjdG9yLnJlcGxhY2UoIHJ0cmltQ1NTLCBcIiQxXCIgKSwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApO1xufVxuXG4vKipcbiAqIENyZWF0ZSBrZXktdmFsdWUgY2FjaGVzIG9mIGxpbWl0ZWQgc2l6ZVxuICogQHJldHVybnMge2Z1bmN0aW9uKHN0cmluZywgb2JqZWN0KX0gUmV0dXJucyB0aGUgT2JqZWN0IGRhdGEgYWZ0ZXIgc3RvcmluZyBpdCBvbiBpdHNlbGYgd2l0aFxuICpcdHByb3BlcnR5IG5hbWUgdGhlIChzcGFjZS1zdWZmaXhlZCkgc3RyaW5nIGFuZCAoaWYgdGhlIGNhY2hlIGlzIGxhcmdlciB0aGFuIEV4cHIuY2FjaGVMZW5ndGgpXG4gKlx0ZGVsZXRpbmcgdGhlIG9sZGVzdCBlbnRyeVxuICovXG5mdW5jdGlvbiBjcmVhdGVDYWNoZSgpIHtcblx0dmFyIGtleXMgPSBbXTtcblxuXHRmdW5jdGlvbiBjYWNoZSgga2V5LCB2YWx1ZSApIHtcblxuXHRcdC8vIFVzZSAoa2V5ICsgXCIgXCIpIHRvIGF2b2lkIGNvbGxpc2lvbiB3aXRoIG5hdGl2ZSBwcm90b3R5cGUgcHJvcGVydGllc1xuXHRcdC8vIChzZWUgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9zaXp6bGUvaXNzdWVzLzE1Nylcblx0XHRpZiAoIGtleXMucHVzaCgga2V5ICsgXCIgXCIgKSA+IEV4cHIuY2FjaGVMZW5ndGggKSB7XG5cblx0XHRcdC8vIE9ubHkga2VlcCB0aGUgbW9zdCByZWNlbnQgZW50cmllc1xuXHRcdFx0ZGVsZXRlIGNhY2hlWyBrZXlzLnNoaWZ0KCkgXTtcblx0XHR9XG5cdFx0cmV0dXJuICggY2FjaGVbIGtleSArIFwiIFwiIF0gPSB2YWx1ZSApO1xuXHR9XG5cdHJldHVybiBjYWNoZTtcbn1cblxuLyoqXG4gKiBNYXJrIGEgZnVuY3Rpb24gZm9yIHNwZWNpYWwgdXNlIGJ5IGpRdWVyeSBzZWxlY3RvciBtb2R1bGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBtYXJrXG4gKi9cbmZ1bmN0aW9uIG1hcmtGdW5jdGlvbiggZm4gKSB7XG5cdGZuWyBleHBhbmRvIF0gPSB0cnVlO1xuXHRyZXR1cm4gZm47XG59XG5cbi8qKlxuICogU3VwcG9ydCB0ZXN0aW5nIHVzaW5nIGFuIGVsZW1lbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFBhc3NlZCB0aGUgY3JlYXRlZCBlbGVtZW50IGFuZCByZXR1cm5zIGEgYm9vbGVhbiByZXN1bHRcbiAqL1xuZnVuY3Rpb24gYXNzZXJ0KCBmbiApIHtcblx0dmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJmaWVsZHNldFwiICk7XG5cblx0dHJ5IHtcblx0XHRyZXR1cm4gISFmbiggZWwgKTtcblx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9IGZpbmFsbHkge1xuXG5cdFx0Ly8gUmVtb3ZlIGZyb20gaXRzIHBhcmVudCBieSBkZWZhdWx0XG5cdFx0aWYgKCBlbC5wYXJlbnROb2RlICkge1xuXHRcdFx0ZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggZWwgKTtcblx0XHR9XG5cblx0XHQvLyByZWxlYXNlIG1lbW9yeSBpbiBJRVxuXHRcdGVsID0gbnVsbDtcblx0fVxufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgaW5wdXQgdHlwZXNcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUlucHV0UHNldWRvKCB0eXBlICkge1xuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIG5vZGVOYW1lKCBlbGVtLCBcImlucHV0XCIgKSAmJiBlbGVtLnR5cGUgPT09IHR5cGU7XG5cdH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBidXR0b25zXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICovXG5mdW5jdGlvbiBjcmVhdGVCdXR0b25Qc2V1ZG8oIHR5cGUgKSB7XG5cdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gKCBub2RlTmFtZSggZWxlbSwgXCJpbnB1dFwiICkgfHwgbm9kZU5hbWUoIGVsZW0sIFwiYnV0dG9uXCIgKSApICYmXG5cdFx0XHRlbGVtLnR5cGUgPT09IHR5cGU7XG5cdH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciA6ZW5hYmxlZC86ZGlzYWJsZWRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZGlzYWJsZWQgdHJ1ZSBmb3IgOmRpc2FibGVkOyBmYWxzZSBmb3IgOmVuYWJsZWRcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRGlzYWJsZWRQc2V1ZG8oIGRpc2FibGVkICkge1xuXG5cdC8vIEtub3duIDpkaXNhYmxlZCBmYWxzZSBwb3NpdGl2ZXM6IGZpZWxkc2V0W2Rpc2FibGVkXSA+IGxlZ2VuZDpudGgtb2YtdHlwZShuKzIpIDpjYW4tZGlzYWJsZVxuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHQvLyBPbmx5IGNlcnRhaW4gZWxlbWVudHMgY2FuIG1hdGNoIDplbmFibGVkIG9yIDpkaXNhYmxlZFxuXHRcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NjcmlwdGluZy5odG1sI3NlbGVjdG9yLWVuYWJsZWRcblx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zY3JpcHRpbmcuaHRtbCNzZWxlY3Rvci1kaXNhYmxlZFxuXHRcdGlmICggXCJmb3JtXCIgaW4gZWxlbSApIHtcblxuXHRcdFx0Ly8gQ2hlY2sgZm9yIGluaGVyaXRlZCBkaXNhYmxlZG5lc3Mgb24gcmVsZXZhbnQgbm9uLWRpc2FibGVkIGVsZW1lbnRzOlxuXHRcdFx0Ly8gKiBsaXN0ZWQgZm9ybS1hc3NvY2lhdGVkIGVsZW1lbnRzIGluIGEgZGlzYWJsZWQgZmllbGRzZXRcblx0XHRcdC8vICAgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybXMuaHRtbCNjYXRlZ29yeS1saXN0ZWRcblx0XHRcdC8vICAgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybXMuaHRtbCNjb25jZXB0LWZlLWRpc2FibGVkXG5cdFx0XHQvLyAqIG9wdGlvbiBlbGVtZW50cyBpbiBhIGRpc2FibGVkIG9wdGdyb3VwXG5cdFx0XHQvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY29uY2VwdC1vcHRpb24tZGlzYWJsZWRcblx0XHRcdC8vIEFsbCBzdWNoIGVsZW1lbnRzIGhhdmUgYSBcImZvcm1cIiBwcm9wZXJ0eS5cblx0XHRcdGlmICggZWxlbS5wYXJlbnROb2RlICYmIGVsZW0uZGlzYWJsZWQgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdC8vIE9wdGlvbiBlbGVtZW50cyBkZWZlciB0byBhIHBhcmVudCBvcHRncm91cCBpZiBwcmVzZW50XG5cdFx0XHRcdGlmICggXCJsYWJlbFwiIGluIGVsZW0gKSB7XG5cdFx0XHRcdFx0aWYgKCBcImxhYmVsXCIgaW4gZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW0ucGFyZW50Tm9kZS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA2IC0gMTErXG5cdFx0XHRcdC8vIFVzZSB0aGUgaXNEaXNhYmxlZCBzaG9ydGN1dCBwcm9wZXJ0eSB0byBjaGVjayBmb3IgZGlzYWJsZWQgZmllbGRzZXQgYW5jZXN0b3JzXG5cdFx0XHRcdHJldHVybiBlbGVtLmlzRGlzYWJsZWQgPT09IGRpc2FibGVkIHx8XG5cblx0XHRcdFx0XHQvLyBXaGVyZSB0aGVyZSBpcyBubyBpc0Rpc2FibGVkLCBjaGVjayBtYW51YWxseVxuXHRcdFx0XHRcdGVsZW0uaXNEaXNhYmxlZCAhPT0gIWRpc2FibGVkICYmXG5cdFx0XHRcdFx0XHRpbkRpc2FibGVkRmllbGRzZXQoIGVsZW0gKSA9PT0gZGlzYWJsZWQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblxuXHRcdC8vIFRyeSB0byB3aW5ub3cgb3V0IGVsZW1lbnRzIHRoYXQgY2FuJ3QgYmUgZGlzYWJsZWQgYmVmb3JlIHRydXN0aW5nIHRoZSBkaXNhYmxlZCBwcm9wZXJ0eS5cblx0XHQvLyBTb21lIHZpY3RpbXMgZ2V0IGNhdWdodCBpbiBvdXIgbmV0IChsYWJlbCwgbGVnZW5kLCBtZW51LCB0cmFjayksIGJ1dCBpdCBzaG91bGRuJ3Rcblx0XHQvLyBldmVuIGV4aXN0IG9uIHRoZW0sIGxldCBhbG9uZSBoYXZlIGEgYm9vbGVhbiB2YWx1ZS5cblx0XHR9IGVsc2UgaWYgKCBcImxhYmVsXCIgaW4gZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblx0XHR9XG5cblx0XHQvLyBSZW1haW5pbmcgZWxlbWVudHMgYXJlIG5laXRoZXIgOmVuYWJsZWQgbm9yIDpkaXNhYmxlZFxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIHBvc2l0aW9uYWxzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICovXG5mdW5jdGlvbiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmbiApIHtcblx0cmV0dXJuIG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIGFyZ3VtZW50ICkge1xuXHRcdGFyZ3VtZW50ID0gK2FyZ3VtZW50O1xuXHRcdHJldHVybiBtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzICkge1xuXHRcdFx0dmFyIGosXG5cdFx0XHRcdG1hdGNoSW5kZXhlcyA9IGZuKCBbXSwgc2VlZC5sZW5ndGgsIGFyZ3VtZW50ICksXG5cdFx0XHRcdGkgPSBtYXRjaEluZGV4ZXMubGVuZ3RoO1xuXG5cdFx0XHQvLyBNYXRjaCBlbGVtZW50cyBmb3VuZCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4ZXNcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoIHNlZWRbICggaiA9IG1hdGNoSW5kZXhlc1sgaSBdICkgXSApIHtcblx0XHRcdFx0XHRzZWVkWyBqIF0gPSAhKCBtYXRjaGVzWyBqIF0gPSBzZWVkWyBqIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSApO1xufVxuXG4vKipcbiAqIENoZWNrcyBhIG5vZGUgZm9yIHZhbGlkaXR5IGFzIGEgalF1ZXJ5IHNlbGVjdG9yIGNvbnRleHRcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3Q9fSBjb250ZXh0XG4gKiBAcmV0dXJucyB7RWxlbWVudHxPYmplY3R8Qm9vbGVhbn0gVGhlIGlucHV0IG5vZGUgaWYgYWNjZXB0YWJsZSwgb3RoZXJ3aXNlIGEgZmFsc3kgdmFsdWVcbiAqL1xuZnVuY3Rpb24gdGVzdENvbnRleHQoIGNvbnRleHQgKSB7XG5cdHJldHVybiBjb250ZXh0ICYmIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICYmIGNvbnRleHQ7XG59XG5cbi8qKlxuICogU2V0cyBkb2N1bWVudC1yZWxhdGVkIHZhcmlhYmxlcyBvbmNlIGJhc2VkIG9uIHRoZSBjdXJyZW50IGRvY3VtZW50XG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBbbm9kZV0gQW4gZWxlbWVudCBvciBkb2N1bWVudCBvYmplY3QgdG8gdXNlIHRvIHNldCB0aGUgZG9jdW1lbnRcbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGN1cnJlbnQgZG9jdW1lbnRcbiAqL1xuZnVuY3Rpb24gc2V0RG9jdW1lbnQoIG5vZGUgKSB7XG5cdHZhciBzdWJXaW5kb3csXG5cdFx0ZG9jID0gbm9kZSA/IG5vZGUub3duZXJEb2N1bWVudCB8fCBub2RlIDogcHJlZmVycmVkRG9jO1xuXG5cdC8vIFJldHVybiBlYXJseSBpZiBkb2MgaXMgaW52YWxpZCBvciBhbHJlYWR5IHNlbGVjdGVkXG5cdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcblx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cdGlmICggZG9jID09IGRvY3VtZW50IHx8IGRvYy5ub2RlVHlwZSAhPT0gOSB8fCAhZG9jLmRvY3VtZW50RWxlbWVudCApIHtcblx0XHRyZXR1cm4gZG9jdW1lbnQ7XG5cdH1cblxuXHQvLyBVcGRhdGUgZ2xvYmFsIHZhcmlhYmxlc1xuXHRkb2N1bWVudCA9IGRvYztcblx0ZG9jdW1lbnRFbGVtZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXHRkb2N1bWVudElzSFRNTCA9ICFqUXVlcnkuaXNYTUxEb2MoIGRvY3VtZW50ICk7XG5cblx0Ly8gU3VwcG9ydDogaU9TIDcgb25seSwgSUUgOSAtIDExK1xuXHQvLyBPbGRlciBicm93c2VycyBkaWRuJ3Qgc3VwcG9ydCB1bnByZWZpeGVkIGBtYXRjaGVzYC5cblx0bWF0Y2hlcyA9IGRvY3VtZW50RWxlbWVudC5tYXRjaGVzIHx8XG5cdFx0ZG9jdW1lbnRFbGVtZW50LndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fFxuXHRcdGRvY3VtZW50RWxlbWVudC5tc01hdGNoZXNTZWxlY3RvcjtcblxuXHQvLyBTdXBwb3J0OiBJRSA5IC0gMTErLCBFZGdlIDEyIC0gMTgrXG5cdC8vIEFjY2Vzc2luZyBpZnJhbWUgZG9jdW1lbnRzIGFmdGVyIHVubG9hZCB0aHJvd3MgXCJwZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yc1xuXHQvLyAoc2VlIHRyYWMtMTM5MzYpLlxuXHQvLyBMaW1pdCB0aGUgZml4IHRvIElFICYgRWRnZSBMZWdhY3k7IGRlc3BpdGUgRWRnZSAxNSsgaW1wbGVtZW50aW5nIGBtYXRjaGVzYCxcblx0Ly8gYWxsIElFIDkrIGFuZCBFZGdlIExlZ2FjeSB2ZXJzaW9ucyBpbXBsZW1lbnQgYG1zTWF0Y2hlc1NlbGVjdG9yYCBhcyB3ZWxsLlxuXHRpZiAoIGRvY3VtZW50RWxlbWVudC5tc01hdGNoZXNTZWxlY3RvciAmJlxuXG5cdFx0Ly8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXG5cdFx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdFx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblx0XHRwcmVmZXJyZWREb2MgIT0gZG9jdW1lbnQgJiZcblx0XHQoIHN1YldpbmRvdyA9IGRvY3VtZW50LmRlZmF1bHRWaWV3ICkgJiYgc3ViV2luZG93LnRvcCAhPT0gc3ViV2luZG93ICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgOSAtIDExKywgRWRnZSAxMiAtIDE4K1xuXHRcdHN1YldpbmRvdy5hZGRFdmVudExpc3RlbmVyKCBcInVubG9hZFwiLCB1bmxvYWRIYW5kbGVyICk7XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBJRSA8MTBcblx0Ly8gQ2hlY2sgaWYgZ2V0RWxlbWVudEJ5SWQgcmV0dXJucyBlbGVtZW50cyBieSBuYW1lXG5cdC8vIFRoZSBicm9rZW4gZ2V0RWxlbWVudEJ5SWQgbWV0aG9kcyBkb24ndCBwaWNrIHVwIHByb2dyYW1tYXRpY2FsbHktc2V0IG5hbWVzLFxuXHQvLyBzbyB1c2UgYSByb3VuZGFib3V0IGdldEVsZW1lbnRzQnlOYW1lIHRlc3Rcblx0c3VwcG9ydC5nZXRCeUlkID0gYXNzZXJ0KCBmdW5jdGlvbiggZWwgKSB7XG5cdFx0ZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKCBlbCApLmlkID0galF1ZXJ5LmV4cGFuZG87XG5cdFx0cmV0dXJuICFkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZSB8fFxuXHRcdFx0IWRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKCBqUXVlcnkuZXhwYW5kbyApLmxlbmd0aDtcblx0fSApO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDkgb25seVxuXHQvLyBDaGVjayB0byBzZWUgaWYgaXQncyBwb3NzaWJsZSB0byBkbyBtYXRjaGVzU2VsZWN0b3Jcblx0Ly8gb24gYSBkaXNjb25uZWN0ZWQgbm9kZS5cblx0c3VwcG9ydC5kaXNjb25uZWN0ZWRNYXRjaCA9IGFzc2VydCggZnVuY3Rpb24oIGVsICkge1xuXHRcdHJldHVybiBtYXRjaGVzLmNhbGwoIGVsLCBcIipcIiApO1xuXHR9ICk7XG5cblx0Ly8gU3VwcG9ydDogSUUgOSAtIDExKywgRWRnZSAxMiAtIDE4K1xuXHQvLyBJRS9FZGdlIGRvbid0IHN1cHBvcnQgdGhlIDpzY29wZSBwc2V1ZG8tY2xhc3MuXG5cdHN1cHBvcnQuc2NvcGUgPSBhc3NlcnQoIGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCBcIjpzY29wZVwiICk7XG5cdH0gKTtcblxuXHQvLyBTdXBwb3J0OiBDaHJvbWUgMTA1IC0gMTExIG9ubHksIFNhZmFyaSAxNS40IC0gMTYuMyBvbmx5XG5cdC8vIE1ha2Ugc3VyZSB0aGUgYDpoYXMoKWAgYXJndW1lbnQgaXMgcGFyc2VkIHVuZm9yZ2l2aW5nbHkuXG5cdC8vIFdlIGluY2x1ZGUgYCpgIGluIHRoZSB0ZXN0IHRvIGRldGVjdCBidWdneSBpbXBsZW1lbnRhdGlvbnMgdGhhdCBhcmVcblx0Ly8gX3NlbGVjdGl2ZWx5XyBmb3JnaXZpbmcgKHNwZWNpZmljYWxseSB3aGVuIHRoZSBsaXN0IGluY2x1ZGVzIGF0IGxlYXN0XG5cdC8vIG9uZSB2YWxpZCBzZWxlY3RvcikuXG5cdC8vIE5vdGUgdGhhdCB3ZSB0cmVhdCBjb21wbGV0ZSBsYWNrIG9mIHN1cHBvcnQgZm9yIGA6aGFzKClgIGFzIGlmIGl0IHdlcmVcblx0Ly8gc3BlYy1jb21wbGlhbnQgc3VwcG9ydCwgd2hpY2ggaXMgZmluZSBiZWNhdXNlIHVzZSBvZiBgOmhhcygpYCBpbiBzdWNoXG5cdC8vIGVudmlyb25tZW50cyB3aWxsIGZhaWwgaW4gdGhlIHFTQSBwYXRoIGFuZCBmYWxsIGJhY2sgdG8galF1ZXJ5IHRyYXZlcnNhbFxuXHQvLyBhbnl3YXkuXG5cdHN1cHBvcnQuY3NzSGFzID0gYXNzZXJ0KCBmdW5jdGlvbigpIHtcblx0XHR0cnkge1xuXHRcdFx0ZG9jdW1lbnQucXVlcnlTZWxlY3RvciggXCI6aGFzKCosOmpxZmFrZSlcIiApO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0gY2F0Y2ggKCBlICkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHR9ICk7XG5cblx0Ly8gSUQgZmlsdGVyIGFuZCBmaW5kXG5cdGlmICggc3VwcG9ydC5nZXRCeUlkICkge1xuXHRcdEV4cHIuZmlsdGVyLklEID0gZnVuY3Rpb24oIGlkICkge1xuXHRcdFx0dmFyIGF0dHJJZCA9IGlkLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggXCJpZFwiICkgPT09IGF0dHJJZDtcblx0XHRcdH07XG5cdFx0fTtcblx0XHRFeHByLmZpbmQuSUQgPSBmdW5jdGlvbiggaWQsIGNvbnRleHQgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRCeUlkICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuXHRcdFx0XHR2YXIgZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIGlkICk7XG5cdFx0XHRcdHJldHVybiBlbGVtID8gWyBlbGVtIF0gOiBbXTtcblx0XHRcdH1cblx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdEV4cHIuZmlsdGVyLklEID0gIGZ1bmN0aW9uKCBpZCApIHtcblx0XHRcdHZhciBhdHRySWQgPSBpZC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgbm9kZSA9IHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZU5vZGUgIT09IFwidW5kZWZpbmVkXCIgJiZcblx0XHRcdFx0XHRlbGVtLmdldEF0dHJpYnV0ZU5vZGUoIFwiaWRcIiApO1xuXHRcdFx0XHRyZXR1cm4gbm9kZSAmJiBub2RlLnZhbHVlID09PSBhdHRySWQ7XG5cdFx0XHR9O1xuXHRcdH07XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA2IC0gNyBvbmx5XG5cdFx0Ly8gZ2V0RWxlbWVudEJ5SWQgaXMgbm90IHJlbGlhYmxlIGFzIGEgZmluZCBzaG9ydGN1dFxuXHRcdEV4cHIuZmluZC5JRCA9IGZ1bmN0aW9uKCBpZCwgY29udGV4dCApIHtcblx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnRJc0hUTUwgKSB7XG5cdFx0XHRcdHZhciBub2RlLCBpLCBlbGVtcyxcblx0XHRcdFx0XHRlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggaWQgKTtcblxuXHRcdFx0XHRpZiAoIGVsZW0gKSB7XG5cblx0XHRcdFx0XHQvLyBWZXJpZnkgdGhlIGlkIGF0dHJpYnV0ZVxuXHRcdFx0XHRcdG5vZGUgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoIFwiaWRcIiApO1xuXHRcdFx0XHRcdGlmICggbm9kZSAmJiBub2RlLnZhbHVlID09PSBpZCApIHtcblx0XHRcdFx0XHRcdHJldHVybiBbIGVsZW0gXTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBGYWxsIGJhY2sgb24gZ2V0RWxlbWVudHNCeU5hbWVcblx0XHRcdFx0XHRlbGVtcyA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeU5hbWUoIGlkICk7XG5cdFx0XHRcdFx0aSA9IDA7XG5cdFx0XHRcdFx0d2hpbGUgKCAoIGVsZW0gPSBlbGVtc1sgaSsrIF0gKSApIHtcblx0XHRcdFx0XHRcdG5vZGUgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoIFwiaWRcIiApO1xuXHRcdFx0XHRcdFx0aWYgKCBub2RlICYmIG5vZGUudmFsdWUgPT09IGlkICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gWyBlbGVtIF07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIFtdO1xuXHRcdFx0fVxuXHRcdH07XG5cdH1cblxuXHQvLyBUYWdcblx0RXhwci5maW5kLlRBRyA9IGZ1bmN0aW9uKCB0YWcsIGNvbnRleHQgKSB7XG5cdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRcdHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgKTtcblxuXHRcdC8vIERvY3VtZW50RnJhZ21lbnQgbm9kZXMgZG9uJ3QgaGF2ZSBnRUJUTlxuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCB0YWcgKTtcblx0XHR9XG5cdH07XG5cblx0Ly8gQ2xhc3Ncblx0RXhwci5maW5kLkNMQVNTID0gZnVuY3Rpb24oIGNsYXNzTmFtZSwgY29udGV4dCApIHtcblx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnRJc0hUTUwgKSB7XG5cdFx0XHRyZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCBjbGFzc05hbWUgKTtcblx0XHR9XG5cdH07XG5cblx0LyogUVNBL21hdGNoZXNTZWxlY3RvclxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gUVNBIGFuZCBtYXRjaGVzU2VsZWN0b3Igc3VwcG9ydFxuXG5cdHJidWdneVFTQSA9IFtdO1xuXG5cdC8vIEJ1aWxkIFFTQSByZWdleFxuXHQvLyBSZWdleCBzdHJhdGVneSBhZG9wdGVkIGZyb20gRGllZ28gUGVyaW5pXG5cdGFzc2VydCggZnVuY3Rpb24oIGVsICkge1xuXG5cdFx0dmFyIGlucHV0O1xuXG5cdFx0ZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKCBlbCApLmlubmVySFRNTCA9XG5cdFx0XHRcIjxhIGlkPSdcIiArIGV4cGFuZG8gKyBcIicgaHJlZj0nJyBkaXNhYmxlZD0nZGlzYWJsZWQnPjwvYT5cIiArXG5cdFx0XHRcIjxzZWxlY3QgaWQ9J1wiICsgZXhwYW5kbyArIFwiLVxcclxcXFwnIGRpc2FibGVkPSdkaXNhYmxlZCc+XCIgK1xuXHRcdFx0XCI8b3B0aW9uIHNlbGVjdGVkPScnPjwvb3B0aW9uPjwvc2VsZWN0PlwiO1xuXG5cdFx0Ly8gU3VwcG9ydDogaU9TIDw9NyAtIDggb25seVxuXHRcdC8vIEJvb2xlYW4gYXR0cmlidXRlcyBhbmQgXCJ2YWx1ZVwiIGFyZSBub3QgdHJlYXRlZCBjb3JyZWN0bHkgaW4gc29tZSBYTUwgZG9jdW1lbnRzXG5cdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbCggXCJbc2VsZWN0ZWRdXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJcXFxcW1wiICsgd2hpdGVzcGFjZSArIFwiKig/OnZhbHVlfFwiICsgYm9vbGVhbnMgKyBcIilcIiApO1xuXHRcdH1cblxuXHRcdC8vIFN1cHBvcnQ6IGlPUyA8PTcgLSA4IG9ubHlcblx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKCBcIltpZH49XCIgKyBleHBhbmRvICsgXCItXVwiICkubGVuZ3RoICkge1xuXHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwifj1cIiApO1xuXHRcdH1cblxuXHRcdC8vIFN1cHBvcnQ6IGlPUyA4IG9ubHlcblx0XHQvLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM2ODUxXG5cdFx0Ly8gSW4tcGFnZSBgc2VsZWN0b3IjaWQgc2libGluZy1jb21iaW5hdG9yIHNlbGVjdG9yYCBmYWlsc1xuXHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiYSNcIiArIGV4cGFuZG8gKyBcIisqXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRyYnVnZ3lRU0EucHVzaCggXCIuIy4rWyt+XVwiICk7XG5cdFx0fVxuXG5cdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9MTA1KywgRmlyZWZveCA8PTEwNCssIFNhZmFyaSA8PTE1LjQrXG5cdFx0Ly8gSW4gc29tZSBvZiB0aGUgZG9jdW1lbnQga2luZHMsIHRoZXNlIHNlbGVjdG9ycyB3b3VsZG4ndCB3b3JrIG5hdGl2ZWx5LlxuXHRcdC8vIFRoaXMgaXMgcHJvYmFibHkgT0sgYnV0IGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3ZSB3YW50IHRvIG1haW50YWluXG5cdFx0Ly8gaGFuZGxpbmcgdGhlbSB0aHJvdWdoIGpRdWVyeSB0cmF2ZXJzYWwgaW4galF1ZXJ5IDMueC5cblx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKCBcIjpjaGVja2VkXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRyYnVnZ3lRU0EucHVzaCggXCI6Y2hlY2tlZFwiICk7XG5cdFx0fVxuXG5cdFx0Ly8gU3VwcG9ydDogV2luZG93cyA4IE5hdGl2ZSBBcHBzXG5cdFx0Ly8gVGhlIHR5cGUgYW5kIG5hbWUgYXR0cmlidXRlcyBhcmUgcmVzdHJpY3RlZCBkdXJpbmcgLmlubmVySFRNTCBhc3NpZ25tZW50XG5cdFx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKTtcblx0XHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCBcImhpZGRlblwiICk7XG5cdFx0ZWwuYXBwZW5kQ2hpbGQoIGlucHV0ICkuc2V0QXR0cmlidXRlKCBcIm5hbWVcIiwgXCJEXCIgKTtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgLSAxMStcblx0XHQvLyBJRSdzIDpkaXNhYmxlZCBzZWxlY3RvciBkb2VzIG5vdCBwaWNrIHVwIHRoZSBjaGlsZHJlbiBvZiBkaXNhYmxlZCBmaWVsZHNldHNcblx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0xMDUrLCBGaXJlZm94IDw9MTA0KywgU2FmYXJpIDw9MTUuNCtcblx0XHQvLyBJbiBzb21lIG9mIHRoZSBkb2N1bWVudCBraW5kcywgdGhlc2Ugc2VsZWN0b3JzIHdvdWxkbid0IHdvcmsgbmF0aXZlbHkuXG5cdFx0Ly8gVGhpcyBpcyBwcm9iYWJseSBPSyBidXQgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdlIHdhbnQgdG8gbWFpbnRhaW5cblx0XHQvLyBoYW5kbGluZyB0aGVtIHRocm91Z2ggalF1ZXJ5IHRyYXZlcnNhbCBpbiBqUXVlcnkgMy54LlxuXHRcdGRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZCggZWwgKS5kaXNhYmxlZCA9IHRydWU7XG5cdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKCBcIjpkaXNhYmxlZFwiICkubGVuZ3RoICE9PSAyICkge1xuXHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiOmVuYWJsZWRcIiwgXCI6ZGlzYWJsZWRcIiApO1xuXHRcdH1cblxuXHRcdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNSAtIDE4K1xuXHRcdC8vIElFIDExL0VkZ2UgZG9uJ3QgZmluZCBlbGVtZW50cyBvbiBhIGBbbmFtZT0nJ11gIHF1ZXJ5IGluIHNvbWUgY2FzZXMuXG5cdFx0Ly8gQWRkaW5nIGEgdGVtcG9yYXJ5IGF0dHJpYnV0ZSB0byB0aGUgZG9jdW1lbnQgYmVmb3JlIHRoZSBzZWxlY3Rpb24gd29ya3Ncblx0XHQvLyBhcm91bmQgdGhlIGlzc3VlLlxuXHRcdC8vIEludGVyZXN0aW5nbHksIElFIDEwICYgb2xkZXIgZG9uJ3Qgc2VlbSB0byBoYXZlIHRoZSBpc3N1ZS5cblx0XHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApO1xuXHRcdGlucHV0LnNldEF0dHJpYnV0ZSggXCJuYW1lXCIsIFwiXCIgKTtcblx0XHRlbC5hcHBlbmRDaGlsZCggaW5wdXQgKTtcblx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKCBcIltuYW1lPScnXVwiICkubGVuZ3RoICkge1xuXHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiXFxcXFtcIiArIHdoaXRlc3BhY2UgKyBcIipuYW1lXCIgKyB3aGl0ZXNwYWNlICsgXCIqPVwiICtcblx0XHRcdFx0d2hpdGVzcGFjZSArIFwiKig/OicnfFxcXCJcXFwiKVwiICk7XG5cdFx0fVxuXHR9ICk7XG5cblx0aWYgKCAhc3VwcG9ydC5jc3NIYXMgKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgMTA1IC0gMTEwKywgU2FmYXJpIDE1LjQgLSAxNi4zK1xuXHRcdC8vIE91ciByZWd1bGFyIGB0cnktY2F0Y2hgIG1lY2hhbmlzbSBmYWlscyB0byBkZXRlY3QgbmF0aXZlbHktdW5zdXBwb3J0ZWRcblx0XHQvLyBwc2V1ZG8tY2xhc3NlcyBpbnNpZGUgYDpoYXMoKWAgKHN1Y2ggYXMgYDpoYXMoOmNvbnRhaW5zKFwiRm9vXCIpKWApXG5cdFx0Ly8gaW4gYnJvd3NlcnMgdGhhdCBwYXJzZSB0aGUgYDpoYXMoKWAgYXJndW1lbnQgYXMgYSBmb3JnaXZpbmcgc2VsZWN0b3IgbGlzdC5cblx0XHQvLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvc2VsZWN0b3JzLyNyZWxhdGlvbmFsIG5vdyByZXF1aXJlcyB0aGUgYXJndW1lbnRcblx0XHQvLyB0byBiZSBwYXJzZWQgdW5mb3JnaXZpbmdseSwgYnV0IGJyb3dzZXJzIGhhdmUgbm90IHlldCBmdWxseSBhZGp1c3RlZC5cblx0XHRyYnVnZ3lRU0EucHVzaCggXCI6aGFzXCIgKTtcblx0fVxuXG5cdHJidWdneVFTQSA9IHJidWdneVFTQS5sZW5ndGggJiYgbmV3IFJlZ0V4cCggcmJ1Z2d5UVNBLmpvaW4oIFwifFwiICkgKTtcblxuXHQvKiBTb3J0aW5nXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBEb2N1bWVudCBvcmRlciBzb3J0aW5nXG5cdHNvcnRPcmRlciA9IGZ1bmN0aW9uKCBhLCBiICkge1xuXG5cdFx0Ly8gRmxhZyBmb3IgZHVwbGljYXRlIHJlbW92YWxcblx0XHRpZiAoIGEgPT09IGIgKSB7XG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0Ly8gU29ydCBvbiBtZXRob2QgZXhpc3RlbmNlIGlmIG9ubHkgb25lIGlucHV0IGhhcyBjb21wYXJlRG9jdW1lbnRQb3NpdGlvblxuXHRcdHZhciBjb21wYXJlID0gIWEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gLSAhYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbjtcblx0XHRpZiAoIGNvbXBhcmUgKSB7XG5cdFx0XHRyZXR1cm4gY29tcGFyZTtcblx0XHR9XG5cblx0XHQvLyBDYWxjdWxhdGUgcG9zaXRpb24gaWYgYm90aCBpbnB1dHMgYmVsb25nIHRvIHRoZSBzYW1lIGRvY3VtZW50XG5cdFx0Ly8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXG5cdFx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdFx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblx0XHRjb21wYXJlID0gKCBhLm93bmVyRG9jdW1lbnQgfHwgYSApID09ICggYi5vd25lckRvY3VtZW50IHx8IGIgKSA/XG5cdFx0XHRhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBiICkgOlxuXG5cdFx0XHQvLyBPdGhlcndpc2Ugd2Uga25vdyB0aGV5IGFyZSBkaXNjb25uZWN0ZWRcblx0XHRcdDE7XG5cblx0XHQvLyBEaXNjb25uZWN0ZWQgbm9kZXNcblx0XHRpZiAoIGNvbXBhcmUgJiAxIHx8XG5cdFx0XHQoICFzdXBwb3J0LnNvcnREZXRhY2hlZCAmJiBiLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBhICkgPT09IGNvbXBhcmUgKSApIHtcblxuXHRcdFx0Ly8gQ2hvb3NlIHRoZSBmaXJzdCBlbGVtZW50IHRoYXQgaXMgcmVsYXRlZCB0byBvdXIgcHJlZmVycmVkIGRvY3VtZW50XG5cdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcblx0XHRcdC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xuXHRcdFx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXHRcdFx0aWYgKCBhID09PSBkb2N1bWVudCB8fCBhLm93bmVyRG9jdW1lbnQgPT0gcHJlZmVycmVkRG9jICYmXG5cdFx0XHRcdGZpbmQuY29udGFpbnMoIHByZWZlcnJlZERvYywgYSApICkge1xuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHRcdFx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdFx0XHQvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cdFx0XHRpZiAoIGIgPT09IGRvY3VtZW50IHx8IGIub3duZXJEb2N1bWVudCA9PSBwcmVmZXJyZWREb2MgJiZcblx0XHRcdFx0ZmluZC5jb250YWlucyggcHJlZmVycmVkRG9jLCBiICkgKSB7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYWludGFpbiBvcmlnaW5hbCBvcmRlclxuXHRcdFx0cmV0dXJuIHNvcnRJbnB1dCA/XG5cdFx0XHRcdCggaW5kZXhPZi5jYWxsKCBzb3J0SW5wdXQsIGEgKSAtIGluZGV4T2YuY2FsbCggc29ydElucHV0LCBiICkgKSA6XG5cdFx0XHRcdDA7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNvbXBhcmUgJiA0ID8gLTEgOiAxO1xuXHR9O1xuXG5cdHJldHVybiBkb2N1bWVudDtcbn1cblxuZmluZC5tYXRjaGVzID0gZnVuY3Rpb24oIGV4cHIsIGVsZW1lbnRzICkge1xuXHRyZXR1cm4gZmluZCggZXhwciwgbnVsbCwgbnVsbCwgZWxlbWVudHMgKTtcbn07XG5cbmZpbmQubWF0Y2hlc1NlbGVjdG9yID0gZnVuY3Rpb24oIGVsZW0sIGV4cHIgKSB7XG5cdHNldERvY3VtZW50KCBlbGVtICk7XG5cblx0aWYgKCBkb2N1bWVudElzSFRNTCAmJlxuXHRcdCFub25uYXRpdmVTZWxlY3RvckNhY2hlWyBleHByICsgXCIgXCIgXSAmJlxuXHRcdCggIXJidWdneVFTQSB8fCAhcmJ1Z2d5UVNBLnRlc3QoIGV4cHIgKSApICkge1xuXG5cdFx0dHJ5IHtcblx0XHRcdHZhciByZXQgPSBtYXRjaGVzLmNhbGwoIGVsZW0sIGV4cHIgKTtcblxuXHRcdFx0Ly8gSUUgOSdzIG1hdGNoZXNTZWxlY3RvciByZXR1cm5zIGZhbHNlIG9uIGRpc2Nvbm5lY3RlZCBub2Rlc1xuXHRcdFx0aWYgKCByZXQgfHwgc3VwcG9ydC5kaXNjb25uZWN0ZWRNYXRjaCB8fFxuXG5cdFx0XHRcdFx0Ly8gQXMgd2VsbCwgZGlzY29ubmVjdGVkIG5vZGVzIGFyZSBzYWlkIHRvIGJlIGluIGEgZG9jdW1lbnRcblx0XHRcdFx0XHQvLyBmcmFnbWVudCBpbiBJRSA5XG5cdFx0XHRcdFx0ZWxlbS5kb2N1bWVudCAmJiBlbGVtLmRvY3VtZW50Lm5vZGVUeXBlICE9PSAxMSApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblx0XHR9IGNhdGNoICggZSApIHtcblx0XHRcdG5vbm5hdGl2ZVNlbGVjdG9yQ2FjaGUoIGV4cHIsIHRydWUgKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZmluZCggZXhwciwgZG9jdW1lbnQsIG51bGwsIFsgZWxlbSBdICkubGVuZ3RoID4gMDtcbn07XG5cbmZpbmQuY29udGFpbnMgPSBmdW5jdGlvbiggY29udGV4dCwgZWxlbSApIHtcblxuXHQvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcblx0Ly8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXG5cdC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xuXHQvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblx0aWYgKCAoIGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0ICkgIT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGNvbnRleHQgKTtcblx0fVxuXHRyZXR1cm4galF1ZXJ5LmNvbnRhaW5zKCBjb250ZXh0LCBlbGVtICk7XG59O1xuXG5cbmZpbmQuYXR0ciA9IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcblx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXHRpZiAoICggZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0gKSAhPSBkb2N1bWVudCApIHtcblx0XHRzZXREb2N1bWVudCggZWxlbSApO1xuXHR9XG5cblx0dmFyIGZuID0gRXhwci5hdHRySGFuZGxlWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSxcblxuXHRcdC8vIERvbid0IGdldCBmb29sZWQgYnkgT2JqZWN0LnByb3RvdHlwZSBwcm9wZXJ0aWVzIChzZWUgdHJhYy0xMzgwNylcblx0XHR2YWwgPSBmbiAmJiBoYXNPd24uY2FsbCggRXhwci5hdHRySGFuZGxlLCBuYW1lLnRvTG93ZXJDYXNlKCkgKSA/XG5cdFx0XHRmbiggZWxlbSwgbmFtZSwgIWRvY3VtZW50SXNIVE1MICkgOlxuXHRcdFx0dW5kZWZpbmVkO1xuXG5cdGlmICggdmFsICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0cmV0dXJuIHZhbDtcblx0fVxuXG5cdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSApO1xufTtcblxuZmluZC5lcnJvciA9IGZ1bmN0aW9uKCBtc2cgKSB7XG5cdHRocm93IG5ldyBFcnJvciggXCJTeW50YXggZXJyb3IsIHVucmVjb2duaXplZCBleHByZXNzaW9uOiBcIiArIG1zZyApO1xufTtcblxuLyoqXG4gKiBEb2N1bWVudCBzb3J0aW5nIGFuZCByZW1vdmluZyBkdXBsaWNhdGVzXG4gKiBAcGFyYW0ge0FycmF5TGlrZX0gcmVzdWx0c1xuICovXG5qUXVlcnkudW5pcXVlU29ydCA9IGZ1bmN0aW9uKCByZXN1bHRzICkge1xuXHR2YXIgZWxlbSxcblx0XHRkdXBsaWNhdGVzID0gW10sXG5cdFx0aiA9IDAsXG5cdFx0aSA9IDA7XG5cblx0Ly8gVW5sZXNzIHdlICprbm93KiB3ZSBjYW4gZGV0ZWN0IGR1cGxpY2F0ZXMsIGFzc3VtZSB0aGVpciBwcmVzZW5jZVxuXHQvL1xuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wK1xuXHQvLyBUZXN0aW5nIGZvciBkZXRlY3RpbmcgZHVwbGljYXRlcyBpcyB1bnByZWRpY3RhYmxlIHNvIGluc3RlYWQgYXNzdW1lIHdlIGNhbid0XG5cdC8vIGRlcGVuZCBvbiBkdXBsaWNhdGUgZGV0ZWN0aW9uIGluIGFsbCBicm93c2VycyB3aXRob3V0IGEgc3RhYmxlIHNvcnQuXG5cdGhhc0R1cGxpY2F0ZSA9ICFzdXBwb3J0LnNvcnRTdGFibGU7XG5cdHNvcnRJbnB1dCA9ICFzdXBwb3J0LnNvcnRTdGFibGUgJiYgc2xpY2UuY2FsbCggcmVzdWx0cywgMCApO1xuXHRzb3J0LmNhbGwoIHJlc3VsdHMsIHNvcnRPcmRlciApO1xuXG5cdGlmICggaGFzRHVwbGljYXRlICkge1xuXHRcdHdoaWxlICggKCBlbGVtID0gcmVzdWx0c1sgaSsrIF0gKSApIHtcblx0XHRcdGlmICggZWxlbSA9PT0gcmVzdWx0c1sgaSBdICkge1xuXHRcdFx0XHRqID0gZHVwbGljYXRlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHdoaWxlICggai0tICkge1xuXHRcdFx0c3BsaWNlLmNhbGwoIHJlc3VsdHMsIGR1cGxpY2F0ZXNbIGogXSwgMSApO1xuXHRcdH1cblx0fVxuXG5cdC8vIENsZWFyIGlucHV0IGFmdGVyIHNvcnRpbmcgdG8gcmVsZWFzZSBvYmplY3RzXG5cdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L3NpenpsZS9wdWxsLzIyNVxuXHRzb3J0SW5wdXQgPSBudWxsO1xuXG5cdHJldHVybiByZXN1bHRzO1xufTtcblxualF1ZXJ5LmZuLnVuaXF1ZVNvcnQgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkudW5pcXVlU29ydCggc2xpY2UuYXBwbHkoIHRoaXMgKSApICk7XG59O1xuXG5FeHByID0galF1ZXJ5LmV4cHIgPSB7XG5cblx0Ly8gQ2FuIGJlIGFkanVzdGVkIGJ5IHRoZSB1c2VyXG5cdGNhY2hlTGVuZ3RoOiA1MCxcblxuXHRjcmVhdGVQc2V1ZG86IG1hcmtGdW5jdGlvbixcblxuXHRtYXRjaDogbWF0Y2hFeHByLFxuXG5cdGF0dHJIYW5kbGU6IHt9LFxuXG5cdGZpbmQ6IHt9LFxuXG5cdHJlbGF0aXZlOiB7XG5cdFx0XCI+XCI6IHsgZGlyOiBcInBhcmVudE5vZGVcIiwgZmlyc3Q6IHRydWUgfSxcblx0XHRcIiBcIjogeyBkaXI6IFwicGFyZW50Tm9kZVwiIH0sXG5cdFx0XCIrXCI6IHsgZGlyOiBcInByZXZpb3VzU2libGluZ1wiLCBmaXJzdDogdHJ1ZSB9LFxuXHRcdFwiflwiOiB7IGRpcjogXCJwcmV2aW91c1NpYmxpbmdcIiB9XG5cdH0sXG5cblx0cHJlRmlsdGVyOiB7XG5cdFx0QVRUUjogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0bWF0Y2hbIDEgXSA9IG1hdGNoWyAxIF0ucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblxuXHRcdFx0Ly8gTW92ZSB0aGUgZ2l2ZW4gdmFsdWUgdG8gbWF0Y2hbM10gd2hldGhlciBxdW90ZWQgb3IgdW5xdW90ZWRcblx0XHRcdG1hdGNoWyAzIF0gPSAoIG1hdGNoWyAzIF0gfHwgbWF0Y2hbIDQgXSB8fCBtYXRjaFsgNSBdIHx8IFwiXCIgKVxuXHRcdFx0XHQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblxuXHRcdFx0aWYgKCBtYXRjaFsgMiBdID09PSBcIn49XCIgKSB7XG5cdFx0XHRcdG1hdGNoWyAzIF0gPSBcIiBcIiArIG1hdGNoWyAzIF0gKyBcIiBcIjtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1hdGNoLnNsaWNlKCAwLCA0ICk7XG5cdFx0fSxcblxuXHRcdENISUxEOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cblx0XHRcdC8qIG1hdGNoZXMgZnJvbSBtYXRjaEV4cHJbXCJDSElMRFwiXVxuXHRcdFx0XHQxIHR5cGUgKG9ubHl8bnRofC4uLilcblx0XHRcdFx0MiB3aGF0IChjaGlsZHxvZi10eXBlKVxuXHRcdFx0XHQzIGFyZ3VtZW50IChldmVufG9kZHxcXGQqfFxcZCpuKFsrLV1cXGQrKT98Li4uKVxuXHRcdFx0XHQ0IHhuLWNvbXBvbmVudCBvZiB4bit5IGFyZ3VtZW50IChbKy1dP1xcZCpufClcblx0XHRcdFx0NSBzaWduIG9mIHhuLWNvbXBvbmVudFxuXHRcdFx0XHQ2IHggb2YgeG4tY29tcG9uZW50XG5cdFx0XHRcdDcgc2lnbiBvZiB5LWNvbXBvbmVudFxuXHRcdFx0XHQ4IHkgb2YgeS1jb21wb25lbnRcblx0XHRcdCovXG5cdFx0XHRtYXRjaFsgMSBdID0gbWF0Y2hbIDEgXS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0XHRpZiAoIG1hdGNoWyAxIF0uc2xpY2UoIDAsIDMgKSA9PT0gXCJudGhcIiApIHtcblxuXHRcdFx0XHQvLyBudGgtKiByZXF1aXJlcyBhcmd1bWVudFxuXHRcdFx0XHRpZiAoICFtYXRjaFsgMyBdICkge1xuXHRcdFx0XHRcdGZpbmQuZXJyb3IoIG1hdGNoWyAwIF0gKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIG51bWVyaWMgeCBhbmQgeSBwYXJhbWV0ZXJzIGZvciBFeHByLmZpbHRlci5DSElMRFxuXHRcdFx0XHQvLyByZW1lbWJlciB0aGF0IGZhbHNlL3RydWUgY2FzdCByZXNwZWN0aXZlbHkgdG8gMC8xXG5cdFx0XHRcdG1hdGNoWyA0IF0gPSArKCBtYXRjaFsgNCBdID9cblx0XHRcdFx0XHRtYXRjaFsgNSBdICsgKCBtYXRjaFsgNiBdIHx8IDEgKSA6XG5cdFx0XHRcdFx0MiAqICggbWF0Y2hbIDMgXSA9PT0gXCJldmVuXCIgfHwgbWF0Y2hbIDMgXSA9PT0gXCJvZGRcIiApXG5cdFx0XHRcdCk7XG5cdFx0XHRcdG1hdGNoWyA1IF0gPSArKCAoIG1hdGNoWyA3IF0gKyBtYXRjaFsgOCBdICkgfHwgbWF0Y2hbIDMgXSA9PT0gXCJvZGRcIiApO1xuXG5cdFx0XHQvLyBvdGhlciB0eXBlcyBwcm9oaWJpdCBhcmd1bWVudHNcblx0XHRcdH0gZWxzZSBpZiAoIG1hdGNoWyAzIF0gKSB7XG5cdFx0XHRcdGZpbmQuZXJyb3IoIG1hdGNoWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1hdGNoO1xuXHRcdH0sXG5cblx0XHRQU0VVRE86IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdHZhciBleGNlc3MsXG5cdFx0XHRcdHVucXVvdGVkID0gIW1hdGNoWyA2IF0gJiYgbWF0Y2hbIDIgXTtcblxuXHRcdFx0aWYgKCBtYXRjaEV4cHIuQ0hJTEQudGVzdCggbWF0Y2hbIDAgXSApICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWNjZXB0IHF1b3RlZCBhcmd1bWVudHMgYXMtaXNcblx0XHRcdGlmICggbWF0Y2hbIDMgXSApIHtcblx0XHRcdFx0bWF0Y2hbIDIgXSA9IG1hdGNoWyA0IF0gfHwgbWF0Y2hbIDUgXSB8fCBcIlwiO1xuXG5cdFx0XHQvLyBTdHJpcCBleGNlc3MgY2hhcmFjdGVycyBmcm9tIHVucXVvdGVkIGFyZ3VtZW50c1xuXHRcdFx0fSBlbHNlIGlmICggdW5xdW90ZWQgJiYgcnBzZXVkby50ZXN0KCB1bnF1b3RlZCApICYmXG5cblx0XHRcdFx0Ly8gR2V0IGV4Y2VzcyBmcm9tIHRva2VuaXplIChyZWN1cnNpdmVseSlcblx0XHRcdFx0KCBleGNlc3MgPSB0b2tlbml6ZSggdW5xdW90ZWQsIHRydWUgKSApICYmXG5cblx0XHRcdFx0Ly8gYWR2YW5jZSB0byB0aGUgbmV4dCBjbG9zaW5nIHBhcmVudGhlc2lzXG5cdFx0XHRcdCggZXhjZXNzID0gdW5xdW90ZWQuaW5kZXhPZiggXCIpXCIsIHVucXVvdGVkLmxlbmd0aCAtIGV4Y2VzcyApIC0gdW5xdW90ZWQubGVuZ3RoICkgKSB7XG5cblx0XHRcdFx0Ly8gZXhjZXNzIGlzIGEgbmVnYXRpdmUgaW5kZXhcblx0XHRcdFx0bWF0Y2hbIDAgXSA9IG1hdGNoWyAwIF0uc2xpY2UoIDAsIGV4Y2VzcyApO1xuXHRcdFx0XHRtYXRjaFsgMiBdID0gdW5xdW90ZWQuc2xpY2UoIDAsIGV4Y2VzcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXR1cm4gb25seSBjYXB0dXJlcyBuZWVkZWQgYnkgdGhlIHBzZXVkbyBmaWx0ZXIgbWV0aG9kICh0eXBlIGFuZCBhcmd1bWVudClcblx0XHRcdHJldHVybiBtYXRjaC5zbGljZSggMCwgMyApO1xuXHRcdH1cblx0fSxcblxuXHRmaWx0ZXI6IHtcblxuXHRcdFRBRzogZnVuY3Rpb24oIG5vZGVOYW1lU2VsZWN0b3IgKSB7XG5cdFx0XHR2YXIgZXhwZWN0ZWROb2RlTmFtZSA9IG5vZGVOYW1lU2VsZWN0b3IucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIG5vZGVOYW1lU2VsZWN0b3IgPT09IFwiKlwiID9cblx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH0gOlxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gbm9kZU5hbWUoIGVsZW0sIGV4cGVjdGVkTm9kZU5hbWUgKTtcblx0XHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0Q0xBU1M6IGZ1bmN0aW9uKCBjbGFzc05hbWUgKSB7XG5cdFx0XHR2YXIgcGF0dGVybiA9IGNsYXNzQ2FjaGVbIGNsYXNzTmFtZSArIFwiIFwiIF07XG5cblx0XHRcdHJldHVybiBwYXR0ZXJuIHx8XG5cdFx0XHRcdCggcGF0dGVybiA9IG5ldyBSZWdFeHAoIFwiKF58XCIgKyB3aGl0ZXNwYWNlICsgXCIpXCIgKyBjbGFzc05hbWUgK1xuXHRcdFx0XHRcdFwiKFwiICsgd2hpdGVzcGFjZSArIFwifCQpXCIgKSApICYmXG5cdFx0XHRcdGNsYXNzQ2FjaGUoIGNsYXNzTmFtZSwgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHBhdHRlcm4udGVzdChcblx0XHRcdFx0XHRcdHR5cGVvZiBlbGVtLmNsYXNzTmFtZSA9PT0gXCJzdHJpbmdcIiAmJiBlbGVtLmNsYXNzTmFtZSB8fFxuXHRcdFx0XHRcdFx0XHR0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGUgIT09IFwidW5kZWZpbmVkXCIgJiZcblx0XHRcdFx0XHRcdFx0XHRlbGVtLmdldEF0dHJpYnV0ZSggXCJjbGFzc1wiICkgfHxcblx0XHRcdFx0XHRcdFx0XCJcIlxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH0gKTtcblx0XHR9LFxuXG5cdFx0QVRUUjogZnVuY3Rpb24oIG5hbWUsIG9wZXJhdG9yLCBjaGVjayApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIHJlc3VsdCA9IGZpbmQuYXR0ciggZWxlbSwgbmFtZSApO1xuXG5cdFx0XHRcdGlmICggcmVzdWx0ID09IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9wZXJhdG9yID09PSBcIiE9XCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCAhb3BlcmF0b3IgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXN1bHQgKz0gXCJcIjtcblxuXHRcdFx0XHRpZiAoIG9wZXJhdG9yID09PSBcIj1cIiApIHtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0ID09PSBjaGVjaztcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIG9wZXJhdG9yID09PSBcIiE9XCIgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdCAhPT0gY2hlY2s7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBvcGVyYXRvciA9PT0gXCJePVwiICkge1xuXHRcdFx0XHRcdHJldHVybiBjaGVjayAmJiByZXN1bHQuaW5kZXhPZiggY2hlY2sgKSA9PT0gMDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIG9wZXJhdG9yID09PSBcIio9XCIgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGNoZWNrICYmIHJlc3VsdC5pbmRleE9mKCBjaGVjayApID4gLTE7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBvcGVyYXRvciA9PT0gXCIkPVwiICkge1xuXHRcdFx0XHRcdHJldHVybiBjaGVjayAmJiByZXN1bHQuc2xpY2UoIC1jaGVjay5sZW5ndGggKSA9PT0gY2hlY2s7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBvcGVyYXRvciA9PT0gXCJ+PVwiICkge1xuXHRcdFx0XHRcdHJldHVybiAoIFwiIFwiICsgcmVzdWx0LnJlcGxhY2UoIHJ3aGl0ZXNwYWNlLCBcIiBcIiApICsgXCIgXCIgKVxuXHRcdFx0XHRcdFx0LmluZGV4T2YoIGNoZWNrICkgPiAtMTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIG9wZXJhdG9yID09PSBcInw9XCIgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdCA9PT0gY2hlY2sgfHwgcmVzdWx0LnNsaWNlKCAwLCBjaGVjay5sZW5ndGggKyAxICkgPT09IGNoZWNrICsgXCItXCI7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRDSElMRDogZnVuY3Rpb24oIHR5cGUsIHdoYXQsIF9hcmd1bWVudCwgZmlyc3QsIGxhc3QgKSB7XG5cdFx0XHR2YXIgc2ltcGxlID0gdHlwZS5zbGljZSggMCwgMyApICE9PSBcIm50aFwiLFxuXHRcdFx0XHRmb3J3YXJkID0gdHlwZS5zbGljZSggLTQgKSAhPT0gXCJsYXN0XCIsXG5cdFx0XHRcdG9mVHlwZSA9IHdoYXQgPT09IFwib2YtdHlwZVwiO1xuXG5cdFx0XHRyZXR1cm4gZmlyc3QgPT09IDEgJiYgbGFzdCA9PT0gMCA/XG5cblx0XHRcdFx0Ly8gU2hvcnRjdXQgZm9yIDpudGgtKihuKVxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gISFlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRcdH0gOlxuXG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtLCBfY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdHZhciBjYWNoZSwgb3V0ZXJDYWNoZSwgbm9kZSwgbm9kZUluZGV4LCBzdGFydCxcblx0XHRcdFx0XHRcdGRpciA9IHNpbXBsZSAhPT0gZm9yd2FyZCA/IFwibmV4dFNpYmxpbmdcIiA6IFwicHJldmlvdXNTaWJsaW5nXCIsXG5cdFx0XHRcdFx0XHRwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGUsXG5cdFx0XHRcdFx0XHRuYW1lID0gb2ZUeXBlICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSxcblx0XHRcdFx0XHRcdHVzZUNhY2hlID0gIXhtbCAmJiAhb2ZUeXBlLFxuXHRcdFx0XHRcdFx0ZGlmZiA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cblx0XHRcdFx0XHRcdC8vIDooZmlyc3R8bGFzdHxvbmx5KS0oY2hpbGR8b2YtdHlwZSlcblx0XHRcdFx0XHRcdGlmICggc2ltcGxlICkge1xuXHRcdFx0XHRcdFx0XHR3aGlsZSAoIGRpciApIHtcblx0XHRcdFx0XHRcdFx0XHRub2RlID0gZWxlbTtcblx0XHRcdFx0XHRcdFx0XHR3aGlsZSAoICggbm9kZSA9IG5vZGVbIGRpciBdICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIG9mVHlwZSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGVOYW1lKCBub2RlLCBuYW1lICkgOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBSZXZlcnNlIGRpcmVjdGlvbiBmb3IgOm9ubHktKiAoaWYgd2UgaGF2ZW4ndCB5ZXQgZG9uZSBzbylcblx0XHRcdFx0XHRcdFx0XHRzdGFydCA9IGRpciA9IHR5cGUgPT09IFwib25seVwiICYmICFzdGFydCAmJiBcIm5leHRTaWJsaW5nXCI7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHN0YXJ0ID0gWyBmb3J3YXJkID8gcGFyZW50LmZpcnN0Q2hpbGQgOiBwYXJlbnQubGFzdENoaWxkIF07XG5cblx0XHRcdFx0XHRcdC8vIG5vbi14bWwgOm50aC1jaGlsZCguLi4pIHN0b3JlcyBjYWNoZSBkYXRhIG9uIGBwYXJlbnRgXG5cdFx0XHRcdFx0XHRpZiAoIGZvcndhcmQgJiYgdXNlQ2FjaGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU2VlayBgZWxlbWAgZnJvbSBhIHByZXZpb3VzbHktY2FjaGVkIGluZGV4XG5cdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBwYXJlbnRbIGV4cGFuZG8gXSB8fCAoIHBhcmVudFsgZXhwYW5kbyBdID0ge30gKTtcblx0XHRcdFx0XHRcdFx0Y2FjaGUgPSBvdXRlckNhY2hlWyB0eXBlIF0gfHwgW107XG5cdFx0XHRcdFx0XHRcdG5vZGVJbmRleCA9IGNhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgY2FjaGVbIDEgXTtcblx0XHRcdFx0XHRcdFx0ZGlmZiA9IG5vZGVJbmRleCAmJiBjYWNoZVsgMiBdO1xuXHRcdFx0XHRcdFx0XHRub2RlID0gbm9kZUluZGV4ICYmIHBhcmVudC5jaGlsZE5vZGVzWyBub2RlSW5kZXggXTtcblxuXHRcdFx0XHRcdFx0XHR3aGlsZSAoICggbm9kZSA9ICsrbm9kZUluZGV4ICYmIG5vZGUgJiYgbm9kZVsgZGlyIF0gfHxcblxuXHRcdFx0XHRcdFx0XHRcdC8vIEZhbGxiYWNrIHRvIHNlZWtpbmcgYGVsZW1gIGZyb20gdGhlIHN0YXJ0XG5cdFx0XHRcdFx0XHRcdFx0KCBkaWZmID0gbm9kZUluZGV4ID0gMCApIHx8IHN0YXJ0LnBvcCgpICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBXaGVuIGZvdW5kLCBjYWNoZSBpbmRleGVzIG9uIGBwYXJlbnRgIGFuZCBicmVha1xuXHRcdFx0XHRcdFx0XHRcdGlmICggbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiArK2RpZmYgJiYgbm9kZSA9PT0gZWxlbSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGVbIHR5cGUgXSA9IFsgZGlycnVucywgbm9kZUluZGV4LCBkaWZmIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBVc2UgcHJldmlvdXNseS1jYWNoZWQgZWxlbWVudCBpbmRleCBpZiBhdmFpbGFibGVcblx0XHRcdFx0XHRcdFx0aWYgKCB1c2VDYWNoZSApIHtcblx0XHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gZWxlbVsgZXhwYW5kbyBdIHx8ICggZWxlbVsgZXhwYW5kbyBdID0ge30gKTtcblx0XHRcdFx0XHRcdFx0XHRjYWNoZSA9IG91dGVyQ2FjaGVbIHR5cGUgXSB8fCBbXTtcblx0XHRcdFx0XHRcdFx0XHRub2RlSW5kZXggPSBjYWNoZVsgMCBdID09PSBkaXJydW5zICYmIGNhY2hlWyAxIF07XG5cdFx0XHRcdFx0XHRcdFx0ZGlmZiA9IG5vZGVJbmRleDtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdC8vIHhtbCA6bnRoLWNoaWxkKC4uLilcblx0XHRcdFx0XHRcdFx0Ly8gb3IgOm50aC1sYXN0LWNoaWxkKC4uLikgb3IgOm50aCgtbGFzdCk/LW9mLXR5cGUoLi4uKVxuXHRcdFx0XHRcdFx0XHRpZiAoIGRpZmYgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gVXNlIHRoZSBzYW1lIGxvb3AgYXMgYWJvdmUgdG8gc2VlayBgZWxlbWAgZnJvbSB0aGUgc3RhcnRcblx0XHRcdFx0XHRcdFx0XHR3aGlsZSAoICggbm9kZSA9ICsrbm9kZUluZGV4ICYmIG5vZGUgJiYgbm9kZVsgZGlyIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdCggZGlmZiA9IG5vZGVJbmRleCA9IDAgKSB8fCBzdGFydC5wb3AoKSApICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoICggb2ZUeXBlID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZU5hbWUoIG5vZGUsIG5hbWUgKSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZVR5cGUgPT09IDEgKSAmJlxuXHRcdFx0XHRcdFx0XHRcdFx0XHQrK2RpZmYgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gQ2FjaGUgdGhlIGluZGV4IG9mIGVhY2ggZW5jb3VudGVyZWQgZWxlbWVudFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHVzZUNhY2hlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBub2RlWyBleHBhbmRvIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdCggbm9kZVsgZXhwYW5kbyBdID0ge30gKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlWyB0eXBlIF0gPSBbIGRpcnJ1bnMsIGRpZmYgXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggbm9kZSA9PT0gZWxlbSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBJbmNvcnBvcmF0ZSB0aGUgb2Zmc2V0LCB0aGVuIGNoZWNrIGFnYWluc3QgY3ljbGUgc2l6ZVxuXHRcdFx0XHRcdFx0ZGlmZiAtPSBsYXN0O1xuXHRcdFx0XHRcdFx0cmV0dXJuIGRpZmYgPT09IGZpcnN0IHx8ICggZGlmZiAlIGZpcnN0ID09PSAwICYmIGRpZmYgLyBmaXJzdCA+PSAwICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRQU0VVRE86IGZ1bmN0aW9uKCBwc2V1ZG8sIGFyZ3VtZW50ICkge1xuXG5cdFx0XHQvLyBwc2V1ZG8tY2xhc3MgbmFtZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmVcblx0XHRcdC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI3BzZXVkby1jbGFzc2VzXG5cdFx0XHQvLyBQcmlvcml0aXplIGJ5IGNhc2Ugc2Vuc2l0aXZpdHkgaW4gY2FzZSBjdXN0b20gcHNldWRvcyBhcmUgYWRkZWQgd2l0aCB1cHBlcmNhc2UgbGV0dGVyc1xuXHRcdFx0Ly8gUmVtZW1iZXIgdGhhdCBzZXRGaWx0ZXJzIGluaGVyaXRzIGZyb20gcHNldWRvc1xuXHRcdFx0dmFyIGFyZ3MsXG5cdFx0XHRcdGZuID0gRXhwci5wc2V1ZG9zWyBwc2V1ZG8gXSB8fCBFeHByLnNldEZpbHRlcnNbIHBzZXVkby50b0xvd2VyQ2FzZSgpIF0gfHxcblx0XHRcdFx0XHRmaW5kLmVycm9yKCBcInVuc3VwcG9ydGVkIHBzZXVkbzogXCIgKyBwc2V1ZG8gKTtcblxuXHRcdFx0Ly8gVGhlIHVzZXIgbWF5IHVzZSBjcmVhdGVQc2V1ZG8gdG8gaW5kaWNhdGUgdGhhdFxuXHRcdFx0Ly8gYXJndW1lbnRzIGFyZSBuZWVkZWQgdG8gY3JlYXRlIHRoZSBmaWx0ZXIgZnVuY3Rpb25cblx0XHRcdC8vIGp1c3QgYXMgalF1ZXJ5IGRvZXNcblx0XHRcdGlmICggZm5bIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0cmV0dXJuIGZuKCBhcmd1bWVudCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBCdXQgbWFpbnRhaW4gc3VwcG9ydCBmb3Igb2xkIHNpZ25hdHVyZXNcblx0XHRcdGlmICggZm4ubGVuZ3RoID4gMSApIHtcblx0XHRcdFx0YXJncyA9IFsgcHNldWRvLCBwc2V1ZG8sIFwiXCIsIGFyZ3VtZW50IF07XG5cdFx0XHRcdHJldHVybiBFeHByLnNldEZpbHRlcnMuaGFzT3duUHJvcGVydHkoIHBzZXVkby50b0xvd2VyQ2FzZSgpICkgP1xuXHRcdFx0XHRcdG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMgKSB7XG5cdFx0XHRcdFx0XHR2YXIgaWR4LFxuXHRcdFx0XHRcdFx0XHRtYXRjaGVkID0gZm4oIHNlZWQsIGFyZ3VtZW50ICksXG5cdFx0XHRcdFx0XHRcdGkgPSBtYXRjaGVkLmxlbmd0aDtcblx0XHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0XHRpZHggPSBpbmRleE9mLmNhbGwoIHNlZWQsIG1hdGNoZWRbIGkgXSApO1xuXHRcdFx0XHRcdFx0XHRzZWVkWyBpZHggXSA9ICEoIG1hdGNoZXNbIGlkeCBdID0gbWF0Y2hlZFsgaSBdICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSApIDpcblx0XHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRcdHJldHVybiBmbiggZWxlbSwgMCwgYXJncyApO1xuXHRcdFx0XHRcdH07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmbjtcblx0XHR9XG5cdH0sXG5cblx0cHNldWRvczoge1xuXG5cdFx0Ly8gUG90ZW50aWFsbHkgY29tcGxleCBwc2V1ZG9zXG5cdFx0bm90OiBtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblxuXHRcdFx0Ly8gVHJpbSB0aGUgc2VsZWN0b3IgcGFzc2VkIHRvIGNvbXBpbGVcblx0XHRcdC8vIHRvIGF2b2lkIHRyZWF0aW5nIGxlYWRpbmcgYW5kIHRyYWlsaW5nXG5cdFx0XHQvLyBzcGFjZXMgYXMgY29tYmluYXRvcnNcblx0XHRcdHZhciBpbnB1dCA9IFtdLFxuXHRcdFx0XHRyZXN1bHRzID0gW10sXG5cdFx0XHRcdG1hdGNoZXIgPSBjb21waWxlKCBzZWxlY3Rvci5yZXBsYWNlKCBydHJpbUNTUywgXCIkMVwiICkgKTtcblxuXHRcdFx0cmV0dXJuIG1hdGNoZXJbIGV4cGFuZG8gXSA/XG5cdFx0XHRcdG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMsIF9jb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0dmFyIGVsZW0sXG5cdFx0XHRcdFx0XHR1bm1hdGNoZWQgPSBtYXRjaGVyKCBzZWVkLCBudWxsLCB4bWwsIFtdICksXG5cdFx0XHRcdFx0XHRpID0gc2VlZC5sZW5ndGg7XG5cblx0XHRcdFx0XHQvLyBNYXRjaCBlbGVtZW50cyB1bm1hdGNoZWQgYnkgYG1hdGNoZXJgXG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRpZiAoICggZWxlbSA9IHVubWF0Y2hlZFsgaSBdICkgKSB7XG5cdFx0XHRcdFx0XHRcdHNlZWRbIGkgXSA9ICEoIG1hdGNoZXNbIGkgXSA9IGVsZW0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKSA6XG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtLCBfY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdGlucHV0WyAwIF0gPSBlbGVtO1xuXHRcdFx0XHRcdG1hdGNoZXIoIGlucHV0LCBudWxsLCB4bWwsIHJlc3VsdHMgKTtcblxuXHRcdFx0XHRcdC8vIERvbid0IGtlZXAgdGhlIGVsZW1lbnRcblx0XHRcdFx0XHQvLyAoc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvc2l6emxlL2lzc3Vlcy8yOTkpXG5cdFx0XHRcdFx0aW5wdXRbIDAgXSA9IG51bGw7XG5cdFx0XHRcdFx0cmV0dXJuICFyZXN1bHRzLnBvcCgpO1xuXHRcdFx0XHR9O1xuXHRcdH0gKSxcblxuXHRcdGhhczogbWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBmaW5kKCBzZWxlY3RvciwgZWxlbSApLmxlbmd0aCA+IDA7XG5cdFx0XHR9O1xuXHRcdH0gKSxcblxuXHRcdGNvbnRhaW5zOiBtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdFx0dGV4dCA9IHRleHQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuICggZWxlbS50ZXh0Q29udGVudCB8fCBqUXVlcnkudGV4dCggZWxlbSApICkuaW5kZXhPZiggdGV4dCApID4gLTE7XG5cdFx0XHR9O1xuXHRcdH0gKSxcblxuXHRcdC8vIFwiV2hldGhlciBhbiBlbGVtZW50IGlzIHJlcHJlc2VudGVkIGJ5IGEgOmxhbmcoKSBzZWxlY3RvclxuXHRcdC8vIGlzIGJhc2VkIHNvbGVseSBvbiB0aGUgZWxlbWVudCdzIGxhbmd1YWdlIHZhbHVlXG5cdFx0Ly8gYmVpbmcgZXF1YWwgdG8gdGhlIGlkZW50aWZpZXIgQyxcblx0XHQvLyBvciBiZWdpbm5pbmcgd2l0aCB0aGUgaWRlbnRpZmllciBDIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IFwiLVwiLlxuXHRcdC8vIFRoZSBtYXRjaGluZyBvZiBDIGFnYWluc3QgdGhlIGVsZW1lbnQncyBsYW5ndWFnZSB2YWx1ZSBpcyBwZXJmb3JtZWQgY2FzZS1pbnNlbnNpdGl2ZWx5LlxuXHRcdC8vIFRoZSBpZGVudGlmaWVyIEMgZG9lcyBub3QgaGF2ZSB0byBiZSBhIHZhbGlkIGxhbmd1YWdlIG5hbWUuXCJcblx0XHQvLyBodHRwczovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNsYW5nLXBzZXVkb1xuXHRcdGxhbmc6IG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIGxhbmcgKSB7XG5cblx0XHRcdC8vIGxhbmcgdmFsdWUgbXVzdCBiZSBhIHZhbGlkIGlkZW50aWZpZXJcblx0XHRcdGlmICggIXJpZGVudGlmaWVyLnRlc3QoIGxhbmcgfHwgXCJcIiApICkge1xuXHRcdFx0XHRmaW5kLmVycm9yKCBcInVuc3VwcG9ydGVkIGxhbmc6IFwiICsgbGFuZyApO1xuXHRcdFx0fVxuXHRcdFx0bGFuZyA9IGxhbmcucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgZWxlbUxhbmc7XG5cdFx0XHRcdGRvIHtcblx0XHRcdFx0XHRpZiAoICggZWxlbUxhbmcgPSBkb2N1bWVudElzSFRNTCA/XG5cdFx0XHRcdFx0XHRlbGVtLmxhbmcgOlxuXHRcdFx0XHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGUoIFwieG1sOmxhbmdcIiApIHx8IGVsZW0uZ2V0QXR0cmlidXRlKCBcImxhbmdcIiApICkgKSB7XG5cblx0XHRcdFx0XHRcdGVsZW1MYW5nID0gZWxlbUxhbmcudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtTGFuZyA9PT0gbGFuZyB8fCBlbGVtTGFuZy5pbmRleE9mKCBsYW5nICsgXCItXCIgKSA9PT0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gd2hpbGUgKCAoIGVsZW0gPSBlbGVtLnBhcmVudE5vZGUgKSAmJiBlbGVtLm5vZGVUeXBlID09PSAxICk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH07XG5cdFx0fSApLFxuXG5cdFx0Ly8gTWlzY2VsbGFuZW91c1xuXHRcdHRhcmdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgaGFzaCA9IHdpbmRvdy5sb2NhdGlvbiAmJiB3aW5kb3cubG9jYXRpb24uaGFzaDtcblx0XHRcdHJldHVybiBoYXNoICYmIGhhc2guc2xpY2UoIDEgKSA9PT0gZWxlbS5pZDtcblx0XHR9LFxuXG5cdFx0cm9vdDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gZG9jdW1lbnRFbGVtZW50O1xuXHRcdH0sXG5cblx0XHRmb2N1czogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gc2FmZUFjdGl2ZUVsZW1lbnQoKSAmJlxuXHRcdFx0XHRkb2N1bWVudC5oYXNGb2N1cygpICYmXG5cdFx0XHRcdCEhKCBlbGVtLnR5cGUgfHwgZWxlbS5ocmVmIHx8IH5lbGVtLnRhYkluZGV4ICk7XG5cdFx0fSxcblxuXHRcdC8vIEJvb2xlYW4gcHJvcGVydGllc1xuXHRcdGVuYWJsZWQ6IGNyZWF0ZURpc2FibGVkUHNldWRvKCBmYWxzZSApLFxuXHRcdGRpc2FibGVkOiBjcmVhdGVEaXNhYmxlZFBzZXVkbyggdHJ1ZSApLFxuXG5cdFx0Y2hlY2tlZDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdC8vIEluIENTUzMsIDpjaGVja2VkIHNob3VsZCByZXR1cm4gYm90aCBjaGVja2VkIGFuZCBzZWxlY3RlZCBlbGVtZW50c1xuXHRcdFx0Ly8gaHR0cHM6Ly93d3cudzMub3JnL1RSLzIwMTEvUkVDLWNzczMtc2VsZWN0b3JzLTIwMTEwOTI5LyNjaGVja2VkXG5cdFx0XHRyZXR1cm4gKCBub2RlTmFtZSggZWxlbSwgXCJpbnB1dFwiICkgJiYgISFlbGVtLmNoZWNrZWQgKSB8fFxuXHRcdFx0XHQoIG5vZGVOYW1lKCBlbGVtLCBcIm9wdGlvblwiICkgJiYgISFlbGVtLnNlbGVjdGVkICk7XG5cdFx0fSxcblxuXHRcdHNlbGVjdGVkOiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgPD0xMStcblx0XHRcdC8vIEFjY2Vzc2luZyB0aGUgc2VsZWN0ZWRJbmRleCBwcm9wZXJ0eVxuXHRcdFx0Ly8gZm9yY2VzIHRoZSBicm93c2VyIHRvIHRyZWF0IHRoZSBkZWZhdWx0IG9wdGlvbiBhc1xuXHRcdFx0Ly8gc2VsZWN0ZWQgd2hlbiBpbiBhbiBvcHRncm91cC5cblx0XHRcdGlmICggZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zXG5cdFx0XHRcdGVsZW0ucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZWxlbS5zZWxlY3RlZCA9PT0gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0Ly8gQ29udGVudHNcblx0XHRlbXB0eTogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2VtcHR5LXBzZXVkb1xuXHRcdFx0Ly8gOmVtcHR5IGlzIG5lZ2F0ZWQgYnkgZWxlbWVudCAoMSkgb3IgY29udGVudCBub2RlcyAodGV4dDogMzsgY2RhdGE6IDQ7IGVudGl0eSByZWY6IDUpLFxuXHRcdFx0Ly8gICBidXQgbm90IGJ5IG90aGVycyAoY29tbWVudDogODsgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbjogNzsgZXRjLilcblx0XHRcdC8vIG5vZGVUeXBlIDwgNiB3b3JrcyBiZWNhdXNlIGF0dHJpYnV0ZXMgKDIpIGRvIG5vdCBhcHBlYXIgYXMgY2hpbGRyZW5cblx0XHRcdGZvciAoIGVsZW0gPSBlbGVtLmZpcnN0Q2hpbGQ7IGVsZW07IGVsZW0gPSBlbGVtLm5leHRTaWJsaW5nICkge1xuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPCA2ICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblxuXHRcdHBhcmVudDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gIUV4cHIucHNldWRvcy5lbXB0eSggZWxlbSApO1xuXHRcdH0sXG5cblx0XHQvLyBFbGVtZW50L2lucHV0IHR5cGVzXG5cdFx0aGVhZGVyOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiByaGVhZGVyLnRlc3QoIGVsZW0ubm9kZU5hbWUgKTtcblx0XHR9LFxuXG5cdFx0aW5wdXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIHJpbnB1dHMudGVzdCggZWxlbS5ub2RlTmFtZSApO1xuXHRcdH0sXG5cblx0XHRidXR0b246IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIG5vZGVOYW1lKCBlbGVtLCBcImlucHV0XCIgKSAmJiBlbGVtLnR5cGUgPT09IFwiYnV0dG9uXCIgfHxcblx0XHRcdFx0bm9kZU5hbWUoIGVsZW0sIFwiYnV0dG9uXCIgKTtcblx0XHR9LFxuXG5cdFx0dGV4dDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgYXR0cjtcblx0XHRcdHJldHVybiBub2RlTmFtZSggZWxlbSwgXCJpbnB1dFwiICkgJiYgZWxlbS50eXBlID09PSBcInRleHRcIiAmJlxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDwxMCBvbmx5XG5cdFx0XHRcdC8vIE5ldyBIVE1MNSBhdHRyaWJ1dGUgdmFsdWVzIChlLmcuLCBcInNlYXJjaFwiKSBhcHBlYXJcblx0XHRcdFx0Ly8gd2l0aCBlbGVtLnR5cGUgPT09IFwidGV4dFwiXG5cdFx0XHRcdCggKCBhdHRyID0gZWxlbS5nZXRBdHRyaWJ1dGUoIFwidHlwZVwiICkgKSA9PSBudWxsIHx8XG5cdFx0XHRcdFx0YXR0ci50b0xvd2VyQ2FzZSgpID09PSBcInRleHRcIiApO1xuXHRcdH0sXG5cblx0XHQvLyBQb3NpdGlvbi1pbi1jb2xsZWN0aW9uXG5cdFx0Zmlyc3Q6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIFsgMCBdO1xuXHRcdH0gKSxcblxuXHRcdGxhc3Q6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZ1bmN0aW9uKCBfbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gWyBsZW5ndGggLSAxIF07XG5cdFx0fSApLFxuXG5cdFx0ZXE6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZ1bmN0aW9uKCBfbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0cmV0dXJuIFsgYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudCBdO1xuXHRcdH0gKSxcblxuXHRcdGV2ZW46IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHZhciBpID0gMDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSArPSAyICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9ICksXG5cblx0XHRvZGQ6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHZhciBpID0gMTtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSArPSAyICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9ICksXG5cblx0XHRsdDogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyggZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHZhciBpO1xuXG5cdFx0XHRpZiAoIGFyZ3VtZW50IDwgMCApIHtcblx0XHRcdFx0aSA9IGFyZ3VtZW50ICsgbGVuZ3RoO1xuXHRcdFx0fSBlbHNlIGlmICggYXJndW1lbnQgPiBsZW5ndGggKSB7XG5cdFx0XHRcdGkgPSBsZW5ndGg7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpID0gYXJndW1lbnQ7XG5cdFx0XHR9XG5cblx0XHRcdGZvciAoIDsgLS1pID49IDA7ICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9ICksXG5cblx0XHRndDogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyggZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHZhciBpID0gYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudDtcblx0XHRcdGZvciAoIDsgKytpIDwgbGVuZ3RoOyApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSApXG5cdH1cbn07XG5cbkV4cHIucHNldWRvcy5udGggPSBFeHByLnBzZXVkb3MuZXE7XG5cbi8vIEFkZCBidXR0b24vaW5wdXQgdHlwZSBwc2V1ZG9zXG5mb3IgKCBpIGluIHsgcmFkaW86IHRydWUsIGNoZWNrYm94OiB0cnVlLCBmaWxlOiB0cnVlLCBwYXNzd29yZDogdHJ1ZSwgaW1hZ2U6IHRydWUgfSApIHtcblx0RXhwci5wc2V1ZG9zWyBpIF0gPSBjcmVhdGVJbnB1dFBzZXVkbyggaSApO1xufVxuZm9yICggaSBpbiB7IHN1Ym1pdDogdHJ1ZSwgcmVzZXQ6IHRydWUgfSApIHtcblx0RXhwci5wc2V1ZG9zWyBpIF0gPSBjcmVhdGVCdXR0b25Qc2V1ZG8oIGkgKTtcbn1cblxuLy8gRWFzeSBBUEkgZm9yIGNyZWF0aW5nIG5ldyBzZXRGaWx0ZXJzXG5mdW5jdGlvbiBzZXRGaWx0ZXJzKCkge31cbnNldEZpbHRlcnMucHJvdG90eXBlID0gRXhwci5maWx0ZXJzID0gRXhwci5wc2V1ZG9zO1xuRXhwci5zZXRGaWx0ZXJzID0gbmV3IHNldEZpbHRlcnMoKTtcblxuZnVuY3Rpb24gdG9rZW5pemUoIHNlbGVjdG9yLCBwYXJzZU9ubHkgKSB7XG5cdHZhciBtYXRjaGVkLCBtYXRjaCwgdG9rZW5zLCB0eXBlLFxuXHRcdHNvRmFyLCBncm91cHMsIHByZUZpbHRlcnMsXG5cdFx0Y2FjaGVkID0gdG9rZW5DYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdO1xuXG5cdGlmICggY2FjaGVkICkge1xuXHRcdHJldHVybiBwYXJzZU9ubHkgPyAwIDogY2FjaGVkLnNsaWNlKCAwICk7XG5cdH1cblxuXHRzb0ZhciA9IHNlbGVjdG9yO1xuXHRncm91cHMgPSBbXTtcblx0cHJlRmlsdGVycyA9IEV4cHIucHJlRmlsdGVyO1xuXG5cdHdoaWxlICggc29GYXIgKSB7XG5cblx0XHQvLyBDb21tYSBhbmQgZmlyc3QgcnVuXG5cdFx0aWYgKCAhbWF0Y2hlZCB8fCAoIG1hdGNoID0gcmNvbW1hLmV4ZWMoIHNvRmFyICkgKSApIHtcblx0XHRcdGlmICggbWF0Y2ggKSB7XG5cblx0XHRcdFx0Ly8gRG9uJ3QgY29uc3VtZSB0cmFpbGluZyBjb21tYXMgYXMgdmFsaWRcblx0XHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hbIDAgXS5sZW5ndGggKSB8fCBzb0Zhcjtcblx0XHRcdH1cblx0XHRcdGdyb3Vwcy5wdXNoKCAoIHRva2VucyA9IFtdICkgKTtcblx0XHR9XG5cblx0XHRtYXRjaGVkID0gZmFsc2U7XG5cblx0XHQvLyBDb21iaW5hdG9yc1xuXHRcdGlmICggKCBtYXRjaCA9IHJsZWFkaW5nQ29tYmluYXRvci5leGVjKCBzb0ZhciApICkgKSB7XG5cdFx0XHRtYXRjaGVkID0gbWF0Y2guc2hpZnQoKTtcblx0XHRcdHRva2Vucy5wdXNoKCB7XG5cdFx0XHRcdHZhbHVlOiBtYXRjaGVkLFxuXG5cdFx0XHRcdC8vIENhc3QgZGVzY2VuZGFudCBjb21iaW5hdG9ycyB0byBzcGFjZVxuXHRcdFx0XHR0eXBlOiBtYXRjaFsgMCBdLnJlcGxhY2UoIHJ0cmltQ1NTLCBcIiBcIiApXG5cdFx0XHR9ICk7XG5cdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaGVkLmxlbmd0aCApO1xuXHRcdH1cblxuXHRcdC8vIEZpbHRlcnNcblx0XHRmb3IgKCB0eXBlIGluIEV4cHIuZmlsdGVyICkge1xuXHRcdFx0aWYgKCAoIG1hdGNoID0gbWF0Y2hFeHByWyB0eXBlIF0uZXhlYyggc29GYXIgKSApICYmICggIXByZUZpbHRlcnNbIHR5cGUgXSB8fFxuXHRcdFx0XHQoIG1hdGNoID0gcHJlRmlsdGVyc1sgdHlwZSBdKCBtYXRjaCApICkgKSApIHtcblx0XHRcdFx0bWF0Y2hlZCA9IG1hdGNoLnNoaWZ0KCk7XG5cdFx0XHRcdHRva2Vucy5wdXNoKCB7XG5cdFx0XHRcdFx0dmFsdWU6IG1hdGNoZWQsXG5cdFx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0XHRtYXRjaGVzOiBtYXRjaFxuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoZWQubGVuZ3RoICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCAhbWF0Y2hlZCApIHtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgbGVuZ3RoIG9mIHRoZSBpbnZhbGlkIGV4Y2Vzc1xuXHQvLyBpZiB3ZSdyZSBqdXN0IHBhcnNpbmdcblx0Ly8gT3RoZXJ3aXNlLCB0aHJvdyBhbiBlcnJvciBvciByZXR1cm4gdG9rZW5zXG5cdGlmICggcGFyc2VPbmx5ICkge1xuXHRcdHJldHVybiBzb0Zhci5sZW5ndGg7XG5cdH1cblxuXHRyZXR1cm4gc29GYXIgP1xuXHRcdGZpbmQuZXJyb3IoIHNlbGVjdG9yICkgOlxuXG5cdFx0Ly8gQ2FjaGUgdGhlIHRva2Vuc1xuXHRcdHRva2VuQ2FjaGUoIHNlbGVjdG9yLCBncm91cHMgKS5zbGljZSggMCApO1xufVxuXG5mdW5jdGlvbiB0b1NlbGVjdG9yKCB0b2tlbnMgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSB0b2tlbnMubGVuZ3RoLFxuXHRcdHNlbGVjdG9yID0gXCJcIjtcblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0c2VsZWN0b3IgKz0gdG9rZW5zWyBpIF0udmFsdWU7XG5cdH1cblx0cmV0dXJuIHNlbGVjdG9yO1xufVxuXG5mdW5jdGlvbiBhZGRDb21iaW5hdG9yKCBtYXRjaGVyLCBjb21iaW5hdG9yLCBiYXNlICkge1xuXHR2YXIgZGlyID0gY29tYmluYXRvci5kaXIsXG5cdFx0c2tpcCA9IGNvbWJpbmF0b3IubmV4dCxcblx0XHRrZXkgPSBza2lwIHx8IGRpcixcblx0XHRjaGVja05vbkVsZW1lbnRzID0gYmFzZSAmJiBrZXkgPT09IFwicGFyZW50Tm9kZVwiLFxuXHRcdGRvbmVOYW1lID0gZG9uZSsrO1xuXG5cdHJldHVybiBjb21iaW5hdG9yLmZpcnN0ID9cblxuXHRcdC8vIENoZWNrIGFnYWluc3QgY2xvc2VzdCBhbmNlc3Rvci9wcmVjZWRpbmcgZWxlbWVudFxuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IGVsZW1bIGRpciBdICkgKSB7XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdHJldHVybiBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0gOlxuXG5cdFx0Ly8gQ2hlY2sgYWdhaW5zdCBhbGwgYW5jZXN0b3IvcHJlY2VkaW5nIGVsZW1lbnRzXG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciBvbGRDYWNoZSwgb3V0ZXJDYWNoZSxcblx0XHRcdFx0bmV3Q2FjaGUgPSBbIGRpcnJ1bnMsIGRvbmVOYW1lIF07XG5cblx0XHRcdC8vIFdlIGNhbid0IHNldCBhcmJpdHJhcnkgZGF0YSBvbiBYTUwgbm9kZXMsIHNvIHRoZXkgZG9uJ3QgYmVuZWZpdCBmcm9tIGNvbWJpbmF0b3IgY2FjaGluZ1xuXHRcdFx0aWYgKCB4bWwgKSB7XG5cdFx0XHRcdHdoaWxlICggKCBlbGVtID0gZWxlbVsgZGlyIF0gKSApIHtcblx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0d2hpbGUgKCAoIGVsZW0gPSBlbGVtWyBkaXIgXSApICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IGVsZW1bIGV4cGFuZG8gXSB8fCAoIGVsZW1bIGV4cGFuZG8gXSA9IHt9ICk7XG5cblx0XHRcdFx0XHRcdGlmICggc2tpcCAmJiBub2RlTmFtZSggZWxlbSwgc2tpcCApICkge1xuXHRcdFx0XHRcdFx0XHRlbGVtID0gZWxlbVsgZGlyIF0gfHwgZWxlbTtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoICggb2xkQ2FjaGUgPSBvdXRlckNhY2hlWyBrZXkgXSApICYmXG5cdFx0XHRcdFx0XHRcdG9sZENhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgb2xkQ2FjaGVbIDEgXSA9PT0gZG9uZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQXNzaWduIHRvIG5ld0NhY2hlIHNvIHJlc3VsdHMgYmFjay1wcm9wYWdhdGUgdG8gcHJldmlvdXMgZWxlbWVudHNcblx0XHRcdFx0XHRcdFx0cmV0dXJuICggbmV3Q2FjaGVbIDIgXSA9IG9sZENhY2hlWyAyIF0gKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gUmV1c2UgbmV3Y2FjaGUgc28gcmVzdWx0cyBiYWNrLXByb3BhZ2F0ZSB0byBwcmV2aW91cyBlbGVtZW50c1xuXHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlWyBrZXkgXSA9IG5ld0NhY2hlO1xuXG5cdFx0XHRcdFx0XHRcdC8vIEEgbWF0Y2ggbWVhbnMgd2UncmUgZG9uZTsgYSBmYWlsIG1lYW5zIHdlIGhhdmUgdG8ga2VlcCBjaGVja2luZ1xuXHRcdFx0XHRcdFx0XHRpZiAoICggbmV3Q2FjaGVbIDIgXSA9IG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xufVxuXG5mdW5jdGlvbiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSB7XG5cdHJldHVybiBtYXRjaGVycy5sZW5ndGggPiAxID9cblx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0dmFyIGkgPSBtYXRjaGVycy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCAhbWF0Y2hlcnNbIGkgXSggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9IDpcblx0XHRtYXRjaGVyc1sgMCBdO1xufVxuXG5mdW5jdGlvbiBtdWx0aXBsZUNvbnRleHRzKCBzZWxlY3RvciwgY29udGV4dHMsIHJlc3VsdHMgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSBjb250ZXh0cy5sZW5ndGg7XG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGZpbmQoIHNlbGVjdG9yLCBjb250ZXh0c1sgaSBdLCByZXN1bHRzICk7XG5cdH1cblx0cmV0dXJuIHJlc3VsdHM7XG59XG5cbmZ1bmN0aW9uIGNvbmRlbnNlKCB1bm1hdGNoZWQsIG1hcCwgZmlsdGVyLCBjb250ZXh0LCB4bWwgKSB7XG5cdHZhciBlbGVtLFxuXHRcdG5ld1VubWF0Y2hlZCA9IFtdLFxuXHRcdGkgPSAwLFxuXHRcdGxlbiA9IHVubWF0Y2hlZC5sZW5ndGgsXG5cdFx0bWFwcGVkID0gbWFwICE9IG51bGw7XG5cblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0aWYgKCAoIGVsZW0gPSB1bm1hdGNoZWRbIGkgXSApICkge1xuXHRcdFx0aWYgKCAhZmlsdGVyIHx8IGZpbHRlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdG5ld1VubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdGlmICggbWFwcGVkICkge1xuXHRcdFx0XHRcdG1hcC5wdXNoKCBpICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbmV3VW5tYXRjaGVkO1xufVxuXG5mdW5jdGlvbiBzZXRNYXRjaGVyKCBwcmVGaWx0ZXIsIHNlbGVjdG9yLCBtYXRjaGVyLCBwb3N0RmlsdGVyLCBwb3N0RmluZGVyLCBwb3N0U2VsZWN0b3IgKSB7XG5cdGlmICggcG9zdEZpbHRlciAmJiAhcG9zdEZpbHRlclsgZXhwYW5kbyBdICkge1xuXHRcdHBvc3RGaWx0ZXIgPSBzZXRNYXRjaGVyKCBwb3N0RmlsdGVyICk7XG5cdH1cblx0aWYgKCBwb3N0RmluZGVyICYmICFwb3N0RmluZGVyWyBleHBhbmRvIF0gKSB7XG5cdFx0cG9zdEZpbmRlciA9IHNldE1hdGNoZXIoIHBvc3RGaW5kZXIsIHBvc3RTZWxlY3RvciApO1xuXHR9XG5cdHJldHVybiBtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBzZWVkLCByZXN1bHRzLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0dmFyIHRlbXAsIGksIGVsZW0sIG1hdGNoZXJPdXQsXG5cdFx0XHRwcmVNYXAgPSBbXSxcblx0XHRcdHBvc3RNYXAgPSBbXSxcblx0XHRcdHByZWV4aXN0aW5nID0gcmVzdWx0cy5sZW5ndGgsXG5cblx0XHRcdC8vIEdldCBpbml0aWFsIGVsZW1lbnRzIGZyb20gc2VlZCBvciBjb250ZXh0XG5cdFx0XHRlbGVtcyA9IHNlZWQgfHxcblx0XHRcdFx0bXVsdGlwbGVDb250ZXh0cyggc2VsZWN0b3IgfHwgXCIqXCIsXG5cdFx0XHRcdFx0Y29udGV4dC5ub2RlVHlwZSA/IFsgY29udGV4dCBdIDogY29udGV4dCwgW10gKSxcblxuXHRcdFx0Ly8gUHJlZmlsdGVyIHRvIGdldCBtYXRjaGVyIGlucHV0LCBwcmVzZXJ2aW5nIGEgbWFwIGZvciBzZWVkLXJlc3VsdHMgc3luY2hyb25pemF0aW9uXG5cdFx0XHRtYXRjaGVySW4gPSBwcmVGaWx0ZXIgJiYgKCBzZWVkIHx8ICFzZWxlY3RvciApID9cblx0XHRcdFx0Y29uZGVuc2UoIGVsZW1zLCBwcmVNYXAsIHByZUZpbHRlciwgY29udGV4dCwgeG1sICkgOlxuXHRcdFx0XHRlbGVtcztcblxuXHRcdGlmICggbWF0Y2hlciApIHtcblxuXHRcdFx0Ly8gSWYgd2UgaGF2ZSBhIHBvc3RGaW5kZXIsIG9yIGZpbHRlcmVkIHNlZWQsIG9yIG5vbi1zZWVkIHBvc3RGaWx0ZXJcblx0XHRcdC8vIG9yIHByZWV4aXN0aW5nIHJlc3VsdHMsXG5cdFx0XHRtYXRjaGVyT3V0ID0gcG9zdEZpbmRlciB8fCAoIHNlZWQgPyBwcmVGaWx0ZXIgOiBwcmVleGlzdGluZyB8fCBwb3N0RmlsdGVyICkgP1xuXG5cdFx0XHRcdC8vIC4uLmludGVybWVkaWF0ZSBwcm9jZXNzaW5nIGlzIG5lY2Vzc2FyeVxuXHRcdFx0XHRbXSA6XG5cblx0XHRcdFx0Ly8gLi4ub3RoZXJ3aXNlIHVzZSByZXN1bHRzIGRpcmVjdGx5XG5cdFx0XHRcdHJlc3VsdHM7XG5cblx0XHRcdC8vIEZpbmQgcHJpbWFyeSBtYXRjaGVzXG5cdFx0XHRtYXRjaGVyKCBtYXRjaGVySW4sIG1hdGNoZXJPdXQsIGNvbnRleHQsIHhtbCApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXRjaGVyT3V0ID0gbWF0Y2hlckluO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHBvc3RGaWx0ZXJcblx0XHRpZiAoIHBvc3RGaWx0ZXIgKSB7XG5cdFx0XHR0ZW1wID0gY29uZGVuc2UoIG1hdGNoZXJPdXQsIHBvc3RNYXAgKTtcblx0XHRcdHBvc3RGaWx0ZXIoIHRlbXAsIFtdLCBjb250ZXh0LCB4bWwgKTtcblxuXHRcdFx0Ly8gVW4tbWF0Y2ggZmFpbGluZyBlbGVtZW50cyBieSBtb3ZpbmcgdGhlbSBiYWNrIHRvIG1hdGNoZXJJblxuXHRcdFx0aSA9IHRlbXAubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggKCBlbGVtID0gdGVtcFsgaSBdICkgKSB7XG5cdFx0XHRcdFx0bWF0Y2hlck91dFsgcG9zdE1hcFsgaSBdIF0gPSAhKCBtYXRjaGVySW5bIHBvc3RNYXBbIGkgXSBdID0gZWxlbSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBzZWVkICkge1xuXHRcdFx0aWYgKCBwb3N0RmluZGVyIHx8IHByZUZpbHRlciApIHtcblx0XHRcdFx0aWYgKCBwb3N0RmluZGVyICkge1xuXG5cdFx0XHRcdFx0Ly8gR2V0IHRoZSBmaW5hbCBtYXRjaGVyT3V0IGJ5IGNvbmRlbnNpbmcgdGhpcyBpbnRlcm1lZGlhdGUgaW50byBwb3N0RmluZGVyIGNvbnRleHRzXG5cdFx0XHRcdFx0dGVtcCA9IFtdO1xuXHRcdFx0XHRcdGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGlmICggKCBlbGVtID0gbWF0Y2hlck91dFsgaSBdICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gUmVzdG9yZSBtYXRjaGVySW4gc2luY2UgZWxlbSBpcyBub3QgeWV0IGEgZmluYWwgbWF0Y2hcblx0XHRcdFx0XHRcdFx0dGVtcC5wdXNoKCAoIG1hdGNoZXJJblsgaSBdID0gZWxlbSApICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHBvc3RGaW5kZXIoIG51bGwsICggbWF0Y2hlck91dCA9IFtdICksIHRlbXAsIHhtbCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gTW92ZSBtYXRjaGVkIGVsZW1lbnRzIGZyb20gc2VlZCB0byByZXN1bHRzIHRvIGtlZXAgdGhlbSBzeW5jaHJvbml6ZWRcblx0XHRcdFx0aSA9IG1hdGNoZXJPdXQubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRpZiAoICggZWxlbSA9IG1hdGNoZXJPdXRbIGkgXSApICYmXG5cdFx0XHRcdFx0XHQoIHRlbXAgPSBwb3N0RmluZGVyID8gaW5kZXhPZi5jYWxsKCBzZWVkLCBlbGVtICkgOiBwcmVNYXBbIGkgXSApID4gLTEgKSB7XG5cblx0XHRcdFx0XHRcdHNlZWRbIHRlbXAgXSA9ICEoIHJlc3VsdHNbIHRlbXAgXSA9IGVsZW0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEFkZCBlbGVtZW50cyB0byByZXN1bHRzLCB0aHJvdWdoIHBvc3RGaW5kZXIgaWYgZGVmaW5lZFxuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXRjaGVyT3V0ID0gY29uZGVuc2UoXG5cdFx0XHRcdG1hdGNoZXJPdXQgPT09IHJlc3VsdHMgP1xuXHRcdFx0XHRcdG1hdGNoZXJPdXQuc3BsaWNlKCBwcmVleGlzdGluZywgbWF0Y2hlck91dC5sZW5ndGggKSA6XG5cdFx0XHRcdFx0bWF0Y2hlck91dFxuXHRcdFx0KTtcblx0XHRcdGlmICggcG9zdEZpbmRlciApIHtcblx0XHRcdFx0cG9zdEZpbmRlciggbnVsbCwgcmVzdWx0cywgbWF0Y2hlck91dCwgeG1sICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBtYXRjaGVyT3V0ICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9ICk7XG59XG5cbmZ1bmN0aW9uIG1hdGNoZXJGcm9tVG9rZW5zKCB0b2tlbnMgKSB7XG5cdHZhciBjaGVja0NvbnRleHQsIG1hdGNoZXIsIGosXG5cdFx0bGVuID0gdG9rZW5zLmxlbmd0aCxcblx0XHRsZWFkaW5nUmVsYXRpdmUgPSBFeHByLnJlbGF0aXZlWyB0b2tlbnNbIDAgXS50eXBlIF0sXG5cdFx0aW1wbGljaXRSZWxhdGl2ZSA9IGxlYWRpbmdSZWxhdGl2ZSB8fCBFeHByLnJlbGF0aXZlWyBcIiBcIiBdLFxuXHRcdGkgPSBsZWFkaW5nUmVsYXRpdmUgPyAxIDogMCxcblxuXHRcdC8vIFRoZSBmb3VuZGF0aW9uYWwgbWF0Y2hlciBlbnN1cmVzIHRoYXQgZWxlbWVudHMgYXJlIHJlYWNoYWJsZSBmcm9tIHRvcC1sZXZlbCBjb250ZXh0KHMpXG5cdFx0bWF0Y2hDb250ZXh0ID0gYWRkQ29tYmluYXRvciggZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gY2hlY2tDb250ZXh0O1xuXHRcdH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcblx0XHRtYXRjaEFueUNvbnRleHQgPSBhZGRDb21iaW5hdG9yKCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBpbmRleE9mLmNhbGwoIGNoZWNrQ29udGV4dCwgZWxlbSApID4gLTE7XG5cdFx0fSwgaW1wbGljaXRSZWxhdGl2ZSwgdHJ1ZSApLFxuXHRcdG1hdGNoZXJzID0gWyBmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcblx0XHRcdC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xuXHRcdFx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXHRcdFx0dmFyIHJldCA9ICggIWxlYWRpbmdSZWxhdGl2ZSAmJiAoIHhtbCB8fCBjb250ZXh0ICE9IG91dGVybW9zdENvbnRleHQgKSApIHx8IChcblx0XHRcdFx0KCBjaGVja0NvbnRleHQgPSBjb250ZXh0ICkubm9kZVR5cGUgP1xuXHRcdFx0XHRcdG1hdGNoQ29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgOlxuXHRcdFx0XHRcdG1hdGNoQW55Q29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgKTtcblxuXHRcdFx0Ly8gQXZvaWQgaGFuZ2luZyBvbnRvIGVsZW1lbnRcblx0XHRcdC8vIChzZWUgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9zaXp6bGUvaXNzdWVzLzI5OSlcblx0XHRcdGNoZWNrQ29udGV4dCA9IG51bGw7XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH0gXTtcblxuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRpZiAoICggbWF0Y2hlciA9IEV4cHIucmVsYXRpdmVbIHRva2Vuc1sgaSBdLnR5cGUgXSApICkge1xuXHRcdFx0bWF0Y2hlcnMgPSBbIGFkZENvbWJpbmF0b3IoIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApLCBtYXRjaGVyICkgXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWF0Y2hlciA9IEV4cHIuZmlsdGVyWyB0b2tlbnNbIGkgXS50eXBlIF0uYXBwbHkoIG51bGwsIHRva2Vuc1sgaSBdLm1hdGNoZXMgKTtcblxuXHRcdFx0Ly8gUmV0dXJuIHNwZWNpYWwgdXBvbiBzZWVpbmcgYSBwb3NpdGlvbmFsIG1hdGNoZXJcblx0XHRcdGlmICggbWF0Y2hlclsgZXhwYW5kbyBdICkge1xuXG5cdFx0XHRcdC8vIEZpbmQgdGhlIG5leHQgcmVsYXRpdmUgb3BlcmF0b3IgKGlmIGFueSkgZm9yIHByb3BlciBoYW5kbGluZ1xuXHRcdFx0XHRqID0gKytpO1xuXHRcdFx0XHRmb3IgKCA7IGogPCBsZW47IGorKyApIHtcblx0XHRcdFx0XHRpZiAoIEV4cHIucmVsYXRpdmVbIHRva2Vuc1sgaiBdLnR5cGUgXSApIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gc2V0TWF0Y2hlcihcblx0XHRcdFx0XHRpID4gMSAmJiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSxcblx0XHRcdFx0XHRpID4gMSAmJiB0b1NlbGVjdG9yKFxuXG5cdFx0XHRcdFx0XHQvLyBJZiB0aGUgcHJlY2VkaW5nIHRva2VuIHdhcyBhIGRlc2NlbmRhbnQgY29tYmluYXRvciwgaW5zZXJ0IGFuIGltcGxpY2l0IGFueS1lbGVtZW50IGAqYFxuXHRcdFx0XHRcdFx0dG9rZW5zLnNsaWNlKCAwLCBpIC0gMSApXG5cdFx0XHRcdFx0XHRcdC5jb25jYXQoIHsgdmFsdWU6IHRva2Vuc1sgaSAtIDIgXS50eXBlID09PSBcIiBcIiA/IFwiKlwiIDogXCJcIiB9IClcblx0XHRcdFx0XHQpLnJlcGxhY2UoIHJ0cmltQ1NTLCBcIiQxXCIgKSxcblx0XHRcdFx0XHRtYXRjaGVyLFxuXHRcdFx0XHRcdGkgPCBqICYmIG1hdGNoZXJGcm9tVG9rZW5zKCB0b2tlbnMuc2xpY2UoIGksIGogKSApLFxuXHRcdFx0XHRcdGogPCBsZW4gJiYgbWF0Y2hlckZyb21Ub2tlbnMoICggdG9rZW5zID0gdG9rZW5zLnNsaWNlKCBqICkgKSApLFxuXHRcdFx0XHRcdGogPCBsZW4gJiYgdG9TZWxlY3RvciggdG9rZW5zIClcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHRcdG1hdGNoZXJzLnB1c2goIG1hdGNoZXIgKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICk7XG59XG5cbmZ1bmN0aW9uIG1hdGNoZXJGcm9tR3JvdXBNYXRjaGVycyggZWxlbWVudE1hdGNoZXJzLCBzZXRNYXRjaGVycyApIHtcblx0dmFyIGJ5U2V0ID0gc2V0TWF0Y2hlcnMubGVuZ3RoID4gMCxcblx0XHRieUVsZW1lbnQgPSBlbGVtZW50TWF0Y2hlcnMubGVuZ3RoID4gMCxcblx0XHRzdXBlck1hdGNoZXIgPSBmdW5jdGlvbiggc2VlZCwgY29udGV4dCwgeG1sLCByZXN1bHRzLCBvdXRlcm1vc3QgKSB7XG5cdFx0XHR2YXIgZWxlbSwgaiwgbWF0Y2hlcixcblx0XHRcdFx0bWF0Y2hlZENvdW50ID0gMCxcblx0XHRcdFx0aSA9IFwiMFwiLFxuXHRcdFx0XHR1bm1hdGNoZWQgPSBzZWVkICYmIFtdLFxuXHRcdFx0XHRzZXRNYXRjaGVkID0gW10sXG5cdFx0XHRcdGNvbnRleHRCYWNrdXAgPSBvdXRlcm1vc3RDb250ZXh0LFxuXG5cdFx0XHRcdC8vIFdlIG11c3QgYWx3YXlzIGhhdmUgZWl0aGVyIHNlZWQgZWxlbWVudHMgb3Igb3V0ZXJtb3N0IGNvbnRleHRcblx0XHRcdFx0ZWxlbXMgPSBzZWVkIHx8IGJ5RWxlbWVudCAmJiBFeHByLmZpbmQuVEFHKCBcIipcIiwgb3V0ZXJtb3N0ICksXG5cblx0XHRcdFx0Ly8gVXNlIGludGVnZXIgZGlycnVucyBpZmYgdGhpcyBpcyB0aGUgb3V0ZXJtb3N0IG1hdGNoZXJcblx0XHRcdFx0ZGlycnVuc1VuaXF1ZSA9ICggZGlycnVucyArPSBjb250ZXh0QmFja3VwID09IG51bGwgPyAxIDogTWF0aC5yYW5kb20oKSB8fCAwLjEgKSxcblx0XHRcdFx0bGVuID0gZWxlbXMubGVuZ3RoO1xuXG5cdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcblx0XHRcdFx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdFx0XHRcdC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cblx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXHRcdFx0XHRvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dCA9PSBkb2N1bWVudCB8fCBjb250ZXh0IHx8IG91dGVybW9zdDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIGVsZW1lbnRzIHBhc3NpbmcgZWxlbWVudE1hdGNoZXJzIGRpcmVjdGx5IHRvIHJlc3VsdHNcblx0XHRcdC8vIFN1cHBvcnQ6IGlPUyA8PTcgLSA5IG9ubHlcblx0XHRcdC8vIFRvbGVyYXRlIE5vZGVMaXN0IHByb3BlcnRpZXMgKElFOiBcImxlbmd0aFwiOyBTYWZhcmk6IDxudW1iZXI+KSBtYXRjaGluZ1xuXHRcdFx0Ly8gZWxlbWVudHMgYnkgaWQuIChzZWUgdHJhYy0xNDE0Milcblx0XHRcdGZvciAoIDsgaSAhPT0gbGVuICYmICggZWxlbSA9IGVsZW1zWyBpIF0gKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0XHRcdGlmICggYnlFbGVtZW50ICYmIGVsZW0gKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcblx0XHRcdFx0XHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcblx0XHRcdFx0XHQvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG5cdFx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXHRcdFx0XHRcdGlmICggIWNvbnRleHQgJiYgZWxlbS5vd25lckRvY3VtZW50ICE9IGRvY3VtZW50ICkge1xuXHRcdFx0XHRcdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0XHRcdFx0XHRcdHhtbCA9ICFkb2N1bWVudElzSFRNTDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0d2hpbGUgKCAoIG1hdGNoZXIgPSBlbGVtZW50TWF0Y2hlcnNbIGorKyBdICkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQgfHwgZG9jdW1lbnQsIHhtbCApICkge1xuXHRcdFx0XHRcdFx0XHRwdXNoLmNhbGwoIHJlc3VsdHMsIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggb3V0ZXJtb3N0ICkge1xuXHRcdFx0XHRcdFx0ZGlycnVucyA9IGRpcnJ1bnNVbmlxdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVHJhY2sgdW5tYXRjaGVkIGVsZW1lbnRzIGZvciBzZXQgZmlsdGVyc1xuXHRcdFx0XHRpZiAoIGJ5U2V0ICkge1xuXG5cdFx0XHRcdFx0Ly8gVGhleSB3aWxsIGhhdmUgZ29uZSB0aHJvdWdoIGFsbCBwb3NzaWJsZSBtYXRjaGVyc1xuXHRcdFx0XHRcdGlmICggKCBlbGVtID0gIW1hdGNoZXIgJiYgZWxlbSApICkge1xuXHRcdFx0XHRcdFx0bWF0Y2hlZENvdW50LS07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gTGVuZ3RoZW4gdGhlIGFycmF5IGZvciBldmVyeSBlbGVtZW50LCBtYXRjaGVkIG9yIG5vdFxuXHRcdFx0XHRcdGlmICggc2VlZCApIHtcblx0XHRcdFx0XHRcdHVubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIGBpYCBpcyBub3cgdGhlIGNvdW50IG9mIGVsZW1lbnRzIHZpc2l0ZWQgYWJvdmUsIGFuZCBhZGRpbmcgaXQgdG8gYG1hdGNoZWRDb3VudGBcblx0XHRcdC8vIG1ha2VzIHRoZSBsYXR0ZXIgbm9ubmVnYXRpdmUuXG5cdFx0XHRtYXRjaGVkQ291bnQgKz0gaTtcblxuXHRcdFx0Ly8gQXBwbHkgc2V0IGZpbHRlcnMgdG8gdW5tYXRjaGVkIGVsZW1lbnRzXG5cdFx0XHQvLyBOT1RFOiBUaGlzIGNhbiBiZSBza2lwcGVkIGlmIHRoZXJlIGFyZSBubyB1bm1hdGNoZWQgZWxlbWVudHMgKGkuZS4sIGBtYXRjaGVkQ291bnRgXG5cdFx0XHQvLyBlcXVhbHMgYGlgKSwgdW5sZXNzIHdlIGRpZG4ndCB2aXNpdCBfYW55XyBlbGVtZW50cyBpbiB0aGUgYWJvdmUgbG9vcCBiZWNhdXNlIHdlIGhhdmVcblx0XHRcdC8vIG5vIGVsZW1lbnQgbWF0Y2hlcnMgYW5kIG5vIHNlZWQuXG5cdFx0XHQvLyBJbmNyZW1lbnRpbmcgYW4gaW5pdGlhbGx5LXN0cmluZyBcIjBcIiBgaWAgYWxsb3dzIGBpYCB0byByZW1haW4gYSBzdHJpbmcgb25seSBpbiB0aGF0XG5cdFx0XHQvLyBjYXNlLCB3aGljaCB3aWxsIHJlc3VsdCBpbiBhIFwiMDBcIiBgbWF0Y2hlZENvdW50YCB0aGF0IGRpZmZlcnMgZnJvbSBgaWAgYnV0IGlzIGFsc29cblx0XHRcdC8vIG51bWVyaWNhbGx5IHplcm8uXG5cdFx0XHRpZiAoIGJ5U2V0ICYmIGkgIT09IG1hdGNoZWRDb3VudCApIHtcblx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdHdoaWxlICggKCBtYXRjaGVyID0gc2V0TWF0Y2hlcnNbIGorKyBdICkgKSB7XG5cdFx0XHRcdFx0bWF0Y2hlciggdW5tYXRjaGVkLCBzZXRNYXRjaGVkLCBjb250ZXh0LCB4bWwgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggc2VlZCApIHtcblxuXHRcdFx0XHRcdC8vIFJlaW50ZWdyYXRlIGVsZW1lbnQgbWF0Y2hlcyB0byBlbGltaW5hdGUgdGhlIG5lZWQgZm9yIHNvcnRpbmdcblx0XHRcdFx0XHRpZiAoIG1hdGNoZWRDb3VudCA+IDAgKSB7XG5cdFx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCAhKCB1bm1hdGNoZWRbIGkgXSB8fCBzZXRNYXRjaGVkWyBpIF0gKSApIHtcblx0XHRcdFx0XHRcdFx0XHRzZXRNYXRjaGVkWyBpIF0gPSBwb3AuY2FsbCggcmVzdWx0cyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRGlzY2FyZCBpbmRleCBwbGFjZWhvbGRlciB2YWx1ZXMgdG8gZ2V0IG9ubHkgYWN0dWFsIG1hdGNoZXNcblx0XHRcdFx0XHRzZXRNYXRjaGVkID0gY29uZGVuc2UoIHNldE1hdGNoZWQgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEFkZCBtYXRjaGVzIHRvIHJlc3VsdHNcblx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgc2V0TWF0Y2hlZCApO1xuXG5cdFx0XHRcdC8vIFNlZWRsZXNzIHNldCBtYXRjaGVzIHN1Y2NlZWRpbmcgbXVsdGlwbGUgc3VjY2Vzc2Z1bCBtYXRjaGVycyBzdGlwdWxhdGUgc29ydGluZ1xuXHRcdFx0XHRpZiAoIG91dGVybW9zdCAmJiAhc2VlZCAmJiBzZXRNYXRjaGVkLmxlbmd0aCA+IDAgJiZcblx0XHRcdFx0XHQoIG1hdGNoZWRDb3VudCArIHNldE1hdGNoZXJzLmxlbmd0aCApID4gMSApIHtcblxuXHRcdFx0XHRcdGpRdWVyeS51bmlxdWVTb3J0KCByZXN1bHRzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gT3ZlcnJpZGUgbWFuaXB1bGF0aW9uIG9mIGdsb2JhbHMgYnkgbmVzdGVkIG1hdGNoZXJzXG5cdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0ZGlycnVucyA9IGRpcnJ1bnNVbmlxdWU7XG5cdFx0XHRcdG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0QmFja3VwO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdW5tYXRjaGVkO1xuXHRcdH07XG5cblx0cmV0dXJuIGJ5U2V0ID9cblx0XHRtYXJrRnVuY3Rpb24oIHN1cGVyTWF0Y2hlciApIDpcblx0XHRzdXBlck1hdGNoZXI7XG59XG5cbmZ1bmN0aW9uIGNvbXBpbGUoIHNlbGVjdG9yLCBtYXRjaCAvKiBJbnRlcm5hbCBVc2UgT25seSAqLyApIHtcblx0dmFyIGksXG5cdFx0c2V0TWF0Y2hlcnMgPSBbXSxcblx0XHRlbGVtZW50TWF0Y2hlcnMgPSBbXSxcblx0XHRjYWNoZWQgPSBjb21waWxlckNhY2hlWyBzZWxlY3RvciArIFwiIFwiIF07XG5cblx0aWYgKCAhY2FjaGVkICkge1xuXG5cdFx0Ly8gR2VuZXJhdGUgYSBmdW5jdGlvbiBvZiByZWN1cnNpdmUgZnVuY3Rpb25zIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2hlY2sgZWFjaCBlbGVtZW50XG5cdFx0aWYgKCAhbWF0Y2ggKSB7XG5cdFx0XHRtYXRjaCA9IHRva2VuaXplKCBzZWxlY3RvciApO1xuXHRcdH1cblx0XHRpID0gbWF0Y2gubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0Y2FjaGVkID0gbWF0Y2hlckZyb21Ub2tlbnMoIG1hdGNoWyBpIF0gKTtcblx0XHRcdGlmICggY2FjaGVkWyBleHBhbmRvIF0gKSB7XG5cdFx0XHRcdHNldE1hdGNoZXJzLnB1c2goIGNhY2hlZCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWxlbWVudE1hdGNoZXJzLnB1c2goIGNhY2hlZCApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhY2hlIHRoZSBjb21waWxlZCBmdW5jdGlvblxuXHRcdGNhY2hlZCA9IGNvbXBpbGVyQ2FjaGUoIHNlbGVjdG9yLFxuXHRcdFx0bWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzICkgKTtcblxuXHRcdC8vIFNhdmUgc2VsZWN0b3IgYW5kIHRva2VuaXphdGlvblxuXHRcdGNhY2hlZC5zZWxlY3RvciA9IHNlbGVjdG9yO1xuXHR9XG5cdHJldHVybiBjYWNoZWQ7XG59XG5cbi8qKlxuICogQSBsb3ctbGV2ZWwgc2VsZWN0aW9uIGZ1bmN0aW9uIHRoYXQgd29ya3Mgd2l0aCBqUXVlcnkncyBjb21waWxlZFxuICogIHNlbGVjdG9yIGZ1bmN0aW9uc1xuICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IHNlbGVjdG9yIEEgc2VsZWN0b3Igb3IgYSBwcmUtY29tcGlsZWRcbiAqICBzZWxlY3RvciBmdW5jdGlvbiBidWlsdCB3aXRoIGpRdWVyeSBzZWxlY3RvciBjb21waWxlXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGNvbnRleHRcbiAqIEBwYXJhbSB7QXJyYXl9IFtyZXN1bHRzXVxuICogQHBhcmFtIHtBcnJheX0gW3NlZWRdIEEgc2V0IG9mIGVsZW1lbnRzIHRvIG1hdGNoIGFnYWluc3RcbiAqL1xuZnVuY3Rpb24gc2VsZWN0KCBzZWxlY3RvciwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApIHtcblx0dmFyIGksIHRva2VucywgdG9rZW4sIHR5cGUsIGZpbmQsXG5cdFx0Y29tcGlsZWQgPSB0eXBlb2Ygc2VsZWN0b3IgPT09IFwiZnVuY3Rpb25cIiAmJiBzZWxlY3Rvcixcblx0XHRtYXRjaCA9ICFzZWVkICYmIHRva2VuaXplKCAoIHNlbGVjdG9yID0gY29tcGlsZWQuc2VsZWN0b3IgfHwgc2VsZWN0b3IgKSApO1xuXG5cdHJlc3VsdHMgPSByZXN1bHRzIHx8IFtdO1xuXG5cdC8vIFRyeSB0byBtaW5pbWl6ZSBvcGVyYXRpb25zIGlmIHRoZXJlIGlzIG9ubHkgb25lIHNlbGVjdG9yIGluIHRoZSBsaXN0IGFuZCBubyBzZWVkXG5cdC8vICh0aGUgbGF0dGVyIG9mIHdoaWNoIGd1YXJhbnRlZXMgdXMgY29udGV4dClcblx0aWYgKCBtYXRjaC5sZW5ndGggPT09IDEgKSB7XG5cblx0XHQvLyBSZWR1Y2UgY29udGV4dCBpZiB0aGUgbGVhZGluZyBjb21wb3VuZCBzZWxlY3RvciBpcyBhbiBJRFxuXHRcdHRva2VucyA9IG1hdGNoWyAwIF0gPSBtYXRjaFsgMCBdLnNsaWNlKCAwICk7XG5cdFx0aWYgKCB0b2tlbnMubGVuZ3RoID4gMiAmJiAoIHRva2VuID0gdG9rZW5zWyAwIF0gKS50eXBlID09PSBcIklEXCIgJiZcblx0XHRcdFx0Y29udGV4dC5ub2RlVHlwZSA9PT0gOSAmJiBkb2N1bWVudElzSFRNTCAmJiBFeHByLnJlbGF0aXZlWyB0b2tlbnNbIDEgXS50eXBlIF0gKSB7XG5cblx0XHRcdGNvbnRleHQgPSAoIEV4cHIuZmluZC5JRChcblx0XHRcdFx0dG9rZW4ubWF0Y2hlc1sgMCBdLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICksXG5cdFx0XHRcdGNvbnRleHRcblx0XHRcdCkgfHwgW10gKVsgMCBdO1xuXHRcdFx0aWYgKCAhY29udGV4dCApIHtcblx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cblx0XHRcdC8vIFByZWNvbXBpbGVkIG1hdGNoZXJzIHdpbGwgc3RpbGwgdmVyaWZ5IGFuY2VzdHJ5LCBzbyBzdGVwIHVwIGEgbGV2ZWxcblx0XHRcdH0gZWxzZSBpZiAoIGNvbXBpbGVkICkge1xuXHRcdFx0XHRjb250ZXh0ID0gY29udGV4dC5wYXJlbnROb2RlO1xuXHRcdFx0fVxuXG5cdFx0XHRzZWxlY3RvciA9IHNlbGVjdG9yLnNsaWNlKCB0b2tlbnMuc2hpZnQoKS52YWx1ZS5sZW5ndGggKTtcblx0XHR9XG5cblx0XHQvLyBGZXRjaCBhIHNlZWQgc2V0IGZvciByaWdodC10by1sZWZ0IG1hdGNoaW5nXG5cdFx0aSA9IG1hdGNoRXhwci5uZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3IgKSA/IDAgOiB0b2tlbnMubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0dG9rZW4gPSB0b2tlbnNbIGkgXTtcblxuXHRcdFx0Ly8gQWJvcnQgaWYgd2UgaGl0IGEgY29tYmluYXRvclxuXHRcdFx0aWYgKCBFeHByLnJlbGF0aXZlWyAoIHR5cGUgPSB0b2tlbi50eXBlICkgXSApIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRpZiAoICggZmluZCA9IEV4cHIuZmluZFsgdHlwZSBdICkgKSB7XG5cblx0XHRcdFx0Ly8gU2VhcmNoLCBleHBhbmRpbmcgY29udGV4dCBmb3IgbGVhZGluZyBzaWJsaW5nIGNvbWJpbmF0b3JzXG5cdFx0XHRcdGlmICggKCBzZWVkID0gZmluZChcblx0XHRcdFx0XHR0b2tlbi5tYXRjaGVzWyAwIF0ucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKSxcblx0XHRcdFx0XHRyc2libGluZy50ZXN0KCB0b2tlbnNbIDAgXS50eXBlICkgJiZcblx0XHRcdFx0XHRcdHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fCBjb250ZXh0XG5cdFx0XHRcdCkgKSApIHtcblxuXHRcdFx0XHRcdC8vIElmIHNlZWQgaXMgZW1wdHkgb3Igbm8gdG9rZW5zIHJlbWFpbiwgd2UgY2FuIHJldHVybiBlYXJseVxuXHRcdFx0XHRcdHRva2Vucy5zcGxpY2UoIGksIDEgKTtcblx0XHRcdFx0XHRzZWxlY3RvciA9IHNlZWQubGVuZ3RoICYmIHRvU2VsZWN0b3IoIHRva2VucyApO1xuXHRcdFx0XHRcdGlmICggIXNlbGVjdG9yICkge1xuXHRcdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgc2VlZCApO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBDb21waWxlIGFuZCBleGVjdXRlIGEgZmlsdGVyaW5nIGZ1bmN0aW9uIGlmIG9uZSBpcyBub3QgcHJvdmlkZWRcblx0Ly8gUHJvdmlkZSBgbWF0Y2hgIHRvIGF2b2lkIHJldG9rZW5pemF0aW9uIGlmIHdlIG1vZGlmaWVkIHRoZSBzZWxlY3RvciBhYm92ZVxuXHQoIGNvbXBpbGVkIHx8IGNvbXBpbGUoIHNlbGVjdG9yLCBtYXRjaCApICkoXG5cdFx0c2VlZCxcblx0XHRjb250ZXh0LFxuXHRcdCFkb2N1bWVudElzSFRNTCxcblx0XHRyZXN1bHRzLFxuXHRcdCFjb250ZXh0IHx8IHJzaWJsaW5nLnRlc3QoIHNlbGVjdG9yICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8IGNvbnRleHRcblx0KTtcblx0cmV0dXJuIHJlc3VsdHM7XG59XG5cbi8vIE9uZS10aW1lIGFzc2lnbm1lbnRzXG5cbi8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgLSA0LjErXG4vLyBTb3J0IHN0YWJpbGl0eVxuc3VwcG9ydC5zb3J0U3RhYmxlID0gZXhwYW5kby5zcGxpdCggXCJcIiApLnNvcnQoIHNvcnRPcmRlciApLmpvaW4oIFwiXCIgKSA9PT0gZXhwYW5kbztcblxuLy8gSW5pdGlhbGl6ZSBhZ2FpbnN0IHRoZSBkZWZhdWx0IGRvY3VtZW50XG5zZXREb2N1bWVudCgpO1xuXG4vLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIC0gNC4xK1xuLy8gRGV0YWNoZWQgbm9kZXMgY29uZm91bmRpbmdseSBmb2xsb3cgKmVhY2ggb3RoZXIqXG5zdXBwb3J0LnNvcnREZXRhY2hlZCA9IGFzc2VydCggZnVuY3Rpb24oIGVsICkge1xuXG5cdC8vIFNob3VsZCByZXR1cm4gMSwgYnV0IHJldHVybnMgNCAoZm9sbG93aW5nKVxuXHRyZXR1cm4gZWwuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZmllbGRzZXRcIiApICkgJiAxO1xufSApO1xuXG5qUXVlcnkuZmluZCA9IGZpbmQ7XG5cbi8vIERlcHJlY2F0ZWRcbmpRdWVyeS5leHByWyBcIjpcIiBdID0galF1ZXJ5LmV4cHIucHNldWRvcztcbmpRdWVyeS51bmlxdWUgPSBqUXVlcnkudW5pcXVlU29ydDtcblxuLy8gVGhlc2UgaGF2ZSBhbHdheXMgYmVlbiBwcml2YXRlLCBidXQgdGhleSB1c2VkIHRvIGJlIGRvY3VtZW50ZWQgYXMgcGFydCBvZlxuLy8gU2l6emxlIHNvIGxldCdzIG1haW50YWluIHRoZW0gZm9yIG5vdyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgcHVycG9zZXMuXG5maW5kLmNvbXBpbGUgPSBjb21waWxlO1xuZmluZC5zZWxlY3QgPSBzZWxlY3Q7XG5maW5kLnNldERvY3VtZW50ID0gc2V0RG9jdW1lbnQ7XG5maW5kLnRva2VuaXplID0gdG9rZW5pemU7XG5cbmZpbmQuZXNjYXBlID0galF1ZXJ5LmVzY2FwZVNlbGVjdG9yO1xuZmluZC5nZXRUZXh0ID0galF1ZXJ5LnRleHQ7XG5maW5kLmlzWE1MID0galF1ZXJ5LmlzWE1MRG9jO1xuZmluZC5zZWxlY3RvcnMgPSBqUXVlcnkuZXhwcjtcbmZpbmQuc3VwcG9ydCA9IGpRdWVyeS5zdXBwb3J0O1xuZmluZC51bmlxdWVTb3J0ID0galF1ZXJ5LnVuaXF1ZVNvcnQ7XG5cblx0LyogZXNsaW50LWVuYWJsZSAqL1xuXG59ICkoKTtcblxuXG52YXIgZGlyID0gZnVuY3Rpb24oIGVsZW0sIGRpciwgdW50aWwgKSB7XG5cdHZhciBtYXRjaGVkID0gW10sXG5cdFx0dHJ1bmNhdGUgPSB1bnRpbCAhPT0gdW5kZWZpbmVkO1xuXG5cdHdoaWxlICggKCBlbGVtID0gZWxlbVsgZGlyIF0gKSAmJiBlbGVtLm5vZGVUeXBlICE9PSA5ICkge1xuXHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdGlmICggdHJ1bmNhdGUgJiYgalF1ZXJ5KCBlbGVtICkuaXMoIHVudGlsICkgKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0bWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBtYXRjaGVkO1xufTtcblxuXG52YXIgc2libGluZ3MgPSBmdW5jdGlvbiggbiwgZWxlbSApIHtcblx0dmFyIG1hdGNoZWQgPSBbXTtcblxuXHRmb3IgKCA7IG47IG4gPSBuLm5leHRTaWJsaW5nICkge1xuXHRcdGlmICggbi5ub2RlVHlwZSA9PT0gMSAmJiBuICE9PSBlbGVtICkge1xuXHRcdFx0bWF0Y2hlZC5wdXNoKCBuICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG1hdGNoZWQ7XG59O1xuXG5cbnZhciBybmVlZHNDb250ZXh0ID0galF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0O1xuXG52YXIgcnNpbmdsZVRhZyA9ICggL148KFthLXpdW15cXC9cXDA+OlxceDIwXFx0XFxyXFxuXFxmXSopW1xceDIwXFx0XFxyXFxuXFxmXSpcXC8/Pig/OjxcXC9cXDE+fCkkL2kgKTtcblxuXG5cbi8vIEltcGxlbWVudCB0aGUgaWRlbnRpY2FsIGZ1bmN0aW9uYWxpdHkgZm9yIGZpbHRlciBhbmQgbm90XG5mdW5jdGlvbiB3aW5ub3coIGVsZW1lbnRzLCBxdWFsaWZpZXIsIG5vdCApIHtcblx0aWYgKCBpc0Z1bmN0aW9uKCBxdWFsaWZpZXIgKSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSwgaSApIHtcblx0XHRcdHJldHVybiAhIXF1YWxpZmllci5jYWxsKCBlbGVtLCBpLCBlbGVtICkgIT09IG5vdDtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBTaW5nbGUgZWxlbWVudFxuXHRpZiAoIHF1YWxpZmllci5ub2RlVHlwZSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAoIGVsZW0gPT09IHF1YWxpZmllciApICE9PSBub3Q7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gQXJyYXlsaWtlIG9mIGVsZW1lbnRzIChqUXVlcnksIGFyZ3VtZW50cywgQXJyYXkpXG5cdGlmICggdHlwZW9mIHF1YWxpZmllciAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAoIGluZGV4T2YuY2FsbCggcXVhbGlmaWVyLCBlbGVtICkgPiAtMSApICE9PSBub3Q7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gRmlsdGVyZWQgZGlyZWN0bHkgZm9yIGJvdGggc2ltcGxlIGFuZCBjb21wbGV4IHNlbGVjdG9yc1xuXHRyZXR1cm4galF1ZXJ5LmZpbHRlciggcXVhbGlmaWVyLCBlbGVtZW50cywgbm90ICk7XG59XG5cbmpRdWVyeS5maWx0ZXIgPSBmdW5jdGlvbiggZXhwciwgZWxlbXMsIG5vdCApIHtcblx0dmFyIGVsZW0gPSBlbGVtc1sgMCBdO1xuXG5cdGlmICggbm90ICkge1xuXHRcdGV4cHIgPSBcIjpub3QoXCIgKyBleHByICsgXCIpXCI7XG5cdH1cblxuXHRpZiAoIGVsZW1zLmxlbmd0aCA9PT0gMSAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdHJldHVybiBqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGVsZW0sIGV4cHIgKSA/IFsgZWxlbSBdIDogW107XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5LmZpbmQubWF0Y2hlcyggZXhwciwgalF1ZXJ5LmdyZXAoIGVsZW1zLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZWxlbS5ub2RlVHlwZSA9PT0gMTtcblx0fSApICk7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGZpbmQ6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgaSwgcmV0LFxuXHRcdFx0bGVuID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRzZWxmID0gdGhpcztcblxuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkoIHNlbGVjdG9yICkuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0XHRpZiAoIGpRdWVyeS5jb250YWlucyggc2VsZlsgaSBdLCB0aGlzICkgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gKSApO1xuXHRcdH1cblxuXHRcdHJldCA9IHRoaXMucHVzaFN0YWNrKCBbXSApO1xuXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdGpRdWVyeS5maW5kKCBzZWxlY3Rvciwgc2VsZlsgaSBdLCByZXQgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbGVuID4gMSA/IGpRdWVyeS51bmlxdWVTb3J0KCByZXQgKSA6IHJldDtcblx0fSxcblx0ZmlsdGVyOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCB3aW5ub3coIHRoaXMsIHNlbGVjdG9yIHx8IFtdLCBmYWxzZSApICk7XG5cdH0sXG5cdG5vdDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggd2lubm93KCB0aGlzLCBzZWxlY3RvciB8fCBbXSwgdHJ1ZSApICk7XG5cdH0sXG5cdGlzOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuICEhd2lubm93KFxuXHRcdFx0dGhpcyxcblxuXHRcdFx0Ly8gSWYgdGhpcyBpcyBhIHBvc2l0aW9uYWwvcmVsYXRpdmUgc2VsZWN0b3IsIGNoZWNrIG1lbWJlcnNoaXAgaW4gdGhlIHJldHVybmVkIHNldFxuXHRcdFx0Ly8gc28gJChcInA6Zmlyc3RcIikuaXMoXCJwOmxhc3RcIikgd29uJ3QgcmV0dXJuIHRydWUgZm9yIGEgZG9jIHdpdGggdHdvIFwicFwiLlxuXHRcdFx0dHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICYmIHJuZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3IgKSA/XG5cdFx0XHRcdGpRdWVyeSggc2VsZWN0b3IgKSA6XG5cdFx0XHRcdHNlbGVjdG9yIHx8IFtdLFxuXHRcdFx0ZmFsc2Vcblx0XHQpLmxlbmd0aDtcblx0fVxufSApO1xuXG5cbi8vIEluaXRpYWxpemUgYSBqUXVlcnkgb2JqZWN0XG5cblxuLy8gQSBjZW50cmFsIHJlZmVyZW5jZSB0byB0aGUgcm9vdCBqUXVlcnkoZG9jdW1lbnQpXG52YXIgcm9vdGpRdWVyeSxcblxuXHQvLyBBIHNpbXBsZSB3YXkgdG8gY2hlY2sgZm9yIEhUTUwgc3RyaW5nc1xuXHQvLyBQcmlvcml0aXplICNpZCBvdmVyIDx0YWc+IHRvIGF2b2lkIFhTUyB2aWEgbG9jYXRpb24uaGFzaCAodHJhYy05NTIxKVxuXHQvLyBTdHJpY3QgSFRNTCByZWNvZ25pdGlvbiAodHJhYy0xMTI5MDogbXVzdCBzdGFydCB3aXRoIDwpXG5cdC8vIFNob3J0Y3V0IHNpbXBsZSAjaWQgY2FzZSBmb3Igc3BlZWRcblx0cnF1aWNrRXhwciA9IC9eKD86XFxzKig8W1xcd1xcV10rPilbXj5dKnwjKFtcXHctXSspKSQvLFxuXG5cdGluaXQgPSBqUXVlcnkuZm4uaW5pdCA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCwgcm9vdCApIHtcblx0XHR2YXIgbWF0Y2gsIGVsZW07XG5cblx0XHQvLyBIQU5ETEU6ICQoXCJcIiksICQobnVsbCksICQodW5kZWZpbmVkKSwgJChmYWxzZSlcblx0XHRpZiAoICFzZWxlY3RvciApIHtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdC8vIE1ldGhvZCBpbml0KCkgYWNjZXB0cyBhbiBhbHRlcm5hdGUgcm9vdGpRdWVyeVxuXHRcdC8vIHNvIG1pZ3JhdGUgY2FuIHN1cHBvcnQgalF1ZXJ5LnN1YiAoZ2gtMjEwMSlcblx0XHRyb290ID0gcm9vdCB8fCByb290alF1ZXJ5O1xuXG5cdFx0Ly8gSGFuZGxlIEhUTUwgc3RyaW5nc1xuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0aWYgKCBzZWxlY3RvclsgMCBdID09PSBcIjxcIiAmJlxuXHRcdFx0XHRzZWxlY3Rvclsgc2VsZWN0b3IubGVuZ3RoIC0gMSBdID09PSBcIj5cIiAmJlxuXHRcdFx0XHRzZWxlY3Rvci5sZW5ndGggPj0gMyApIHtcblxuXHRcdFx0XHQvLyBBc3N1bWUgdGhhdCBzdHJpbmdzIHRoYXQgc3RhcnQgYW5kIGVuZCB3aXRoIDw+IGFyZSBIVE1MIGFuZCBza2lwIHRoZSByZWdleCBjaGVja1xuXHRcdFx0XHRtYXRjaCA9IFsgbnVsbCwgc2VsZWN0b3IsIG51bGwgXTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bWF0Y2ggPSBycXVpY2tFeHByLmV4ZWMoIHNlbGVjdG9yICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1hdGNoIGh0bWwgb3IgbWFrZSBzdXJlIG5vIGNvbnRleHQgaXMgc3BlY2lmaWVkIGZvciAjaWRcblx0XHRcdGlmICggbWF0Y2ggJiYgKCBtYXRjaFsgMSBdIHx8ICFjb250ZXh0ICkgKSB7XG5cblx0XHRcdFx0Ly8gSEFORExFOiAkKGh0bWwpIC0+ICQoYXJyYXkpXG5cdFx0XHRcdGlmICggbWF0Y2hbIDEgXSApIHtcblx0XHRcdFx0XHRjb250ZXh0ID0gY29udGV4dCBpbnN0YW5jZW9mIGpRdWVyeSA/IGNvbnRleHRbIDAgXSA6IGNvbnRleHQ7XG5cblx0XHRcdFx0XHQvLyBPcHRpb24gdG8gcnVuIHNjcmlwdHMgaXMgdHJ1ZSBmb3IgYmFjay1jb21wYXRcblx0XHRcdFx0XHQvLyBJbnRlbnRpb25hbGx5IGxldCB0aGUgZXJyb3IgYmUgdGhyb3duIGlmIHBhcnNlSFRNTCBpcyBub3QgcHJlc2VudFxuXHRcdFx0XHRcdGpRdWVyeS5tZXJnZSggdGhpcywgalF1ZXJ5LnBhcnNlSFRNTChcblx0XHRcdFx0XHRcdG1hdGNoWyAxIF0sXG5cdFx0XHRcdFx0XHRjb250ZXh0ICYmIGNvbnRleHQubm9kZVR5cGUgPyBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCA6IGRvY3VtZW50LFxuXHRcdFx0XHRcdFx0dHJ1ZVxuXHRcdFx0XHRcdCkgKTtcblxuXHRcdFx0XHRcdC8vIEhBTkRMRTogJChodG1sLCBwcm9wcylcblx0XHRcdFx0XHRpZiAoIHJzaW5nbGVUYWcudGVzdCggbWF0Y2hbIDEgXSApICYmIGpRdWVyeS5pc1BsYWluT2JqZWN0KCBjb250ZXh0ICkgKSB7XG5cdFx0XHRcdFx0XHRmb3IgKCBtYXRjaCBpbiBjb250ZXh0ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFByb3BlcnRpZXMgb2YgY29udGV4dCBhcmUgY2FsbGVkIGFzIG1ldGhvZHMgaWYgcG9zc2libGVcblx0XHRcdFx0XHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCB0aGlzWyBtYXRjaCBdICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpc1sgbWF0Y2ggXSggY29udGV4dFsgbWF0Y2ggXSApO1xuXG5cdFx0XHRcdFx0XHRcdC8vIC4uLmFuZCBvdGhlcndpc2Ugc2V0IGFzIGF0dHJpYnV0ZXNcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLmF0dHIoIG1hdGNoLCBjb250ZXh0WyBtYXRjaCBdICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdFx0XHQvLyBIQU5ETEU6ICQoI2lkKVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGVsZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCggbWF0Y2hbIDIgXSApO1xuXG5cdFx0XHRcdFx0aWYgKCBlbGVtICkge1xuXG5cdFx0XHRcdFx0XHQvLyBJbmplY3QgdGhlIGVsZW1lbnQgZGlyZWN0bHkgaW50byB0aGUgalF1ZXJ5IG9iamVjdFxuXHRcdFx0XHRcdFx0dGhpc1sgMCBdID0gZWxlbTtcblx0XHRcdFx0XHRcdHRoaXMubGVuZ3RoID0gMTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly8gSEFORExFOiAkKGV4cHIsICQoLi4uKSlcblx0XHRcdH0gZWxzZSBpZiAoICFjb250ZXh0IHx8IGNvbnRleHQuanF1ZXJ5ICkge1xuXHRcdFx0XHRyZXR1cm4gKCBjb250ZXh0IHx8IHJvb3QgKS5maW5kKCBzZWxlY3RvciApO1xuXG5cdFx0XHQvLyBIQU5ETEU6ICQoZXhwciwgY29udGV4dClcblx0XHRcdC8vICh3aGljaCBpcyBqdXN0IGVxdWl2YWxlbnQgdG86ICQoY29udGV4dCkuZmluZChleHByKVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuY29uc3RydWN0b3IoIGNvbnRleHQgKS5maW5kKCBzZWxlY3RvciApO1xuXHRcdFx0fVxuXG5cdFx0Ly8gSEFORExFOiAkKERPTUVsZW1lbnQpXG5cdFx0fSBlbHNlIGlmICggc2VsZWN0b3Iubm9kZVR5cGUgKSB7XG5cdFx0XHR0aGlzWyAwIF0gPSBzZWxlY3Rvcjtcblx0XHRcdHRoaXMubGVuZ3RoID0gMTtcblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0Ly8gSEFORExFOiAkKGZ1bmN0aW9uKVxuXHRcdC8vIFNob3J0Y3V0IGZvciBkb2N1bWVudCByZWFkeVxuXHRcdH0gZWxzZSBpZiAoIGlzRnVuY3Rpb24oIHNlbGVjdG9yICkgKSB7XG5cdFx0XHRyZXR1cm4gcm9vdC5yZWFkeSAhPT0gdW5kZWZpbmVkID9cblx0XHRcdFx0cm9vdC5yZWFkeSggc2VsZWN0b3IgKSA6XG5cblx0XHRcdFx0Ly8gRXhlY3V0ZSBpbW1lZGlhdGVseSBpZiByZWFkeSBpcyBub3QgcHJlc2VudFxuXHRcdFx0XHRzZWxlY3RvciggalF1ZXJ5ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGpRdWVyeS5tYWtlQXJyYXkoIHNlbGVjdG9yLCB0aGlzICk7XG5cdH07XG5cbi8vIEdpdmUgdGhlIGluaXQgZnVuY3Rpb24gdGhlIGpRdWVyeSBwcm90b3R5cGUgZm9yIGxhdGVyIGluc3RhbnRpYXRpb25cbmluaXQucHJvdG90eXBlID0galF1ZXJ5LmZuO1xuXG4vLyBJbml0aWFsaXplIGNlbnRyYWwgcmVmZXJlbmNlXG5yb290alF1ZXJ5ID0galF1ZXJ5KCBkb2N1bWVudCApO1xuXG5cbnZhciBycGFyZW50c3ByZXYgPSAvXig/OnBhcmVudHN8cHJldig/OlVudGlsfEFsbCkpLyxcblxuXHQvLyBNZXRob2RzIGd1YXJhbnRlZWQgdG8gcHJvZHVjZSBhIHVuaXF1ZSBzZXQgd2hlbiBzdGFydGluZyBmcm9tIGEgdW5pcXVlIHNldFxuXHRndWFyYW50ZWVkVW5pcXVlID0ge1xuXHRcdGNoaWxkcmVuOiB0cnVlLFxuXHRcdGNvbnRlbnRzOiB0cnVlLFxuXHRcdG5leHQ6IHRydWUsXG5cdFx0cHJldjogdHJ1ZVxuXHR9O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGhhczogZnVuY3Rpb24oIHRhcmdldCApIHtcblx0XHR2YXIgdGFyZ2V0cyA9IGpRdWVyeSggdGFyZ2V0LCB0aGlzICksXG5cdFx0XHRsID0gdGFyZ2V0cy5sZW5ndGg7XG5cblx0XHRyZXR1cm4gdGhpcy5maWx0ZXIoIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGkgPSAwO1xuXHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGpRdWVyeS5jb250YWlucyggdGhpcywgdGFyZ2V0c1sgaSBdICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0Y2xvc2VzdDogZnVuY3Rpb24oIHNlbGVjdG9ycywgY29udGV4dCApIHtcblx0XHR2YXIgY3VyLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRtYXRjaGVkID0gW10sXG5cdFx0XHR0YXJnZXRzID0gdHlwZW9mIHNlbGVjdG9ycyAhPT0gXCJzdHJpbmdcIiAmJiBqUXVlcnkoIHNlbGVjdG9ycyApO1xuXG5cdFx0Ly8gUG9zaXRpb25hbCBzZWxlY3RvcnMgbmV2ZXIgbWF0Y2gsIHNpbmNlIHRoZXJlJ3Mgbm8gX3NlbGVjdGlvbl8gY29udGV4dFxuXHRcdGlmICggIXJuZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3JzICkgKSB7XG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdGZvciAoIGN1ciA9IHRoaXNbIGkgXTsgY3VyICYmIGN1ciAhPT0gY29udGV4dDsgY3VyID0gY3VyLnBhcmVudE5vZGUgKSB7XG5cblx0XHRcdFx0XHQvLyBBbHdheXMgc2tpcCBkb2N1bWVudCBmcmFnbWVudHNcblx0XHRcdFx0XHRpZiAoIGN1ci5ub2RlVHlwZSA8IDExICYmICggdGFyZ2V0cyA/XG5cdFx0XHRcdFx0XHR0YXJnZXRzLmluZGV4KCBjdXIgKSA+IC0xIDpcblxuXHRcdFx0XHRcdFx0Ly8gRG9uJ3QgcGFzcyBub24tZWxlbWVudHMgdG8galF1ZXJ5I2ZpbmRcblx0XHRcdFx0XHRcdGN1ci5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHRcdFx0XHRqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGN1ciwgc2VsZWN0b3JzICkgKSApIHtcblxuXHRcdFx0XHRcdFx0bWF0Y2hlZC5wdXNoKCBjdXIgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggbWF0Y2hlZC5sZW5ndGggPiAxID8galF1ZXJ5LnVuaXF1ZVNvcnQoIG1hdGNoZWQgKSA6IG1hdGNoZWQgKTtcblx0fSxcblxuXHQvLyBEZXRlcm1pbmUgdGhlIHBvc2l0aW9uIG9mIGFuIGVsZW1lbnQgd2l0aGluIHRoZSBzZXRcblx0aW5kZXg6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gTm8gYXJndW1lbnQsIHJldHVybiBpbmRleCBpbiBwYXJlbnRcblx0XHRpZiAoICFlbGVtICkge1xuXHRcdFx0cmV0dXJuICggdGhpc1sgMCBdICYmIHRoaXNbIDAgXS5wYXJlbnROb2RlICkgPyB0aGlzLmZpcnN0KCkucHJldkFsbCgpLmxlbmd0aCA6IC0xO1xuXHRcdH1cblxuXHRcdC8vIEluZGV4IGluIHNlbGVjdG9yXG5cdFx0aWYgKCB0eXBlb2YgZWxlbSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiBpbmRleE9mLmNhbGwoIGpRdWVyeSggZWxlbSApLCB0aGlzWyAwIF0gKTtcblx0XHR9XG5cblx0XHQvLyBMb2NhdGUgdGhlIHBvc2l0aW9uIG9mIHRoZSBkZXNpcmVkIGVsZW1lbnRcblx0XHRyZXR1cm4gaW5kZXhPZi5jYWxsKCB0aGlzLFxuXG5cdFx0XHQvLyBJZiBpdCByZWNlaXZlcyBhIGpRdWVyeSBvYmplY3QsIHRoZSBmaXJzdCBlbGVtZW50IGlzIHVzZWRcblx0XHRcdGVsZW0uanF1ZXJ5ID8gZWxlbVsgMCBdIDogZWxlbVxuXHRcdCk7XG5cdH0sXG5cblx0YWRkOiBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKFxuXHRcdFx0alF1ZXJ5LnVuaXF1ZVNvcnQoXG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggdGhpcy5nZXQoKSwgalF1ZXJ5KCBzZWxlY3RvciwgY29udGV4dCApIClcblx0XHRcdClcblx0XHQpO1xuXHR9LFxuXG5cdGFkZEJhY2s6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5hZGQoIHNlbGVjdG9yID09IG51bGwgP1xuXHRcdFx0dGhpcy5wcmV2T2JqZWN0IDogdGhpcy5wcmV2T2JqZWN0LmZpbHRlciggc2VsZWN0b3IgKVxuXHRcdCk7XG5cdH1cbn0gKTtcblxuZnVuY3Rpb24gc2libGluZyggY3VyLCBkaXIgKSB7XG5cdHdoaWxlICggKCBjdXIgPSBjdXJbIGRpciBdICkgJiYgY3VyLm5vZGVUeXBlICE9PSAxICkge31cblx0cmV0dXJuIGN1cjtcbn1cblxualF1ZXJ5LmVhY2goIHtcblx0cGFyZW50OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdHJldHVybiBwYXJlbnQgJiYgcGFyZW50Lm5vZGVUeXBlICE9PSAxMSA/IHBhcmVudCA6IG51bGw7XG5cdH0sXG5cdHBhcmVudHM6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicGFyZW50Tm9kZVwiICk7XG5cdH0sXG5cdHBhcmVudHNVbnRpbDogZnVuY3Rpb24oIGVsZW0sIF9pLCB1bnRpbCApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInBhcmVudE5vZGVcIiwgdW50aWwgKTtcblx0fSxcblx0bmV4dDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmcoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiApO1xuXHR9LFxuXHRwcmV2OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZyggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiApO1xuXHR9LFxuXHRuZXh0QWxsOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIgKTtcblx0fSxcblx0cHJldkFsbDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiApO1xuXHR9LFxuXHRuZXh0VW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBfaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJuZXh0U2libGluZ1wiLCB1bnRpbCApO1xuXHR9LFxuXHRwcmV2VW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBfaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiwgdW50aWwgKTtcblx0fSxcblx0c2libGluZ3M6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5ncyggKCBlbGVtLnBhcmVudE5vZGUgfHwge30gKS5maXJzdENoaWxkLCBlbGVtICk7XG5cdH0sXG5cdGNoaWxkcmVuOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZ3MoIGVsZW0uZmlyc3RDaGlsZCApO1xuXHR9LFxuXHRjb250ZW50czogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0aWYgKCBlbGVtLmNvbnRlbnREb2N1bWVudCAhPSBudWxsICYmXG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDExK1xuXHRcdFx0Ly8gPG9iamVjdD4gZWxlbWVudHMgd2l0aCBubyBgZGF0YWAgYXR0cmlidXRlIGhhcyBhbiBvYmplY3Rcblx0XHRcdC8vIGBjb250ZW50RG9jdW1lbnRgIHdpdGggYSBgbnVsbGAgcHJvdG90eXBlLlxuXHRcdFx0Z2V0UHJvdG8oIGVsZW0uY29udGVudERvY3VtZW50ICkgKSB7XG5cblx0XHRcdHJldHVybiBlbGVtLmNvbnRlbnREb2N1bWVudDtcblx0XHR9XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA5IC0gMTEgb25seSwgaU9TIDcgb25seSwgQW5kcm9pZCBCcm93c2VyIDw9NC4zIG9ubHlcblx0XHQvLyBUcmVhdCB0aGUgdGVtcGxhdGUgZWxlbWVudCBhcyBhIHJlZ3VsYXIgb25lIGluIGJyb3dzZXJzIHRoYXRcblx0XHQvLyBkb24ndCBzdXBwb3J0IGl0LlxuXHRcdGlmICggbm9kZU5hbWUoIGVsZW0sIFwidGVtcGxhdGVcIiApICkge1xuXHRcdFx0ZWxlbSA9IGVsZW0uY29udGVudCB8fCBlbGVtO1xuXHRcdH1cblxuXHRcdHJldHVybiBqUXVlcnkubWVyZ2UoIFtdLCBlbGVtLmNoaWxkTm9kZXMgKTtcblx0fVxufSwgZnVuY3Rpb24oIG5hbWUsIGZuICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCB1bnRpbCwgc2VsZWN0b3IgKSB7XG5cdFx0dmFyIG1hdGNoZWQgPSBqUXVlcnkubWFwKCB0aGlzLCBmbiwgdW50aWwgKTtcblxuXHRcdGlmICggbmFtZS5zbGljZSggLTUgKSAhPT0gXCJVbnRpbFwiICkge1xuXHRcdFx0c2VsZWN0b3IgPSB1bnRpbDtcblx0XHR9XG5cblx0XHRpZiAoIHNlbGVjdG9yICYmIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdG1hdGNoZWQgPSBqUXVlcnkuZmlsdGVyKCBzZWxlY3RvciwgbWF0Y2hlZCApO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5sZW5ndGggPiAxICkge1xuXG5cdFx0XHQvLyBSZW1vdmUgZHVwbGljYXRlc1xuXHRcdFx0aWYgKCAhZ3VhcmFudGVlZFVuaXF1ZVsgbmFtZSBdICkge1xuXHRcdFx0XHRqUXVlcnkudW5pcXVlU29ydCggbWF0Y2hlZCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXZlcnNlIG9yZGVyIGZvciBwYXJlbnRzKiBhbmQgcHJldi1kZXJpdmF0aXZlc1xuXHRcdFx0aWYgKCBycGFyZW50c3ByZXYudGVzdCggbmFtZSApICkge1xuXHRcdFx0XHRtYXRjaGVkLnJldmVyc2UoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIG1hdGNoZWQgKTtcblx0fTtcbn0gKTtcbnZhciBybm90aHRtbHdoaXRlID0gKCAvW15cXHgyMFxcdFxcclxcblxcZl0rL2cgKTtcblxuXG5cbi8vIENvbnZlcnQgU3RyaW5nLWZvcm1hdHRlZCBvcHRpb25zIGludG8gT2JqZWN0LWZvcm1hdHRlZCBvbmVzXG5mdW5jdGlvbiBjcmVhdGVPcHRpb25zKCBvcHRpb25zICkge1xuXHR2YXIgb2JqZWN0ID0ge307XG5cdGpRdWVyeS5lYWNoKCBvcHRpb25zLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW10sIGZ1bmN0aW9uKCBfLCBmbGFnICkge1xuXHRcdG9iamVjdFsgZmxhZyBdID0gdHJ1ZTtcblx0fSApO1xuXHRyZXR1cm4gb2JqZWN0O1xufVxuXG4vKlxuICogQ3JlYXRlIGEgY2FsbGJhY2sgbGlzdCB1c2luZyB0aGUgZm9sbG93aW5nIHBhcmFtZXRlcnM6XG4gKlxuICpcdG9wdGlvbnM6IGFuIG9wdGlvbmFsIGxpc3Qgb2Ygc3BhY2Utc2VwYXJhdGVkIG9wdGlvbnMgdGhhdCB3aWxsIGNoYW5nZSBob3dcbiAqXHRcdFx0dGhlIGNhbGxiYWNrIGxpc3QgYmVoYXZlcyBvciBhIG1vcmUgdHJhZGl0aW9uYWwgb3B0aW9uIG9iamVjdFxuICpcbiAqIEJ5IGRlZmF1bHQgYSBjYWxsYmFjayBsaXN0IHdpbGwgYWN0IGxpa2UgYW4gZXZlbnQgY2FsbGJhY2sgbGlzdCBhbmQgY2FuIGJlXG4gKiBcImZpcmVkXCIgbXVsdGlwbGUgdGltZXMuXG4gKlxuICogUG9zc2libGUgb3B0aW9uczpcbiAqXG4gKlx0b25jZTpcdFx0XHR3aWxsIGVuc3VyZSB0aGUgY2FsbGJhY2sgbGlzdCBjYW4gb25seSBiZSBmaXJlZCBvbmNlIChsaWtlIGEgRGVmZXJyZWQpXG4gKlxuICpcdG1lbW9yeTpcdFx0XHR3aWxsIGtlZXAgdHJhY2sgb2YgcHJldmlvdXMgdmFsdWVzIGFuZCB3aWxsIGNhbGwgYW55IGNhbGxiYWNrIGFkZGVkXG4gKlx0XHRcdFx0XHRhZnRlciB0aGUgbGlzdCBoYXMgYmVlbiBmaXJlZCByaWdodCBhd2F5IHdpdGggdGhlIGxhdGVzdCBcIm1lbW9yaXplZFwiXG4gKlx0XHRcdFx0XHR2YWx1ZXMgKGxpa2UgYSBEZWZlcnJlZClcbiAqXG4gKlx0dW5pcXVlOlx0XHRcdHdpbGwgZW5zdXJlIGEgY2FsbGJhY2sgY2FuIG9ubHkgYmUgYWRkZWQgb25jZSAobm8gZHVwbGljYXRlIGluIHRoZSBsaXN0KVxuICpcbiAqXHRzdG9wT25GYWxzZTpcdGludGVycnVwdCBjYWxsaW5ncyB3aGVuIGEgY2FsbGJhY2sgcmV0dXJucyBmYWxzZVxuICpcbiAqL1xualF1ZXJ5LkNhbGxiYWNrcyA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXG5cdC8vIENvbnZlcnQgb3B0aW9ucyBmcm9tIFN0cmluZy1mb3JtYXR0ZWQgdG8gT2JqZWN0LWZvcm1hdHRlZCBpZiBuZWVkZWRcblx0Ly8gKHdlIGNoZWNrIGluIGNhY2hlIGZpcnN0KVxuXHRvcHRpb25zID0gdHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIgP1xuXHRcdGNyZWF0ZU9wdGlvbnMoIG9wdGlvbnMgKSA6XG5cdFx0alF1ZXJ5LmV4dGVuZCgge30sIG9wdGlvbnMgKTtcblxuXHR2YXIgLy8gRmxhZyB0byBrbm93IGlmIGxpc3QgaXMgY3VycmVudGx5IGZpcmluZ1xuXHRcdGZpcmluZyxcblxuXHRcdC8vIExhc3QgZmlyZSB2YWx1ZSBmb3Igbm9uLWZvcmdldHRhYmxlIGxpc3RzXG5cdFx0bWVtb3J5LFxuXG5cdFx0Ly8gRmxhZyB0byBrbm93IGlmIGxpc3Qgd2FzIGFscmVhZHkgZmlyZWRcblx0XHRmaXJlZCxcblxuXHRcdC8vIEZsYWcgdG8gcHJldmVudCBmaXJpbmdcblx0XHRsb2NrZWQsXG5cblx0XHQvLyBBY3R1YWwgY2FsbGJhY2sgbGlzdFxuXHRcdGxpc3QgPSBbXSxcblxuXHRcdC8vIFF1ZXVlIG9mIGV4ZWN1dGlvbiBkYXRhIGZvciByZXBlYXRhYmxlIGxpc3RzXG5cdFx0cXVldWUgPSBbXSxcblxuXHRcdC8vIEluZGV4IG9mIGN1cnJlbnRseSBmaXJpbmcgY2FsbGJhY2sgKG1vZGlmaWVkIGJ5IGFkZC9yZW1vdmUgYXMgbmVlZGVkKVxuXHRcdGZpcmluZ0luZGV4ID0gLTEsXG5cblx0XHQvLyBGaXJlIGNhbGxiYWNrc1xuXHRcdGZpcmUgPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRW5mb3JjZSBzaW5nbGUtZmlyaW5nXG5cdFx0XHRsb2NrZWQgPSBsb2NrZWQgfHwgb3B0aW9ucy5vbmNlO1xuXG5cdFx0XHQvLyBFeGVjdXRlIGNhbGxiYWNrcyBmb3IgYWxsIHBlbmRpbmcgZXhlY3V0aW9ucyxcblx0XHRcdC8vIHJlc3BlY3RpbmcgZmlyaW5nSW5kZXggb3ZlcnJpZGVzIGFuZCBydW50aW1lIGNoYW5nZXNcblx0XHRcdGZpcmVkID0gZmlyaW5nID0gdHJ1ZTtcblx0XHRcdGZvciAoIDsgcXVldWUubGVuZ3RoOyBmaXJpbmdJbmRleCA9IC0xICkge1xuXHRcdFx0XHRtZW1vcnkgPSBxdWV1ZS5zaGlmdCgpO1xuXHRcdFx0XHR3aGlsZSAoICsrZmlyaW5nSW5kZXggPCBsaXN0Lmxlbmd0aCApIHtcblxuXHRcdFx0XHRcdC8vIFJ1biBjYWxsYmFjayBhbmQgY2hlY2sgZm9yIGVhcmx5IHRlcm1pbmF0aW9uXG5cdFx0XHRcdFx0aWYgKCBsaXN0WyBmaXJpbmdJbmRleCBdLmFwcGx5KCBtZW1vcnlbIDAgXSwgbWVtb3J5WyAxIF0gKSA9PT0gZmFsc2UgJiZcblx0XHRcdFx0XHRcdG9wdGlvbnMuc3RvcE9uRmFsc2UgKSB7XG5cblx0XHRcdFx0XHRcdC8vIEp1bXAgdG8gZW5kIGFuZCBmb3JnZXQgdGhlIGRhdGEgc28gLmFkZCBkb2Vzbid0IHJlLWZpcmVcblx0XHRcdFx0XHRcdGZpcmluZ0luZGV4ID0gbGlzdC5sZW5ndGg7XG5cdFx0XHRcdFx0XHRtZW1vcnkgPSBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gRm9yZ2V0IHRoZSBkYXRhIGlmIHdlJ3JlIGRvbmUgd2l0aCBpdFxuXHRcdFx0aWYgKCAhb3B0aW9ucy5tZW1vcnkgKSB7XG5cdFx0XHRcdG1lbW9yeSA9IGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRmaXJpbmcgPSBmYWxzZTtcblxuXHRcdFx0Ly8gQ2xlYW4gdXAgaWYgd2UncmUgZG9uZSBmaXJpbmcgZm9yIGdvb2Rcblx0XHRcdGlmICggbG9ja2VkICkge1xuXG5cdFx0XHRcdC8vIEtlZXAgYW4gZW1wdHkgbGlzdCBpZiB3ZSBoYXZlIGRhdGEgZm9yIGZ1dHVyZSBhZGQgY2FsbHNcblx0XHRcdFx0aWYgKCBtZW1vcnkgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IFtdO1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSwgdGhpcyBvYmplY3QgaXMgc3BlbnRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRsaXN0ID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvLyBBY3R1YWwgQ2FsbGJhY2tzIG9iamVjdFxuXHRcdHNlbGYgPSB7XG5cblx0XHRcdC8vIEFkZCBhIGNhbGxiYWNrIG9yIGEgY29sbGVjdGlvbiBvZiBjYWxsYmFja3MgdG8gdGhlIGxpc3Rcblx0XHRcdGFkZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggbGlzdCApIHtcblxuXHRcdFx0XHRcdC8vIElmIHdlIGhhdmUgbWVtb3J5IGZyb20gYSBwYXN0IHJ1biwgd2Ugc2hvdWxkIGZpcmUgYWZ0ZXIgYWRkaW5nXG5cdFx0XHRcdFx0aWYgKCBtZW1vcnkgJiYgIWZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmluZ0luZGV4ID0gbGlzdC5sZW5ndGggLSAxO1xuXHRcdFx0XHRcdFx0cXVldWUucHVzaCggbWVtb3J5ICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0KCBmdW5jdGlvbiBhZGQoIGFyZ3MgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZWFjaCggYXJncywgZnVuY3Rpb24oIF8sIGFyZyApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCBhcmcgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoICFvcHRpb25zLnVuaXF1ZSB8fCAhc2VsZi5oYXMoIGFyZyApICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0bGlzdC5wdXNoKCBhcmcgKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGFyZyAmJiBhcmcubGVuZ3RoICYmIHRvVHlwZSggYXJnICkgIT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBJbnNwZWN0IHJlY3Vyc2l2ZWx5XG5cdFx0XHRcdFx0XHRcdFx0YWRkKCBhcmcgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdH0gKSggYXJndW1lbnRzICk7XG5cblx0XHRcdFx0XHRpZiAoIG1lbW9yeSAmJiAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIFJlbW92ZSBhIGNhbGxiYWNrIGZyb20gdGhlIGxpc3Rcblx0XHRcdHJlbW92ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGpRdWVyeS5lYWNoKCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBfLCBhcmcgKSB7XG5cdFx0XHRcdFx0dmFyIGluZGV4O1xuXHRcdFx0XHRcdHdoaWxlICggKCBpbmRleCA9IGpRdWVyeS5pbkFycmF5KCBhcmcsIGxpc3QsIGluZGV4ICkgKSA+IC0xICkge1xuXHRcdFx0XHRcdFx0bGlzdC5zcGxpY2UoIGluZGV4LCAxICk7XG5cblx0XHRcdFx0XHRcdC8vIEhhbmRsZSBmaXJpbmcgaW5kZXhlc1xuXHRcdFx0XHRcdFx0aWYgKCBpbmRleCA8PSBmaXJpbmdJbmRleCApIHtcblx0XHRcdFx0XHRcdFx0ZmlyaW5nSW5kZXgtLTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBDaGVjayBpZiBhIGdpdmVuIGNhbGxiYWNrIGlzIGluIHRoZSBsaXN0LlxuXHRcdFx0Ly8gSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIHJldHVybiB3aGV0aGVyIG9yIG5vdCBsaXN0IGhhcyBjYWxsYmFja3MgYXR0YWNoZWQuXG5cdFx0XHRoYXM6IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRcdFx0cmV0dXJuIGZuID9cblx0XHRcdFx0XHRqUXVlcnkuaW5BcnJheSggZm4sIGxpc3QgKSA+IC0xIDpcblx0XHRcdFx0XHRsaXN0Lmxlbmd0aCA+IDA7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBSZW1vdmUgYWxsIGNhbGxiYWNrcyBmcm9tIHRoZSBsaXN0XG5cdFx0XHRlbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggbGlzdCApIHtcblx0XHRcdFx0XHRsaXN0ID0gW107XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBEaXNhYmxlIC5maXJlIGFuZCAuYWRkXG5cdFx0XHQvLyBBYm9ydCBhbnkgY3VycmVudC9wZW5kaW5nIGV4ZWN1dGlvbnNcblx0XHRcdC8vIENsZWFyIGFsbCBjYWxsYmFja3MgYW5kIHZhbHVlc1xuXHRcdFx0ZGlzYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGxvY2tlZCA9IHF1ZXVlID0gW107XG5cdFx0XHRcdGxpc3QgPSBtZW1vcnkgPSBcIlwiO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHRkaXNhYmxlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhbGlzdDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIERpc2FibGUgLmZpcmVcblx0XHRcdC8vIEFsc28gZGlzYWJsZSAuYWRkIHVubGVzcyB3ZSBoYXZlIG1lbW9yeSAoc2luY2UgaXQgd291bGQgaGF2ZSBubyBlZmZlY3QpXG5cdFx0XHQvLyBBYm9ydCBhbnkgcGVuZGluZyBleGVjdXRpb25zXG5cdFx0XHRsb2NrOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0bG9ja2VkID0gcXVldWUgPSBbXTtcblx0XHRcdFx0aWYgKCAhbWVtb3J5ICYmICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IG1lbW9yeSA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0bG9ja2VkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICEhbG9ja2VkO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQ2FsbCBhbGwgY2FsbGJhY2tzIHdpdGggdGhlIGdpdmVuIGNvbnRleHQgYW5kIGFyZ3VtZW50c1xuXHRcdFx0ZmlyZVdpdGg6IGZ1bmN0aW9uKCBjb250ZXh0LCBhcmdzICkge1xuXHRcdFx0XHRpZiAoICFsb2NrZWQgKSB7XG5cdFx0XHRcdFx0YXJncyA9IGFyZ3MgfHwgW107XG5cdFx0XHRcdFx0YXJncyA9IFsgY29udGV4dCwgYXJncy5zbGljZSA/IGFyZ3Muc2xpY2UoKSA6IGFyZ3MgXTtcblx0XHRcdFx0XHRxdWV1ZS5wdXNoKCBhcmdzICk7XG5cdFx0XHRcdFx0aWYgKCAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIENhbGwgYWxsIHRoZSBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gYXJndW1lbnRzXG5cdFx0XHRmaXJlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0c2VsZi5maXJlV2l0aCggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gVG8ga25vdyBpZiB0aGUgY2FsbGJhY2tzIGhhdmUgYWxyZWFkeSBiZWVuIGNhbGxlZCBhdCBsZWFzdCBvbmNlXG5cdFx0XHRmaXJlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhIWZpcmVkO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0cmV0dXJuIHNlbGY7XG59O1xuXG5cbmZ1bmN0aW9uIElkZW50aXR5KCB2ICkge1xuXHRyZXR1cm4gdjtcbn1cbmZ1bmN0aW9uIFRocm93ZXIoIGV4ICkge1xuXHR0aHJvdyBleDtcbn1cblxuZnVuY3Rpb24gYWRvcHRWYWx1ZSggdmFsdWUsIHJlc29sdmUsIHJlamVjdCwgbm9WYWx1ZSApIHtcblx0dmFyIG1ldGhvZDtcblxuXHR0cnkge1xuXG5cdFx0Ly8gQ2hlY2sgZm9yIHByb21pc2UgYXNwZWN0IGZpcnN0IHRvIHByaXZpbGVnZSBzeW5jaHJvbm91cyBiZWhhdmlvclxuXHRcdGlmICggdmFsdWUgJiYgaXNGdW5jdGlvbiggKCBtZXRob2QgPSB2YWx1ZS5wcm9taXNlICkgKSApIHtcblx0XHRcdG1ldGhvZC5jYWxsKCB2YWx1ZSApLmRvbmUoIHJlc29sdmUgKS5mYWlsKCByZWplY3QgKTtcblxuXHRcdC8vIE90aGVyIHRoZW5hYmxlc1xuXHRcdH0gZWxzZSBpZiAoIHZhbHVlICYmIGlzRnVuY3Rpb24oICggbWV0aG9kID0gdmFsdWUudGhlbiApICkgKSB7XG5cdFx0XHRtZXRob2QuY2FsbCggdmFsdWUsIHJlc29sdmUsIHJlamVjdCApO1xuXG5cdFx0Ly8gT3RoZXIgbm9uLXRoZW5hYmxlc1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIENvbnRyb2wgYHJlc29sdmVgIGFyZ3VtZW50cyBieSBsZXR0aW5nIEFycmF5I3NsaWNlIGNhc3QgYm9vbGVhbiBgbm9WYWx1ZWAgdG8gaW50ZWdlcjpcblx0XHRcdC8vICogZmFsc2U6IFsgdmFsdWUgXS5zbGljZSggMCApID0+IHJlc29sdmUoIHZhbHVlIClcblx0XHRcdC8vICogdHJ1ZTogWyB2YWx1ZSBdLnNsaWNlKCAxICkgPT4gcmVzb2x2ZSgpXG5cdFx0XHRyZXNvbHZlLmFwcGx5KCB1bmRlZmluZWQsIFsgdmFsdWUgXS5zbGljZSggbm9WYWx1ZSApICk7XG5cdFx0fVxuXG5cdC8vIEZvciBQcm9taXNlcy9BKywgY29udmVydCBleGNlcHRpb25zIGludG8gcmVqZWN0aW9uc1xuXHQvLyBTaW5jZSBqUXVlcnkud2hlbiBkb2Vzbid0IHVud3JhcCB0aGVuYWJsZXMsIHdlIGNhbiBza2lwIHRoZSBleHRyYSBjaGVja3MgYXBwZWFyaW5nIGluXG5cdC8vIERlZmVycmVkI3RoZW4gdG8gY29uZGl0aW9uYWxseSBzdXBwcmVzcyByZWplY3Rpb24uXG5cdH0gY2F0Y2ggKCB2YWx1ZSApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIG9ubHlcblx0XHQvLyBTdHJpY3QgbW9kZSBmdW5jdGlvbnMgaW52b2tlZCB3aXRob3V0IC5jYWxsLy5hcHBseSBnZXQgZ2xvYmFsLW9iamVjdCBjb250ZXh0XG5cdFx0cmVqZWN0LmFwcGx5KCB1bmRlZmluZWQsIFsgdmFsdWUgXSApO1xuXHR9XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHREZWZlcnJlZDogZnVuY3Rpb24oIGZ1bmMgKSB7XG5cdFx0dmFyIHR1cGxlcyA9IFtcblxuXHRcdFx0XHQvLyBhY3Rpb24sIGFkZCBsaXN0ZW5lciwgY2FsbGJhY2tzLFxuXHRcdFx0XHQvLyAuLi4gLnRoZW4gaGFuZGxlcnMsIGFyZ3VtZW50IGluZGV4LCBbZmluYWwgc3RhdGVdXG5cdFx0XHRcdFsgXCJub3RpZnlcIiwgXCJwcm9ncmVzc1wiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm1lbW9yeVwiICksXG5cdFx0XHRcdFx0alF1ZXJ5LkNhbGxiYWNrcyggXCJtZW1vcnlcIiApLCAyIF0sXG5cdFx0XHRcdFsgXCJyZXNvbHZlXCIsIFwiZG9uZVwiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblx0XHRcdFx0XHRqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSwgMCwgXCJyZXNvbHZlZFwiIF0sXG5cdFx0XHRcdFsgXCJyZWplY3RcIiwgXCJmYWlsXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLFxuXHRcdFx0XHRcdGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLCAxLCBcInJlamVjdGVkXCIgXVxuXHRcdFx0XSxcblx0XHRcdHN0YXRlID0gXCJwZW5kaW5nXCIsXG5cdFx0XHRwcm9taXNlID0ge1xuXHRcdFx0XHRzdGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHN0YXRlO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRhbHdheXM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGRlZmVycmVkLmRvbmUoIGFyZ3VtZW50cyApLmZhaWwoIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRcImNhdGNoXCI6IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRcdFx0XHRyZXR1cm4gcHJvbWlzZS50aGVuKCBudWxsLCBmbiApO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIEtlZXAgcGlwZSBmb3IgYmFjay1jb21wYXRcblx0XHRcdFx0cGlwZTogZnVuY3Rpb24oIC8qIGZuRG9uZSwgZm5GYWlsLCBmblByb2dyZXNzICovICkge1xuXHRcdFx0XHRcdHZhciBmbnMgPSBhcmd1bWVudHM7XG5cblx0XHRcdFx0XHRyZXR1cm4galF1ZXJ5LkRlZmVycmVkKCBmdW5jdGlvbiggbmV3RGVmZXIgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZWFjaCggdHVwbGVzLCBmdW5jdGlvbiggX2ksIHR1cGxlICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIE1hcCB0dXBsZXMgKHByb2dyZXNzLCBkb25lLCBmYWlsKSB0byBhcmd1bWVudHMgKGRvbmUsIGZhaWwsIHByb2dyZXNzKVxuXHRcdFx0XHRcdFx0XHR2YXIgZm4gPSBpc0Z1bmN0aW9uKCBmbnNbIHR1cGxlWyA0IF0gXSApICYmIGZuc1sgdHVwbGVbIDQgXSBdO1xuXG5cdFx0XHRcdFx0XHRcdC8vIGRlZmVycmVkLnByb2dyZXNzKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLm5vdGlmeSB9KVxuXHRcdFx0XHRcdFx0XHQvLyBkZWZlcnJlZC5kb25lKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLnJlc29sdmUgfSlcblx0XHRcdFx0XHRcdFx0Ly8gZGVmZXJyZWQuZmFpbChmdW5jdGlvbigpIHsgYmluZCB0byBuZXdEZWZlciBvciBuZXdEZWZlci5yZWplY3QgfSlcblx0XHRcdFx0XHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAxIF0gXSggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIHJldHVybmVkID0gZm4gJiYgZm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdFx0XHRcdGlmICggcmV0dXJuZWQgJiYgaXNGdW5jdGlvbiggcmV0dXJuZWQucHJvbWlzZSApICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQucHJvbWlzZSgpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5wcm9ncmVzcyggbmV3RGVmZXIubm90aWZ5IClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LmRvbmUoIG5ld0RlZmVyLnJlc29sdmUgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuZmFpbCggbmV3RGVmZXIucmVqZWN0ICk7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXShcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGhpcyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0Zm4gPyBbIHJldHVybmVkIF0gOiBhcmd1bWVudHNcblx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHRmbnMgPSBudWxsO1xuXHRcdFx0XHRcdH0gKS5wcm9taXNlKCk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHRoZW46IGZ1bmN0aW9uKCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgb25Qcm9ncmVzcyApIHtcblx0XHRcdFx0XHR2YXIgbWF4RGVwdGggPSAwO1xuXHRcdFx0XHRcdGZ1bmN0aW9uIHJlc29sdmUoIGRlcHRoLCBkZWZlcnJlZCwgaGFuZGxlciwgc3BlY2lhbCApIHtcblx0XHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0dmFyIHRoYXQgPSB0aGlzLFxuXHRcdFx0XHRcdFx0XHRcdGFyZ3MgPSBhcmd1bWVudHMsXG5cdFx0XHRcdFx0XHRcdFx0bWlnaHRUaHJvdyA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIHJldHVybmVkLCB0aGVuO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuM1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNTlcblx0XHRcdFx0XHRcdFx0XHRcdC8vIElnbm9yZSBkb3VibGUtcmVzb2x1dGlvbiBhdHRlbXB0c1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBkZXB0aCA8IG1heERlcHRoICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkID0gaGFuZGxlci5hcHBseSggdGhhdCwgYXJncyApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4xXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC00OFxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCByZXR1cm5lZCA9PT0gZGVmZXJyZWQucHJvbWlzZSgpICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCBcIlRoZW5hYmxlIHNlbGYtcmVzb2x1dGlvblwiICk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb25zIDIuMy4zLjEsIDMuNVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNTRcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTc1XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBSZXRyaWV2ZSBgdGhlbmAgb25seSBvbmNlXG5cdFx0XHRcdFx0XHRcdFx0XHR0aGVuID0gcmV0dXJuZWQgJiZcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy40XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTY0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgY2hlY2sgb2JqZWN0cyBhbmQgZnVuY3Rpb25zIGZvciB0aGVuYWJpbGl0eVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQoIHR5cGVvZiByZXR1cm5lZCA9PT0gXCJvYmplY3RcIiB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGVvZiByZXR1cm5lZCA9PT0gXCJmdW5jdGlvblwiICkgJiZcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQudGhlbjtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSGFuZGxlIGEgcmV0dXJuZWQgdGhlbmFibGVcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggaXNGdW5jdGlvbiggdGhlbiApICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFNwZWNpYWwgcHJvY2Vzc29ycyAobm90aWZ5KSBqdXN0IHdhaXQgZm9yIHJlc29sdXRpb25cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBzcGVjaWFsICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoZW4uY2FsbChcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBJZGVudGl0eSwgc3BlY2lhbCApLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBUaHJvd2VyLCBzcGVjaWFsIClcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE5vcm1hbCBwcm9jZXNzb3JzIChyZXNvbHZlKSBhbHNvIGhvb2sgaW50byBwcm9ncmVzc1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gLi4uYW5kIGRpc3JlZ2FyZCBvbGRlciByZXNvbHV0aW9uIHZhbHVlc1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG1heERlcHRoKys7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGVuLmNhbGwoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgSWRlbnRpdHksIHNwZWNpYWwgKSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgVGhyb3dlciwgc3BlY2lhbCApLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBJZGVudGl0eSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBIYW5kbGUgYWxsIG90aGVyIHJldHVybmVkIHZhbHVlc1xuXHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IHN1YnN0aXR1dGUgaGFuZGxlcnMgcGFzcyBvbiBjb250ZXh0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGFuZCBtdWx0aXBsZSB2YWx1ZXMgKG5vbi1zcGVjIGJlaGF2aW9yKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGhhbmRsZXIgIT09IElkZW50aXR5ICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoYXQgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YXJncyA9IFsgcmV0dXJuZWQgXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFByb2Nlc3MgdGhlIHZhbHVlKHMpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIERlZmF1bHQgcHJvY2VzcyBpcyByZXNvbHZlXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCggc3BlY2lhbCB8fCBkZWZlcnJlZC5yZXNvbHZlV2l0aCApKCB0aGF0LCBhcmdzICk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSxcblxuXHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgbm9ybWFsIHByb2Nlc3NvcnMgKHJlc29sdmUpIGNhdGNoIGFuZCByZWplY3QgZXhjZXB0aW9uc1xuXHRcdFx0XHRcdFx0XHRcdHByb2Nlc3MgPSBzcGVjaWFsID9cblx0XHRcdFx0XHRcdFx0XHRcdG1pZ2h0VGhyb3cgOlxuXHRcdFx0XHRcdFx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bWlnaHRUaHJvdygpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5LkRlZmVycmVkLmV4Y2VwdGlvbkhvb2sgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayggZSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cHJvY2Vzcy5lcnJvciApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjMuMy40LjFcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC02MVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIElnbm9yZSBwb3N0LXJlc29sdXRpb24gZXhjZXB0aW9uc1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggZGVwdGggKyAxID49IG1heERlcHRoICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IHN1YnN0aXR1dGUgaGFuZGxlcnMgcGFzcyBvbiBjb250ZXh0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBhbmQgbXVsdGlwbGUgdmFsdWVzIChub24tc3BlYyBiZWhhdmlvcilcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggaGFuZGxlciAhPT0gVGhyb3dlciApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhhdCA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0YXJncyA9IFsgZSBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkZWZlcnJlZC5yZWplY3RXaXRoKCB0aGF0LCBhcmdzICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjMuMy4xXG5cdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTU3XG5cdFx0XHRcdFx0XHRcdC8vIFJlLXJlc29sdmUgcHJvbWlzZXMgaW1tZWRpYXRlbHkgdG8gZG9kZ2UgZmFsc2UgcmVqZWN0aW9uIGZyb21cblx0XHRcdFx0XHRcdFx0Ly8gc3Vic2VxdWVudCBlcnJvcnNcblx0XHRcdFx0XHRcdFx0aWYgKCBkZXB0aCApIHtcblx0XHRcdFx0XHRcdFx0XHRwcm9jZXNzKCk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBDYWxsIGFuIG9wdGlvbmFsIGhvb2sgdG8gcmVjb3JkIHRoZSBlcnJvciwgaW4gY2FzZSBvZiBleGNlcHRpb25cblx0XHRcdFx0XHRcdFx0XHQvLyBzaW5jZSBpdCdzIG90aGVyd2lzZSBsb3N0IHdoZW4gZXhlY3V0aW9uIGdvZXMgYXN5bmNcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5EZWZlcnJlZC5nZXRFcnJvckhvb2sgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRwcm9jZXNzLmVycm9yID0galF1ZXJ5LkRlZmVycmVkLmdldEVycm9ySG9vaygpO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gVGhlIGRlcHJlY2F0ZWQgYWxpYXMgb2YgdGhlIGFib3ZlLiBXaGlsZSB0aGUgbmFtZSBzdWdnZXN0c1xuXHRcdFx0XHRcdFx0XHRcdC8vIHJldHVybmluZyB0aGUgc3RhY2ssIG5vdCBhbiBlcnJvciBpbnN0YW5jZSwgalF1ZXJ5IGp1c3QgcGFzc2VzXG5cdFx0XHRcdFx0XHRcdFx0Ly8gaXQgZGlyZWN0bHkgdG8gYGNvbnNvbGUud2FybmAgc28gYm90aCB3aWxsIHdvcms7IGFuIGluc3RhbmNlXG5cdFx0XHRcdFx0XHRcdFx0Ly8ganVzdCBiZXR0ZXIgY29vcGVyYXRlcyB3aXRoIHNvdXJjZSBtYXBzLlxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGpRdWVyeS5EZWZlcnJlZC5nZXRTdGFja0hvb2sgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRwcm9jZXNzLmVycm9yID0galF1ZXJ5LkRlZmVycmVkLmdldFN0YWNrSG9vaygpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR3aW5kb3cuc2V0VGltZW91dCggcHJvY2VzcyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiBqUXVlcnkuRGVmZXJyZWQoIGZ1bmN0aW9uKCBuZXdEZWZlciApIHtcblxuXHRcdFx0XHRcdFx0Ly8gcHJvZ3Jlc3NfaGFuZGxlcnMuYWRkKCAuLi4gKVxuXHRcdFx0XHRcdFx0dHVwbGVzWyAwIF1bIDMgXS5hZGQoXG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoXG5cdFx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlcixcblx0XHRcdFx0XHRcdFx0XHRpc0Z1bmN0aW9uKCBvblByb2dyZXNzICkgP1xuXHRcdFx0XHRcdFx0XHRcdFx0b25Qcm9ncmVzcyA6XG5cdFx0XHRcdFx0XHRcdFx0XHRJZGVudGl0eSxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlci5ub3RpZnlXaXRoXG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdC8vIGZ1bGZpbGxlZF9oYW5kbGVycy5hZGQoIC4uLiApXG5cdFx0XHRcdFx0XHR0dXBsZXNbIDEgXVsgMyBdLmFkZChcblx0XHRcdFx0XHRcdFx0cmVzb2x2ZShcblx0XHRcdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyLFxuXHRcdFx0XHRcdFx0XHRcdGlzRnVuY3Rpb24oIG9uRnVsZmlsbGVkICkgP1xuXHRcdFx0XHRcdFx0XHRcdFx0b25GdWxmaWxsZWQgOlxuXHRcdFx0XHRcdFx0XHRcdFx0SWRlbnRpdHlcblx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0Ly8gcmVqZWN0ZWRfaGFuZGxlcnMuYWRkKCAuLi4gKVxuXHRcdFx0XHRcdFx0dHVwbGVzWyAyIF1bIDMgXS5hZGQoXG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoXG5cdFx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlcixcblx0XHRcdFx0XHRcdFx0XHRpc0Z1bmN0aW9uKCBvblJlamVjdGVkICkgP1xuXHRcdFx0XHRcdFx0XHRcdFx0b25SZWplY3RlZCA6XG5cdFx0XHRcdFx0XHRcdFx0XHRUaHJvd2VyXG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fSApLnByb21pc2UoKTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBHZXQgYSBwcm9taXNlIGZvciB0aGlzIGRlZmVycmVkXG5cdFx0XHRcdC8vIElmIG9iaiBpcyBwcm92aWRlZCwgdGhlIHByb21pc2UgYXNwZWN0IGlzIGFkZGVkIHRvIHRoZSBvYmplY3Rcblx0XHRcdFx0cHJvbWlzZTogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRcdFx0XHRyZXR1cm4gb2JqICE9IG51bGwgPyBqUXVlcnkuZXh0ZW5kKCBvYmosIHByb21pc2UgKSA6IHByb21pc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRkZWZlcnJlZCA9IHt9O1xuXG5cdFx0Ly8gQWRkIGxpc3Qtc3BlY2lmaWMgbWV0aG9kc1xuXHRcdGpRdWVyeS5lYWNoKCB0dXBsZXMsIGZ1bmN0aW9uKCBpLCB0dXBsZSApIHtcblx0XHRcdHZhciBsaXN0ID0gdHVwbGVbIDIgXSxcblx0XHRcdFx0c3RhdGVTdHJpbmcgPSB0dXBsZVsgNSBdO1xuXG5cdFx0XHQvLyBwcm9taXNlLnByb2dyZXNzID0gbGlzdC5hZGRcblx0XHRcdC8vIHByb21pc2UuZG9uZSA9IGxpc3QuYWRkXG5cdFx0XHQvLyBwcm9taXNlLmZhaWwgPSBsaXN0LmFkZFxuXHRcdFx0cHJvbWlzZVsgdHVwbGVbIDEgXSBdID0gbGlzdC5hZGQ7XG5cblx0XHRcdC8vIEhhbmRsZSBzdGF0ZVxuXHRcdFx0aWYgKCBzdGF0ZVN0cmluZyApIHtcblx0XHRcdFx0bGlzdC5hZGQoXG5cdFx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0XHRcdC8vIHN0YXRlID0gXCJyZXNvbHZlZFwiIChpLmUuLCBmdWxmaWxsZWQpXG5cdFx0XHRcdFx0XHQvLyBzdGF0ZSA9IFwicmVqZWN0ZWRcIlxuXHRcdFx0XHRcdFx0c3RhdGUgPSBzdGF0ZVN0cmluZztcblx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdFx0Ly8gcmVqZWN0ZWRfY2FsbGJhY2tzLmRpc2FibGVcblx0XHRcdFx0XHQvLyBmdWxmaWxsZWRfY2FsbGJhY2tzLmRpc2FibGVcblx0XHRcdFx0XHR0dXBsZXNbIDMgLSBpIF1bIDIgXS5kaXNhYmxlLFxuXG5cdFx0XHRcdFx0Ly8gcmVqZWN0ZWRfaGFuZGxlcnMuZGlzYWJsZVxuXHRcdFx0XHRcdC8vIGZ1bGZpbGxlZF9oYW5kbGVycy5kaXNhYmxlXG5cdFx0XHRcdFx0dHVwbGVzWyAzIC0gaSBdWyAzIF0uZGlzYWJsZSxcblxuXHRcdFx0XHRcdC8vIHByb2dyZXNzX2NhbGxiYWNrcy5sb2NrXG5cdFx0XHRcdFx0dHVwbGVzWyAwIF1bIDIgXS5sb2NrLFxuXG5cdFx0XHRcdFx0Ly8gcHJvZ3Jlc3NfaGFuZGxlcnMubG9ja1xuXHRcdFx0XHRcdHR1cGxlc1sgMCBdWyAzIF0ubG9ja1xuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBwcm9ncmVzc19oYW5kbGVycy5maXJlXG5cdFx0XHQvLyBmdWxmaWxsZWRfaGFuZGxlcnMuZmlyZVxuXHRcdFx0Ly8gcmVqZWN0ZWRfaGFuZGxlcnMuZmlyZVxuXHRcdFx0bGlzdC5hZGQoIHR1cGxlWyAzIF0uZmlyZSApO1xuXG5cdFx0XHQvLyBkZWZlcnJlZC5ub3RpZnkgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQubm90aWZ5V2l0aCguLi4pIH1cblx0XHRcdC8vIGRlZmVycmVkLnJlc29sdmUgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQucmVzb2x2ZVdpdGgoLi4uKSB9XG5cdFx0XHQvLyBkZWZlcnJlZC5yZWplY3QgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQucmVqZWN0V2l0aCguLi4pIH1cblx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMCBdIF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdKCB0aGlzID09PSBkZWZlcnJlZCA/IHVuZGVmaW5lZCA6IHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH07XG5cblx0XHRcdC8vIGRlZmVycmVkLm5vdGlmeVdpdGggPSBsaXN0LmZpcmVXaXRoXG5cdFx0XHQvLyBkZWZlcnJlZC5yZXNvbHZlV2l0aCA9IGxpc3QuZmlyZVdpdGhcblx0XHRcdC8vIGRlZmVycmVkLnJlamVjdFdpdGggPSBsaXN0LmZpcmVXaXRoXG5cdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDAgXSArIFwiV2l0aFwiIF0gPSBsaXN0LmZpcmVXaXRoO1xuXHRcdH0gKTtcblxuXHRcdC8vIE1ha2UgdGhlIGRlZmVycmVkIGEgcHJvbWlzZVxuXHRcdHByb21pc2UucHJvbWlzZSggZGVmZXJyZWQgKTtcblxuXHRcdC8vIENhbGwgZ2l2ZW4gZnVuYyBpZiBhbnlcblx0XHRpZiAoIGZ1bmMgKSB7XG5cdFx0XHRmdW5jLmNhbGwoIGRlZmVycmVkLCBkZWZlcnJlZCApO1xuXHRcdH1cblxuXHRcdC8vIEFsbCBkb25lIVxuXHRcdHJldHVybiBkZWZlcnJlZDtcblx0fSxcblxuXHQvLyBEZWZlcnJlZCBoZWxwZXJcblx0d2hlbjogZnVuY3Rpb24oIHNpbmdsZVZhbHVlICkge1xuXHRcdHZhclxuXG5cdFx0XHQvLyBjb3VudCBvZiB1bmNvbXBsZXRlZCBzdWJvcmRpbmF0ZXNcblx0XHRcdHJlbWFpbmluZyA9IGFyZ3VtZW50cy5sZW5ndGgsXG5cblx0XHRcdC8vIGNvdW50IG9mIHVucHJvY2Vzc2VkIGFyZ3VtZW50c1xuXHRcdFx0aSA9IHJlbWFpbmluZyxcblxuXHRcdFx0Ly8gc3Vib3JkaW5hdGUgZnVsZmlsbG1lbnQgZGF0YVxuXHRcdFx0cmVzb2x2ZUNvbnRleHRzID0gQXJyYXkoIGkgKSxcblx0XHRcdHJlc29sdmVWYWx1ZXMgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSxcblxuXHRcdFx0Ly8gdGhlIHByaW1hcnkgRGVmZXJyZWRcblx0XHRcdHByaW1hcnkgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblxuXHRcdFx0Ly8gc3Vib3JkaW5hdGUgY2FsbGJhY2sgZmFjdG9yeVxuXHRcdFx0dXBkYXRlRnVuYyA9IGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRcdHJlc29sdmVDb250ZXh0c1sgaSBdID0gdGhpcztcblx0XHRcdFx0XHRyZXNvbHZlVmFsdWVzWyBpIF0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApIDogdmFsdWU7XG5cdFx0XHRcdFx0aWYgKCAhKCAtLXJlbWFpbmluZyApICkge1xuXHRcdFx0XHRcdFx0cHJpbWFyeS5yZXNvbHZlV2l0aCggcmVzb2x2ZUNvbnRleHRzLCByZXNvbHZlVmFsdWVzICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblxuXHRcdC8vIFNpbmdsZS0gYW5kIGVtcHR5IGFyZ3VtZW50cyBhcmUgYWRvcHRlZCBsaWtlIFByb21pc2UucmVzb2x2ZVxuXHRcdGlmICggcmVtYWluaW5nIDw9IDEgKSB7XG5cdFx0XHRhZG9wdFZhbHVlKCBzaW5nbGVWYWx1ZSwgcHJpbWFyeS5kb25lKCB1cGRhdGVGdW5jKCBpICkgKS5yZXNvbHZlLCBwcmltYXJ5LnJlamVjdCxcblx0XHRcdFx0IXJlbWFpbmluZyApO1xuXG5cdFx0XHQvLyBVc2UgLnRoZW4oKSB0byB1bndyYXAgc2Vjb25kYXJ5IHRoZW5hYmxlcyAoY2YuIGdoLTMwMDApXG5cdFx0XHRpZiAoIHByaW1hcnkuc3RhdGUoKSA9PT0gXCJwZW5kaW5nXCIgfHxcblx0XHRcdFx0aXNGdW5jdGlvbiggcmVzb2x2ZVZhbHVlc1sgaSBdICYmIHJlc29sdmVWYWx1ZXNbIGkgXS50aGVuICkgKSB7XG5cblx0XHRcdFx0cmV0dXJuIHByaW1hcnkudGhlbigpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIE11bHRpcGxlIGFyZ3VtZW50cyBhcmUgYWdncmVnYXRlZCBsaWtlIFByb21pc2UuYWxsIGFycmF5IGVsZW1lbnRzXG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRhZG9wdFZhbHVlKCByZXNvbHZlVmFsdWVzWyBpIF0sIHVwZGF0ZUZ1bmMoIGkgKSwgcHJpbWFyeS5yZWplY3QgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcHJpbWFyeS5wcm9taXNlKCk7XG5cdH1cbn0gKTtcblxuXG4vLyBUaGVzZSB1c3VhbGx5IGluZGljYXRlIGEgcHJvZ3JhbW1lciBtaXN0YWtlIGR1cmluZyBkZXZlbG9wbWVudCxcbi8vIHdhcm4gYWJvdXQgdGhlbSBBU0FQIHJhdGhlciB0aGFuIHN3YWxsb3dpbmcgdGhlbSBieSBkZWZhdWx0LlxudmFyIHJlcnJvck5hbWVzID0gL14oRXZhbHxJbnRlcm5hbHxSYW5nZXxSZWZlcmVuY2V8U3ludGF4fFR5cGV8VVJJKUVycm9yJC87XG5cbi8vIElmIGBqUXVlcnkuRGVmZXJyZWQuZ2V0RXJyb3JIb29rYCBpcyBkZWZpbmVkLCBgYXN5bmNFcnJvcmAgaXMgYW4gZXJyb3Jcbi8vIGNhcHR1cmVkIGJlZm9yZSB0aGUgYXN5bmMgYmFycmllciB0byBnZXQgdGhlIG9yaWdpbmFsIGVycm9yIGNhdXNlXG4vLyB3aGljaCBtYXkgb3RoZXJ3aXNlIGJlIGhpZGRlbi5cbmpRdWVyeS5EZWZlcnJlZC5leGNlcHRpb25Ib29rID0gZnVuY3Rpb24oIGVycm9yLCBhc3luY0Vycm9yICkge1xuXG5cdC8vIFN1cHBvcnQ6IElFIDggLSA5IG9ubHlcblx0Ly8gQ29uc29sZSBleGlzdHMgd2hlbiBkZXYgdG9vbHMgYXJlIG9wZW4sIHdoaWNoIGNhbiBoYXBwZW4gYXQgYW55IHRpbWVcblx0aWYgKCB3aW5kb3cuY29uc29sZSAmJiB3aW5kb3cuY29uc29sZS53YXJuICYmIGVycm9yICYmIHJlcnJvck5hbWVzLnRlc3QoIGVycm9yLm5hbWUgKSApIHtcblx0XHR3aW5kb3cuY29uc29sZS53YXJuKCBcImpRdWVyeS5EZWZlcnJlZCBleGNlcHRpb246IFwiICsgZXJyb3IubWVzc2FnZSxcblx0XHRcdGVycm9yLnN0YWNrLCBhc3luY0Vycm9yICk7XG5cdH1cbn07XG5cblxuXG5cbmpRdWVyeS5yZWFkeUV4Y2VwdGlvbiA9IGZ1bmN0aW9uKCBlcnJvciApIHtcblx0d2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdHRocm93IGVycm9yO1xuXHR9ICk7XG59O1xuXG5cblxuXG4vLyBUaGUgZGVmZXJyZWQgdXNlZCBvbiBET00gcmVhZHlcbnZhciByZWFkeUxpc3QgPSBqUXVlcnkuRGVmZXJyZWQoKTtcblxualF1ZXJ5LmZuLnJlYWR5ID0gZnVuY3Rpb24oIGZuICkge1xuXG5cdHJlYWR5TGlzdFxuXHRcdC50aGVuKCBmbiApXG5cblx0XHQvLyBXcmFwIGpRdWVyeS5yZWFkeUV4Y2VwdGlvbiBpbiBhIGZ1bmN0aW9uIHNvIHRoYXQgdGhlIGxvb2t1cFxuXHRcdC8vIGhhcHBlbnMgYXQgdGhlIHRpbWUgb2YgZXJyb3IgaGFuZGxpbmcgaW5zdGVhZCBvZiBjYWxsYmFja1xuXHRcdC8vIHJlZ2lzdHJhdGlvbi5cblx0XHQuY2F0Y2goIGZ1bmN0aW9uKCBlcnJvciApIHtcblx0XHRcdGpRdWVyeS5yZWFkeUV4Y2VwdGlvbiggZXJyb3IgKTtcblx0XHR9ICk7XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gSXMgdGhlIERPTSByZWFkeSB0byBiZSB1c2VkPyBTZXQgdG8gdHJ1ZSBvbmNlIGl0IG9jY3Vycy5cblx0aXNSZWFkeTogZmFsc2UsXG5cblx0Ly8gQSBjb3VudGVyIHRvIHRyYWNrIGhvdyBtYW55IGl0ZW1zIHRvIHdhaXQgZm9yIGJlZm9yZVxuXHQvLyB0aGUgcmVhZHkgZXZlbnQgZmlyZXMuIFNlZSB0cmFjLTY3ODFcblx0cmVhZHlXYWl0OiAxLFxuXG5cdC8vIEhhbmRsZSB3aGVuIHRoZSBET00gaXMgcmVhZHlcblx0cmVhZHk6IGZ1bmN0aW9uKCB3YWl0ICkge1xuXG5cdFx0Ly8gQWJvcnQgaWYgdGhlcmUgYXJlIHBlbmRpbmcgaG9sZHMgb3Igd2UncmUgYWxyZWFkeSByZWFkeVxuXHRcdGlmICggd2FpdCA9PT0gdHJ1ZSA/IC0talF1ZXJ5LnJlYWR5V2FpdCA6IGpRdWVyeS5pc1JlYWR5ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFJlbWVtYmVyIHRoYXQgdGhlIERPTSBpcyByZWFkeVxuXHRcdGpRdWVyeS5pc1JlYWR5ID0gdHJ1ZTtcblxuXHRcdC8vIElmIGEgbm9ybWFsIERPTSBSZWFkeSBldmVudCBmaXJlZCwgZGVjcmVtZW50LCBhbmQgd2FpdCBpZiBuZWVkIGJlXG5cdFx0aWYgKCB3YWl0ICE9PSB0cnVlICYmIC0talF1ZXJ5LnJlYWR5V2FpdCA+IDAgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gSWYgdGhlcmUgYXJlIGZ1bmN0aW9ucyBib3VuZCwgdG8gZXhlY3V0ZVxuXHRcdHJlYWR5TGlzdC5yZXNvbHZlV2l0aCggZG9jdW1lbnQsIFsgalF1ZXJ5IF0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkucmVhZHkudGhlbiA9IHJlYWR5TGlzdC50aGVuO1xuXG4vLyBUaGUgcmVhZHkgZXZlbnQgaGFuZGxlciBhbmQgc2VsZiBjbGVhbnVwIG1ldGhvZFxuZnVuY3Rpb24gY29tcGxldGVkKCkge1xuXHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY29tcGxldGVkICk7XG5cdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCBcImxvYWRcIiwgY29tcGxldGVkICk7XG5cdGpRdWVyeS5yZWFkeSgpO1xufVxuXG4vLyBDYXRjaCBjYXNlcyB3aGVyZSAkKGRvY3VtZW50KS5yZWFkeSgpIGlzIGNhbGxlZFxuLy8gYWZ0ZXIgdGhlIGJyb3dzZXIgZXZlbnQgaGFzIGFscmVhZHkgb2NjdXJyZWQuXG4vLyBTdXBwb3J0OiBJRSA8PTkgLSAxMCBvbmx5XG4vLyBPbGRlciBJRSBzb21ldGltZXMgc2lnbmFscyBcImludGVyYWN0aXZlXCIgdG9vIHNvb25cbmlmICggZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXCJjb21wbGV0ZVwiIHx8XG5cdCggZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gXCJsb2FkaW5nXCIgJiYgIWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5kb1Njcm9sbCApICkge1xuXG5cdC8vIEhhbmRsZSBpdCBhc3luY2hyb25vdXNseSB0byBhbGxvdyBzY3JpcHRzIHRoZSBvcHBvcnR1bml0eSB0byBkZWxheSByZWFkeVxuXHR3aW5kb3cuc2V0VGltZW91dCggalF1ZXJ5LnJlYWR5ICk7XG5cbn0gZWxzZSB7XG5cblx0Ly8gVXNlIHRoZSBoYW5keSBldmVudCBjYWxsYmFja1xuXHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY29tcGxldGVkICk7XG5cblx0Ly8gQSBmYWxsYmFjayB0byB3aW5kb3cub25sb2FkLCB0aGF0IHdpbGwgYWx3YXlzIHdvcmtcblx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoIFwibG9hZFwiLCBjb21wbGV0ZWQgKTtcbn1cblxuXG5cblxuLy8gTXVsdGlmdW5jdGlvbmFsIG1ldGhvZCB0byBnZXQgYW5kIHNldCB2YWx1ZXMgb2YgYSBjb2xsZWN0aW9uXG4vLyBUaGUgdmFsdWUvcyBjYW4gb3B0aW9uYWxseSBiZSBleGVjdXRlZCBpZiBpdCdzIGEgZnVuY3Rpb25cbnZhciBhY2Nlc3MgPSBmdW5jdGlvbiggZWxlbXMsIGZuLCBrZXksIHZhbHVlLCBjaGFpbmFibGUsIGVtcHR5R2V0LCByYXcgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSBlbGVtcy5sZW5ndGgsXG5cdFx0YnVsayA9IGtleSA9PSBudWxsO1xuXG5cdC8vIFNldHMgbWFueSB2YWx1ZXNcblx0aWYgKCB0b1R5cGUoIGtleSApID09PSBcIm9iamVjdFwiICkge1xuXHRcdGNoYWluYWJsZSA9IHRydWU7XG5cdFx0Zm9yICggaSBpbiBrZXkgKSB7XG5cdFx0XHRhY2Nlc3MoIGVsZW1zLCBmbiwgaSwga2V5WyBpIF0sIHRydWUsIGVtcHR5R2V0LCByYXcgKTtcblx0XHR9XG5cblx0Ly8gU2V0cyBvbmUgdmFsdWVcblx0fSBlbHNlIGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRjaGFpbmFibGUgPSB0cnVlO1xuXG5cdFx0aWYgKCAhaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJhdyA9IHRydWU7XG5cdFx0fVxuXG5cdFx0aWYgKCBidWxrICkge1xuXG5cdFx0XHQvLyBCdWxrIG9wZXJhdGlvbnMgcnVuIGFnYWluc3QgdGhlIGVudGlyZSBzZXRcblx0XHRcdGlmICggcmF3ICkge1xuXHRcdFx0XHRmbi5jYWxsKCBlbGVtcywgdmFsdWUgKTtcblx0XHRcdFx0Zm4gPSBudWxsO1xuXG5cdFx0XHQvLyAuLi5leGNlcHQgd2hlbiBleGVjdXRpbmcgZnVuY3Rpb24gdmFsdWVzXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRidWxrID0gZm47XG5cdFx0XHRcdGZuID0gZnVuY3Rpb24oIGVsZW0sIF9rZXksIHZhbHVlICkge1xuXHRcdFx0XHRcdHJldHVybiBidWxrLmNhbGwoIGpRdWVyeSggZWxlbSApLCB2YWx1ZSApO1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggZm4gKSB7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0Zm4oXG5cdFx0XHRcdFx0ZWxlbXNbIGkgXSwga2V5LCByYXcgP1xuXHRcdFx0XHRcdFx0dmFsdWUgOlxuXHRcdFx0XHRcdFx0dmFsdWUuY2FsbCggZWxlbXNbIGkgXSwgaSwgZm4oIGVsZW1zWyBpIF0sIGtleSApIClcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRpZiAoIGNoYWluYWJsZSApIHtcblx0XHRyZXR1cm4gZWxlbXM7XG5cdH1cblxuXHQvLyBHZXRzXG5cdGlmICggYnVsayApIHtcblx0XHRyZXR1cm4gZm4uY2FsbCggZWxlbXMgKTtcblx0fVxuXG5cdHJldHVybiBsZW4gPyBmbiggZWxlbXNbIDAgXSwga2V5ICkgOiBlbXB0eUdldDtcbn07XG5cblxuLy8gTWF0Y2hlcyBkYXNoZWQgc3RyaW5nIGZvciBjYW1lbGl6aW5nXG52YXIgcm1zUHJlZml4ID0gL14tbXMtLyxcblx0cmRhc2hBbHBoYSA9IC8tKFthLXpdKS9nO1xuXG4vLyBVc2VkIGJ5IGNhbWVsQ2FzZSBhcyBjYWxsYmFjayB0byByZXBsYWNlKClcbmZ1bmN0aW9uIGZjYW1lbENhc2UoIF9hbGwsIGxldHRlciApIHtcblx0cmV0dXJuIGxldHRlci50b1VwcGVyQ2FzZSgpO1xufVxuXG4vLyBDb252ZXJ0IGRhc2hlZCB0byBjYW1lbENhc2U7IHVzZWQgYnkgdGhlIGNzcyBhbmQgZGF0YSBtb2R1bGVzXG4vLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSwgRWRnZSAxMiAtIDE1XG4vLyBNaWNyb3NvZnQgZm9yZ290IHRvIGh1bXAgdGhlaXIgdmVuZG9yIHByZWZpeCAodHJhYy05NTcyKVxuZnVuY3Rpb24gY2FtZWxDYXNlKCBzdHJpbmcgKSB7XG5cdHJldHVybiBzdHJpbmcucmVwbGFjZSggcm1zUHJlZml4LCBcIm1zLVwiICkucmVwbGFjZSggcmRhc2hBbHBoYSwgZmNhbWVsQ2FzZSApO1xufVxudmFyIGFjY2VwdERhdGEgPSBmdW5jdGlvbiggb3duZXIgKSB7XG5cblx0Ly8gQWNjZXB0cyBvbmx5OlxuXHQvLyAgLSBOb2RlXG5cdC8vICAgIC0gTm9kZS5FTEVNRU5UX05PREVcblx0Ly8gICAgLSBOb2RlLkRPQ1VNRU5UX05PREVcblx0Ly8gIC0gT2JqZWN0XG5cdC8vICAgIC0gQW55XG5cdHJldHVybiBvd25lci5ub2RlVHlwZSA9PT0gMSB8fCBvd25lci5ub2RlVHlwZSA9PT0gOSB8fCAhKCArb3duZXIubm9kZVR5cGUgKTtcbn07XG5cblxuXG5cbmZ1bmN0aW9uIERhdGEoKSB7XG5cdHRoaXMuZXhwYW5kbyA9IGpRdWVyeS5leHBhbmRvICsgRGF0YS51aWQrKztcbn1cblxuRGF0YS51aWQgPSAxO1xuXG5EYXRhLnByb3RvdHlwZSA9IHtcblxuXHRjYWNoZTogZnVuY3Rpb24oIG93bmVyICkge1xuXG5cdFx0Ly8gQ2hlY2sgaWYgdGhlIG93bmVyIG9iamVjdCBhbHJlYWR5IGhhcyBhIGNhY2hlXG5cdFx0dmFyIHZhbHVlID0gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXG5cdFx0Ly8gSWYgbm90LCBjcmVhdGUgb25lXG5cdFx0aWYgKCAhdmFsdWUgKSB7XG5cdFx0XHR2YWx1ZSA9IHt9O1xuXG5cdFx0XHQvLyBXZSBjYW4gYWNjZXB0IGRhdGEgZm9yIG5vbi1lbGVtZW50IG5vZGVzIGluIG1vZGVybiBicm93c2Vycyxcblx0XHRcdC8vIGJ1dCB3ZSBzaG91bGQgbm90LCBzZWUgdHJhYy04MzM1LlxuXHRcdFx0Ly8gQWx3YXlzIHJldHVybiBhbiBlbXB0eSBvYmplY3QuXG5cdFx0XHRpZiAoIGFjY2VwdERhdGEoIG93bmVyICkgKSB7XG5cblx0XHRcdFx0Ly8gSWYgaXQgaXMgYSBub2RlIHVubGlrZWx5IHRvIGJlIHN0cmluZ2lmeS1lZCBvciBsb29wZWQgb3ZlclxuXHRcdFx0XHQvLyB1c2UgcGxhaW4gYXNzaWdubWVudFxuXHRcdFx0XHRpZiAoIG93bmVyLm5vZGVUeXBlICkge1xuXHRcdFx0XHRcdG93bmVyWyB0aGlzLmV4cGFuZG8gXSA9IHZhbHVlO1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBzZWN1cmUgaXQgaW4gYSBub24tZW51bWVyYWJsZSBwcm9wZXJ0eVxuXHRcdFx0XHQvLyBjb25maWd1cmFibGUgbXVzdCBiZSB0cnVlIHRvIGFsbG93IHRoZSBwcm9wZXJ0eSB0byBiZVxuXHRcdFx0XHQvLyBkZWxldGVkIHdoZW4gZGF0YSBpcyByZW1vdmVkXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCBvd25lciwgdGhpcy5leHBhbmRvLCB7XG5cdFx0XHRcdFx0XHR2YWx1ZTogdmFsdWUsXG5cdFx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWVcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdmFsdWU7XG5cdH0sXG5cdHNldDogZnVuY3Rpb24oIG93bmVyLCBkYXRhLCB2YWx1ZSApIHtcblx0XHR2YXIgcHJvcCxcblx0XHRcdGNhY2hlID0gdGhpcy5jYWNoZSggb3duZXIgKTtcblxuXHRcdC8vIEhhbmRsZTogWyBvd25lciwga2V5LCB2YWx1ZSBdIGFyZ3Ncblx0XHQvLyBBbHdheXMgdXNlIGNhbWVsQ2FzZSBrZXkgKGdoLTIyNTcpXG5cdFx0aWYgKCB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGNhY2hlWyBjYW1lbENhc2UoIGRhdGEgKSBdID0gdmFsdWU7XG5cblx0XHQvLyBIYW5kbGU6IFsgb3duZXIsIHsgcHJvcGVydGllcyB9IF0gYXJnc1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIENvcHkgdGhlIHByb3BlcnRpZXMgb25lLWJ5LW9uZSB0byB0aGUgY2FjaGUgb2JqZWN0XG5cdFx0XHRmb3IgKCBwcm9wIGluIGRhdGEgKSB7XG5cdFx0XHRcdGNhY2hlWyBjYW1lbENhc2UoIHByb3AgKSBdID0gZGF0YVsgcHJvcCBdO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gY2FjaGU7XG5cdH0sXG5cdGdldDogZnVuY3Rpb24oIG93bmVyLCBrZXkgKSB7XG5cdFx0cmV0dXJuIGtleSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdHRoaXMuY2FjaGUoIG93bmVyICkgOlxuXG5cdFx0XHQvLyBBbHdheXMgdXNlIGNhbWVsQ2FzZSBrZXkgKGdoLTIyNTcpXG5cdFx0XHRvd25lclsgdGhpcy5leHBhbmRvIF0gJiYgb3duZXJbIHRoaXMuZXhwYW5kbyBdWyBjYW1lbENhc2UoIGtleSApIF07XG5cdH0sXG5cdGFjY2VzczogZnVuY3Rpb24oIG93bmVyLCBrZXksIHZhbHVlICkge1xuXG5cdFx0Ly8gSW4gY2FzZXMgd2hlcmUgZWl0aGVyOlxuXHRcdC8vXG5cdFx0Ly8gICAxLiBObyBrZXkgd2FzIHNwZWNpZmllZFxuXHRcdC8vICAgMi4gQSBzdHJpbmcga2V5IHdhcyBzcGVjaWZpZWQsIGJ1dCBubyB2YWx1ZSBwcm92aWRlZFxuXHRcdC8vXG5cdFx0Ly8gVGFrZSB0aGUgXCJyZWFkXCIgcGF0aCBhbmQgYWxsb3cgdGhlIGdldCBtZXRob2QgdG8gZGV0ZXJtaW5lXG5cdFx0Ly8gd2hpY2ggdmFsdWUgdG8gcmV0dXJuLCByZXNwZWN0aXZlbHkgZWl0aGVyOlxuXHRcdC8vXG5cdFx0Ly8gICAxLiBUaGUgZW50aXJlIGNhY2hlIG9iamVjdFxuXHRcdC8vICAgMi4gVGhlIGRhdGEgc3RvcmVkIGF0IHRoZSBrZXlcblx0XHQvL1xuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgfHxcblx0XHRcdFx0KCAoIGtleSAmJiB0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiICkgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCApICkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5nZXQoIG93bmVyLCBrZXkgKTtcblx0XHR9XG5cblx0XHQvLyBXaGVuIHRoZSBrZXkgaXMgbm90IGEgc3RyaW5nLCBvciBib3RoIGEga2V5IGFuZCB2YWx1ZVxuXHRcdC8vIGFyZSBzcGVjaWZpZWQsIHNldCBvciBleHRlbmQgKGV4aXN0aW5nIG9iamVjdHMpIHdpdGggZWl0aGVyOlxuXHRcdC8vXG5cdFx0Ly8gICAxLiBBbiBvYmplY3Qgb2YgcHJvcGVydGllc1xuXHRcdC8vICAgMi4gQSBrZXkgYW5kIHZhbHVlXG5cdFx0Ly9cblx0XHR0aGlzLnNldCggb3duZXIsIGtleSwgdmFsdWUgKTtcblxuXHRcdC8vIFNpbmNlIHRoZSBcInNldFwiIHBhdGggY2FuIGhhdmUgdHdvIHBvc3NpYmxlIGVudHJ5IHBvaW50c1xuXHRcdC8vIHJldHVybiB0aGUgZXhwZWN0ZWQgZGF0YSBiYXNlZCBvbiB3aGljaCBwYXRoIHdhcyB0YWtlblsqXVxuXHRcdHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiBrZXk7XG5cdH0sXG5cdHJlbW92ZTogZnVuY3Rpb24oIG93bmVyLCBrZXkgKSB7XG5cdFx0dmFyIGksXG5cdFx0XHRjYWNoZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblxuXHRcdGlmICggY2FjaGUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIGtleSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHQvLyBTdXBwb3J0IGFycmF5IG9yIHNwYWNlIHNlcGFyYXRlZCBzdHJpbmcgb2Yga2V5c1xuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCBrZXkgKSApIHtcblxuXHRcdFx0XHQvLyBJZiBrZXkgaXMgYW4gYXJyYXkgb2Yga2V5cy4uLlxuXHRcdFx0XHQvLyBXZSBhbHdheXMgc2V0IGNhbWVsQ2FzZSBrZXlzLCBzbyByZW1vdmUgdGhhdC5cblx0XHRcdFx0a2V5ID0ga2V5Lm1hcCggY2FtZWxDYXNlICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRrZXkgPSBjYW1lbENhc2UoIGtleSApO1xuXG5cdFx0XHRcdC8vIElmIGEga2V5IHdpdGggdGhlIHNwYWNlcyBleGlzdHMsIHVzZSBpdC5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCBjcmVhdGUgYW4gYXJyYXkgYnkgbWF0Y2hpbmcgbm9uLXdoaXRlc3BhY2Vcblx0XHRcdFx0a2V5ID0ga2V5IGluIGNhY2hlID9cblx0XHRcdFx0XHRbIGtleSBdIDpcblx0XHRcdFx0XHQoIGtleS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdICk7XG5cdFx0XHR9XG5cblx0XHRcdGkgPSBrZXkubGVuZ3RoO1xuXG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0ZGVsZXRlIGNhY2hlWyBrZXlbIGkgXSBdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFJlbW92ZSB0aGUgZXhwYW5kbyBpZiB0aGVyZSdzIG5vIG1vcmUgZGF0YVxuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgfHwgalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGNhY2hlICkgKSB7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTM1IC0gNDVcblx0XHRcdC8vIFdlYmtpdCAmIEJsaW5rIHBlcmZvcm1hbmNlIHN1ZmZlcnMgd2hlbiBkZWxldGluZyBwcm9wZXJ0aWVzXG5cdFx0XHQvLyBmcm9tIERPTSBub2Rlcywgc28gc2V0IHRvIHVuZGVmaW5lZCBpbnN0ZWFkXG5cdFx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0zNzg2MDcgKGJ1ZyByZXN0cmljdGVkKVxuXHRcdFx0aWYgKCBvd25lci5ub2RlVHlwZSApIHtcblx0XHRcdFx0b3duZXJbIHRoaXMuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVsZXRlIG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cdGhhc0RhdGE6IGZ1bmN0aW9uKCBvd25lciApIHtcblx0XHR2YXIgY2FjaGUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cdFx0cmV0dXJuIGNhY2hlICE9PSB1bmRlZmluZWQgJiYgIWpRdWVyeS5pc0VtcHR5T2JqZWN0KCBjYWNoZSApO1xuXHR9XG59O1xudmFyIGRhdGFQcml2ID0gbmV3IERhdGEoKTtcblxudmFyIGRhdGFVc2VyID0gbmV3IERhdGEoKTtcblxuXG5cbi8vXHRJbXBsZW1lbnRhdGlvbiBTdW1tYXJ5XG4vL1xuLy9cdDEuIEVuZm9yY2UgQVBJIHN1cmZhY2UgYW5kIHNlbWFudGljIGNvbXBhdGliaWxpdHkgd2l0aCAxLjkueCBicmFuY2hcbi8vXHQyLiBJbXByb3ZlIHRoZSBtb2R1bGUncyBtYWludGFpbmFiaWxpdHkgYnkgcmVkdWNpbmcgdGhlIHN0b3JhZ2Vcbi8vXHRcdHBhdGhzIHRvIGEgc2luZ2xlIG1lY2hhbmlzbS5cbi8vXHQzLiBVc2UgdGhlIHNhbWUgc2luZ2xlIG1lY2hhbmlzbSB0byBzdXBwb3J0IFwicHJpdmF0ZVwiIGFuZCBcInVzZXJcIiBkYXRhLlxuLy9cdDQuIF9OZXZlcl8gZXhwb3NlIFwicHJpdmF0ZVwiIGRhdGEgdG8gdXNlciBjb2RlIChUT0RPOiBEcm9wIF9kYXRhLCBfcmVtb3ZlRGF0YSlcbi8vXHQ1LiBBdm9pZCBleHBvc2luZyBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzIG9uIHVzZXIgb2JqZWN0cyAoZWcuIGV4cGFuZG8gcHJvcGVydGllcylcbi8vXHQ2LiBQcm92aWRlIGEgY2xlYXIgcGF0aCBmb3IgaW1wbGVtZW50YXRpb24gdXBncmFkZSB0byBXZWFrTWFwIGluIDIwMTRcblxudmFyIHJicmFjZSA9IC9eKD86XFx7W1xcd1xcV10qXFx9fFxcW1tcXHdcXFddKlxcXSkkLyxcblx0cm11bHRpRGFzaCA9IC9bQS1aXS9nO1xuXG5mdW5jdGlvbiBnZXREYXRhKCBkYXRhICkge1xuXHRpZiAoIGRhdGEgPT09IFwidHJ1ZVwiICkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0aWYgKCBkYXRhID09PSBcImZhbHNlXCIgKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0aWYgKCBkYXRhID09PSBcIm51bGxcIiApIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdC8vIE9ubHkgY29udmVydCB0byBhIG51bWJlciBpZiBpdCBkb2Vzbid0IGNoYW5nZSB0aGUgc3RyaW5nXG5cdGlmICggZGF0YSA9PT0gK2RhdGEgKyBcIlwiICkge1xuXHRcdHJldHVybiArZGF0YTtcblx0fVxuXG5cdGlmICggcmJyYWNlLnRlc3QoIGRhdGEgKSApIHtcblx0XHRyZXR1cm4gSlNPTi5wYXJzZSggZGF0YSApO1xuXHR9XG5cblx0cmV0dXJuIGRhdGE7XG59XG5cbmZ1bmN0aW9uIGRhdGFBdHRyKCBlbGVtLCBrZXksIGRhdGEgKSB7XG5cdHZhciBuYW1lO1xuXG5cdC8vIElmIG5vdGhpbmcgd2FzIGZvdW5kIGludGVybmFsbHksIHRyeSB0byBmZXRjaCBhbnlcblx0Ly8gZGF0YSBmcm9tIHRoZSBIVE1MNSBkYXRhLSogYXR0cmlidXRlXG5cdGlmICggZGF0YSA9PT0gdW5kZWZpbmVkICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0bmFtZSA9IFwiZGF0YS1cIiArIGtleS5yZXBsYWNlKCBybXVsdGlEYXNoLCBcIi0kJlwiICkudG9Mb3dlckNhc2UoKTtcblx0XHRkYXRhID0gZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUgKTtcblxuXHRcdGlmICggdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRkYXRhID0gZ2V0RGF0YSggZGF0YSApO1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7fVxuXG5cdFx0XHQvLyBNYWtlIHN1cmUgd2Ugc2V0IHRoZSBkYXRhIHNvIGl0IGlzbid0IGNoYW5nZWQgbGF0ZXJcblx0XHRcdGRhdGFVc2VyLnNldCggZWxlbSwga2V5LCBkYXRhICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBkYXRhO1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdGhhc0RhdGE6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkYXRhVXNlci5oYXNEYXRhKCBlbGVtICkgfHwgZGF0YVByaXYuaGFzRGF0YSggZWxlbSApO1xuXHR9LFxuXG5cdGRhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBkYXRhICkge1xuXHRcdHJldHVybiBkYXRhVXNlci5hY2Nlc3MoIGVsZW0sIG5hbWUsIGRhdGEgKTtcblx0fSxcblxuXHRyZW1vdmVEYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHRkYXRhVXNlci5yZW1vdmUoIGVsZW0sIG5hbWUgKTtcblx0fSxcblxuXHQvLyBUT0RPOiBOb3cgdGhhdCBhbGwgY2FsbHMgdG8gX2RhdGEgYW5kIF9yZW1vdmVEYXRhIGhhdmUgYmVlbiByZXBsYWNlZFxuXHQvLyB3aXRoIGRpcmVjdCBjYWxscyB0byBkYXRhUHJpdiBtZXRob2RzLCB0aGVzZSBjYW4gYmUgZGVwcmVjYXRlZC5cblx0X2RhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBkYXRhICkge1xuXHRcdHJldHVybiBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIG5hbWUsIGRhdGEgKTtcblx0fSxcblxuXHRfcmVtb3ZlRGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBuYW1lICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRkYXRhOiBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblx0XHR2YXIgaSwgbmFtZSwgZGF0YSxcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF0sXG5cdFx0XHRhdHRycyA9IGVsZW0gJiYgZWxlbS5hdHRyaWJ1dGVzO1xuXG5cdFx0Ly8gR2V0cyBhbGwgdmFsdWVzXG5cdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggdGhpcy5sZW5ndGggKSB7XG5cdFx0XHRcdGRhdGEgPSBkYXRhVXNlci5nZXQoIGVsZW0gKTtcblxuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgIWRhdGFQcml2LmdldCggZWxlbSwgXCJoYXNEYXRhQXR0cnNcIiApICkge1xuXHRcdFx0XHRcdGkgPSBhdHRycy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDExIG9ubHlcblx0XHRcdFx0XHRcdC8vIFRoZSBhdHRycyBlbGVtZW50cyBjYW4gYmUgbnVsbCAodHJhYy0xNDg5NClcblx0XHRcdFx0XHRcdGlmICggYXR0cnNbIGkgXSApIHtcblx0XHRcdFx0XHRcdFx0bmFtZSA9IGF0dHJzWyBpIF0ubmFtZTtcblx0XHRcdFx0XHRcdFx0aWYgKCBuYW1lLmluZGV4T2YoIFwiZGF0YS1cIiApID09PSAwICkge1xuXHRcdFx0XHRcdFx0XHRcdG5hbWUgPSBjYW1lbENhc2UoIG5hbWUuc2xpY2UoIDUgKSApO1xuXHRcdFx0XHRcdFx0XHRcdGRhdGFBdHRyKCBlbGVtLCBuYW1lLCBkYXRhWyBuYW1lIF0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIGVsZW0sIFwiaGFzRGF0YUF0dHJzXCIsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblx0XHR9XG5cblx0XHQvLyBTZXRzIG11bHRpcGxlIHZhbHVlc1xuXHRcdGlmICggdHlwZW9mIGtleSA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkYXRhVXNlci5zZXQoIHRoaXMsIGtleSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBkYXRhO1xuXG5cdFx0XHQvLyBUaGUgY2FsbGluZyBqUXVlcnkgb2JqZWN0IChlbGVtZW50IG1hdGNoZXMpIGlzIG5vdCBlbXB0eVxuXHRcdFx0Ly8gKGFuZCB0aGVyZWZvcmUgaGFzIGFuIGVsZW1lbnQgYXBwZWFycyBhdCB0aGlzWyAwIF0pIGFuZCB0aGVcblx0XHRcdC8vIGB2YWx1ZWAgcGFyYW1ldGVyIHdhcyBub3QgdW5kZWZpbmVkLiBBbiBlbXB0eSBqUXVlcnkgb2JqZWN0XG5cdFx0XHQvLyB3aWxsIHJlc3VsdCBpbiBgdW5kZWZpbmVkYCBmb3IgZWxlbSA9IHRoaXNbIDAgXSB3aGljaCB3aWxsXG5cdFx0XHQvLyB0aHJvdyBhbiBleGNlcHRpb24gaWYgYW4gYXR0ZW1wdCB0byByZWFkIGEgZGF0YSBjYWNoZSBpcyBtYWRlLlxuXHRcdFx0aWYgKCBlbGVtICYmIHZhbHVlID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Ly8gQXR0ZW1wdCB0byBnZXQgZGF0YSBmcm9tIHRoZSBjYWNoZVxuXHRcdFx0XHQvLyBUaGUga2V5IHdpbGwgYWx3YXlzIGJlIGNhbWVsQ2FzZWQgaW4gRGF0YVxuXHRcdFx0XHRkYXRhID0gZGF0YVVzZXIuZ2V0KCBlbGVtLCBrZXkgKTtcblx0XHRcdFx0aWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBdHRlbXB0IHRvIFwiZGlzY292ZXJcIiB0aGUgZGF0YSBpblxuXHRcdFx0XHQvLyBIVE1MNSBjdXN0b20gZGF0YS0qIGF0dHJzXG5cdFx0XHRcdGRhdGEgPSBkYXRhQXR0ciggZWxlbSwga2V5ICk7XG5cdFx0XHRcdGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gV2UgdHJpZWQgcmVhbGx5IGhhcmQsIGJ1dCB0aGUgZGF0YSBkb2Vzbid0IGV4aXN0LlxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNldCB0aGUgZGF0YS4uLlxuXHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvLyBXZSBhbHdheXMgc3RvcmUgdGhlIGNhbWVsQ2FzZWQga2V5XG5cdFx0XHRcdGRhdGFVc2VyLnNldCggdGhpcywga2V5LCB2YWx1ZSApO1xuXHRcdFx0fSApO1xuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSwgbnVsbCwgdHJ1ZSApO1xuXHR9LFxuXG5cdHJlbW92ZURhdGE6IGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRkYXRhVXNlci5yZW1vdmUoIHRoaXMsIGtleSApO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5cbmpRdWVyeS5leHRlbmQoIHtcblx0cXVldWU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBxdWV1ZTtcblxuXHRcdGlmICggZWxlbSApIHtcblx0XHRcdHR5cGUgPSAoIHR5cGUgfHwgXCJmeFwiICkgKyBcInF1ZXVlXCI7XG5cdFx0XHRxdWV1ZSA9IGRhdGFQcml2LmdldCggZWxlbSwgdHlwZSApO1xuXG5cdFx0XHQvLyBTcGVlZCB1cCBkZXF1ZXVlIGJ5IGdldHRpbmcgb3V0IHF1aWNrbHkgaWYgdGhpcyBpcyBqdXN0IGEgbG9va3VwXG5cdFx0XHRpZiAoIGRhdGEgKSB7XG5cdFx0XHRcdGlmICggIXF1ZXVlIHx8IEFycmF5LmlzQXJyYXkoIGRhdGEgKSApIHtcblx0XHRcdFx0XHRxdWV1ZSA9IGRhdGFQcml2LmFjY2VzcyggZWxlbSwgdHlwZSwgalF1ZXJ5Lm1ha2VBcnJheSggZGF0YSApICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cXVldWUucHVzaCggZGF0YSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcXVldWUgfHwgW107XG5cdFx0fVxuXHR9LFxuXG5cdGRlcXVldWU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlICkge1xuXHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRcdHZhciBxdWV1ZSA9IGpRdWVyeS5xdWV1ZSggZWxlbSwgdHlwZSApLFxuXHRcdFx0c3RhcnRMZW5ndGggPSBxdWV1ZS5sZW5ndGgsXG5cdFx0XHRmbiA9IHF1ZXVlLnNoaWZ0KCksXG5cdFx0XHRob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyggZWxlbSwgdHlwZSApLFxuXHRcdFx0bmV4dCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggZWxlbSwgdHlwZSApO1xuXHRcdFx0fTtcblxuXHRcdC8vIElmIHRoZSBmeCBxdWV1ZSBpcyBkZXF1ZXVlZCwgYWx3YXlzIHJlbW92ZSB0aGUgcHJvZ3Jlc3Mgc2VudGluZWxcblx0XHRpZiAoIGZuID09PSBcImlucHJvZ3Jlc3NcIiApIHtcblx0XHRcdGZuID0gcXVldWUuc2hpZnQoKTtcblx0XHRcdHN0YXJ0TGVuZ3RoLS07XG5cdFx0fVxuXG5cdFx0aWYgKCBmbiApIHtcblxuXHRcdFx0Ly8gQWRkIGEgcHJvZ3Jlc3Mgc2VudGluZWwgdG8gcHJldmVudCB0aGUgZnggcXVldWUgZnJvbSBiZWluZ1xuXHRcdFx0Ly8gYXV0b21hdGljYWxseSBkZXF1ZXVlZFxuXHRcdFx0aWYgKCB0eXBlID09PSBcImZ4XCIgKSB7XG5cdFx0XHRcdHF1ZXVlLnVuc2hpZnQoIFwiaW5wcm9ncmVzc1wiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENsZWFyIHVwIHRoZSBsYXN0IHF1ZXVlIHN0b3AgZnVuY3Rpb25cblx0XHRcdGRlbGV0ZSBob29rcy5zdG9wO1xuXHRcdFx0Zm4uY2FsbCggZWxlbSwgbmV4dCwgaG9va3MgKTtcblx0XHR9XG5cblx0XHRpZiAoICFzdGFydExlbmd0aCAmJiBob29rcyApIHtcblx0XHRcdGhvb2tzLmVtcHR5LmZpcmUoKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gTm90IHB1YmxpYyAtIGdlbmVyYXRlIGEgcXVldWVIb29rcyBvYmplY3QsIG9yIHJldHVybiB0aGUgY3VycmVudCBvbmVcblx0X3F1ZXVlSG9va3M6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlICkge1xuXHRcdHZhciBrZXkgPSB0eXBlICsgXCJxdWV1ZUhvb2tzXCI7XG5cdFx0cmV0dXJuIGRhdGFQcml2LmdldCggZWxlbSwga2V5ICkgfHwgZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBrZXksIHtcblx0XHRcdGVtcHR5OiBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKS5hZGQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFsgdHlwZSArIFwicXVldWVcIiwga2V5IF0gKTtcblx0XHRcdH0gKVxuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHF1ZXVlOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgc2V0dGVyID0gMjtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRkYXRhID0gdHlwZTtcblx0XHRcdHR5cGUgPSBcImZ4XCI7XG5cdFx0XHRzZXR0ZXItLTtcblx0XHR9XG5cblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPCBzZXR0ZXIgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LnF1ZXVlKCB0aGlzWyAwIF0sIHR5cGUgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZGF0YSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdHRoaXMgOlxuXHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHF1ZXVlID0galF1ZXJ5LnF1ZXVlKCB0aGlzLCB0eXBlLCBkYXRhICk7XG5cblx0XHRcdFx0Ly8gRW5zdXJlIGEgaG9va3MgZm9yIHRoaXMgcXVldWVcblx0XHRcdFx0alF1ZXJ5Ll9xdWV1ZUhvb2tzKCB0aGlzLCB0eXBlICk7XG5cblx0XHRcdFx0aWYgKCB0eXBlID09PSBcImZ4XCIgJiYgcXVldWVbIDAgXSAhPT0gXCJpbnByb2dyZXNzXCIgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHR9LFxuXHRkZXF1ZXVlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0fSApO1xuXHR9LFxuXHRjbGVhclF1ZXVlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRyZXR1cm4gdGhpcy5xdWV1ZSggdHlwZSB8fCBcImZ4XCIsIFtdICk7XG5cdH0sXG5cblx0Ly8gR2V0IGEgcHJvbWlzZSByZXNvbHZlZCB3aGVuIHF1ZXVlcyBvZiBhIGNlcnRhaW4gdHlwZVxuXHQvLyBhcmUgZW1wdGllZCAoZnggaXMgdGhlIHR5cGUgYnkgZGVmYXVsdClcblx0cHJvbWlzZTogZnVuY3Rpb24oIHR5cGUsIG9iaiApIHtcblx0XHR2YXIgdG1wLFxuXHRcdFx0Y291bnQgPSAxLFxuXHRcdFx0ZGVmZXIgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblx0XHRcdGVsZW1lbnRzID0gdGhpcyxcblx0XHRcdGkgPSB0aGlzLmxlbmd0aCxcblx0XHRcdHJlc29sdmUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAhKCAtLWNvdW50ICkgKSB7XG5cdFx0XHRcdFx0ZGVmZXIucmVzb2x2ZVdpdGgoIGVsZW1lbnRzLCBbIGVsZW1lbnRzIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRvYmogPSB0eXBlO1xuXHRcdFx0dHlwZSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHR0bXAgPSBkYXRhUHJpdi5nZXQoIGVsZW1lbnRzWyBpIF0sIHR5cGUgKyBcInF1ZXVlSG9va3NcIiApO1xuXHRcdFx0aWYgKCB0bXAgJiYgdG1wLmVtcHR5ICkge1xuXHRcdFx0XHRjb3VudCsrO1xuXHRcdFx0XHR0bXAuZW1wdHkuYWRkKCByZXNvbHZlICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJlc29sdmUoKTtcblx0XHRyZXR1cm4gZGVmZXIucHJvbWlzZSggb2JqICk7XG5cdH1cbn0gKTtcbnZhciBwbnVtID0gKCAvWystXT8oPzpcXGQqXFwufClcXGQrKD86W2VFXVsrLV0/XFxkK3wpLyApLnNvdXJjZTtcblxudmFyIHJjc3NOdW0gPSBuZXcgUmVnRXhwKCBcIl4oPzooWystXSk9fCkoXCIgKyBwbnVtICsgXCIpKFthLXolXSopJFwiLCBcImlcIiApO1xuXG5cbnZhciBjc3NFeHBhbmQgPSBbIFwiVG9wXCIsIFwiUmlnaHRcIiwgXCJCb3R0b21cIiwgXCJMZWZ0XCIgXTtcblxudmFyIGRvY3VtZW50RWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuXG5cblx0dmFyIGlzQXR0YWNoZWQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApO1xuXHRcdH0sXG5cdFx0Y29tcG9zZWQgPSB7IGNvbXBvc2VkOiB0cnVlIH07XG5cblx0Ly8gU3VwcG9ydDogSUUgOSAtIDExKywgRWRnZSAxMiAtIDE4KywgaU9TIDEwLjAgLSAxMC4yIG9ubHlcblx0Ly8gQ2hlY2sgYXR0YWNobWVudCBhY3Jvc3Mgc2hhZG93IERPTSBib3VuZGFyaWVzIHdoZW4gcG9zc2libGUgKGdoLTM1MDQpXG5cdC8vIFN1cHBvcnQ6IGlPUyAxMC4wLTEwLjIgb25seVxuXHQvLyBFYXJseSBpT1MgMTAgdmVyc2lvbnMgc3VwcG9ydCBgYXR0YWNoU2hhZG93YCBidXQgbm90IGBnZXRSb290Tm9kZWAsXG5cdC8vIGxlYWRpbmcgdG8gZXJyb3JzLiBXZSBuZWVkIHRvIGNoZWNrIGZvciBgZ2V0Um9vdE5vZGVgLlxuXHRpZiAoIGRvY3VtZW50RWxlbWVudC5nZXRSb290Tm9kZSApIHtcblx0XHRpc0F0dGFjaGVkID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKSB8fFxuXHRcdFx0XHRlbGVtLmdldFJvb3ROb2RlKCBjb21wb3NlZCApID09PSBlbGVtLm93bmVyRG9jdW1lbnQ7XG5cdFx0fTtcblx0fVxudmFyIGlzSGlkZGVuV2l0aGluVHJlZSA9IGZ1bmN0aW9uKCBlbGVtLCBlbCApIHtcblxuXHRcdC8vIGlzSGlkZGVuV2l0aGluVHJlZSBtaWdodCBiZSBjYWxsZWQgZnJvbSBqUXVlcnkjZmlsdGVyIGZ1bmN0aW9uO1xuXHRcdC8vIGluIHRoYXQgY2FzZSwgZWxlbWVudCB3aWxsIGJlIHNlY29uZCBhcmd1bWVudFxuXHRcdGVsZW0gPSBlbCB8fCBlbGVtO1xuXG5cdFx0Ly8gSW5saW5lIHN0eWxlIHRydW1wcyBhbGxcblx0XHRyZXR1cm4gZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIm5vbmVcIiB8fFxuXHRcdFx0ZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIlwiICYmXG5cblx0XHRcdC8vIE90aGVyd2lzZSwgY2hlY2sgY29tcHV0ZWQgc3R5bGVcblx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00MyAtIDQ1XG5cdFx0XHQvLyBEaXNjb25uZWN0ZWQgZWxlbWVudHMgY2FuIGhhdmUgY29tcHV0ZWQgZGlzcGxheTogbm9uZSwgc28gZmlyc3QgY29uZmlybSB0aGF0IGVsZW0gaXNcblx0XHRcdC8vIGluIHRoZSBkb2N1bWVudC5cblx0XHRcdGlzQXR0YWNoZWQoIGVsZW0gKSAmJlxuXG5cdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApID09PSBcIm5vbmVcIjtcblx0fTtcblxuXG5cbmZ1bmN0aW9uIGFkanVzdENTUyggZWxlbSwgcHJvcCwgdmFsdWVQYXJ0cywgdHdlZW4gKSB7XG5cdHZhciBhZGp1c3RlZCwgc2NhbGUsXG5cdFx0bWF4SXRlcmF0aW9ucyA9IDIwLFxuXHRcdGN1cnJlbnRWYWx1ZSA9IHR3ZWVuID9cblx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdHdlZW4uY3VyKCk7XG5cdFx0XHR9IDpcblx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4galF1ZXJ5LmNzcyggZWxlbSwgcHJvcCwgXCJcIiApO1xuXHRcdFx0fSxcblx0XHRpbml0aWFsID0gY3VycmVudFZhbHVlKCksXG5cdFx0dW5pdCA9IHZhbHVlUGFydHMgJiYgdmFsdWVQYXJ0c1sgMyBdIHx8ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdID8gXCJcIiA6IFwicHhcIiApLFxuXG5cdFx0Ly8gU3RhcnRpbmcgdmFsdWUgY29tcHV0YXRpb24gaXMgcmVxdWlyZWQgZm9yIHBvdGVudGlhbCB1bml0IG1pc21hdGNoZXNcblx0XHRpbml0aWFsSW5Vbml0ID0gZWxlbS5ub2RlVHlwZSAmJlxuXHRcdFx0KCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gfHwgdW5pdCAhPT0gXCJweFwiICYmICtpbml0aWFsICkgJiZcblx0XHRcdHJjc3NOdW0uZXhlYyggalF1ZXJ5LmNzcyggZWxlbSwgcHJvcCApICk7XG5cblx0aWYgKCBpbml0aWFsSW5Vbml0ICYmIGluaXRpYWxJblVuaXRbIDMgXSAhPT0gdW5pdCApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD01NFxuXHRcdC8vIEhhbHZlIHRoZSBpdGVyYXRpb24gdGFyZ2V0IHZhbHVlIHRvIHByZXZlbnQgaW50ZXJmZXJlbmNlIGZyb20gQ1NTIHVwcGVyIGJvdW5kcyAoZ2gtMjE0NClcblx0XHRpbml0aWFsID0gaW5pdGlhbCAvIDI7XG5cblx0XHQvLyBUcnVzdCB1bml0cyByZXBvcnRlZCBieSBqUXVlcnkuY3NzXG5cdFx0dW5pdCA9IHVuaXQgfHwgaW5pdGlhbEluVW5pdFsgMyBdO1xuXG5cdFx0Ly8gSXRlcmF0aXZlbHkgYXBwcm94aW1hdGUgZnJvbSBhIG5vbnplcm8gc3RhcnRpbmcgcG9pbnRcblx0XHRpbml0aWFsSW5Vbml0ID0gK2luaXRpYWwgfHwgMTtcblxuXHRcdHdoaWxlICggbWF4SXRlcmF0aW9ucy0tICkge1xuXG5cdFx0XHQvLyBFdmFsdWF0ZSBhbmQgdXBkYXRlIG91ciBiZXN0IGd1ZXNzIChkb3VibGluZyBndWVzc2VzIHRoYXQgemVybyBvdXQpLlxuXHRcdFx0Ly8gRmluaXNoIGlmIHRoZSBzY2FsZSBlcXVhbHMgb3IgY3Jvc3NlcyAxIChtYWtpbmcgdGhlIG9sZCpuZXcgcHJvZHVjdCBub24tcG9zaXRpdmUpLlxuXHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wLCBpbml0aWFsSW5Vbml0ICsgdW5pdCApO1xuXHRcdFx0aWYgKCAoIDEgLSBzY2FsZSApICogKCAxIC0gKCBzY2FsZSA9IGN1cnJlbnRWYWx1ZSgpIC8gaW5pdGlhbCB8fCAwLjUgKSApIDw9IDAgKSB7XG5cdFx0XHRcdG1heEl0ZXJhdGlvbnMgPSAwO1xuXHRcdFx0fVxuXHRcdFx0aW5pdGlhbEluVW5pdCA9IGluaXRpYWxJblVuaXQgLyBzY2FsZTtcblxuXHRcdH1cblxuXHRcdGluaXRpYWxJblVuaXQgPSBpbml0aWFsSW5Vbml0ICogMjtcblx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIGluaXRpYWxJblVuaXQgKyB1bml0ICk7XG5cblx0XHQvLyBNYWtlIHN1cmUgd2UgdXBkYXRlIHRoZSB0d2VlbiBwcm9wZXJ0aWVzIGxhdGVyIG9uXG5cdFx0dmFsdWVQYXJ0cyA9IHZhbHVlUGFydHMgfHwgW107XG5cdH1cblxuXHRpZiAoIHZhbHVlUGFydHMgKSB7XG5cdFx0aW5pdGlhbEluVW5pdCA9ICtpbml0aWFsSW5Vbml0IHx8ICtpbml0aWFsIHx8IDA7XG5cblx0XHQvLyBBcHBseSByZWxhdGl2ZSBvZmZzZXQgKCs9Ly09KSBpZiBzcGVjaWZpZWRcblx0XHRhZGp1c3RlZCA9IHZhbHVlUGFydHNbIDEgXSA/XG5cdFx0XHRpbml0aWFsSW5Vbml0ICsgKCB2YWx1ZVBhcnRzWyAxIF0gKyAxICkgKiB2YWx1ZVBhcnRzWyAyIF0gOlxuXHRcdFx0K3ZhbHVlUGFydHNbIDIgXTtcblx0XHRpZiAoIHR3ZWVuICkge1xuXHRcdFx0dHdlZW4udW5pdCA9IHVuaXQ7XG5cdFx0XHR0d2Vlbi5zdGFydCA9IGluaXRpYWxJblVuaXQ7XG5cdFx0XHR0d2Vlbi5lbmQgPSBhZGp1c3RlZDtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGFkanVzdGVkO1xufVxuXG5cbnZhciBkZWZhdWx0RGlzcGxheU1hcCA9IHt9O1xuXG5mdW5jdGlvbiBnZXREZWZhdWx0RGlzcGxheSggZWxlbSApIHtcblx0dmFyIHRlbXAsXG5cdFx0ZG9jID0gZWxlbS5vd25lckRvY3VtZW50LFxuXHRcdG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZSxcblx0XHRkaXNwbGF5ID0gZGVmYXVsdERpc3BsYXlNYXBbIG5vZGVOYW1lIF07XG5cblx0aWYgKCBkaXNwbGF5ICkge1xuXHRcdHJldHVybiBkaXNwbGF5O1xuXHR9XG5cblx0dGVtcCA9IGRvYy5ib2R5LmFwcGVuZENoaWxkKCBkb2MuY3JlYXRlRWxlbWVudCggbm9kZU5hbWUgKSApO1xuXHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggdGVtcCwgXCJkaXNwbGF5XCIgKTtcblxuXHR0ZW1wLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIHRlbXAgKTtcblxuXHRpZiAoIGRpc3BsYXkgPT09IFwibm9uZVwiICkge1xuXHRcdGRpc3BsYXkgPSBcImJsb2NrXCI7XG5cdH1cblx0ZGVmYXVsdERpc3BsYXlNYXBbIG5vZGVOYW1lIF0gPSBkaXNwbGF5O1xuXG5cdHJldHVybiBkaXNwbGF5O1xufVxuXG5mdW5jdGlvbiBzaG93SGlkZSggZWxlbWVudHMsIHNob3cgKSB7XG5cdHZhciBkaXNwbGF5LCBlbGVtLFxuXHRcdHZhbHVlcyA9IFtdLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBlbGVtZW50cy5sZW5ndGg7XG5cblx0Ly8gRGV0ZXJtaW5lIG5ldyBkaXNwbGF5IHZhbHVlIGZvciBlbGVtZW50cyB0aGF0IG5lZWQgdG8gY2hhbmdlXG5cdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0ZWxlbSA9IGVsZW1lbnRzWyBpbmRleCBdO1xuXHRcdGlmICggIWVsZW0uc3R5bGUgKSB7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRkaXNwbGF5ID0gZWxlbS5zdHlsZS5kaXNwbGF5O1xuXHRcdGlmICggc2hvdyApIHtcblxuXHRcdFx0Ly8gU2luY2Ugd2UgZm9yY2UgdmlzaWJpbGl0eSB1cG9uIGNhc2NhZGUtaGlkZGVuIGVsZW1lbnRzLCBhbiBpbW1lZGlhdGUgKGFuZCBzbG93KVxuXHRcdFx0Ly8gY2hlY2sgaXMgcmVxdWlyZWQgaW4gdGhpcyBmaXJzdCBsb29wIHVubGVzcyB3ZSBoYXZlIGEgbm9uZW1wdHkgZGlzcGxheSB2YWx1ZSAoZWl0aGVyXG5cdFx0XHQvLyBpbmxpbmUgb3IgYWJvdXQtdG8tYmUtcmVzdG9yZWQpXG5cdFx0XHRpZiAoIGRpc3BsYXkgPT09IFwibm9uZVwiICkge1xuXHRcdFx0XHR2YWx1ZXNbIGluZGV4IF0gPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFwiZGlzcGxheVwiICkgfHwgbnVsbDtcblx0XHRcdFx0aWYgKCAhdmFsdWVzWyBpbmRleCBdICkge1xuXHRcdFx0XHRcdGVsZW0uc3R5bGUuZGlzcGxheSA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICggZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIlwiICYmIGlzSGlkZGVuV2l0aGluVHJlZSggZWxlbSApICkge1xuXHRcdFx0XHR2YWx1ZXNbIGluZGV4IF0gPSBnZXREZWZhdWx0RGlzcGxheSggZWxlbSApO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoIGRpc3BsYXkgIT09IFwibm9uZVwiICkge1xuXHRcdFx0XHR2YWx1ZXNbIGluZGV4IF0gPSBcIm5vbmVcIjtcblxuXHRcdFx0XHQvLyBSZW1lbWJlciB3aGF0IHdlJ3JlIG92ZXJ3cml0aW5nXG5cdFx0XHRcdGRhdGFQcml2LnNldCggZWxlbSwgXCJkaXNwbGF5XCIsIGRpc3BsYXkgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBTZXQgdGhlIGRpc3BsYXkgb2YgdGhlIGVsZW1lbnRzIGluIGEgc2Vjb25kIGxvb3AgdG8gYXZvaWQgY29uc3RhbnQgcmVmbG93XG5cdGZvciAoIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0aWYgKCB2YWx1ZXNbIGluZGV4IF0gIT0gbnVsbCApIHtcblx0XHRcdGVsZW1lbnRzWyBpbmRleCBdLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZXNbIGluZGV4IF07XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW1lbnRzO1xufVxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHNob3c6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzaG93SGlkZSggdGhpcywgdHJ1ZSApO1xuXHR9LFxuXHRoaWRlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2hvd0hpZGUoIHRoaXMgKTtcblx0fSxcblx0dG9nZ2xlOiBmdW5jdGlvbiggc3RhdGUgKSB7XG5cdFx0aWYgKCB0eXBlb2Ygc3RhdGUgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdFx0cmV0dXJuIHN0YXRlID8gdGhpcy5zaG93KCkgOiB0aGlzLmhpZGUoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggaXNIaWRkZW5XaXRoaW5UcmVlKCB0aGlzICkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnNob3coKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLmhpZGUoKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH1cbn0gKTtcbnZhciByY2hlY2thYmxlVHlwZSA9ICggL14oPzpjaGVja2JveHxyYWRpbykkL2kgKTtcblxudmFyIHJ0YWdOYW1lID0gKCAvPChbYS16XVteXFwvXFwwPlxceDIwXFx0XFxyXFxuXFxmXSopL2kgKTtcblxudmFyIHJzY3JpcHRUeXBlID0gKCAvXiR8Xm1vZHVsZSR8XFwvKD86amF2YXxlY21hKXNjcmlwdC9pICk7XG5cblxuXG4oIGZ1bmN0aW9uKCkge1xuXHR2YXIgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG5cdFx0ZGl2ID0gZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSApLFxuXHRcdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICk7XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgLSA0LjMgb25seVxuXHQvLyBDaGVjayBzdGF0ZSBsb3N0IGlmIHRoZSBuYW1lIGlzIHNldCAodHJhYy0xMTIxNylcblx0Ly8gU3VwcG9ydDogV2luZG93cyBXZWIgQXBwcyAoV1dBKVxuXHQvLyBgbmFtZWAgYW5kIGB0eXBlYCBtdXN0IHVzZSAuc2V0QXR0cmlidXRlIGZvciBXV0EgKHRyYWMtMTQ5MDEpXG5cdGlucHV0LnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIFwicmFkaW9cIiApO1xuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwiY2hlY2tlZFwiLCBcImNoZWNrZWRcIiApO1xuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwibmFtZVwiLCBcInRcIiApO1xuXG5cdGRpdi5hcHBlbmRDaGlsZCggaW5wdXQgKTtcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4xIG9ubHlcblx0Ly8gT2xkZXIgV2ViS2l0IGRvZXNuJ3QgY2xvbmUgY2hlY2tlZCBzdGF0ZSBjb3JyZWN0bHkgaW4gZnJhZ21lbnRzXG5cdHN1cHBvcnQuY2hlY2tDbG9uZSA9IGRpdi5jbG9uZU5vZGUoIHRydWUgKS5jbG9uZU5vZGUoIHRydWUgKS5sYXN0Q2hpbGQuY2hlY2tlZDtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0Ly8gTWFrZSBzdXJlIHRleHRhcmVhIChhbmQgY2hlY2tib3gpIGRlZmF1bHRWYWx1ZSBpcyBwcm9wZXJseSBjbG9uZWRcblx0ZGl2LmlubmVySFRNTCA9IFwiPHRleHRhcmVhPng8L3RleHRhcmVhPlwiO1xuXHRzdXBwb3J0Lm5vQ2xvbmVDaGVja2VkID0gISFkaXYuY2xvbmVOb2RlKCB0cnVlICkubGFzdENoaWxkLmRlZmF1bHRWYWx1ZTtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHQvLyBJRSA8PTkgcmVwbGFjZXMgPG9wdGlvbj4gdGFncyB3aXRoIHRoZWlyIGNvbnRlbnRzIHdoZW4gaW5zZXJ0ZWQgb3V0c2lkZSBvZlxuXHQvLyB0aGUgc2VsZWN0IGVsZW1lbnQuXG5cdGRpdi5pbm5lckhUTUwgPSBcIjxvcHRpb24+PC9vcHRpb24+XCI7XG5cdHN1cHBvcnQub3B0aW9uID0gISFkaXYubGFzdENoaWxkO1xufSApKCk7XG5cblxuLy8gV2UgaGF2ZSB0byBjbG9zZSB0aGVzZSB0YWdzIHRvIHN1cHBvcnQgWEhUTUwgKHRyYWMtMTMyMDApXG52YXIgd3JhcE1hcCA9IHtcblxuXHQvLyBYSFRNTCBwYXJzZXJzIGRvIG5vdCBtYWdpY2FsbHkgaW5zZXJ0IGVsZW1lbnRzIGluIHRoZVxuXHQvLyBzYW1lIHdheSB0aGF0IHRhZyBzb3VwIHBhcnNlcnMgZG8uIFNvIHdlIGNhbm5vdCBzaG9ydGVuXG5cdC8vIHRoaXMgYnkgb21pdHRpbmcgPHRib2R5PiBvciBvdGhlciByZXF1aXJlZCBlbGVtZW50cy5cblx0dGhlYWQ6IFsgMSwgXCI8dGFibGU+XCIsIFwiPC90YWJsZT5cIiBdLFxuXHRjb2w6IFsgMiwgXCI8dGFibGU+PGNvbGdyb3VwPlwiLCBcIjwvY29sZ3JvdXA+PC90YWJsZT5cIiBdLFxuXHR0cjogWyAyLCBcIjx0YWJsZT48dGJvZHk+XCIsIFwiPC90Ym9keT48L3RhYmxlPlwiIF0sXG5cdHRkOiBbIDMsIFwiPHRhYmxlPjx0Ym9keT48dHI+XCIsIFwiPC90cj48L3Rib2R5PjwvdGFibGU+XCIgXSxcblxuXHRfZGVmYXVsdDogWyAwLCBcIlwiLCBcIlwiIF1cbn07XG5cbndyYXBNYXAudGJvZHkgPSB3cmFwTWFwLnRmb290ID0gd3JhcE1hcC5jb2xncm91cCA9IHdyYXBNYXAuY2FwdGlvbiA9IHdyYXBNYXAudGhlYWQ7XG53cmFwTWFwLnRoID0gd3JhcE1hcC50ZDtcblxuLy8gU3VwcG9ydDogSUUgPD05IG9ubHlcbmlmICggIXN1cHBvcnQub3B0aW9uICkge1xuXHR3cmFwTWFwLm9wdGdyb3VwID0gd3JhcE1hcC5vcHRpb24gPSBbIDEsIFwiPHNlbGVjdCBtdWx0aXBsZT0nbXVsdGlwbGUnPlwiLCBcIjwvc2VsZWN0PlwiIF07XG59XG5cblxuZnVuY3Rpb24gZ2V0QWxsKCBjb250ZXh0LCB0YWcgKSB7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHQvLyBVc2UgdHlwZW9mIHRvIGF2b2lkIHplcm8tYXJndW1lbnQgbWV0aG9kIGludm9jYXRpb24gb24gaG9zdCBvYmplY3RzICh0cmFjLTE1MTUxKVxuXHR2YXIgcmV0O1xuXG5cdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0cmV0ID0gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnIHx8IFwiKlwiICk7XG5cblx0fSBlbHNlIGlmICggdHlwZW9mIGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRyZXQgPSBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIHRhZyB8fCBcIipcIiApO1xuXG5cdH0gZWxzZSB7XG5cdFx0cmV0ID0gW107XG5cdH1cblxuXHRpZiAoIHRhZyA9PT0gdW5kZWZpbmVkIHx8IHRhZyAmJiBub2RlTmFtZSggY29udGV4dCwgdGFnICkgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5tZXJnZSggWyBjb250ZXh0IF0sIHJldCApO1xuXHR9XG5cblx0cmV0dXJuIHJldDtcbn1cblxuXG4vLyBNYXJrIHNjcmlwdHMgYXMgaGF2aW5nIGFscmVhZHkgYmVlbiBldmFsdWF0ZWRcbmZ1bmN0aW9uIHNldEdsb2JhbEV2YWwoIGVsZW1zLCByZWZFbGVtZW50cyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGwgPSBlbGVtcy5sZW5ndGg7XG5cblx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdGRhdGFQcml2LnNldChcblx0XHRcdGVsZW1zWyBpIF0sXG5cdFx0XHRcImdsb2JhbEV2YWxcIixcblx0XHRcdCFyZWZFbGVtZW50cyB8fCBkYXRhUHJpdi5nZXQoIHJlZkVsZW1lbnRzWyBpIF0sIFwiZ2xvYmFsRXZhbFwiIClcblx0XHQpO1xuXHR9XG59XG5cblxudmFyIHJodG1sID0gLzx8JiM/XFx3KzsvO1xuXG5mdW5jdGlvbiBidWlsZEZyYWdtZW50KCBlbGVtcywgY29udGV4dCwgc2NyaXB0cywgc2VsZWN0aW9uLCBpZ25vcmVkICkge1xuXHR2YXIgZWxlbSwgdG1wLCB0YWcsIHdyYXAsIGF0dGFjaGVkLCBqLFxuXHRcdGZyYWdtZW50ID0gY29udGV4dC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG5cdFx0bm9kZXMgPSBbXSxcblx0XHRpID0gMCxcblx0XHRsID0gZWxlbXMubGVuZ3RoO1xuXG5cdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRlbGVtID0gZWxlbXNbIGkgXTtcblxuXHRcdGlmICggZWxlbSB8fCBlbGVtID09PSAwICkge1xuXG5cdFx0XHQvLyBBZGQgbm9kZXMgZGlyZWN0bHlcblx0XHRcdGlmICggdG9UeXBlKCBlbGVtICkgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHRcdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBub2RlcywgZWxlbS5ub2RlVHlwZSA/IFsgZWxlbSBdIDogZWxlbSApO1xuXG5cdFx0XHQvLyBDb252ZXJ0IG5vbi1odG1sIGludG8gYSB0ZXh0IG5vZGVcblx0XHRcdH0gZWxzZSBpZiAoICFyaHRtbC50ZXN0KCBlbGVtICkgKSB7XG5cdFx0XHRcdG5vZGVzLnB1c2goIGNvbnRleHQuY3JlYXRlVGV4dE5vZGUoIGVsZW0gKSApO1xuXG5cdFx0XHQvLyBDb252ZXJ0IGh0bWwgaW50byBET00gbm9kZXNcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRtcCA9IHRtcCB8fCBmcmFnbWVudC5hcHBlbmRDaGlsZCggY29udGV4dC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkgKTtcblxuXHRcdFx0XHQvLyBEZXNlcmlhbGl6ZSBhIHN0YW5kYXJkIHJlcHJlc2VudGF0aW9uXG5cdFx0XHRcdHRhZyA9ICggcnRhZ05hbWUuZXhlYyggZWxlbSApIHx8IFsgXCJcIiwgXCJcIiBdIClbIDEgXS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHR3cmFwID0gd3JhcE1hcFsgdGFnIF0gfHwgd3JhcE1hcC5fZGVmYXVsdDtcblx0XHRcdFx0dG1wLmlubmVySFRNTCA9IHdyYXBbIDEgXSArIGpRdWVyeS5odG1sUHJlZmlsdGVyKCBlbGVtICkgKyB3cmFwWyAyIF07XG5cblx0XHRcdFx0Ly8gRGVzY2VuZCB0aHJvdWdoIHdyYXBwZXJzIHRvIHRoZSByaWdodCBjb250ZW50XG5cdFx0XHRcdGogPSB3cmFwWyAwIF07XG5cdFx0XHRcdHdoaWxlICggai0tICkge1xuXHRcdFx0XHRcdHRtcCA9IHRtcC5sYXN0Q2hpbGQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0XHRcdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIG5vZGVzLCB0bXAuY2hpbGROb2RlcyApO1xuXG5cdFx0XHRcdC8vIFJlbWVtYmVyIHRoZSB0b3AtbGV2ZWwgY29udGFpbmVyXG5cdFx0XHRcdHRtcCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XG5cblx0XHRcdFx0Ly8gRW5zdXJlIHRoZSBjcmVhdGVkIG5vZGVzIGFyZSBvcnBoYW5lZCAodHJhYy0xMjM5Milcblx0XHRcdFx0dG1wLnRleHRDb250ZW50ID0gXCJcIjtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBSZW1vdmUgd3JhcHBlciBmcm9tIGZyYWdtZW50XG5cdGZyYWdtZW50LnRleHRDb250ZW50ID0gXCJcIjtcblxuXHRpID0gMDtcblx0d2hpbGUgKCAoIGVsZW0gPSBub2Rlc1sgaSsrIF0gKSApIHtcblxuXHRcdC8vIFNraXAgZWxlbWVudHMgYWxyZWFkeSBpbiB0aGUgY29udGV4dCBjb2xsZWN0aW9uICh0cmFjLTQwODcpXG5cdFx0aWYgKCBzZWxlY3Rpb24gJiYgalF1ZXJ5LmluQXJyYXkoIGVsZW0sIHNlbGVjdGlvbiApID4gLTEgKSB7XG5cdFx0XHRpZiAoIGlnbm9yZWQgKSB7XG5cdFx0XHRcdGlnbm9yZWQucHVzaCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0YXR0YWNoZWQgPSBpc0F0dGFjaGVkKCBlbGVtICk7XG5cblx0XHQvLyBBcHBlbmQgdG8gZnJhZ21lbnRcblx0XHR0bXAgPSBnZXRBbGwoIGZyYWdtZW50LmFwcGVuZENoaWxkKCBlbGVtICksIFwic2NyaXB0XCIgKTtcblxuXHRcdC8vIFByZXNlcnZlIHNjcmlwdCBldmFsdWF0aW9uIGhpc3Rvcnlcblx0XHRpZiAoIGF0dGFjaGVkICkge1xuXHRcdFx0c2V0R2xvYmFsRXZhbCggdG1wICk7XG5cdFx0fVxuXG5cdFx0Ly8gQ2FwdHVyZSBleGVjdXRhYmxlc1xuXHRcdGlmICggc2NyaXB0cyApIHtcblx0XHRcdGogPSAwO1xuXHRcdFx0d2hpbGUgKCAoIGVsZW0gPSB0bXBbIGorKyBdICkgKSB7XG5cdFx0XHRcdGlmICggcnNjcmlwdFR5cGUudGVzdCggZWxlbS50eXBlIHx8IFwiXCIgKSApIHtcblx0XHRcdFx0XHRzY3JpcHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBmcmFnbWVudDtcbn1cblxuXG52YXIgcnR5cGVuYW1lc3BhY2UgPSAvXihbXi5dKikoPzpcXC4oLispfCkvO1xuXG5mdW5jdGlvbiByZXR1cm5UcnVlKCkge1xuXHRyZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmV0dXJuRmFsc2UoKSB7XG5cdHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb24oIGVsZW0sIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4sIG9uZSApIHtcblx0dmFyIG9yaWdGbiwgdHlwZTtcblxuXHQvLyBUeXBlcyBjYW4gYmUgYSBtYXAgb2YgdHlwZXMvaGFuZGxlcnNcblx0aWYgKCB0eXBlb2YgdHlwZXMgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHQvLyAoIHR5cGVzLU9iamVjdCwgc2VsZWN0b3IsIGRhdGEgKVxuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzLU9iamVjdCwgZGF0YSApXG5cdFx0XHRkYXRhID0gZGF0YSB8fCBzZWxlY3Rvcjtcblx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRmb3IgKCB0eXBlIGluIHR5cGVzICkge1xuXHRcdFx0b24oIGVsZW0sIHR5cGUsIHNlbGVjdG9yLCBkYXRhLCB0eXBlc1sgdHlwZSBdLCBvbmUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIGVsZW07XG5cdH1cblxuXHRpZiAoIGRhdGEgPT0gbnVsbCAmJiBmbiA9PSBudWxsICkge1xuXG5cdFx0Ly8gKCB0eXBlcywgZm4gKVxuXHRcdGZuID0gc2VsZWN0b3I7XG5cdFx0ZGF0YSA9IHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHR9IGVsc2UgaWYgKCBmbiA9PSBudWxsICkge1xuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzLCBzZWxlY3RvciwgZm4gKVxuXHRcdFx0Zm4gPSBkYXRhO1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyAoIHR5cGVzLCBkYXRhLCBmbiApXG5cdFx0XHRmbiA9IGRhdGE7XG5cdFx0XHRkYXRhID0gc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdH1cblx0aWYgKCBmbiA9PT0gZmFsc2UgKSB7XG5cdFx0Zm4gPSByZXR1cm5GYWxzZTtcblx0fSBlbHNlIGlmICggIWZuICkge1xuXHRcdHJldHVybiBlbGVtO1xuXHR9XG5cblx0aWYgKCBvbmUgPT09IDEgKSB7XG5cdFx0b3JpZ0ZuID0gZm47XG5cdFx0Zm4gPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cblx0XHRcdC8vIENhbiB1c2UgYW4gZW1wdHkgc2V0LCBzaW5jZSBldmVudCBjb250YWlucyB0aGUgaW5mb1xuXHRcdFx0alF1ZXJ5KCkub2ZmKCBldmVudCApO1xuXHRcdFx0cmV0dXJuIG9yaWdGbi5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0fTtcblxuXHRcdC8vIFVzZSBzYW1lIGd1aWQgc28gY2FsbGVyIGNhbiByZW1vdmUgdXNpbmcgb3JpZ0ZuXG5cdFx0Zm4uZ3VpZCA9IG9yaWdGbi5ndWlkIHx8ICggb3JpZ0ZuLmd1aWQgPSBqUXVlcnkuZ3VpZCsrICk7XG5cdH1cblx0cmV0dXJuIGVsZW0uZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0alF1ZXJ5LmV2ZW50LmFkZCggdGhpcywgdHlwZXMsIGZuLCBkYXRhLCBzZWxlY3RvciApO1xuXHR9ICk7XG59XG5cbi8qXG4gKiBIZWxwZXIgZnVuY3Rpb25zIGZvciBtYW5hZ2luZyBldmVudHMgLS0gbm90IHBhcnQgb2YgdGhlIHB1YmxpYyBpbnRlcmZhY2UuXG4gKiBQcm9wcyB0byBEZWFuIEVkd2FyZHMnIGFkZEV2ZW50IGxpYnJhcnkgZm9yIG1hbnkgb2YgdGhlIGlkZWFzLlxuICovXG5qUXVlcnkuZXZlbnQgPSB7XG5cblx0Z2xvYmFsOiB7fSxcblxuXHRhZGQ6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlcywgaGFuZGxlciwgZGF0YSwgc2VsZWN0b3IgKSB7XG5cblx0XHR2YXIgaGFuZGxlT2JqSW4sIGV2ZW50SGFuZGxlLCB0bXAsXG5cdFx0XHRldmVudHMsIHQsIGhhbmRsZU9iaixcblx0XHRcdHNwZWNpYWwsIGhhbmRsZXJzLCB0eXBlLCBuYW1lc3BhY2VzLCBvcmlnVHlwZSxcblx0XHRcdGVsZW1EYXRhID0gZGF0YVByaXYuZ2V0KCBlbGVtICk7XG5cblx0XHQvLyBPbmx5IGF0dGFjaCBldmVudHMgdG8gb2JqZWN0cyB0aGF0IGFjY2VwdCBkYXRhXG5cdFx0aWYgKCAhYWNjZXB0RGF0YSggZWxlbSApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIENhbGxlciBjYW4gcGFzcyBpbiBhbiBvYmplY3Qgb2YgY3VzdG9tIGRhdGEgaW4gbGlldSBvZiB0aGUgaGFuZGxlclxuXHRcdGlmICggaGFuZGxlci5oYW5kbGVyICkge1xuXHRcdFx0aGFuZGxlT2JqSW4gPSBoYW5kbGVyO1xuXHRcdFx0aGFuZGxlciA9IGhhbmRsZU9iakluLmhhbmRsZXI7XG5cdFx0XHRzZWxlY3RvciA9IGhhbmRsZU9iakluLnNlbGVjdG9yO1xuXHRcdH1cblxuXHRcdC8vIEVuc3VyZSB0aGF0IGludmFsaWQgc2VsZWN0b3JzIHRocm93IGV4Y2VwdGlvbnMgYXQgYXR0YWNoIHRpbWVcblx0XHQvLyBFdmFsdWF0ZSBhZ2FpbnN0IGRvY3VtZW50RWxlbWVudCBpbiBjYXNlIGVsZW0gaXMgYSBub24tZWxlbWVudCBub2RlIChlLmcuLCBkb2N1bWVudClcblx0XHRpZiAoIHNlbGVjdG9yICkge1xuXHRcdFx0alF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKCBkb2N1bWVudEVsZW1lbnQsIHNlbGVjdG9yICk7XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgdGhlIGhhbmRsZXIgaGFzIGEgdW5pcXVlIElELCB1c2VkIHRvIGZpbmQvcmVtb3ZlIGl0IGxhdGVyXG5cdFx0aWYgKCAhaGFuZGxlci5ndWlkICkge1xuXHRcdFx0aGFuZGxlci5ndWlkID0galF1ZXJ5Lmd1aWQrKztcblx0XHR9XG5cblx0XHQvLyBJbml0IHRoZSBlbGVtZW50J3MgZXZlbnQgc3RydWN0dXJlIGFuZCBtYWluIGhhbmRsZXIsIGlmIHRoaXMgaXMgdGhlIGZpcnN0XG5cdFx0aWYgKCAhKCBldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgKSApIHtcblx0XHRcdGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyA9IE9iamVjdC5jcmVhdGUoIG51bGwgKTtcblx0XHR9XG5cdFx0aWYgKCAhKCBldmVudEhhbmRsZSA9IGVsZW1EYXRhLmhhbmRsZSApICkge1xuXHRcdFx0ZXZlbnRIYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGUgPSBmdW5jdGlvbiggZSApIHtcblxuXHRcdFx0XHQvLyBEaXNjYXJkIHRoZSBzZWNvbmQgZXZlbnQgb2YgYSBqUXVlcnkuZXZlbnQudHJpZ2dlcigpIGFuZFxuXHRcdFx0XHQvLyB3aGVuIGFuIGV2ZW50IGlzIGNhbGxlZCBhZnRlciBhIHBhZ2UgaGFzIHVubG9hZGVkXG5cdFx0XHRcdHJldHVybiB0eXBlb2YgalF1ZXJ5ICE9PSBcInVuZGVmaW5lZFwiICYmIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgIT09IGUudHlwZSA/XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LmRpc3BhdGNoLmFwcGx5KCBlbGVtLCBhcmd1bWVudHMgKSA6IHVuZGVmaW5lZDtcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0Ly8gSGFuZGxlIG11bHRpcGxlIGV2ZW50cyBzZXBhcmF0ZWQgYnkgYSBzcGFjZVxuXHRcdHR5cGVzID0gKCB0eXBlcyB8fCBcIlwiICkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbIFwiXCIgXTtcblx0XHR0ID0gdHlwZXMubGVuZ3RoO1xuXHRcdHdoaWxlICggdC0tICkge1xuXHRcdFx0dG1wID0gcnR5cGVuYW1lc3BhY2UuZXhlYyggdHlwZXNbIHQgXSApIHx8IFtdO1xuXHRcdFx0dHlwZSA9IG9yaWdUeXBlID0gdG1wWyAxIF07XG5cdFx0XHRuYW1lc3BhY2VzID0gKCB0bXBbIDIgXSB8fCBcIlwiICkuc3BsaXQoIFwiLlwiICkuc29ydCgpO1xuXG5cdFx0XHQvLyBUaGVyZSAqbXVzdCogYmUgYSB0eXBlLCBubyBhdHRhY2hpbmcgbmFtZXNwYWNlLW9ubHkgaGFuZGxlcnNcblx0XHRcdGlmICggIXR5cGUgKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBldmVudCBjaGFuZ2VzIGl0cyB0eXBlLCB1c2UgdGhlIHNwZWNpYWwgZXZlbnQgaGFuZGxlcnMgZm9yIHRoZSBjaGFuZ2VkIHR5cGVcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXG5cdFx0XHQvLyBJZiBzZWxlY3RvciBkZWZpbmVkLCBkZXRlcm1pbmUgc3BlY2lhbCBldmVudCBhcGkgdHlwZSwgb3RoZXJ3aXNlIGdpdmVuIHR5cGVcblx0XHRcdHR5cGUgPSAoIHNlbGVjdG9yID8gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgOiBzcGVjaWFsLmJpbmRUeXBlICkgfHwgdHlwZTtcblxuXHRcdFx0Ly8gVXBkYXRlIHNwZWNpYWwgYmFzZWQgb24gbmV3bHkgcmVzZXQgdHlwZVxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cblx0XHRcdC8vIGhhbmRsZU9iaiBpcyBwYXNzZWQgdG8gYWxsIGV2ZW50IGhhbmRsZXJzXG5cdFx0XHRoYW5kbGVPYmogPSBqUXVlcnkuZXh0ZW5kKCB7XG5cdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdG9yaWdUeXBlOiBvcmlnVHlwZSxcblx0XHRcdFx0ZGF0YTogZGF0YSxcblx0XHRcdFx0aGFuZGxlcjogaGFuZGxlcixcblx0XHRcdFx0Z3VpZDogaGFuZGxlci5ndWlkLFxuXHRcdFx0XHRzZWxlY3Rvcjogc2VsZWN0b3IsXG5cdFx0XHRcdG5lZWRzQ29udGV4dDogc2VsZWN0b3IgJiYgalF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9yICksXG5cdFx0XHRcdG5hbWVzcGFjZTogbmFtZXNwYWNlcy5qb2luKCBcIi5cIiApXG5cdFx0XHR9LCBoYW5kbGVPYmpJbiApO1xuXG5cdFx0XHQvLyBJbml0IHRoZSBldmVudCBoYW5kbGVyIHF1ZXVlIGlmIHdlJ3JlIHRoZSBmaXJzdFxuXHRcdFx0aWYgKCAhKCBoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdICkgKSB7XG5cdFx0XHRcdGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gPSBbXTtcblx0XHRcdFx0aGFuZGxlcnMuZGVsZWdhdGVDb3VudCA9IDA7XG5cblx0XHRcdFx0Ly8gT25seSB1c2UgYWRkRXZlbnRMaXN0ZW5lciBpZiB0aGUgc3BlY2lhbCBldmVudHMgaGFuZGxlciByZXR1cm5zIGZhbHNlXG5cdFx0XHRcdGlmICggIXNwZWNpYWwuc2V0dXAgfHxcblx0XHRcdFx0XHRzcGVjaWFsLnNldHVwLmNhbGwoIGVsZW0sIGRhdGEsIG5hbWVzcGFjZXMsIGV2ZW50SGFuZGxlICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0aWYgKCBlbGVtLmFkZEV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLmFkZEV2ZW50TGlzdGVuZXIoIHR5cGUsIGV2ZW50SGFuZGxlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggc3BlY2lhbC5hZGQgKSB7XG5cdFx0XHRcdHNwZWNpYWwuYWRkLmNhbGwoIGVsZW0sIGhhbmRsZU9iaiApO1xuXG5cdFx0XHRcdGlmICggIWhhbmRsZU9iai5oYW5kbGVyLmd1aWQgKSB7XG5cdFx0XHRcdFx0aGFuZGxlT2JqLmhhbmRsZXIuZ3VpZCA9IGhhbmRsZXIuZ3VpZDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgdG8gdGhlIGVsZW1lbnQncyBoYW5kbGVyIGxpc3QsIGRlbGVnYXRlcyBpbiBmcm9udFxuXHRcdFx0aWYgKCBzZWxlY3RvciApIHtcblx0XHRcdFx0aGFuZGxlcnMuc3BsaWNlKCBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50KyssIDAsIGhhbmRsZU9iaiApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aGFuZGxlcnMucHVzaCggaGFuZGxlT2JqICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEtlZXAgdHJhY2sgb2Ygd2hpY2ggZXZlbnRzIGhhdmUgZXZlciBiZWVuIHVzZWQsIGZvciBldmVudCBvcHRpbWl6YXRpb25cblx0XHRcdGpRdWVyeS5ldmVudC5nbG9iYWxbIHR5cGUgXSA9IHRydWU7XG5cdFx0fVxuXG5cdH0sXG5cblx0Ly8gRGV0YWNoIGFuIGV2ZW50IG9yIHNldCBvZiBldmVudHMgZnJvbSBhbiBlbGVtZW50XG5cdHJlbW92ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGVzLCBoYW5kbGVyLCBzZWxlY3RvciwgbWFwcGVkVHlwZXMgKSB7XG5cblx0XHR2YXIgaiwgb3JpZ0NvdW50LCB0bXAsXG5cdFx0XHRldmVudHMsIHQsIGhhbmRsZU9iaixcblx0XHRcdHNwZWNpYWwsIGhhbmRsZXJzLCB0eXBlLCBuYW1lc3BhY2VzLCBvcmlnVHlwZSxcblx0XHRcdGVsZW1EYXRhID0gZGF0YVByaXYuaGFzRGF0YSggZWxlbSApICYmIGRhdGFQcml2LmdldCggZWxlbSApO1xuXG5cdFx0aWYgKCAhZWxlbURhdGEgfHwgISggZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gT25jZSBmb3IgZWFjaCB0eXBlLm5hbWVzcGFjZSBpbiB0eXBlczsgdHlwZSBtYXkgYmUgb21pdHRlZFxuXHRcdHR5cGVzID0gKCB0eXBlcyB8fCBcIlwiICkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbIFwiXCIgXTtcblx0XHR0ID0gdHlwZXMubGVuZ3RoO1xuXHRcdHdoaWxlICggdC0tICkge1xuXHRcdFx0dG1wID0gcnR5cGVuYW1lc3BhY2UuZXhlYyggdHlwZXNbIHQgXSApIHx8IFtdO1xuXHRcdFx0dHlwZSA9IG9yaWdUeXBlID0gdG1wWyAxIF07XG5cdFx0XHRuYW1lc3BhY2VzID0gKCB0bXBbIDIgXSB8fCBcIlwiICkuc3BsaXQoIFwiLlwiICkuc29ydCgpO1xuXG5cdFx0XHQvLyBVbmJpbmQgYWxsIGV2ZW50cyAob24gdGhpcyBuYW1lc3BhY2UsIGlmIHByb3ZpZGVkKSBmb3IgdGhlIGVsZW1lbnRcblx0XHRcdGlmICggIXR5cGUgKSB7XG5cdFx0XHRcdGZvciAoIHR5cGUgaW4gZXZlbnRzICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIGVsZW0sIHR5cGUgKyB0eXBlc1sgdCBdLCBoYW5kbGVyLCBzZWxlY3RvciwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblx0XHRcdHR5cGUgPSAoIHNlbGVjdG9yID8gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgOiBzcGVjaWFsLmJpbmRUeXBlICkgfHwgdHlwZTtcblx0XHRcdGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gfHwgW107XG5cdFx0XHR0bXAgPSB0bXBbIDIgXSAmJlxuXHRcdFx0XHRuZXcgUmVnRXhwKCBcIihefFxcXFwuKVwiICsgbmFtZXNwYWNlcy5qb2luKCBcIlxcXFwuKD86LipcXFxcLnwpXCIgKSArIFwiKFxcXFwufCQpXCIgKTtcblxuXHRcdFx0Ly8gUmVtb3ZlIG1hdGNoaW5nIGV2ZW50c1xuXHRcdFx0b3JpZ0NvdW50ID0gaiA9IGhhbmRsZXJzLmxlbmd0aDtcblx0XHRcdHdoaWxlICggai0tICkge1xuXHRcdFx0XHRoYW5kbGVPYmogPSBoYW5kbGVyc1sgaiBdO1xuXG5cdFx0XHRcdGlmICggKCBtYXBwZWRUeXBlcyB8fCBvcmlnVHlwZSA9PT0gaGFuZGxlT2JqLm9yaWdUeXBlICkgJiZcblx0XHRcdFx0XHQoICFoYW5kbGVyIHx8IGhhbmRsZXIuZ3VpZCA9PT0gaGFuZGxlT2JqLmd1aWQgKSAmJlxuXHRcdFx0XHRcdCggIXRtcCB8fCB0bXAudGVzdCggaGFuZGxlT2JqLm5hbWVzcGFjZSApICkgJiZcblx0XHRcdFx0XHQoICFzZWxlY3RvciB8fCBzZWxlY3RvciA9PT0gaGFuZGxlT2JqLnNlbGVjdG9yIHx8XG5cdFx0XHRcdFx0XHRzZWxlY3RvciA9PT0gXCIqKlwiICYmIGhhbmRsZU9iai5zZWxlY3RvciApICkge1xuXHRcdFx0XHRcdGhhbmRsZXJzLnNwbGljZSggaiwgMSApO1xuXG5cdFx0XHRcdFx0aWYgKCBoYW5kbGVPYmouc2VsZWN0b3IgKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVycy5kZWxlZ2F0ZUNvdW50LS07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggc3BlY2lhbC5yZW1vdmUgKSB7XG5cdFx0XHRcdFx0XHRzcGVjaWFsLnJlbW92ZS5jYWxsKCBlbGVtLCBoYW5kbGVPYmogKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gUmVtb3ZlIGdlbmVyaWMgZXZlbnQgaGFuZGxlciBpZiB3ZSByZW1vdmVkIHNvbWV0aGluZyBhbmQgbm8gbW9yZSBoYW5kbGVycyBleGlzdFxuXHRcdFx0Ly8gKGF2b2lkcyBwb3RlbnRpYWwgZm9yIGVuZGxlc3MgcmVjdXJzaW9uIGR1cmluZyByZW1vdmFsIG9mIHNwZWNpYWwgZXZlbnQgaGFuZGxlcnMpXG5cdFx0XHRpZiAoIG9yaWdDb3VudCAmJiAhaGFuZGxlcnMubGVuZ3RoICkge1xuXHRcdFx0XHRpZiAoICFzcGVjaWFsLnRlYXJkb3duIHx8XG5cdFx0XHRcdFx0c3BlY2lhbC50ZWFyZG93bi5jYWxsKCBlbGVtLCBuYW1lc3BhY2VzLCBlbGVtRGF0YS5oYW5kbGUgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0XHRqUXVlcnkucmVtb3ZlRXZlbnQoIGVsZW0sIHR5cGUsIGVsZW1EYXRhLmhhbmRsZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGVsZXRlIGV2ZW50c1sgdHlwZSBdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFJlbW92ZSBkYXRhIGFuZCB0aGUgZXhwYW5kbyBpZiBpdCdzIG5vIGxvbmdlciB1c2VkXG5cdFx0aWYgKCBqUXVlcnkuaXNFbXB0eU9iamVjdCggZXZlbnRzICkgKSB7XG5cdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFwiaGFuZGxlIGV2ZW50c1wiICk7XG5cdFx0fVxuXHR9LFxuXG5cdGRpc3BhdGNoOiBmdW5jdGlvbiggbmF0aXZlRXZlbnQgKSB7XG5cblx0XHR2YXIgaSwgaiwgcmV0LCBtYXRjaGVkLCBoYW5kbGVPYmosIGhhbmRsZXJRdWV1ZSxcblx0XHRcdGFyZ3MgPSBuZXcgQXJyYXkoIGFyZ3VtZW50cy5sZW5ndGggKSxcblxuXHRcdFx0Ly8gTWFrZSBhIHdyaXRhYmxlIGpRdWVyeS5FdmVudCBmcm9tIHRoZSBuYXRpdmUgZXZlbnQgb2JqZWN0XG5cdFx0XHRldmVudCA9IGpRdWVyeS5ldmVudC5maXgoIG5hdGl2ZUV2ZW50ICksXG5cblx0XHRcdGhhbmRsZXJzID0gKFxuXHRcdFx0XHRkYXRhUHJpdi5nZXQoIHRoaXMsIFwiZXZlbnRzXCIgKSB8fCBPYmplY3QuY3JlYXRlKCBudWxsIClcblx0XHRcdClbIGV2ZW50LnR5cGUgXSB8fCBbXSxcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgZXZlbnQudHlwZSBdIHx8IHt9O1xuXG5cdFx0Ly8gVXNlIHRoZSBmaXgtZWQgalF1ZXJ5LkV2ZW50IHJhdGhlciB0aGFuIHRoZSAocmVhZC1vbmx5KSBuYXRpdmUgZXZlbnRcblx0XHRhcmdzWyAwIF0gPSBldmVudDtcblxuXHRcdGZvciAoIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrICkge1xuXHRcdFx0YXJnc1sgaSBdID0gYXJndW1lbnRzWyBpIF07XG5cdFx0fVxuXG5cdFx0ZXZlbnQuZGVsZWdhdGVUYXJnZXQgPSB0aGlzO1xuXG5cdFx0Ly8gQ2FsbCB0aGUgcHJlRGlzcGF0Y2ggaG9vayBmb3IgdGhlIG1hcHBlZCB0eXBlLCBhbmQgbGV0IGl0IGJhaWwgaWYgZGVzaXJlZFxuXHRcdGlmICggc3BlY2lhbC5wcmVEaXNwYXRjaCAmJiBzcGVjaWFsLnByZURpc3BhdGNoLmNhbGwoIHRoaXMsIGV2ZW50ICkgPT09IGZhbHNlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIERldGVybWluZSBoYW5kbGVyc1xuXHRcdGhhbmRsZXJRdWV1ZSA9IGpRdWVyeS5ldmVudC5oYW5kbGVycy5jYWxsKCB0aGlzLCBldmVudCwgaGFuZGxlcnMgKTtcblxuXHRcdC8vIFJ1biBkZWxlZ2F0ZXMgZmlyc3Q7IHRoZXkgbWF5IHdhbnQgdG8gc3RvcCBwcm9wYWdhdGlvbiBiZW5lYXRoIHVzXG5cdFx0aSA9IDA7XG5cdFx0d2hpbGUgKCAoIG1hdGNoZWQgPSBoYW5kbGVyUXVldWVbIGkrKyBdICkgJiYgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cdFx0XHRldmVudC5jdXJyZW50VGFyZ2V0ID0gbWF0Y2hlZC5lbGVtO1xuXG5cdFx0XHRqID0gMDtcblx0XHRcdHdoaWxlICggKCBoYW5kbGVPYmogPSBtYXRjaGVkLmhhbmRsZXJzWyBqKysgXSApICYmXG5cdFx0XHRcdCFldmVudC5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXG5cdFx0XHRcdC8vIElmIHRoZSBldmVudCBpcyBuYW1lc3BhY2VkLCB0aGVuIGVhY2ggaGFuZGxlciBpcyBvbmx5IGludm9rZWQgaWYgaXQgaXNcblx0XHRcdFx0Ly8gc3BlY2lhbGx5IHVuaXZlcnNhbCBvciBpdHMgbmFtZXNwYWNlcyBhcmUgYSBzdXBlcnNldCBvZiB0aGUgZXZlbnQncy5cblx0XHRcdFx0aWYgKCAhZXZlbnQucm5hbWVzcGFjZSB8fCBoYW5kbGVPYmoubmFtZXNwYWNlID09PSBmYWxzZSB8fFxuXHRcdFx0XHRcdGV2ZW50LnJuYW1lc3BhY2UudGVzdCggaGFuZGxlT2JqLm5hbWVzcGFjZSApICkge1xuXG5cdFx0XHRcdFx0ZXZlbnQuaGFuZGxlT2JqID0gaGFuZGxlT2JqO1xuXHRcdFx0XHRcdGV2ZW50LmRhdGEgPSBoYW5kbGVPYmouZGF0YTtcblxuXHRcdFx0XHRcdHJldCA9ICggKCBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgaGFuZGxlT2JqLm9yaWdUeXBlIF0gfHwge30gKS5oYW5kbGUgfHxcblx0XHRcdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyICkuYXBwbHkoIG1hdGNoZWQuZWxlbSwgYXJncyApO1xuXG5cdFx0XHRcdFx0aWYgKCByZXQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdGlmICggKCBldmVudC5yZXN1bHQgPSByZXQgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0XHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhbGwgdGhlIHBvc3REaXNwYXRjaCBob29rIGZvciB0aGUgbWFwcGVkIHR5cGVcblx0XHRpZiAoIHNwZWNpYWwucG9zdERpc3BhdGNoICkge1xuXHRcdFx0c3BlY2lhbC5wb3N0RGlzcGF0Y2guY2FsbCggdGhpcywgZXZlbnQgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQucmVzdWx0O1xuXHR9LFxuXG5cdGhhbmRsZXJzOiBmdW5jdGlvbiggZXZlbnQsIGhhbmRsZXJzICkge1xuXHRcdHZhciBpLCBoYW5kbGVPYmosIHNlbCwgbWF0Y2hlZEhhbmRsZXJzLCBtYXRjaGVkU2VsZWN0b3JzLFxuXHRcdFx0aGFuZGxlclF1ZXVlID0gW10sXG5cdFx0XHRkZWxlZ2F0ZUNvdW50ID0gaGFuZGxlcnMuZGVsZWdhdGVDb3VudCxcblx0XHRcdGN1ciA9IGV2ZW50LnRhcmdldDtcblxuXHRcdC8vIEZpbmQgZGVsZWdhdGUgaGFuZGxlcnNcblx0XHRpZiAoIGRlbGVnYXRlQ291bnQgJiZcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05XG5cdFx0XHQvLyBCbGFjay1ob2xlIFNWRyA8dXNlPiBpbnN0YW5jZSB0cmVlcyAodHJhYy0xMzE4MClcblx0XHRcdGN1ci5ub2RlVHlwZSAmJlxuXG5cdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9NDJcblx0XHRcdC8vIFN1cHByZXNzIHNwZWMtdmlvbGF0aW5nIGNsaWNrcyBpbmRpY2F0aW5nIGEgbm9uLXByaW1hcnkgcG9pbnRlciBidXR0b24gKHRyYWMtMzg2MSlcblx0XHRcdC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50LXR5cGUtY2xpY2tcblx0XHRcdC8vIFN1cHBvcnQ6IElFIDExIG9ubHlcblx0XHRcdC8vIC4uLmJ1dCBub3QgYXJyb3cga2V5IFwiY2xpY2tzXCIgb2YgcmFkaW8gaW5wdXRzLCB3aGljaCBjYW4gaGF2ZSBgYnV0dG9uYCAtMSAoZ2gtMjM0Mylcblx0XHRcdCEoIGV2ZW50LnR5cGUgPT09IFwiY2xpY2tcIiAmJiBldmVudC5idXR0b24gPj0gMSApICkge1xuXG5cdFx0XHRmb3IgKCA7IGN1ciAhPT0gdGhpczsgY3VyID0gY3VyLnBhcmVudE5vZGUgfHwgdGhpcyApIHtcblxuXHRcdFx0XHQvLyBEb24ndCBjaGVjayBub24tZWxlbWVudHMgKHRyYWMtMTMyMDgpXG5cdFx0XHRcdC8vIERvbid0IHByb2Nlc3MgY2xpY2tzIG9uIGRpc2FibGVkIGVsZW1lbnRzICh0cmFjLTY5MTEsIHRyYWMtODE2NSwgdHJhYy0xMTM4MiwgdHJhYy0xMTc2NClcblx0XHRcdFx0aWYgKCBjdXIubm9kZVR5cGUgPT09IDEgJiYgISggZXZlbnQudHlwZSA9PT0gXCJjbGlja1wiICYmIGN1ci5kaXNhYmxlZCA9PT0gdHJ1ZSApICkge1xuXHRcdFx0XHRcdG1hdGNoZWRIYW5kbGVycyA9IFtdO1xuXHRcdFx0XHRcdG1hdGNoZWRTZWxlY3RvcnMgPSB7fTtcblx0XHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGRlbGVnYXRlQ291bnQ7IGkrKyApIHtcblx0XHRcdFx0XHRcdGhhbmRsZU9iaiA9IGhhbmRsZXJzWyBpIF07XG5cblx0XHRcdFx0XHRcdC8vIERvbid0IGNvbmZsaWN0IHdpdGggT2JqZWN0LnByb3RvdHlwZSBwcm9wZXJ0aWVzICh0cmFjLTEzMjAzKVxuXHRcdFx0XHRcdFx0c2VsID0gaGFuZGxlT2JqLnNlbGVjdG9yICsgXCIgXCI7XG5cblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlZFNlbGVjdG9yc1sgc2VsIF0gPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdFx0bWF0Y2hlZFNlbGVjdG9yc1sgc2VsIF0gPSBoYW5kbGVPYmoubmVlZHNDb250ZXh0ID9cblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkoIHNlbCwgdGhpcyApLmluZGV4KCBjdXIgKSA+IC0xIDpcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuZmluZCggc2VsLCB0aGlzLCBudWxsLCBbIGN1ciBdICkubGVuZ3RoO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVkU2VsZWN0b3JzWyBzZWwgXSApIHtcblx0XHRcdFx0XHRcdFx0bWF0Y2hlZEhhbmRsZXJzLnB1c2goIGhhbmRsZU9iaiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIG1hdGNoZWRIYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVyUXVldWUucHVzaCggeyBlbGVtOiBjdXIsIGhhbmRsZXJzOiBtYXRjaGVkSGFuZGxlcnMgfSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEFkZCB0aGUgcmVtYWluaW5nIChkaXJlY3RseS1ib3VuZCkgaGFuZGxlcnNcblx0XHRjdXIgPSB0aGlzO1xuXHRcdGlmICggZGVsZWdhdGVDb3VudCA8IGhhbmRsZXJzLmxlbmd0aCApIHtcblx0XHRcdGhhbmRsZXJRdWV1ZS5wdXNoKCB7IGVsZW06IGN1ciwgaGFuZGxlcnM6IGhhbmRsZXJzLnNsaWNlKCBkZWxlZ2F0ZUNvdW50ICkgfSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBoYW5kbGVyUXVldWU7XG5cdH0sXG5cblx0YWRkUHJvcDogZnVuY3Rpb24oIG5hbWUsIGhvb2sgKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCBqUXVlcnkuRXZlbnQucHJvdG90eXBlLCBuYW1lLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXG5cdFx0XHRnZXQ6IGlzRnVuY3Rpb24oIGhvb2sgKSA/XG5cdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5vcmlnaW5hbEV2ZW50ICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGhvb2soIHRoaXMub3JpZ2luYWxFdmVudCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSA6XG5cdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5vcmlnaW5hbEV2ZW50ICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMub3JpZ2luYWxFdmVudFsgbmFtZSBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblxuXHRcdFx0c2V0OiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgbmFtZSwge1xuXHRcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdHdyaXRhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdHZhbHVlOiB2YWx1ZVxuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGZpeDogZnVuY3Rpb24oIG9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0cmV0dXJuIG9yaWdpbmFsRXZlbnRbIGpRdWVyeS5leHBhbmRvIF0gP1xuXHRcdFx0b3JpZ2luYWxFdmVudCA6XG5cdFx0XHRuZXcgalF1ZXJ5LkV2ZW50KCBvcmlnaW5hbEV2ZW50ICk7XG5cdH0sXG5cblx0c3BlY2lhbDoge1xuXHRcdGxvYWQ6IHtcblxuXHRcdFx0Ly8gUHJldmVudCB0cmlnZ2VyZWQgaW1hZ2UubG9hZCBldmVudHMgZnJvbSBidWJibGluZyB0byB3aW5kb3cubG9hZFxuXHRcdFx0bm9CdWJibGU6IHRydWVcblx0XHR9LFxuXHRcdGNsaWNrOiB7XG5cblx0XHRcdC8vIFV0aWxpemUgbmF0aXZlIGV2ZW50IHRvIGVuc3VyZSBjb3JyZWN0IHN0YXRlIGZvciBjaGVja2FibGUgaW5wdXRzXG5cdFx0XHRzZXR1cDogZnVuY3Rpb24oIGRhdGEgKSB7XG5cblx0XHRcdFx0Ly8gRm9yIG11dHVhbCBjb21wcmVzc2liaWxpdHkgd2l0aCBfZGVmYXVsdCwgcmVwbGFjZSBgdGhpc2AgYWNjZXNzIHdpdGggYSBsb2NhbCB2YXIuXG5cdFx0XHRcdC8vIGB8fCBkYXRhYCBpcyBkZWFkIGNvZGUgbWVhbnQgb25seSB0byBwcmVzZXJ2ZSB0aGUgdmFyaWFibGUgdGhyb3VnaCBtaW5pZmljYXRpb24uXG5cdFx0XHRcdHZhciBlbCA9IHRoaXMgfHwgZGF0YTtcblxuXHRcdFx0XHQvLyBDbGFpbSB0aGUgZmlyc3QgaGFuZGxlclxuXHRcdFx0XHRpZiAoIHJjaGVja2FibGVUeXBlLnRlc3QoIGVsLnR5cGUgKSAmJlxuXHRcdFx0XHRcdGVsLmNsaWNrICYmIG5vZGVOYW1lKCBlbCwgXCJpbnB1dFwiICkgKSB7XG5cblx0XHRcdFx0XHQvLyBkYXRhUHJpdi5zZXQoIGVsLCBcImNsaWNrXCIsIC4uLiApXG5cdFx0XHRcdFx0bGV2ZXJhZ2VOYXRpdmUoIGVsLCBcImNsaWNrXCIsIHRydWUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJldHVybiBmYWxzZSB0byBhbGxvdyBub3JtYWwgcHJvY2Vzc2luZyBpbiB0aGUgY2FsbGVyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH0sXG5cdFx0XHR0cmlnZ2VyOiBmdW5jdGlvbiggZGF0YSApIHtcblxuXHRcdFx0XHQvLyBGb3IgbXV0dWFsIGNvbXByZXNzaWJpbGl0eSB3aXRoIF9kZWZhdWx0LCByZXBsYWNlIGB0aGlzYCBhY2Nlc3Mgd2l0aCBhIGxvY2FsIHZhci5cblx0XHRcdFx0Ly8gYHx8IGRhdGFgIGlzIGRlYWQgY29kZSBtZWFudCBvbmx5IHRvIHByZXNlcnZlIHRoZSB2YXJpYWJsZSB0aHJvdWdoIG1pbmlmaWNhdGlvbi5cblx0XHRcdFx0dmFyIGVsID0gdGhpcyB8fCBkYXRhO1xuXG5cdFx0XHRcdC8vIEZvcmNlIHNldHVwIGJlZm9yZSB0cmlnZ2VyaW5nIGEgY2xpY2tcblx0XHRcdFx0aWYgKCByY2hlY2thYmxlVHlwZS50ZXN0KCBlbC50eXBlICkgJiZcblx0XHRcdFx0XHRlbC5jbGljayAmJiBub2RlTmFtZSggZWwsIFwiaW5wdXRcIiApICkge1xuXG5cdFx0XHRcdFx0bGV2ZXJhZ2VOYXRpdmUoIGVsLCBcImNsaWNrXCIgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJldHVybiBub24tZmFsc2UgdG8gYWxsb3cgbm9ybWFsIGV2ZW50LXBhdGggcHJvcGFnYXRpb25cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBGb3IgY3Jvc3MtYnJvd3NlciBjb25zaXN0ZW5jeSwgc3VwcHJlc3MgbmF0aXZlIC5jbGljaygpIG9uIGxpbmtzXG5cdFx0XHQvLyBBbHNvIHByZXZlbnQgaXQgaWYgd2UncmUgY3VycmVudGx5IGluc2lkZSBhIGxldmVyYWdlZCBuYXRpdmUtZXZlbnQgc3RhY2tcblx0XHRcdF9kZWZhdWx0OiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdHZhciB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG5cdFx0XHRcdHJldHVybiByY2hlY2thYmxlVHlwZS50ZXN0KCB0YXJnZXQudHlwZSApICYmXG5cdFx0XHRcdFx0dGFyZ2V0LmNsaWNrICYmIG5vZGVOYW1lKCB0YXJnZXQsIFwiaW5wdXRcIiApICYmXG5cdFx0XHRcdFx0ZGF0YVByaXYuZ2V0KCB0YXJnZXQsIFwiY2xpY2tcIiApIHx8XG5cdFx0XHRcdFx0bm9kZU5hbWUoIHRhcmdldCwgXCJhXCIgKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0YmVmb3JldW5sb2FkOiB7XG5cdFx0XHRwb3N0RGlzcGF0Y2g6IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDIwK1xuXHRcdFx0XHQvLyBGaXJlZm94IGRvZXNuJ3QgYWxlcnQgaWYgdGhlIHJldHVyblZhbHVlIGZpZWxkIGlzIG5vdCBzZXQuXG5cdFx0XHRcdGlmICggZXZlbnQucmVzdWx0ICE9PSB1bmRlZmluZWQgJiYgZXZlbnQub3JpZ2luYWxFdmVudCApIHtcblx0XHRcdFx0XHRldmVudC5vcmlnaW5hbEV2ZW50LnJldHVyblZhbHVlID0gZXZlbnQucmVzdWx0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG4vLyBFbnN1cmUgdGhlIHByZXNlbmNlIG9mIGFuIGV2ZW50IGxpc3RlbmVyIHRoYXQgaGFuZGxlcyBtYW51YWxseS10cmlnZ2VyZWRcbi8vIHN5bnRoZXRpYyBldmVudHMgYnkgaW50ZXJydXB0aW5nIHByb2dyZXNzIHVudGlsIHJlaW52b2tlZCBpbiByZXNwb25zZSB0b1xuLy8gKm5hdGl2ZSogZXZlbnRzIHRoYXQgaXQgZmlyZXMgZGlyZWN0bHksIGVuc3VyaW5nIHRoYXQgc3RhdGUgY2hhbmdlcyBoYXZlXG4vLyBhbHJlYWR5IG9jY3VycmVkIGJlZm9yZSBvdGhlciBsaXN0ZW5lcnMgYXJlIGludm9rZWQuXG5mdW5jdGlvbiBsZXZlcmFnZU5hdGl2ZSggZWwsIHR5cGUsIGlzU2V0dXAgKSB7XG5cblx0Ly8gTWlzc2luZyBgaXNTZXR1cGAgaW5kaWNhdGVzIGEgdHJpZ2dlciBjYWxsLCB3aGljaCBtdXN0IGZvcmNlIHNldHVwIHRocm91Z2ggalF1ZXJ5LmV2ZW50LmFkZFxuXHRpZiAoICFpc1NldHVwICkge1xuXHRcdGlmICggZGF0YVByaXYuZ2V0KCBlbCwgdHlwZSApID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQuYWRkKCBlbCwgdHlwZSwgcmV0dXJuVHJ1ZSApO1xuXHRcdH1cblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBSZWdpc3RlciB0aGUgY29udHJvbGxlciBhcyBhIHNwZWNpYWwgdW5pdmVyc2FsIGhhbmRsZXIgZm9yIGFsbCBldmVudCBuYW1lc3BhY2VzXG5cdGRhdGFQcml2LnNldCggZWwsIHR5cGUsIGZhbHNlICk7XG5cdGpRdWVyeS5ldmVudC5hZGQoIGVsLCB0eXBlLCB7XG5cdFx0bmFtZXNwYWNlOiBmYWxzZSxcblx0XHRoYW5kbGVyOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHR2YXIgcmVzdWx0LFxuXHRcdFx0XHRzYXZlZCA9IGRhdGFQcml2LmdldCggdGhpcywgdHlwZSApO1xuXG5cdFx0XHRpZiAoICggZXZlbnQuaXNUcmlnZ2VyICYgMSApICYmIHRoaXNbIHR5cGUgXSApIHtcblxuXHRcdFx0XHQvLyBJbnRlcnJ1cHQgcHJvY2Vzc2luZyBvZiB0aGUgb3V0ZXIgc3ludGhldGljIC50cmlnZ2VyKCllZCBldmVudFxuXHRcdFx0XHRpZiAoICFzYXZlZCApIHtcblxuXHRcdFx0XHRcdC8vIFN0b3JlIGFyZ3VtZW50cyBmb3IgdXNlIHdoZW4gaGFuZGxpbmcgdGhlIGlubmVyIG5hdGl2ZSBldmVudFxuXHRcdFx0XHRcdC8vIFRoZXJlIHdpbGwgYWx3YXlzIGJlIGF0IGxlYXN0IG9uZSBhcmd1bWVudCAoYW4gZXZlbnQgb2JqZWN0KSwgc28gdGhpcyBhcnJheVxuXHRcdFx0XHRcdC8vIHdpbGwgbm90IGJlIGNvbmZ1c2VkIHdpdGggYSBsZWZ0b3ZlciBjYXB0dXJlIG9iamVjdC5cblx0XHRcdFx0XHRzYXZlZCA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdGRhdGFQcml2LnNldCggdGhpcywgdHlwZSwgc2F2ZWQgKTtcblxuXHRcdFx0XHRcdC8vIFRyaWdnZXIgdGhlIG5hdGl2ZSBldmVudCBhbmQgY2FwdHVyZSBpdHMgcmVzdWx0XG5cdFx0XHRcdFx0dGhpc1sgdHlwZSBdKCk7XG5cdFx0XHRcdFx0cmVzdWx0ID0gZGF0YVByaXYuZ2V0KCB0aGlzLCB0eXBlICk7XG5cdFx0XHRcdFx0ZGF0YVByaXYuc2V0KCB0aGlzLCB0eXBlLCBmYWxzZSApO1xuXG5cdFx0XHRcdFx0aWYgKCBzYXZlZCAhPT0gcmVzdWx0ICkge1xuXG5cdFx0XHRcdFx0XHQvLyBDYW5jZWwgdGhlIG91dGVyIHN5bnRoZXRpYyBldmVudFxuXHRcdFx0XHRcdFx0ZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBJZiB0aGlzIGlzIGFuIGlubmVyIHN5bnRoZXRpYyBldmVudCBmb3IgYW4gZXZlbnQgd2l0aCBhIGJ1YmJsaW5nIHN1cnJvZ2F0ZVxuXHRcdFx0XHQvLyAoZm9jdXMgb3IgYmx1ciksIGFzc3VtZSB0aGF0IHRoZSBzdXJyb2dhdGUgYWxyZWFkeSBwcm9wYWdhdGVkIGZyb20gdHJpZ2dlcmluZ1xuXHRcdFx0XHQvLyB0aGUgbmF0aXZlIGV2ZW50IGFuZCBwcmV2ZW50IHRoYXQgZnJvbSBoYXBwZW5pbmcgYWdhaW4gaGVyZS5cblx0XHRcdFx0Ly8gVGhpcyB0ZWNobmljYWxseSBnZXRzIHRoZSBvcmRlcmluZyB3cm9uZyB3LnIudC4gdG8gYC50cmlnZ2VyKClgIChpbiB3aGljaCB0aGVcblx0XHRcdFx0Ly8gYnViYmxpbmcgc3Vycm9nYXRlIHByb3BhZ2F0ZXMgKmFmdGVyKiB0aGUgbm9uLWJ1YmJsaW5nIGJhc2UpLCBidXQgdGhhdCBzZWVtc1xuXHRcdFx0XHQvLyBsZXNzIGJhZCB0aGFuIGR1cGxpY2F0aW9uLlxuXHRcdFx0XHR9IGVsc2UgaWYgKCAoIGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge30gKS5kZWxlZ2F0ZVR5cGUgKSB7XG5cdFx0XHRcdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgdGhpcyBpcyBhIG5hdGl2ZSBldmVudCB0cmlnZ2VyZWQgYWJvdmUsIGV2ZXJ5dGhpbmcgaXMgbm93IGluIG9yZGVyXG5cdFx0XHQvLyBGaXJlIGFuIGlubmVyIHN5bnRoZXRpYyBldmVudCB3aXRoIHRoZSBvcmlnaW5hbCBhcmd1bWVudHNcblx0XHRcdH0gZWxzZSBpZiAoIHNhdmVkICkge1xuXG5cdFx0XHRcdC8vIC4uLmFuZCBjYXB0dXJlIHRoZSByZXN1bHRcblx0XHRcdFx0ZGF0YVByaXYuc2V0KCB0aGlzLCB0eXBlLCBqUXVlcnkuZXZlbnQudHJpZ2dlcihcblx0XHRcdFx0XHRzYXZlZFsgMCBdLFxuXHRcdFx0XHRcdHNhdmVkLnNsaWNlKCAxICksXG5cdFx0XHRcdFx0dGhpc1xuXHRcdFx0XHQpICk7XG5cblx0XHRcdFx0Ly8gQWJvcnQgaGFuZGxpbmcgb2YgdGhlIG5hdGl2ZSBldmVudCBieSBhbGwgalF1ZXJ5IGhhbmRsZXJzIHdoaWxlIGFsbG93aW5nXG5cdFx0XHRcdC8vIG5hdGl2ZSBoYW5kbGVycyBvbiB0aGUgc2FtZSBlbGVtZW50IHRvIHJ1bi4gT24gdGFyZ2V0LCB0aGlzIGlzIGFjaGlldmVkXG5cdFx0XHRcdC8vIGJ5IHN0b3BwaW5nIGltbWVkaWF0ZSBwcm9wYWdhdGlvbiBqdXN0IG9uIHRoZSBqUXVlcnkgZXZlbnQuIEhvd2V2ZXIsXG5cdFx0XHRcdC8vIHRoZSBuYXRpdmUgZXZlbnQgaXMgcmUtd3JhcHBlZCBieSBhIGpRdWVyeSBvbmUgb24gZWFjaCBsZXZlbCBvZiB0aGVcblx0XHRcdFx0Ly8gcHJvcGFnYXRpb24gc28gdGhlIG9ubHkgd2F5IHRvIHN0b3AgaXQgZm9yIGpRdWVyeSBpcyB0byBzdG9wIGl0IGZvclxuXHRcdFx0XHQvLyBldmVyeW9uZSB2aWEgbmF0aXZlIGBzdG9wUHJvcGFnYXRpb24oKWAuIFRoaXMgaXMgbm90IGEgcHJvYmxlbSBmb3Jcblx0XHRcdFx0Ly8gZm9jdXMvYmx1ciB3aGljaCBkb24ndCBidWJibGUsIGJ1dCBpdCBkb2VzIGFsc28gc3RvcCBjbGljayBvbiBjaGVja2JveGVzXG5cdFx0XHRcdC8vIGFuZCByYWRpb3MuIFdlIGFjY2VwdCB0aGlzIGxpbWl0YXRpb24uXG5cdFx0XHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRldmVudC5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9ICk7XG59XG5cbmpRdWVyeS5yZW1vdmVFdmVudCA9IGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCBoYW5kbGUgKSB7XG5cblx0Ly8gVGhpcyBcImlmXCIgaXMgbmVlZGVkIGZvciBwbGFpbiBvYmplY3RzXG5cdGlmICggZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyICkge1xuXHRcdGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lciggdHlwZSwgaGFuZGxlICk7XG5cdH1cbn07XG5cbmpRdWVyeS5FdmVudCA9IGZ1bmN0aW9uKCBzcmMsIHByb3BzICkge1xuXG5cdC8vIEFsbG93IGluc3RhbnRpYXRpb24gd2l0aG91dCB0aGUgJ25ldycga2V5d29yZFxuXHRpZiAoICEoIHRoaXMgaW5zdGFuY2VvZiBqUXVlcnkuRXZlbnQgKSApIHtcblx0XHRyZXR1cm4gbmV3IGpRdWVyeS5FdmVudCggc3JjLCBwcm9wcyApO1xuXHR9XG5cblx0Ly8gRXZlbnQgb2JqZWN0XG5cdGlmICggc3JjICYmIHNyYy50eXBlICkge1xuXHRcdHRoaXMub3JpZ2luYWxFdmVudCA9IHNyYztcblx0XHR0aGlzLnR5cGUgPSBzcmMudHlwZTtcblxuXHRcdC8vIEV2ZW50cyBidWJibGluZyB1cCB0aGUgZG9jdW1lbnQgbWF5IGhhdmUgYmVlbiBtYXJrZWQgYXMgcHJldmVudGVkXG5cdFx0Ly8gYnkgYSBoYW5kbGVyIGxvd2VyIGRvd24gdGhlIHRyZWU7IHJlZmxlY3QgdGhlIGNvcnJlY3QgdmFsdWUuXG5cdFx0dGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBzcmMuZGVmYXVsdFByZXZlbnRlZCB8fFxuXHRcdFx0XHRzcmMuZGVmYXVsdFByZXZlbnRlZCA9PT0gdW5kZWZpbmVkICYmXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTIuMyBvbmx5XG5cdFx0XHRcdHNyYy5yZXR1cm5WYWx1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0cmV0dXJuVHJ1ZSA6XG5cdFx0XHRyZXR1cm5GYWxzZTtcblxuXHRcdC8vIENyZWF0ZSB0YXJnZXQgcHJvcGVydGllc1xuXHRcdC8vIFN1cHBvcnQ6IFNhZmFyaSA8PTYgLSA3IG9ubHlcblx0XHQvLyBUYXJnZXQgc2hvdWxkIG5vdCBiZSBhIHRleHQgbm9kZSAodHJhYy01MDQsIHRyYWMtMTMxNDMpXG5cdFx0dGhpcy50YXJnZXQgPSAoIHNyYy50YXJnZXQgJiYgc3JjLnRhcmdldC5ub2RlVHlwZSA9PT0gMyApID9cblx0XHRcdHNyYy50YXJnZXQucGFyZW50Tm9kZSA6XG5cdFx0XHRzcmMudGFyZ2V0O1xuXG5cdFx0dGhpcy5jdXJyZW50VGFyZ2V0ID0gc3JjLmN1cnJlbnRUYXJnZXQ7XG5cdFx0dGhpcy5yZWxhdGVkVGFyZ2V0ID0gc3JjLnJlbGF0ZWRUYXJnZXQ7XG5cblx0Ly8gRXZlbnQgdHlwZVxuXHR9IGVsc2Uge1xuXHRcdHRoaXMudHlwZSA9IHNyYztcblx0fVxuXG5cdC8vIFB1dCBleHBsaWNpdGx5IHByb3ZpZGVkIHByb3BlcnRpZXMgb250byB0aGUgZXZlbnQgb2JqZWN0XG5cdGlmICggcHJvcHMgKSB7XG5cdFx0alF1ZXJ5LmV4dGVuZCggdGhpcywgcHJvcHMgKTtcblx0fVxuXG5cdC8vIENyZWF0ZSBhIHRpbWVzdGFtcCBpZiBpbmNvbWluZyBldmVudCBkb2Vzbid0IGhhdmUgb25lXG5cdHRoaXMudGltZVN0YW1wID0gc3JjICYmIHNyYy50aW1lU3RhbXAgfHwgRGF0ZS5ub3coKTtcblxuXHQvLyBNYXJrIGl0IGFzIGZpeGVkXG5cdHRoaXNbIGpRdWVyeS5leHBhbmRvIF0gPSB0cnVlO1xufTtcblxuLy8galF1ZXJ5LkV2ZW50IGlzIGJhc2VkIG9uIERPTTMgRXZlbnRzIGFzIHNwZWNpZmllZCBieSB0aGUgRUNNQVNjcmlwdCBMYW5ndWFnZSBCaW5kaW5nXG4vLyBodHRwczovL3d3dy53My5vcmcvVFIvMjAwMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAwMzAzMzEvZWNtYS1zY3JpcHQtYmluZGluZy5odG1sXG5qUXVlcnkuRXZlbnQucHJvdG90eXBlID0ge1xuXHRjb25zdHJ1Y3RvcjogalF1ZXJ5LkV2ZW50LFxuXHRpc0RlZmF1bHRQcmV2ZW50ZWQ6IHJldHVybkZhbHNlLFxuXHRpc1Byb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG5cdGlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcblx0aXNTaW11bGF0ZWQ6IGZhbHNlLFxuXG5cdHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCApIHtcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHR9XG5cdH0sXG5cdHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCApIHtcblx0XHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0fVxuXHR9LFxuXHRzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XG5cdFx0XHRlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXHRcdH1cblxuXHRcdHRoaXMuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdH1cbn07XG5cbi8vIEluY2x1ZGVzIGFsbCBjb21tb24gZXZlbnQgcHJvcHMgaW5jbHVkaW5nIEtleUV2ZW50IGFuZCBNb3VzZUV2ZW50IHNwZWNpZmljIHByb3BzXG5qUXVlcnkuZWFjaCgge1xuXHRhbHRLZXk6IHRydWUsXG5cdGJ1YmJsZXM6IHRydWUsXG5cdGNhbmNlbGFibGU6IHRydWUsXG5cdGNoYW5nZWRUb3VjaGVzOiB0cnVlLFxuXHRjdHJsS2V5OiB0cnVlLFxuXHRkZXRhaWw6IHRydWUsXG5cdGV2ZW50UGhhc2U6IHRydWUsXG5cdG1ldGFLZXk6IHRydWUsXG5cdHBhZ2VYOiB0cnVlLFxuXHRwYWdlWTogdHJ1ZSxcblx0c2hpZnRLZXk6IHRydWUsXG5cdHZpZXc6IHRydWUsXG5cdFwiY2hhclwiOiB0cnVlLFxuXHRjb2RlOiB0cnVlLFxuXHRjaGFyQ29kZTogdHJ1ZSxcblx0a2V5OiB0cnVlLFxuXHRrZXlDb2RlOiB0cnVlLFxuXHRidXR0b246IHRydWUsXG5cdGJ1dHRvbnM6IHRydWUsXG5cdGNsaWVudFg6IHRydWUsXG5cdGNsaWVudFk6IHRydWUsXG5cdG9mZnNldFg6IHRydWUsXG5cdG9mZnNldFk6IHRydWUsXG5cdHBvaW50ZXJJZDogdHJ1ZSxcblx0cG9pbnRlclR5cGU6IHRydWUsXG5cdHNjcmVlblg6IHRydWUsXG5cdHNjcmVlblk6IHRydWUsXG5cdHRhcmdldFRvdWNoZXM6IHRydWUsXG5cdHRvRWxlbWVudDogdHJ1ZSxcblx0dG91Y2hlczogdHJ1ZSxcblx0d2hpY2g6IHRydWVcbn0sIGpRdWVyeS5ldmVudC5hZGRQcm9wICk7XG5cbmpRdWVyeS5lYWNoKCB7IGZvY3VzOiBcImZvY3VzaW5cIiwgYmx1cjogXCJmb2N1c291dFwiIH0sIGZ1bmN0aW9uKCB0eXBlLCBkZWxlZ2F0ZVR5cGUgKSB7XG5cblx0ZnVuY3Rpb24gZm9jdXNNYXBwZWRIYW5kbGVyKCBuYXRpdmVFdmVudCApIHtcblx0XHRpZiAoIGRvY3VtZW50LmRvY3VtZW50TW9kZSApIHtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgMTErXG5cdFx0XHQvLyBBdHRhY2ggYSBzaW5nbGUgZm9jdXNpbi9mb2N1c291dCBoYW5kbGVyIG9uIHRoZSBkb2N1bWVudCB3aGlsZSBzb21lb25lIHdhbnRzXG5cdFx0XHQvLyBmb2N1cy9ibHVyLiBUaGlzIGlzIGJlY2F1c2UgdGhlIGZvcm1lciBhcmUgc3luY2hyb25vdXMgaW4gSUUgd2hpbGUgdGhlIGxhdHRlclxuXHRcdFx0Ly8gYXJlIGFzeW5jLiBJbiBvdGhlciBicm93c2VycywgYWxsIHRob3NlIGhhbmRsZXJzIGFyZSBpbnZva2VkIHN5bmNocm9ub3VzbHkuXG5cblx0XHRcdC8vIGBoYW5kbGVgIGZyb20gcHJpdmF0ZSBkYXRhIHdvdWxkIGFscmVhZHkgd3JhcCB0aGUgZXZlbnQsIGJ1dCB3ZSBuZWVkXG5cdFx0XHQvLyB0byBjaGFuZ2UgdGhlIGB0eXBlYCBoZXJlLlxuXHRcdFx0dmFyIGhhbmRsZSA9IGRhdGFQcml2LmdldCggdGhpcywgXCJoYW5kbGVcIiApLFxuXHRcdFx0XHRldmVudCA9IGpRdWVyeS5ldmVudC5maXgoIG5hdGl2ZUV2ZW50ICk7XG5cdFx0XHRldmVudC50eXBlID0gbmF0aXZlRXZlbnQudHlwZSA9PT0gXCJmb2N1c2luXCIgPyBcImZvY3VzXCIgOiBcImJsdXJcIjtcblx0XHRcdGV2ZW50LmlzU2ltdWxhdGVkID0gdHJ1ZTtcblxuXHRcdFx0Ly8gRmlyc3QsIGhhbmRsZSBmb2N1c2luL2ZvY3Vzb3V0XG5cdFx0XHRoYW5kbGUoIG5hdGl2ZUV2ZW50ICk7XG5cblx0XHRcdC8vIC4uLnRoZW4sIGhhbmRsZSBmb2N1cy9ibHVyXG5cdFx0XHQvL1xuXHRcdFx0Ly8gZm9jdXMvYmx1ciBkb24ndCBidWJibGUgd2hpbGUgZm9jdXNpbi9mb2N1c291dCBkbzsgc2ltdWxhdGUgdGhlIGZvcm1lciBieSBvbmx5XG5cdFx0XHQvLyBpbnZva2luZyB0aGUgaGFuZGxlciBhdCB0aGUgbG93ZXIgbGV2ZWwuXG5cdFx0XHRpZiAoIGV2ZW50LnRhcmdldCA9PT0gZXZlbnQuY3VycmVudFRhcmdldCApIHtcblxuXHRcdFx0XHQvLyBUaGUgc2V0dXAgcGFydCBjYWxscyBgbGV2ZXJhZ2VOYXRpdmVgLCB3aGljaCwgaW4gdHVybiwgY2FsbHNcblx0XHRcdFx0Ly8gYGpRdWVyeS5ldmVudC5hZGRgLCBzbyBldmVudCBoYW5kbGUgd2lsbCBhbHJlYWR5IGhhdmUgYmVlbiBzZXRcblx0XHRcdFx0Ly8gYnkgdGhpcyBwb2ludC5cblx0XHRcdFx0aGFuZGxlKCBldmVudCApO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIEZvciBub24tSUUgYnJvd3NlcnMsIGF0dGFjaCBhIHNpbmdsZSBjYXB0dXJpbmcgaGFuZGxlciBvbiB0aGUgZG9jdW1lbnRcblx0XHRcdC8vIHdoaWxlIHNvbWVvbmUgd2FudHMgZm9jdXNpbi9mb2N1c291dC5cblx0XHRcdGpRdWVyeS5ldmVudC5zaW11bGF0ZSggZGVsZWdhdGVUeXBlLCBuYXRpdmVFdmVudC50YXJnZXQsXG5cdFx0XHRcdGpRdWVyeS5ldmVudC5maXgoIG5hdGl2ZUV2ZW50ICkgKTtcblx0XHR9XG5cdH1cblxuXHRqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdID0ge1xuXG5cdFx0Ly8gVXRpbGl6ZSBuYXRpdmUgZXZlbnQgaWYgcG9zc2libGUgc28gYmx1ci9mb2N1cyBzZXF1ZW5jZSBpcyBjb3JyZWN0XG5cdFx0c2V0dXA6IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHR2YXIgYXR0YWNoZXM7XG5cblx0XHRcdC8vIENsYWltIHRoZSBmaXJzdCBoYW5kbGVyXG5cdFx0XHQvLyBkYXRhUHJpdi5zZXQoIHRoaXMsIFwiZm9jdXNcIiwgLi4uIClcblx0XHRcdC8vIGRhdGFQcml2LnNldCggdGhpcywgXCJibHVyXCIsIC4uLiApXG5cdFx0XHRsZXZlcmFnZU5hdGl2ZSggdGhpcywgdHlwZSwgdHJ1ZSApO1xuXG5cdFx0XHRpZiAoIGRvY3VtZW50LmRvY3VtZW50TW9kZSApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA5IC0gMTErXG5cdFx0XHRcdC8vIFdlIHVzZSB0aGUgc2FtZSBuYXRpdmUgaGFuZGxlciBmb3IgZm9jdXNpbiAmIGZvY3VzIChhbmQgZm9jdXNvdXQgJiBibHVyKVxuXHRcdFx0XHQvLyBzbyB3ZSBuZWVkIHRvIGNvb3JkaW5hdGUgc2V0dXAgJiB0ZWFyZG93biBwYXJ0cyBiZXR3ZWVuIHRob3NlIGV2ZW50cy5cblx0XHRcdFx0Ly8gVXNlIGBkZWxlZ2F0ZVR5cGVgIGFzIHRoZSBrZXkgYXMgYHR5cGVgIGlzIGFscmVhZHkgdXNlZCBieSBgbGV2ZXJhZ2VOYXRpdmVgLlxuXHRcdFx0XHRhdHRhY2hlcyA9IGRhdGFQcml2LmdldCggdGhpcywgZGVsZWdhdGVUeXBlICk7XG5cdFx0XHRcdGlmICggIWF0dGFjaGVzICkge1xuXHRcdFx0XHRcdHRoaXMuYWRkRXZlbnRMaXN0ZW5lciggZGVsZWdhdGVUeXBlLCBmb2N1c01hcHBlZEhhbmRsZXIgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkYXRhUHJpdi5zZXQoIHRoaXMsIGRlbGVnYXRlVHlwZSwgKCBhdHRhY2hlcyB8fCAwICkgKyAxICk7XG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIFJldHVybiBmYWxzZSB0byBhbGxvdyBub3JtYWwgcHJvY2Vzc2luZyBpbiB0aGUgY2FsbGVyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHRyaWdnZXI6IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBGb3JjZSBzZXR1cCBiZWZvcmUgdHJpZ2dlclxuXHRcdFx0bGV2ZXJhZ2VOYXRpdmUoIHRoaXMsIHR5cGUgKTtcblxuXHRcdFx0Ly8gUmV0dXJuIG5vbi1mYWxzZSB0byBhbGxvdyBub3JtYWwgZXZlbnQtcGF0aCBwcm9wYWdhdGlvblxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblxuXHRcdHRlYXJkb3duOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBhdHRhY2hlcztcblxuXHRcdFx0aWYgKCBkb2N1bWVudC5kb2N1bWVudE1vZGUgKSB7XG5cdFx0XHRcdGF0dGFjaGVzID0gZGF0YVByaXYuZ2V0KCB0aGlzLCBkZWxlZ2F0ZVR5cGUgKSAtIDE7XG5cdFx0XHRcdGlmICggIWF0dGFjaGVzICkge1xuXHRcdFx0XHRcdHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lciggZGVsZWdhdGVUeXBlLCBmb2N1c01hcHBlZEhhbmRsZXIgKTtcblx0XHRcdFx0XHRkYXRhUHJpdi5yZW1vdmUoIHRoaXMsIGRlbGVnYXRlVHlwZSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRhdGFQcml2LnNldCggdGhpcywgZGVsZWdhdGVUeXBlLCBhdHRhY2hlcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIFJldHVybiBmYWxzZSB0byBpbmRpY2F0ZSBzdGFuZGFyZCB0ZWFyZG93biBzaG91bGQgYmUgYXBwbGllZFxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8vIFN1cHByZXNzIG5hdGl2ZSBmb2N1cyBvciBibHVyIGlmIHdlJ3JlIGN1cnJlbnRseSBpbnNpZGVcblx0XHQvLyBhIGxldmVyYWdlZCBuYXRpdmUtZXZlbnQgc3RhY2tcblx0XHRfZGVmYXVsdDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0cmV0dXJuIGRhdGFQcml2LmdldCggZXZlbnQudGFyZ2V0LCB0eXBlICk7XG5cdFx0fSxcblxuXHRcdGRlbGVnYXRlVHlwZTogZGVsZWdhdGVUeXBlXG5cdH07XG5cblx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTQ0XG5cdC8vIEZpcmVmb3ggZG9lc24ndCBoYXZlIGZvY3VzKGluIHwgb3V0KSBldmVudHNcblx0Ly8gUmVsYXRlZCB0aWNrZXQgLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02ODc3ODdcblx0Ly9cblx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9NDggLSA0OSwgU2FmYXJpIDw9OS4wIC0gOS4xXG5cdC8vIGZvY3VzKGluIHwgb3V0KSBldmVudHMgZmlyZSBhZnRlciBmb2N1cyAmIGJsdXIgZXZlbnRzLFxuXHQvLyB3aGljaCBpcyBzcGVjIHZpb2xhdGlvbiAtIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnRzLWZvY3VzZXZlbnQtZXZlbnQtb3JkZXJcblx0Ly8gUmVsYXRlZCB0aWNrZXQgLSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00NDk4NTdcblx0Ly9cblx0Ly8gU3VwcG9ydDogSUUgOSAtIDExK1xuXHQvLyBUbyBwcmVzZXJ2ZSByZWxhdGl2ZSBmb2N1c2luL2ZvY3VzICYgZm9jdXNvdXQvYmx1ciBldmVudCBvcmRlciBndWFyYW50ZWVkIG9uIHRoZSAzLnggYnJhbmNoLFxuXHQvLyBhdHRhY2ggYSBzaW5nbGUgaGFuZGxlciBmb3IgYm90aCBldmVudHMgaW4gSUUuXG5cdGpRdWVyeS5ldmVudC5zcGVjaWFsWyBkZWxlZ2F0ZVR5cGUgXSA9IHtcblx0XHRzZXR1cDogZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIEhhbmRsZTogcmVndWxhciBub2RlcyAodmlhIGB0aGlzLm93bmVyRG9jdW1lbnRgKSwgd2luZG93XG5cdFx0XHQvLyAodmlhIGB0aGlzLmRvY3VtZW50YCkgJiBkb2N1bWVudCAodmlhIGB0aGlzYCkuXG5cdFx0XHR2YXIgZG9jID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMuZG9jdW1lbnQgfHwgdGhpcyxcblx0XHRcdFx0ZGF0YUhvbGRlciA9IGRvY3VtZW50LmRvY3VtZW50TW9kZSA/IHRoaXMgOiBkb2MsXG5cdFx0XHRcdGF0dGFjaGVzID0gZGF0YVByaXYuZ2V0KCBkYXRhSG9sZGVyLCBkZWxlZ2F0ZVR5cGUgKTtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgOSAtIDExK1xuXHRcdFx0Ly8gV2UgdXNlIHRoZSBzYW1lIG5hdGl2ZSBoYW5kbGVyIGZvciBmb2N1c2luICYgZm9jdXMgKGFuZCBmb2N1c291dCAmIGJsdXIpXG5cdFx0XHQvLyBzbyB3ZSBuZWVkIHRvIGNvb3JkaW5hdGUgc2V0dXAgJiB0ZWFyZG93biBwYXJ0cyBiZXR3ZWVuIHRob3NlIGV2ZW50cy5cblx0XHRcdC8vIFVzZSBgZGVsZWdhdGVUeXBlYCBhcyB0aGUga2V5IGFzIGB0eXBlYCBpcyBhbHJlYWR5IHVzZWQgYnkgYGxldmVyYWdlTmF0aXZlYC5cblx0XHRcdGlmICggIWF0dGFjaGVzICkge1xuXHRcdFx0XHRpZiAoIGRvY3VtZW50LmRvY3VtZW50TW9kZSApIHtcblx0XHRcdFx0XHR0aGlzLmFkZEV2ZW50TGlzdGVuZXIoIGRlbGVnYXRlVHlwZSwgZm9jdXNNYXBwZWRIYW5kbGVyICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZG9jLmFkZEV2ZW50TGlzdGVuZXIoIHR5cGUsIGZvY3VzTWFwcGVkSGFuZGxlciwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRkYXRhUHJpdi5zZXQoIGRhdGFIb2xkZXIsIGRlbGVnYXRlVHlwZSwgKCBhdHRhY2hlcyB8fCAwICkgKyAxICk7XG5cdFx0fSxcblx0XHR0ZWFyZG93bjogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgZG9jID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMuZG9jdW1lbnQgfHwgdGhpcyxcblx0XHRcdFx0ZGF0YUhvbGRlciA9IGRvY3VtZW50LmRvY3VtZW50TW9kZSA/IHRoaXMgOiBkb2MsXG5cdFx0XHRcdGF0dGFjaGVzID0gZGF0YVByaXYuZ2V0KCBkYXRhSG9sZGVyLCBkZWxlZ2F0ZVR5cGUgKSAtIDE7XG5cblx0XHRcdGlmICggIWF0dGFjaGVzICkge1xuXHRcdFx0XHRpZiAoIGRvY3VtZW50LmRvY3VtZW50TW9kZSApIHtcblx0XHRcdFx0XHR0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoIGRlbGVnYXRlVHlwZSwgZm9jdXNNYXBwZWRIYW5kbGVyICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoIHR5cGUsIGZvY3VzTWFwcGVkSGFuZGxlciwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRhdGFQcml2LnJlbW92ZSggZGF0YUhvbGRlciwgZGVsZWdhdGVUeXBlICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkYXRhUHJpdi5zZXQoIGRhdGFIb2xkZXIsIGRlbGVnYXRlVHlwZSwgYXR0YWNoZXMgKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG59ICk7XG5cbi8vIENyZWF0ZSBtb3VzZWVudGVyL2xlYXZlIGV2ZW50cyB1c2luZyBtb3VzZW92ZXIvb3V0IGFuZCBldmVudC10aW1lIGNoZWNrc1xuLy8gc28gdGhhdCBldmVudCBkZWxlZ2F0aW9uIHdvcmtzIGluIGpRdWVyeS5cbi8vIERvIHRoZSBzYW1lIGZvciBwb2ludGVyZW50ZXIvcG9pbnRlcmxlYXZlIGFuZCBwb2ludGVyb3Zlci9wb2ludGVyb3V0XG4vL1xuLy8gU3VwcG9ydDogU2FmYXJpIDcgb25seVxuLy8gU2FmYXJpIHNlbmRzIG1vdXNlZW50ZXIgdG9vIG9mdGVuOyBzZWU6XG4vLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00NzAyNThcbi8vIGZvciB0aGUgZGVzY3JpcHRpb24gb2YgdGhlIGJ1ZyAoaXQgZXhpc3RlZCBpbiBvbGRlciBDaHJvbWUgdmVyc2lvbnMgYXMgd2VsbCkuXG5qUXVlcnkuZWFjaCgge1xuXHRtb3VzZWVudGVyOiBcIm1vdXNlb3ZlclwiLFxuXHRtb3VzZWxlYXZlOiBcIm1vdXNlb3V0XCIsXG5cdHBvaW50ZXJlbnRlcjogXCJwb2ludGVyb3ZlclwiLFxuXHRwb2ludGVybGVhdmU6IFwicG9pbnRlcm91dFwiXG59LCBmdW5jdGlvbiggb3JpZywgZml4ICkge1xuXHRqUXVlcnkuZXZlbnQuc3BlY2lhbFsgb3JpZyBdID0ge1xuXHRcdGRlbGVnYXRlVHlwZTogZml4LFxuXHRcdGJpbmRUeXBlOiBmaXgsXG5cblx0XHRoYW5kbGU6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdHZhciByZXQsXG5cdFx0XHRcdHRhcmdldCA9IHRoaXMsXG5cdFx0XHRcdHJlbGF0ZWQgPSBldmVudC5yZWxhdGVkVGFyZ2V0LFxuXHRcdFx0XHRoYW5kbGVPYmogPSBldmVudC5oYW5kbGVPYmo7XG5cblx0XHRcdC8vIEZvciBtb3VzZWVudGVyL2xlYXZlIGNhbGwgdGhlIGhhbmRsZXIgaWYgcmVsYXRlZCBpcyBvdXRzaWRlIHRoZSB0YXJnZXQuXG5cdFx0XHQvLyBOQjogTm8gcmVsYXRlZFRhcmdldCBpZiB0aGUgbW91c2UgbGVmdC9lbnRlcmVkIHRoZSBicm93c2VyIHdpbmRvd1xuXHRcdFx0aWYgKCAhcmVsYXRlZCB8fCAoIHJlbGF0ZWQgIT09IHRhcmdldCAmJiAhalF1ZXJ5LmNvbnRhaW5zKCB0YXJnZXQsIHJlbGF0ZWQgKSApICkge1xuXHRcdFx0XHRldmVudC50eXBlID0gaGFuZGxlT2JqLm9yaWdUeXBlO1xuXHRcdFx0XHRyZXQgPSBoYW5kbGVPYmouaGFuZGxlci5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdGV2ZW50LnR5cGUgPSBmaXg7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblx0fTtcbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdG9uOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gb24oIHRoaXMsIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKTtcblx0fSxcblx0b25lOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gb24oIHRoaXMsIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4sIDEgKTtcblx0fSxcblx0b2ZmOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBmbiApIHtcblx0XHR2YXIgaGFuZGxlT2JqLCB0eXBlO1xuXHRcdGlmICggdHlwZXMgJiYgdHlwZXMucHJldmVudERlZmF1bHQgJiYgdHlwZXMuaGFuZGxlT2JqICkge1xuXG5cdFx0XHQvLyAoIGV2ZW50ICkgIGRpc3BhdGNoZWQgalF1ZXJ5LkV2ZW50XG5cdFx0XHRoYW5kbGVPYmogPSB0eXBlcy5oYW5kbGVPYmo7XG5cdFx0XHRqUXVlcnkoIHR5cGVzLmRlbGVnYXRlVGFyZ2V0ICkub2ZmKFxuXHRcdFx0XHRoYW5kbGVPYmoubmFtZXNwYWNlID9cblx0XHRcdFx0XHRoYW5kbGVPYmoub3JpZ1R5cGUgKyBcIi5cIiArIGhhbmRsZU9iai5uYW1lc3BhY2UgOlxuXHRcdFx0XHRcdGhhbmRsZU9iai5vcmlnVHlwZSxcblx0XHRcdFx0aGFuZGxlT2JqLnNlbGVjdG9yLFxuXHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlclxuXHRcdFx0KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRpZiAoIHR5cGVvZiB0eXBlcyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcy1vYmplY3QgWywgc2VsZWN0b3JdIClcblx0XHRcdGZvciAoIHR5cGUgaW4gdHlwZXMgKSB7XG5cdFx0XHRcdHRoaXMub2ZmKCB0eXBlLCBzZWxlY3RvciwgdHlwZXNbIHR5cGUgXSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdGlmICggc2VsZWN0b3IgPT09IGZhbHNlIHx8IHR5cGVvZiBzZWxlY3RvciA9PT0gXCJmdW5jdGlvblwiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzIFssIGZuXSApXG5cdFx0XHRmbiA9IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGlmICggZm4gPT09IGZhbHNlICkge1xuXHRcdFx0Zm4gPSByZXR1cm5GYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCB0aGlzLCB0eXBlcywgZm4sIHNlbGVjdG9yICk7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cblxudmFyXG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMCAtIDExLCBFZGdlIDEyIC0gMTMgb25seVxuXHQvLyBJbiBJRS9FZGdlIHVzaW5nIHJlZ2V4IGdyb3VwcyBoZXJlIGNhdXNlcyBzZXZlcmUgc2xvd2Rvd25zLlxuXHQvLyBTZWUgaHR0cHM6Ly9jb25uZWN0Lm1pY3Jvc29mdC5jb20vSUUvZmVlZGJhY2svZGV0YWlscy8xNzM2NTEyL1xuXHRybm9Jbm5lcmh0bWwgPSAvPHNjcmlwdHw8c3R5bGV8PGxpbmsvaSxcblxuXHQvLyBjaGVja2VkPVwiY2hlY2tlZFwiIG9yIGNoZWNrZWRcblx0cmNoZWNrZWQgPSAvY2hlY2tlZFxccyooPzpbXj1dfD1cXHMqLmNoZWNrZWQuKS9pLFxuXG5cdHJjbGVhblNjcmlwdCA9IC9eXFxzKjwhXFxbQ0RBVEFcXFt8XFxdXFxdPlxccyokL2c7XG5cbi8vIFByZWZlciBhIHRib2R5IG92ZXIgaXRzIHBhcmVudCB0YWJsZSBmb3IgY29udGFpbmluZyBuZXcgcm93c1xuZnVuY3Rpb24gbWFuaXB1bGF0aW9uVGFyZ2V0KCBlbGVtLCBjb250ZW50ICkge1xuXHRpZiAoIG5vZGVOYW1lKCBlbGVtLCBcInRhYmxlXCIgKSAmJlxuXHRcdG5vZGVOYW1lKCBjb250ZW50Lm5vZGVUeXBlICE9PSAxMSA/IGNvbnRlbnQgOiBjb250ZW50LmZpcnN0Q2hpbGQsIFwidHJcIiApICkge1xuXG5cdFx0cmV0dXJuIGpRdWVyeSggZWxlbSApLmNoaWxkcmVuKCBcInRib2R5XCIgKVsgMCBdIHx8IGVsZW07XG5cdH1cblxuXHRyZXR1cm4gZWxlbTtcbn1cblxuLy8gUmVwbGFjZS9yZXN0b3JlIHRoZSB0eXBlIGF0dHJpYnV0ZSBvZiBzY3JpcHQgZWxlbWVudHMgZm9yIHNhZmUgRE9NIG1hbmlwdWxhdGlvblxuZnVuY3Rpb24gZGlzYWJsZVNjcmlwdCggZWxlbSApIHtcblx0ZWxlbS50eXBlID0gKCBlbGVtLmdldEF0dHJpYnV0ZSggXCJ0eXBlXCIgKSAhPT0gbnVsbCApICsgXCIvXCIgKyBlbGVtLnR5cGU7XG5cdHJldHVybiBlbGVtO1xufVxuZnVuY3Rpb24gcmVzdG9yZVNjcmlwdCggZWxlbSApIHtcblx0aWYgKCAoIGVsZW0udHlwZSB8fCBcIlwiICkuc2xpY2UoIDAsIDUgKSA9PT0gXCJ0cnVlL1wiICkge1xuXHRcdGVsZW0udHlwZSA9IGVsZW0udHlwZS5zbGljZSggNSApO1xuXHR9IGVsc2Uge1xuXHRcdGVsZW0ucmVtb3ZlQXR0cmlidXRlKCBcInR5cGVcIiApO1xuXHR9XG5cblx0cmV0dXJuIGVsZW07XG59XG5cbmZ1bmN0aW9uIGNsb25lQ29weUV2ZW50KCBzcmMsIGRlc3QgKSB7XG5cdHZhciBpLCBsLCB0eXBlLCBwZGF0YU9sZCwgdWRhdGFPbGQsIHVkYXRhQ3VyLCBldmVudHM7XG5cblx0aWYgKCBkZXN0Lm5vZGVUeXBlICE9PSAxICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIDEuIENvcHkgcHJpdmF0ZSBkYXRhOiBldmVudHMsIGhhbmRsZXJzLCBldGMuXG5cdGlmICggZGF0YVByaXYuaGFzRGF0YSggc3JjICkgKSB7XG5cdFx0cGRhdGFPbGQgPSBkYXRhUHJpdi5nZXQoIHNyYyApO1xuXHRcdGV2ZW50cyA9IHBkYXRhT2xkLmV2ZW50cztcblxuXHRcdGlmICggZXZlbnRzICkge1xuXHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBkZXN0LCBcImhhbmRsZSBldmVudHNcIiApO1xuXG5cdFx0XHRmb3IgKCB0eXBlIGluIGV2ZW50cyApIHtcblx0XHRcdFx0Zm9yICggaSA9IDAsIGwgPSBldmVudHNbIHR5cGUgXS5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LmFkZCggZGVzdCwgdHlwZSwgZXZlbnRzWyB0eXBlIF1bIGkgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gMi4gQ29weSB1c2VyIGRhdGFcblx0aWYgKCBkYXRhVXNlci5oYXNEYXRhKCBzcmMgKSApIHtcblx0XHR1ZGF0YU9sZCA9IGRhdGFVc2VyLmFjY2Vzcyggc3JjICk7XG5cdFx0dWRhdGFDdXIgPSBqUXVlcnkuZXh0ZW5kKCB7fSwgdWRhdGFPbGQgKTtcblxuXHRcdGRhdGFVc2VyLnNldCggZGVzdCwgdWRhdGFDdXIgKTtcblx0fVxufVxuXG4vLyBGaXggSUUgYnVncywgc2VlIHN1cHBvcnQgdGVzdHNcbmZ1bmN0aW9uIGZpeElucHV0KCBzcmMsIGRlc3QgKSB7XG5cdHZhciBub2RlTmFtZSA9IGRlc3Qubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblxuXHQvLyBGYWlscyB0byBwZXJzaXN0IHRoZSBjaGVja2VkIHN0YXRlIG9mIGEgY2xvbmVkIGNoZWNrYm94IG9yIHJhZGlvIGJ1dHRvbi5cblx0aWYgKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiICYmIHJjaGVja2FibGVUeXBlLnRlc3QoIHNyYy50eXBlICkgKSB7XG5cdFx0ZGVzdC5jaGVja2VkID0gc3JjLmNoZWNrZWQ7XG5cblx0Ly8gRmFpbHMgdG8gcmV0dXJuIHRoZSBzZWxlY3RlZCBvcHRpb24gdG8gdGhlIGRlZmF1bHQgc2VsZWN0ZWQgc3RhdGUgd2hlbiBjbG9uaW5nIG9wdGlvbnNcblx0fSBlbHNlIGlmICggbm9kZU5hbWUgPT09IFwiaW5wdXRcIiB8fCBub2RlTmFtZSA9PT0gXCJ0ZXh0YXJlYVwiICkge1xuXHRcdGRlc3QuZGVmYXVsdFZhbHVlID0gc3JjLmRlZmF1bHRWYWx1ZTtcblx0fVxufVxuXG5mdW5jdGlvbiBkb21NYW5pcCggY29sbGVjdGlvbiwgYXJncywgY2FsbGJhY2ssIGlnbm9yZWQgKSB7XG5cblx0Ly8gRmxhdHRlbiBhbnkgbmVzdGVkIGFycmF5c1xuXHRhcmdzID0gZmxhdCggYXJncyApO1xuXG5cdHZhciBmcmFnbWVudCwgZmlyc3QsIHNjcmlwdHMsIGhhc1NjcmlwdHMsIG5vZGUsIGRvYyxcblx0XHRpID0gMCxcblx0XHRsID0gY29sbGVjdGlvbi5sZW5ndGgsXG5cdFx0aU5vQ2xvbmUgPSBsIC0gMSxcblx0XHR2YWx1ZSA9IGFyZ3NbIDAgXSxcblx0XHR2YWx1ZUlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uKCB2YWx1ZSApO1xuXG5cdC8vIFdlIGNhbid0IGNsb25lTm9kZSBmcmFnbWVudHMgdGhhdCBjb250YWluIGNoZWNrZWQsIGluIFdlYktpdFxuXHRpZiAoIHZhbHVlSXNGdW5jdGlvbiB8fFxuXHRcdFx0KCBsID4gMSAmJiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiZcblx0XHRcdFx0IXN1cHBvcnQuY2hlY2tDbG9uZSAmJiByY2hlY2tlZC50ZXN0KCB2YWx1ZSApICkgKSB7XG5cdFx0cmV0dXJuIGNvbGxlY3Rpb24uZWFjaCggZnVuY3Rpb24oIGluZGV4ICkge1xuXHRcdFx0dmFyIHNlbGYgPSBjb2xsZWN0aW9uLmVxKCBpbmRleCApO1xuXHRcdFx0aWYgKCB2YWx1ZUlzRnVuY3Rpb24gKSB7XG5cdFx0XHRcdGFyZ3NbIDAgXSA9IHZhbHVlLmNhbGwoIHRoaXMsIGluZGV4LCBzZWxmLmh0bWwoKSApO1xuXHRcdFx0fVxuXHRcdFx0ZG9tTWFuaXAoIHNlbGYsIGFyZ3MsIGNhbGxiYWNrLCBpZ25vcmVkICk7XG5cdFx0fSApO1xuXHR9XG5cblx0aWYgKCBsICkge1xuXHRcdGZyYWdtZW50ID0gYnVpbGRGcmFnbWVudCggYXJncywgY29sbGVjdGlvblsgMCBdLm93bmVyRG9jdW1lbnQsIGZhbHNlLCBjb2xsZWN0aW9uLCBpZ25vcmVkICk7XG5cdFx0Zmlyc3QgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuXG5cdFx0aWYgKCBmcmFnbWVudC5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSApIHtcblx0XHRcdGZyYWdtZW50ID0gZmlyc3Q7XG5cdFx0fVxuXG5cdFx0Ly8gUmVxdWlyZSBlaXRoZXIgbmV3IGNvbnRlbnQgb3IgYW4gaW50ZXJlc3QgaW4gaWdub3JlZCBlbGVtZW50cyB0byBpbnZva2UgdGhlIGNhbGxiYWNrXG5cdFx0aWYgKCBmaXJzdCB8fCBpZ25vcmVkICkge1xuXHRcdFx0c2NyaXB0cyA9IGpRdWVyeS5tYXAoIGdldEFsbCggZnJhZ21lbnQsIFwic2NyaXB0XCIgKSwgZGlzYWJsZVNjcmlwdCApO1xuXHRcdFx0aGFzU2NyaXB0cyA9IHNjcmlwdHMubGVuZ3RoO1xuXG5cdFx0XHQvLyBVc2UgdGhlIG9yaWdpbmFsIGZyYWdtZW50IGZvciB0aGUgbGFzdCBpdGVtXG5cdFx0XHQvLyBpbnN0ZWFkIG9mIHRoZSBmaXJzdCBiZWNhdXNlIGl0IGNhbiBlbmQgdXBcblx0XHRcdC8vIGJlaW5nIGVtcHRpZWQgaW5jb3JyZWN0bHkgaW4gY2VydGFpbiBzaXR1YXRpb25zICh0cmFjLTgwNzApLlxuXHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRub2RlID0gZnJhZ21lbnQ7XG5cblx0XHRcdFx0aWYgKCBpICE9PSBpTm9DbG9uZSApIHtcblx0XHRcdFx0XHRub2RlID0galF1ZXJ5LmNsb25lKCBub2RlLCB0cnVlLCB0cnVlICk7XG5cblx0XHRcdFx0XHQvLyBLZWVwIHJlZmVyZW5jZXMgdG8gY2xvbmVkIHNjcmlwdHMgZm9yIGxhdGVyIHJlc3RvcmF0aW9uXG5cdFx0XHRcdFx0aWYgKCBoYXNTY3JpcHRzICkge1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0XHRcdFx0XHRcdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdFx0XHRcdGpRdWVyeS5tZXJnZSggc2NyaXB0cywgZ2V0QWxsKCBub2RlLCBcInNjcmlwdFwiICkgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjYWxsYmFjay5jYWxsKCBjb2xsZWN0aW9uWyBpIF0sIG5vZGUsIGkgKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBoYXNTY3JpcHRzICkge1xuXHRcdFx0XHRkb2MgPSBzY3JpcHRzWyBzY3JpcHRzLmxlbmd0aCAtIDEgXS5vd25lckRvY3VtZW50O1xuXG5cdFx0XHRcdC8vIFJlLWVuYWJsZSBzY3JpcHRzXG5cdFx0XHRcdGpRdWVyeS5tYXAoIHNjcmlwdHMsIHJlc3RvcmVTY3JpcHQgKTtcblxuXHRcdFx0XHQvLyBFdmFsdWF0ZSBleGVjdXRhYmxlIHNjcmlwdHMgb24gZmlyc3QgZG9jdW1lbnQgaW5zZXJ0aW9uXG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgaGFzU2NyaXB0czsgaSsrICkge1xuXHRcdFx0XHRcdG5vZGUgPSBzY3JpcHRzWyBpIF07XG5cdFx0XHRcdFx0aWYgKCByc2NyaXB0VHlwZS50ZXN0KCBub2RlLnR5cGUgfHwgXCJcIiApICYmXG5cdFx0XHRcdFx0XHQhZGF0YVByaXYuYWNjZXNzKCBub2RlLCBcImdsb2JhbEV2YWxcIiApICYmXG5cdFx0XHRcdFx0XHRqUXVlcnkuY29udGFpbnMoIGRvYywgbm9kZSApICkge1xuXG5cdFx0XHRcdFx0XHRpZiAoIG5vZGUuc3JjICYmICggbm9kZS50eXBlIHx8IFwiXCIgKS50b0xvd2VyQ2FzZSgpICAhPT0gXCJtb2R1bGVcIiApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBPcHRpb25hbCBBSkFYIGRlcGVuZGVuY3ksIGJ1dCB3b24ndCBydW4gc2NyaXB0cyBpZiBub3QgcHJlc2VudFxuXHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5fZXZhbFVybCAmJiAhbm9kZS5ub01vZHVsZSApIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuX2V2YWxVcmwoIG5vZGUuc3JjLCB7XG5cdFx0XHRcdFx0XHRcdFx0XHRub25jZTogbm9kZS5ub25jZSB8fCBub2RlLmdldEF0dHJpYnV0ZSggXCJub25jZVwiIClcblx0XHRcdFx0XHRcdFx0XHR9LCBkb2MgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBVbndyYXAgYSBDREFUQSBzZWN0aW9uIGNvbnRhaW5pbmcgc2NyaXB0IGNvbnRlbnRzLiBUaGlzIHNob3VsZG4ndCBiZVxuXHRcdFx0XHRcdFx0XHQvLyBuZWVkZWQgYXMgaW4gWE1MIGRvY3VtZW50cyB0aGV5J3JlIGFscmVhZHkgbm90IHZpc2libGUgd2hlblxuXHRcdFx0XHRcdFx0XHQvLyBpbnNwZWN0aW5nIGVsZW1lbnQgY29udGVudHMgYW5kIGluIEhUTUwgZG9jdW1lbnRzIHRoZXkgaGF2ZSBub1xuXHRcdFx0XHRcdFx0XHQvLyBtZWFuaW5nIGJ1dCB3ZSdyZSBwcmVzZXJ2aW5nIHRoYXQgbG9naWMgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuXHRcdFx0XHRcdFx0XHQvLyBUaGlzIHdpbGwgYmUgcmVtb3ZlZCBjb21wbGV0ZWx5IGluIDQuMC4gU2VlIGdoLTQ5MDQuXG5cdFx0XHRcdFx0XHRcdERPTUV2YWwoIG5vZGUudGV4dENvbnRlbnQucmVwbGFjZSggcmNsZWFuU2NyaXB0LCBcIlwiICksIG5vZGUsIGRvYyApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBjb2xsZWN0aW9uO1xufVxuXG5mdW5jdGlvbiByZW1vdmUoIGVsZW0sIHNlbGVjdG9yLCBrZWVwRGF0YSApIHtcblx0dmFyIG5vZGUsXG5cdFx0bm9kZXMgPSBzZWxlY3RvciA/IGpRdWVyeS5maWx0ZXIoIHNlbGVjdG9yLCBlbGVtICkgOiBlbGVtLFxuXHRcdGkgPSAwO1xuXG5cdGZvciAoIDsgKCBub2RlID0gbm9kZXNbIGkgXSApICE9IG51bGw7IGkrKyApIHtcblx0XHRpZiAoICFrZWVwRGF0YSAmJiBub2RlLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBub2RlICkgKTtcblx0XHR9XG5cblx0XHRpZiAoIG5vZGUucGFyZW50Tm9kZSApIHtcblx0XHRcdGlmICgga2VlcERhdGEgJiYgaXNBdHRhY2hlZCggbm9kZSApICkge1xuXHRcdFx0XHRzZXRHbG9iYWxFdmFsKCBnZXRBbGwoIG5vZGUsIFwic2NyaXB0XCIgKSApO1xuXHRcdFx0fVxuXHRcdFx0bm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBub2RlICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW07XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0aHRtbFByZWZpbHRlcjogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0cmV0dXJuIGh0bWw7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCBlbGVtLCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHR2YXIgaSwgbCwgc3JjRWxlbWVudHMsIGRlc3RFbGVtZW50cyxcblx0XHRcdGNsb25lID0gZWxlbS5jbG9uZU5vZGUoIHRydWUgKSxcblx0XHRcdGluUGFnZSA9IGlzQXR0YWNoZWQoIGVsZW0gKTtcblxuXHRcdC8vIEZpeCBJRSBjbG9uaW5nIGlzc3Vlc1xuXHRcdGlmICggIXN1cHBvcnQubm9DbG9uZUNoZWNrZWQgJiYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGVsZW0ubm9kZVR5cGUgPT09IDExICkgJiZcblx0XHRcdFx0IWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXG5cdFx0XHQvLyBXZSBlc2NoZXcgalF1ZXJ5I2ZpbmQgaGVyZSBmb3IgcGVyZm9ybWFuY2UgcmVhc29uczpcblx0XHRcdC8vIGh0dHBzOi8vanNwZXJmLmNvbS9nZXRhbGwtdnMtc2l6emxlLzJcblx0XHRcdGRlc3RFbGVtZW50cyA9IGdldEFsbCggY2xvbmUgKTtcblx0XHRcdHNyY0VsZW1lbnRzID0gZ2V0QWxsKCBlbGVtICk7XG5cblx0XHRcdGZvciAoIGkgPSAwLCBsID0gc3JjRWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRmaXhJbnB1dCggc3JjRWxlbWVudHNbIGkgXSwgZGVzdEVsZW1lbnRzWyBpIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDb3B5IHRoZSBldmVudHMgZnJvbSB0aGUgb3JpZ2luYWwgdG8gdGhlIGNsb25lXG5cdFx0aWYgKCBkYXRhQW5kRXZlbnRzICkge1xuXHRcdFx0aWYgKCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHRcdFx0c3JjRWxlbWVudHMgPSBzcmNFbGVtZW50cyB8fCBnZXRBbGwoIGVsZW0gKTtcblx0XHRcdFx0ZGVzdEVsZW1lbnRzID0gZGVzdEVsZW1lbnRzIHx8IGdldEFsbCggY2xvbmUgKTtcblxuXHRcdFx0XHRmb3IgKCBpID0gMCwgbCA9IHNyY0VsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRjbG9uZUNvcHlFdmVudCggc3JjRWxlbWVudHNbIGkgXSwgZGVzdEVsZW1lbnRzWyBpIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2xvbmVDb3B5RXZlbnQoIGVsZW0sIGNsb25lICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUHJlc2VydmUgc2NyaXB0IGV2YWx1YXRpb24gaGlzdG9yeVxuXHRcdGRlc3RFbGVtZW50cyA9IGdldEFsbCggY2xvbmUsIFwic2NyaXB0XCIgKTtcblx0XHRpZiAoIGRlc3RFbGVtZW50cy5sZW5ndGggPiAwICkge1xuXHRcdFx0c2V0R2xvYmFsRXZhbCggZGVzdEVsZW1lbnRzLCAhaW5QYWdlICYmIGdldEFsbCggZWxlbSwgXCJzY3JpcHRcIiApICk7XG5cdFx0fVxuXG5cdFx0Ly8gUmV0dXJuIHRoZSBjbG9uZWQgc2V0XG5cdFx0cmV0dXJuIGNsb25lO1xuXHR9LFxuXG5cdGNsZWFuRGF0YTogZnVuY3Rpb24oIGVsZW1zICkge1xuXHRcdHZhciBkYXRhLCBlbGVtLCB0eXBlLFxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7ICggZWxlbSA9IGVsZW1zWyBpIF0gKSAhPT0gdW5kZWZpbmVkOyBpKysgKSB7XG5cdFx0XHRpZiAoIGFjY2VwdERhdGEoIGVsZW0gKSApIHtcblx0XHRcdFx0aWYgKCAoIGRhdGEgPSBlbGVtWyBkYXRhUHJpdi5leHBhbmRvIF0gKSApIHtcblx0XHRcdFx0XHRpZiAoIGRhdGEuZXZlbnRzICkge1xuXHRcdFx0XHRcdFx0Zm9yICggdHlwZSBpbiBkYXRhLmV2ZW50cyApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBzcGVjaWFsWyB0eXBlIF0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggZWxlbSwgdHlwZSApO1xuXG5cdFx0XHRcdFx0XHRcdC8vIFRoaXMgaXMgYSBzaG9ydGN1dCB0byBhdm9pZCBqUXVlcnkuZXZlbnQucmVtb3ZlJ3Mgb3ZlcmhlYWRcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkucmVtb3ZlRXZlbnQoIGVsZW0sIHR5cGUsIGRhdGEuaGFuZGxlICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0zNSAtIDQ1K1xuXHRcdFx0XHRcdC8vIEFzc2lnbiB1bmRlZmluZWQgaW5zdGVhZCBvZiB1c2luZyBkZWxldGUsIHNlZSBEYXRhI3JlbW92ZVxuXHRcdFx0XHRcdGVsZW1bIGRhdGFQcml2LmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIGVsZW1bIGRhdGFVc2VyLmV4cGFuZG8gXSApIHtcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTM1IC0gNDUrXG5cdFx0XHRcdFx0Ly8gQXNzaWduIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIHVzaW5nIGRlbGV0ZSwgc2VlIERhdGEjcmVtb3ZlXG5cdFx0XHRcdFx0ZWxlbVsgZGF0YVVzZXIuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZGV0YWNoOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHJlbW92ZSggdGhpcywgc2VsZWN0b3IsIHRydWUgKTtcblx0fSxcblxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gcmVtb3ZlKCB0aGlzLCBzZWxlY3RvciApO1xuXHR9LFxuXG5cdHRleHQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRyZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdGpRdWVyeS50ZXh0KCB0aGlzICkgOlxuXHRcdFx0XHR0aGlzLmVtcHR5KCkuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnRleHRDb250ZW50ID0gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggKTtcblx0fSxcblxuXHRhcHBlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gbWFuaXB1bGF0aW9uVGFyZ2V0KCB0aGlzLCBlbGVtICk7XG5cdFx0XHRcdHRhcmdldC5hcHBlbmRDaGlsZCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRwcmVwZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0dmFyIHRhcmdldCA9IG1hbmlwdWxhdGlvblRhcmdldCggdGhpcywgZWxlbSApO1xuXHRcdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0YXJnZXQuZmlyc3RDaGlsZCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRiZWZvcmU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0aGlzICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGFmdGVyOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0dGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSggZWxlbSwgdGhpcy5uZXh0U2libGluZyApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRlbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGVsZW0sXG5cdFx0XHRpID0gMDtcblxuXHRcdGZvciAoIDsgKCBlbGVtID0gdGhpc1sgaSBdICkgIT0gbnVsbDsgaSsrICkge1xuXHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0XHRcdC8vIFByZXZlbnQgbWVtb3J5IGxlYWtzXG5cdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggZWxlbSwgZmFsc2UgKSApO1xuXG5cdFx0XHRcdC8vIFJlbW92ZSBhbnkgcmVtYWluaW5nIG5vZGVzXG5cdFx0XHRcdGVsZW0udGV4dENvbnRlbnQgPSBcIlwiO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiggZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0ZGF0YUFuZEV2ZW50cyA9IGRhdGFBbmRFdmVudHMgPT0gbnVsbCA/IGZhbHNlIDogZGF0YUFuZEV2ZW50cztcblx0XHRkZWVwRGF0YUFuZEV2ZW50cyA9IGRlZXBEYXRhQW5kRXZlbnRzID09IG51bGwgPyBkYXRhQW5kRXZlbnRzIDogZGVlcERhdGFBbmRFdmVudHM7XG5cblx0XHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5jbG9uZSggdGhpcywgZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKTtcblx0XHR9ICk7XG5cdH0sXG5cblx0aHRtbDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBlbGVtID0gdGhpc1sgMCBdIHx8IHt9LFxuXHRcdFx0XHRpID0gMCxcblx0XHRcdFx0bCA9IHRoaXMubGVuZ3RoO1xuXG5cdFx0XHRpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0cmV0dXJuIGVsZW0uaW5uZXJIVE1MO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZWUgaWYgd2UgY2FuIHRha2UgYSBzaG9ydGN1dCBhbmQganVzdCB1c2UgaW5uZXJIVE1MXG5cdFx0XHRpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiAhcm5vSW5uZXJodG1sLnRlc3QoIHZhbHVlICkgJiZcblx0XHRcdFx0IXdyYXBNYXBbICggcnRhZ05hbWUuZXhlYyggdmFsdWUgKSB8fCBbIFwiXCIsIFwiXCIgXSApWyAxIF0udG9Mb3dlckNhc2UoKSBdICkge1xuXG5cdFx0XHRcdHZhbHVlID0galF1ZXJ5Lmh0bWxQcmVmaWx0ZXIoIHZhbHVlICk7XG5cblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0XHRlbGVtID0gdGhpc1sgaSBdIHx8IHt9O1xuXG5cdFx0XHRcdFx0XHQvLyBSZW1vdmUgZWxlbWVudCBub2RlcyBhbmQgcHJldmVudCBtZW1vcnkgbGVha3Ncblx0XHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBlbGVtLCBmYWxzZSApICk7XG5cdFx0XHRcdFx0XHRcdGVsZW0uaW5uZXJIVE1MID0gdmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0ZWxlbSA9IDA7XG5cblx0XHRcdFx0Ly8gSWYgdXNpbmcgaW5uZXJIVE1MIHRocm93cyBhbiBleGNlcHRpb24sIHVzZSB0aGUgZmFsbGJhY2sgbWV0aG9kXG5cdFx0XHRcdH0gY2F0Y2ggKCBlICkge31cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0XHR0aGlzLmVtcHR5KCkuYXBwZW5kKCB2YWx1ZSApO1xuXHRcdFx0fVxuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH0sXG5cblx0cmVwbGFjZVdpdGg6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBpZ25vcmVkID0gW107XG5cblx0XHQvLyBNYWtlIHRoZSBjaGFuZ2VzLCByZXBsYWNpbmcgZWFjaCBub24taWdub3JlZCBjb250ZXh0IGVsZW1lbnQgd2l0aCB0aGUgbmV3IGNvbnRlbnRcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnROb2RlO1xuXG5cdFx0XHRpZiAoIGpRdWVyeS5pbkFycmF5KCB0aGlzLCBpZ25vcmVkICkgPCAwICkge1xuXHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIHRoaXMgKSApO1xuXHRcdFx0XHRpZiAoIHBhcmVudCApIHtcblx0XHRcdFx0XHRwYXJlbnQucmVwbGFjZUNoaWxkKCBlbGVtLCB0aGlzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEZvcmNlIGNhbGxiYWNrIGludm9jYXRpb25cblx0XHR9LCBpZ25vcmVkICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIHtcblx0YXBwZW5kVG86IFwiYXBwZW5kXCIsXG5cdHByZXBlbmRUbzogXCJwcmVwZW5kXCIsXG5cdGluc2VydEJlZm9yZTogXCJiZWZvcmVcIixcblx0aW5zZXJ0QWZ0ZXI6IFwiYWZ0ZXJcIixcblx0cmVwbGFjZUFsbDogXCJyZXBsYWNlV2l0aFwiXG59LCBmdW5jdGlvbiggbmFtZSwgb3JpZ2luYWwgKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBlbGVtcyxcblx0XHRcdHJldCA9IFtdLFxuXHRcdFx0aW5zZXJ0ID0galF1ZXJ5KCBzZWxlY3RvciApLFxuXHRcdFx0bGFzdCA9IGluc2VydC5sZW5ndGggLSAxLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7IGkgPD0gbGFzdDsgaSsrICkge1xuXHRcdFx0ZWxlbXMgPSBpID09PSBsYXN0ID8gdGhpcyA6IHRoaXMuY2xvbmUoIHRydWUgKTtcblx0XHRcdGpRdWVyeSggaW5zZXJ0WyBpIF0gKVsgb3JpZ2luYWwgXSggZWxlbXMgKTtcblxuXHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHQvLyAuZ2V0KCkgYmVjYXVzZSBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRwdXNoLmFwcGx5KCByZXQsIGVsZW1zLmdldCgpICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCByZXQgKTtcblx0fTtcbn0gKTtcbnZhciBybnVtbm9ucHggPSBuZXcgUmVnRXhwKCBcIl4oXCIgKyBwbnVtICsgXCIpKD8hcHgpW2EteiVdKyRcIiwgXCJpXCIgKTtcblxudmFyIHJjdXN0b21Qcm9wID0gL14tLS87XG5cblxudmFyIGdldFN0eWxlcyA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5LCBGaXJlZm94IDw9MzAgKHRyYWMtMTUwOTgsIHRyYWMtMTQxNTApXG5cdFx0Ly8gSUUgdGhyb3dzIG9uIGVsZW1lbnRzIGNyZWF0ZWQgaW4gcG9wdXBzXG5cdFx0Ly8gRkYgbWVhbndoaWxlIHRocm93cyBvbiBmcmFtZSBlbGVtZW50cyB0aHJvdWdoIFwiZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZVwiXG5cdFx0dmFyIHZpZXcgPSBlbGVtLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG5cblx0XHRpZiAoICF2aWV3IHx8ICF2aWV3Lm9wZW5lciApIHtcblx0XHRcdHZpZXcgPSB3aW5kb3c7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSggZWxlbSApO1xuXHR9O1xuXG52YXIgc3dhcCA9IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBjYWxsYmFjayApIHtcblx0dmFyIHJldCwgbmFtZSxcblx0XHRvbGQgPSB7fTtcblxuXHQvLyBSZW1lbWJlciB0aGUgb2xkIHZhbHVlcywgYW5kIGluc2VydCB0aGUgbmV3IG9uZXNcblx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdG9sZFsgbmFtZSBdID0gZWxlbS5zdHlsZVsgbmFtZSBdO1xuXHRcdGVsZW0uc3R5bGVbIG5hbWUgXSA9IG9wdGlvbnNbIG5hbWUgXTtcblx0fVxuXG5cdHJldCA9IGNhbGxiYWNrLmNhbGwoIGVsZW0gKTtcblxuXHQvLyBSZXZlcnQgdGhlIG9sZCB2YWx1ZXNcblx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdGVsZW0uc3R5bGVbIG5hbWUgXSA9IG9sZFsgbmFtZSBdO1xuXHR9XG5cblx0cmV0dXJuIHJldDtcbn07XG5cblxudmFyIHJib3hTdHlsZSA9IG5ldyBSZWdFeHAoIGNzc0V4cGFuZC5qb2luKCBcInxcIiApLCBcImlcIiApO1xuXG5cblxuKCBmdW5jdGlvbigpIHtcblxuXHQvLyBFeGVjdXRpbmcgYm90aCBwaXhlbFBvc2l0aW9uICYgYm94U2l6aW5nUmVsaWFibGUgdGVzdHMgcmVxdWlyZSBvbmx5IG9uZSBsYXlvdXRcblx0Ly8gc28gdGhleSdyZSBleGVjdXRlZCBhdCB0aGUgc2FtZSB0aW1lIHRvIHNhdmUgdGhlIHNlY29uZCBjb21wdXRhdGlvbi5cblx0ZnVuY3Rpb24gY29tcHV0ZVN0eWxlVGVzdHMoKSB7XG5cblx0XHQvLyBUaGlzIGlzIGEgc2luZ2xldG9uLCB3ZSBuZWVkIHRvIGV4ZWN1dGUgaXQgb25seSBvbmNlXG5cdFx0aWYgKCAhZGl2ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGNvbnRhaW5lci5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0Oi0xMTExMXB4O3dpZHRoOjYwcHg7XCIgK1xuXHRcdFx0XCJtYXJnaW4tdG9wOjFweDtwYWRkaW5nOjA7Ym9yZGVyOjBcIjtcblx0XHRkaXYuc3R5bGUuY3NzVGV4dCA9XG5cdFx0XHRcInBvc2l0aW9uOnJlbGF0aXZlO2Rpc3BsYXk6YmxvY2s7Ym94LXNpemluZzpib3JkZXItYm94O292ZXJmbG93OnNjcm9sbDtcIiArXG5cdFx0XHRcIm1hcmdpbjphdXRvO2JvcmRlcjoxcHg7cGFkZGluZzoxcHg7XCIgK1xuXHRcdFx0XCJ3aWR0aDo2MCU7dG9wOjElXCI7XG5cdFx0ZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKCBjb250YWluZXIgKS5hcHBlbmRDaGlsZCggZGl2ICk7XG5cblx0XHR2YXIgZGl2U3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSggZGl2ICk7XG5cdFx0cGl4ZWxQb3NpdGlvblZhbCA9IGRpdlN0eWxlLnRvcCAhPT0gXCIxJVwiO1xuXG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgLSA0LjMgb25seSwgRmlyZWZveCA8PTMgLSA0NFxuXHRcdHJlbGlhYmxlTWFyZ2luTGVmdFZhbCA9IHJvdW5kUGl4ZWxNZWFzdXJlcyggZGl2U3R5bGUubWFyZ2luTGVmdCApID09PSAxMjtcblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIC0gNC4zIG9ubHksIFNhZmFyaSA8PTkuMSAtIDEwLjEsIGlPUyA8PTcuMCAtIDkuM1xuXHRcdC8vIFNvbWUgc3R5bGVzIGNvbWUgYmFjayB3aXRoIHBlcmNlbnRhZ2UgdmFsdWVzLCBldmVuIHRob3VnaCB0aGV5IHNob3VsZG4ndFxuXHRcdGRpdi5zdHlsZS5yaWdodCA9IFwiNjAlXCI7XG5cdFx0cGl4ZWxCb3hTdHlsZXNWYWwgPSByb3VuZFBpeGVsTWVhc3VyZXMoIGRpdlN0eWxlLnJpZ2h0ICkgPT09IDM2O1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgOSAtIDExIG9ubHlcblx0XHQvLyBEZXRlY3QgbWlzcmVwb3J0aW5nIG9mIGNvbnRlbnQgZGltZW5zaW9ucyBmb3IgYm94LXNpemluZzpib3JkZXItYm94IGVsZW1lbnRzXG5cdFx0Ym94U2l6aW5nUmVsaWFibGVWYWwgPSByb3VuZFBpeGVsTWVhc3VyZXMoIGRpdlN0eWxlLndpZHRoICkgPT09IDM2O1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgOSBvbmx5XG5cdFx0Ly8gRGV0ZWN0IG92ZXJmbG93OnNjcm9sbCBzY3Jld2luZXNzIChnaC0zNjk5KVxuXHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTY0XG5cdFx0Ly8gRG9uJ3QgZ2V0IHRyaWNrZWQgd2hlbiB6b29tIGFmZmVjdHMgb2Zmc2V0V2lkdGggKGdoLTQwMjkpXG5cdFx0ZGl2LnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuXHRcdHNjcm9sbGJveFNpemVWYWwgPSByb3VuZFBpeGVsTWVhc3VyZXMoIGRpdi5vZmZzZXRXaWR0aCAvIDMgKSA9PT0gMTI7XG5cblx0XHRkb2N1bWVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoIGNvbnRhaW5lciApO1xuXG5cdFx0Ly8gTnVsbGlmeSB0aGUgZGl2IHNvIGl0IHdvdWxkbid0IGJlIHN0b3JlZCBpbiB0aGUgbWVtb3J5IGFuZFxuXHRcdC8vIGl0IHdpbGwgYWxzbyBiZSBhIHNpZ24gdGhhdCBjaGVja3MgYWxyZWFkeSBwZXJmb3JtZWRcblx0XHRkaXYgPSBudWxsO1xuXHR9XG5cblx0ZnVuY3Rpb24gcm91bmRQaXhlbE1lYXN1cmVzKCBtZWFzdXJlICkge1xuXHRcdHJldHVybiBNYXRoLnJvdW5kKCBwYXJzZUZsb2F0KCBtZWFzdXJlICkgKTtcblx0fVxuXG5cdHZhciBwaXhlbFBvc2l0aW9uVmFsLCBib3hTaXppbmdSZWxpYWJsZVZhbCwgc2Nyb2xsYm94U2l6ZVZhbCwgcGl4ZWxCb3hTdHlsZXNWYWwsXG5cdFx0cmVsaWFibGVUckRpbWVuc2lvbnNWYWwsIHJlbGlhYmxlTWFyZ2luTGVmdFZhbCxcblx0XHRjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICksXG5cdFx0ZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApO1xuXG5cdC8vIEZpbmlzaCBlYXJseSBpbiBsaW1pdGVkIChub24tYnJvd3NlcikgZW52aXJvbm1lbnRzXG5cdGlmICggIWRpdi5zdHlsZSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdC8vIFN0eWxlIG9mIGNsb25lZCBlbGVtZW50IGFmZmVjdHMgc291cmNlIGVsZW1lbnQgY2xvbmVkICh0cmFjLTg5MDgpXG5cdGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9IFwiY29udGVudC1ib3hcIjtcblx0ZGl2LmNsb25lTm9kZSggdHJ1ZSApLnN0eWxlLmJhY2tncm91bmRDbGlwID0gXCJcIjtcblx0c3VwcG9ydC5jbGVhckNsb25lU3R5bGUgPSBkaXYuc3R5bGUuYmFja2dyb3VuZENsaXAgPT09IFwiY29udGVudC1ib3hcIjtcblxuXHRqUXVlcnkuZXh0ZW5kKCBzdXBwb3J0LCB7XG5cdFx0Ym94U2l6aW5nUmVsaWFibGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBib3hTaXppbmdSZWxpYWJsZVZhbDtcblx0XHR9LFxuXHRcdHBpeGVsQm94U3R5bGVzOiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gcGl4ZWxCb3hTdHlsZXNWYWw7XG5cdFx0fSxcblx0XHRwaXhlbFBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gcGl4ZWxQb3NpdGlvblZhbDtcblx0XHR9LFxuXHRcdHJlbGlhYmxlTWFyZ2luTGVmdDogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIHJlbGlhYmxlTWFyZ2luTGVmdFZhbDtcblx0XHR9LFxuXHRcdHNjcm9sbGJveFNpemU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBzY3JvbGxib3hTaXplVmFsO1xuXHRcdH0sXG5cblx0XHQvLyBTdXBwb3J0OiBJRSA5IC0gMTErLCBFZGdlIDE1IC0gMTgrXG5cdFx0Ly8gSUUvRWRnZSBtaXNyZXBvcnQgYGdldENvbXB1dGVkU3R5bGVgIG9mIHRhYmxlIHJvd3Mgd2l0aCB3aWR0aC9oZWlnaHRcblx0XHQvLyBzZXQgaW4gQ1NTIHdoaWxlIGBvZmZzZXQqYCBwcm9wZXJ0aWVzIHJlcG9ydCBjb3JyZWN0IHZhbHVlcy5cblx0XHQvLyBCZWhhdmlvciBpbiBJRSA5IGlzIG1vcmUgc3VidGxlIHRoYW4gaW4gbmV3ZXIgdmVyc2lvbnMgJiBpdCBwYXNzZXNcblx0XHQvLyBzb21lIHZlcnNpb25zIG9mIHRoaXMgdGVzdDsgbWFrZSBzdXJlIG5vdCB0byBtYWtlIGl0IHBhc3MgdGhlcmUhXG5cdFx0Ly9cblx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDcwK1xuXHRcdC8vIE9ubHkgRmlyZWZveCBpbmNsdWRlcyBib3JkZXIgd2lkdGhzXG5cdFx0Ly8gaW4gY29tcHV0ZWQgZGltZW5zaW9ucy4gKGdoLTQ1MjkpXG5cdFx0cmVsaWFibGVUckRpbWVuc2lvbnM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHRhYmxlLCB0ciwgdHJDaGlsZCwgdHJTdHlsZTtcblx0XHRcdGlmICggcmVsaWFibGVUckRpbWVuc2lvbnNWYWwgPT0gbnVsbCApIHtcblx0XHRcdFx0dGFibGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcInRhYmxlXCIgKTtcblx0XHRcdFx0dHIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcInRyXCIgKTtcblx0XHRcdFx0dHJDaGlsZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKTtcblxuXHRcdFx0XHR0YWJsZS5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0Oi0xMTExMXB4O2JvcmRlci1jb2xsYXBzZTpzZXBhcmF0ZVwiO1xuXHRcdFx0XHR0ci5zdHlsZS5jc3NUZXh0ID0gXCJib3gtc2l6aW5nOmNvbnRlbnQtYm94O2JvcmRlcjoxcHggc29saWRcIjtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgODYrXG5cdFx0XHRcdC8vIEhlaWdodCBzZXQgdGhyb3VnaCBjc3NUZXh0IGRvZXMgbm90IGdldCBhcHBsaWVkLlxuXHRcdFx0XHQvLyBDb21wdXRlZCBoZWlnaHQgdGhlbiBjb21lcyBiYWNrIGFzIDAuXG5cdFx0XHRcdHRyLnN0eWxlLmhlaWdodCA9IFwiMXB4XCI7XG5cdFx0XHRcdHRyQ2hpbGQuc3R5bGUuaGVpZ2h0ID0gXCI5cHhcIjtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDggQ2hyb21lIDg2K1xuXHRcdFx0XHQvLyBJbiBvdXIgYm9keUJhY2tncm91bmQuaHRtbCBpZnJhbWUsXG5cdFx0XHRcdC8vIGRpc3BsYXkgZm9yIGFsbCBkaXYgZWxlbWVudHMgaXMgc2V0IHRvIFwiaW5saW5lXCIsXG5cdFx0XHRcdC8vIHdoaWNoIGNhdXNlcyBhIHByb2JsZW0gb25seSBpbiBBbmRyb2lkIDggQ2hyb21lIDg2LlxuXHRcdFx0XHQvLyBFbnN1cmluZyB0aGUgZGl2IGlzIGBkaXNwbGF5OiBibG9ja2Bcblx0XHRcdFx0Ly8gZ2V0cyBhcm91bmQgdGhpcyBpc3N1ZS5cblx0XHRcdFx0dHJDaGlsZC5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuXG5cdFx0XHRcdGRvY3VtZW50RWxlbWVudFxuXHRcdFx0XHRcdC5hcHBlbmRDaGlsZCggdGFibGUgKVxuXHRcdFx0XHRcdC5hcHBlbmRDaGlsZCggdHIgKVxuXHRcdFx0XHRcdC5hcHBlbmRDaGlsZCggdHJDaGlsZCApO1xuXG5cdFx0XHRcdHRyU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSggdHIgKTtcblx0XHRcdFx0cmVsaWFibGVUckRpbWVuc2lvbnNWYWwgPSAoIHBhcnNlSW50KCB0clN0eWxlLmhlaWdodCwgMTAgKSArXG5cdFx0XHRcdFx0cGFyc2VJbnQoIHRyU3R5bGUuYm9yZGVyVG9wV2lkdGgsIDEwICkgK1xuXHRcdFx0XHRcdHBhcnNlSW50KCB0clN0eWxlLmJvcmRlckJvdHRvbVdpZHRoLCAxMCApICkgPT09IHRyLm9mZnNldEhlaWdodDtcblxuXHRcdFx0XHRkb2N1bWVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoIHRhYmxlICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVsaWFibGVUckRpbWVuc2lvbnNWYWw7XG5cdFx0fVxuXHR9ICk7XG59ICkoKTtcblxuXG5mdW5jdGlvbiBjdXJDU1MoIGVsZW0sIG5hbWUsIGNvbXB1dGVkICkge1xuXHR2YXIgd2lkdGgsIG1pbldpZHRoLCBtYXhXaWR0aCwgcmV0LFxuXHRcdGlzQ3VzdG9tUHJvcCA9IHJjdXN0b21Qcm9wLnRlc3QoIG5hbWUgKSxcblxuXHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggNTErXG5cdFx0Ly8gUmV0cmlldmluZyBzdHlsZSBiZWZvcmUgY29tcHV0ZWQgc29tZWhvd1xuXHRcdC8vIGZpeGVzIGFuIGlzc3VlIHdpdGggZ2V0dGluZyB3cm9uZyB2YWx1ZXNcblx0XHQvLyBvbiBkZXRhY2hlZCBlbGVtZW50c1xuXHRcdHN0eWxlID0gZWxlbS5zdHlsZTtcblxuXHRjb21wdXRlZCA9IGNvbXB1dGVkIHx8IGdldFN0eWxlcyggZWxlbSApO1xuXG5cdC8vIGdldFByb3BlcnR5VmFsdWUgaXMgbmVlZGVkIGZvcjpcblx0Ly8gICAuY3NzKCdmaWx0ZXInKSAoSUUgOSBvbmx5LCB0cmFjLTEyNTM3KVxuXHQvLyAgIC5jc3MoJy0tY3VzdG9tUHJvcGVydHkpIChnaC0zMTQ0KVxuXHRpZiAoIGNvbXB1dGVkICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTErXG5cdFx0Ly8gSUUgb25seSBzdXBwb3J0cyBgXCJmbG9hdFwiYCBpbiBgZ2V0UHJvcGVydHlWYWx1ZWA7IGluIGNvbXB1dGVkIHN0eWxlc1xuXHRcdC8vIGl0J3Mgb25seSBhdmFpbGFibGUgYXMgYFwiY3NzRmxvYXRcImAuIFdlIG5vIGxvbmdlciBtb2RpZnkgcHJvcGVydGllc1xuXHRcdC8vIHNlbnQgdG8gYC5jc3MoKWAgYXBhcnQgZnJvbSBjYW1lbENhc2luZywgc28gd2UgbmVlZCB0byBjaGVjayBib3RoLlxuXHRcdC8vIE5vcm1hbGx5LCB0aGlzIHdvdWxkIGNyZWF0ZSBkaWZmZXJlbmNlIGluIGJlaGF2aW9yOiBpZlxuXHRcdC8vIGBnZXRQcm9wZXJ0eVZhbHVlYCByZXR1cm5zIGFuIGVtcHR5IHN0cmluZywgdGhlIHZhbHVlIHJldHVybmVkXG5cdFx0Ly8gYnkgYC5jc3MoKWAgd291bGQgYmUgYHVuZGVmaW5lZGAuIFRoaXMgaXMgdXN1YWxseSB0aGUgY2FzZSBmb3Jcblx0XHQvLyBkaXNjb25uZWN0ZWQgZWxlbWVudHMuIEhvd2V2ZXIsIGluIElFIGV2ZW4gZGlzY29ubmVjdGVkIGVsZW1lbnRzXG5cdFx0Ly8gd2l0aCBubyBzdHlsZXMgcmV0dXJuIGBcIm5vbmVcImAgZm9yIGBnZXRQcm9wZXJ0eVZhbHVlKCBcImZsb2F0XCIgKWBcblx0XHRyZXQgPSBjb21wdXRlZC5nZXRQcm9wZXJ0eVZhbHVlKCBuYW1lICkgfHwgY29tcHV0ZWRbIG5hbWUgXTtcblxuXHRcdGlmICggaXNDdXN0b21Qcm9wICYmIHJldCApIHtcblxuXHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCAxMDUrLCBDaHJvbWUgPD0xMDUrXG5cdFx0XHQvLyBTcGVjIHJlcXVpcmVzIHRyaW1taW5nIHdoaXRlc3BhY2UgZm9yIGN1c3RvbSBwcm9wZXJ0aWVzIChnaC00OTI2KS5cblx0XHRcdC8vIEZpcmVmb3ggb25seSB0cmltcyBsZWFkaW5nIHdoaXRlc3BhY2UuIENocm9tZSBqdXN0IGNvbGxhcHNlc1xuXHRcdFx0Ly8gYm90aCBsZWFkaW5nICYgdHJhaWxpbmcgd2hpdGVzcGFjZSB0byBhIHNpbmdsZSBzcGFjZS5cblx0XHRcdC8vXG5cdFx0XHQvLyBGYWxsIGJhY2sgdG8gYHVuZGVmaW5lZGAgaWYgZW1wdHkgc3RyaW5nIHJldHVybmVkLlxuXHRcdFx0Ly8gVGhpcyBjb2xsYXBzZXMgYSBtaXNzaW5nIGRlZmluaXRpb24gd2l0aCBwcm9wZXJ0eSBkZWZpbmVkXG5cdFx0XHQvLyBhbmQgc2V0IHRvIGFuIGVtcHR5IHN0cmluZyBidXQgdGhlcmUncyBubyBzdGFuZGFyZCBBUElcblx0XHRcdC8vIGFsbG93aW5nIHVzIHRvIGRpZmZlcmVudGlhdGUgdGhlbSB3aXRob3V0IGEgcGVyZm9ybWFuY2UgcGVuYWx0eVxuXHRcdFx0Ly8gYW5kIHJldHVybmluZyBgdW5kZWZpbmVkYCBhbGlnbnMgd2l0aCBvbGRlciBqUXVlcnkuXG5cdFx0XHQvL1xuXHRcdFx0Ly8gcnRyaW1DU1MgdHJlYXRzIFUrMDAwRCBDQVJSSUFHRSBSRVRVUk4gYW5kIFUrMDAwQyBGT1JNIEZFRURcblx0XHRcdC8vIGFzIHdoaXRlc3BhY2Ugd2hpbGUgQ1NTIGRvZXMgbm90LCBidXQgdGhpcyBpcyBub3QgYSBwcm9ibGVtXG5cdFx0XHQvLyBiZWNhdXNlIENTUyBwcmVwcm9jZXNzaW5nIHJlcGxhY2VzIHRoZW0gd2l0aCBVKzAwMEEgTElORSBGRUVEXG5cdFx0XHQvLyAod2hpY2ggKmlzKiBDU1Mgd2hpdGVzcGFjZSlcblx0XHRcdC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9jc3Mtc3ludGF4LTMvI2lucHV0LXByZXByb2Nlc3Npbmdcblx0XHRcdHJldCA9IHJldC5yZXBsYWNlKCBydHJpbUNTUywgXCIkMVwiICkgfHwgdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdGlmICggcmV0ID09PSBcIlwiICYmICFpc0F0dGFjaGVkKCBlbGVtICkgKSB7XG5cdFx0XHRyZXQgPSBqUXVlcnkuc3R5bGUoIGVsZW0sIG5hbWUgKTtcblx0XHR9XG5cblx0XHQvLyBBIHRyaWJ1dGUgdG8gdGhlIFwiYXdlc29tZSBoYWNrIGJ5IERlYW4gRWR3YXJkc1wiXG5cdFx0Ly8gQW5kcm9pZCBCcm93c2VyIHJldHVybnMgcGVyY2VudGFnZSBmb3Igc29tZSB2YWx1ZXMsXG5cdFx0Ly8gYnV0IHdpZHRoIHNlZW1zIHRvIGJlIHJlbGlhYmx5IHBpeGVscy5cblx0XHQvLyBUaGlzIGlzIGFnYWluc3QgdGhlIENTU09NIGRyYWZ0IHNwZWM6XG5cdFx0Ly8gaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzc29tLyNyZXNvbHZlZC12YWx1ZXNcblx0XHRpZiAoICFzdXBwb3J0LnBpeGVsQm94U3R5bGVzKCkgJiYgcm51bW5vbnB4LnRlc3QoIHJldCApICYmIHJib3hTdHlsZS50ZXN0KCBuYW1lICkgKSB7XG5cblx0XHRcdC8vIFJlbWVtYmVyIHRoZSBvcmlnaW5hbCB2YWx1ZXNcblx0XHRcdHdpZHRoID0gc3R5bGUud2lkdGg7XG5cdFx0XHRtaW5XaWR0aCA9IHN0eWxlLm1pbldpZHRoO1xuXHRcdFx0bWF4V2lkdGggPSBzdHlsZS5tYXhXaWR0aDtcblxuXHRcdFx0Ly8gUHV0IGluIHRoZSBuZXcgdmFsdWVzIHRvIGdldCBhIGNvbXB1dGVkIHZhbHVlIG91dFxuXHRcdFx0c3R5bGUubWluV2lkdGggPSBzdHlsZS5tYXhXaWR0aCA9IHN0eWxlLndpZHRoID0gcmV0O1xuXHRcdFx0cmV0ID0gY29tcHV0ZWQud2lkdGg7XG5cblx0XHRcdC8vIFJldmVydCB0aGUgY2hhbmdlZCB2YWx1ZXNcblx0XHRcdHN0eWxlLndpZHRoID0gd2lkdGg7XG5cdFx0XHRzdHlsZS5taW5XaWR0aCA9IG1pbldpZHRoO1xuXHRcdFx0c3R5bGUubWF4V2lkdGggPSBtYXhXaWR0aDtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gcmV0ICE9PSB1bmRlZmluZWQgP1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHRcdC8vIElFIHJldHVybnMgekluZGV4IHZhbHVlIGFzIGFuIGludGVnZXIuXG5cdFx0cmV0ICsgXCJcIiA6XG5cdFx0cmV0O1xufVxuXG5cbmZ1bmN0aW9uIGFkZEdldEhvb2tJZiggY29uZGl0aW9uRm4sIGhvb2tGbiApIHtcblxuXHQvLyBEZWZpbmUgdGhlIGhvb2ssIHdlJ2xsIGNoZWNrIG9uIHRoZSBmaXJzdCBydW4gaWYgaXQncyByZWFsbHkgbmVlZGVkLlxuXHRyZXR1cm4ge1xuXHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIGNvbmRpdGlvbkZuKCkgKSB7XG5cblx0XHRcdFx0Ly8gSG9vayBub3QgbmVlZGVkIChvciBpdCdzIG5vdCBwb3NzaWJsZSB0byB1c2UgaXQgZHVlXG5cdFx0XHRcdC8vIHRvIG1pc3NpbmcgZGVwZW5kZW5jeSksIHJlbW92ZSBpdC5cblx0XHRcdFx0ZGVsZXRlIHRoaXMuZ2V0O1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIEhvb2sgbmVlZGVkOyByZWRlZmluZSBpdCBzbyB0aGF0IHRoZSBzdXBwb3J0IHRlc3QgaXMgbm90IGV4ZWN1dGVkIGFnYWluLlxuXHRcdFx0cmV0dXJuICggdGhpcy5nZXQgPSBob29rRm4gKS5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0fVxuXHR9O1xufVxuXG5cbnZhciBjc3NQcmVmaXhlcyA9IFsgXCJXZWJraXRcIiwgXCJNb3pcIiwgXCJtc1wiIF0sXG5cdGVtcHR5U3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkuc3R5bGUsXG5cdHZlbmRvclByb3BzID0ge307XG5cbi8vIFJldHVybiBhIHZlbmRvci1wcmVmaXhlZCBwcm9wZXJ0eSBvciB1bmRlZmluZWRcbmZ1bmN0aW9uIHZlbmRvclByb3BOYW1lKCBuYW1lICkge1xuXG5cdC8vIENoZWNrIGZvciB2ZW5kb3IgcHJlZml4ZWQgbmFtZXNcblx0dmFyIGNhcE5hbWUgPSBuYW1lWyAwIF0udG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoIDEgKSxcblx0XHRpID0gY3NzUHJlZml4ZXMubGVuZ3RoO1xuXG5cdHdoaWxlICggaS0tICkge1xuXHRcdG5hbWUgPSBjc3NQcmVmaXhlc1sgaSBdICsgY2FwTmFtZTtcblx0XHRpZiAoIG5hbWUgaW4gZW1wdHlTdHlsZSApIHtcblx0XHRcdHJldHVybiBuYW1lO1xuXHRcdH1cblx0fVxufVxuXG4vLyBSZXR1cm4gYSBwb3RlbnRpYWxseS1tYXBwZWQgalF1ZXJ5LmNzc1Byb3BzIG9yIHZlbmRvciBwcmVmaXhlZCBwcm9wZXJ0eVxuZnVuY3Rpb24gZmluYWxQcm9wTmFtZSggbmFtZSApIHtcblx0dmFyIGZpbmFsID0galF1ZXJ5LmNzc1Byb3BzWyBuYW1lIF0gfHwgdmVuZG9yUHJvcHNbIG5hbWUgXTtcblxuXHRpZiAoIGZpbmFsICkge1xuXHRcdHJldHVybiBmaW5hbDtcblx0fVxuXHRpZiAoIG5hbWUgaW4gZW1wdHlTdHlsZSApIHtcblx0XHRyZXR1cm4gbmFtZTtcblx0fVxuXHRyZXR1cm4gdmVuZG9yUHJvcHNbIG5hbWUgXSA9IHZlbmRvclByb3BOYW1lKCBuYW1lICkgfHwgbmFtZTtcbn1cblxuXG52YXJcblxuXHQvLyBTd2FwcGFibGUgaWYgZGlzcGxheSBpcyBub25lIG9yIHN0YXJ0cyB3aXRoIHRhYmxlXG5cdC8vIGV4Y2VwdCBcInRhYmxlXCIsIFwidGFibGUtY2VsbFwiLCBvciBcInRhYmxlLWNhcHRpb25cIlxuXHQvLyBTZWUgaGVyZSBmb3IgZGlzcGxheSB2YWx1ZXM6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvQ1NTL2Rpc3BsYXlcblx0cmRpc3BsYXlzd2FwID0gL14obm9uZXx0YWJsZSg/IS1jW2VhXSkuKykvLFxuXHRjc3NTaG93ID0geyBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLCB2aXNpYmlsaXR5OiBcImhpZGRlblwiLCBkaXNwbGF5OiBcImJsb2NrXCIgfSxcblx0Y3NzTm9ybWFsVHJhbnNmb3JtID0ge1xuXHRcdGxldHRlclNwYWNpbmc6IFwiMFwiLFxuXHRcdGZvbnRXZWlnaHQ6IFwiNDAwXCJcblx0fTtcblxuZnVuY3Rpb24gc2V0UG9zaXRpdmVOdW1iZXIoIF9lbGVtLCB2YWx1ZSwgc3VidHJhY3QgKSB7XG5cblx0Ly8gQW55IHJlbGF0aXZlICgrLy0pIHZhbHVlcyBoYXZlIGFscmVhZHkgYmVlblxuXHQvLyBub3JtYWxpemVkIGF0IHRoaXMgcG9pbnRcblx0dmFyIG1hdGNoZXMgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICk7XG5cdHJldHVybiBtYXRjaGVzID9cblxuXHRcdC8vIEd1YXJkIGFnYWluc3QgdW5kZWZpbmVkIFwic3VidHJhY3RcIiwgZS5nLiwgd2hlbiB1c2VkIGFzIGluIGNzc0hvb2tzXG5cdFx0TWF0aC5tYXgoIDAsIG1hdGNoZXNbIDIgXSAtICggc3VidHJhY3QgfHwgMCApICkgKyAoIG1hdGNoZXNbIDMgXSB8fCBcInB4XCIgKSA6XG5cdFx0dmFsdWU7XG59XG5cbmZ1bmN0aW9uIGJveE1vZGVsQWRqdXN0bWVudCggZWxlbSwgZGltZW5zaW9uLCBib3gsIGlzQm9yZGVyQm94LCBzdHlsZXMsIGNvbXB1dGVkVmFsICkge1xuXHR2YXIgaSA9IGRpbWVuc2lvbiA9PT0gXCJ3aWR0aFwiID8gMSA6IDAsXG5cdFx0ZXh0cmEgPSAwLFxuXHRcdGRlbHRhID0gMCxcblx0XHRtYXJnaW5EZWx0YSA9IDA7XG5cblx0Ly8gQWRqdXN0bWVudCBtYXkgbm90IGJlIG5lY2Vzc2FyeVxuXHRpZiAoIGJveCA9PT0gKCBpc0JvcmRlckJveCA/IFwiYm9yZGVyXCIgOiBcImNvbnRlbnRcIiApICkge1xuXHRcdHJldHVybiAwO1xuXHR9XG5cblx0Zm9yICggOyBpIDwgNDsgaSArPSAyICkge1xuXG5cdFx0Ly8gQm90aCBib3ggbW9kZWxzIGV4Y2x1ZGUgbWFyZ2luXG5cdFx0Ly8gQ291bnQgbWFyZ2luIGRlbHRhIHNlcGFyYXRlbHkgdG8gb25seSBhZGQgaXQgYWZ0ZXIgc2Nyb2xsIGd1dHRlciBhZGp1c3RtZW50LlxuXHRcdC8vIFRoaXMgaXMgbmVlZGVkIHRvIG1ha2UgbmVnYXRpdmUgbWFyZ2lucyB3b3JrIHdpdGggYG91dGVySGVpZ2h0KCB0cnVlIClgIChnaC0zOTgyKS5cblx0XHRpZiAoIGJveCA9PT0gXCJtYXJnaW5cIiApIHtcblx0XHRcdG1hcmdpbkRlbHRhICs9IGpRdWVyeS5jc3MoIGVsZW0sIGJveCArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblx0XHR9XG5cblx0XHQvLyBJZiB3ZSBnZXQgaGVyZSB3aXRoIGEgY29udGVudC1ib3gsIHdlJ3JlIHNlZWtpbmcgXCJwYWRkaW5nXCIgb3IgXCJib3JkZXJcIiBvciBcIm1hcmdpblwiXG5cdFx0aWYgKCAhaXNCb3JkZXJCb3ggKSB7XG5cblx0XHRcdC8vIEFkZCBwYWRkaW5nXG5cdFx0XHRkZWx0YSArPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBhZGRpbmdcIiArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblxuXHRcdFx0Ly8gRm9yIFwiYm9yZGVyXCIgb3IgXCJtYXJnaW5cIiwgYWRkIGJvcmRlclxuXHRcdFx0aWYgKCBib3ggIT09IFwicGFkZGluZ1wiICkge1xuXHRcdFx0XHRkZWx0YSArPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXG5cdFx0XHQvLyBCdXQgc3RpbGwga2VlcCB0cmFjayBvZiBpdCBvdGhlcndpc2Vcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGV4dHJhICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cblx0XHQvLyBJZiB3ZSBnZXQgaGVyZSB3aXRoIGEgYm9yZGVyLWJveCAoY29udGVudCArIHBhZGRpbmcgKyBib3JkZXIpLCB3ZSdyZSBzZWVraW5nIFwiY29udGVudFwiIG9yXG5cdFx0Ly8gXCJwYWRkaW5nXCIgb3IgXCJtYXJnaW5cIlxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIEZvciBcImNvbnRlbnRcIiwgc3VidHJhY3QgcGFkZGluZ1xuXHRcdFx0aWYgKCBib3ggPT09IFwiY29udGVudFwiICkge1xuXHRcdFx0XHRkZWx0YSAtPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBhZGRpbmdcIiArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRm9yIFwiY29udGVudFwiIG9yIFwicGFkZGluZ1wiLCBzdWJ0cmFjdCBib3JkZXJcblx0XHRcdGlmICggYm94ICE9PSBcIm1hcmdpblwiICkge1xuXHRcdFx0XHRkZWx0YSAtPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIEFjY291bnQgZm9yIHBvc2l0aXZlIGNvbnRlbnQtYm94IHNjcm9sbCBndXR0ZXIgd2hlbiByZXF1ZXN0ZWQgYnkgcHJvdmlkaW5nIGNvbXB1dGVkVmFsXG5cdGlmICggIWlzQm9yZGVyQm94ICYmIGNvbXB1dGVkVmFsID49IDAgKSB7XG5cblx0XHQvLyBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgaXMgYSByb3VuZGVkIHN1bSBvZiBjb250ZW50LCBwYWRkaW5nLCBzY3JvbGwgZ3V0dGVyLCBhbmQgYm9yZGVyXG5cdFx0Ly8gQXNzdW1pbmcgaW50ZWdlciBzY3JvbGwgZ3V0dGVyLCBzdWJ0cmFjdCB0aGUgcmVzdCBhbmQgcm91bmQgZG93blxuXHRcdGRlbHRhICs9IE1hdGgubWF4KCAwLCBNYXRoLmNlaWwoXG5cdFx0XHRlbGVtWyBcIm9mZnNldFwiICsgZGltZW5zaW9uWyAwIF0udG9VcHBlckNhc2UoKSArIGRpbWVuc2lvbi5zbGljZSggMSApIF0gLVxuXHRcdFx0Y29tcHV0ZWRWYWwgLVxuXHRcdFx0ZGVsdGEgLVxuXHRcdFx0ZXh0cmEgLVxuXHRcdFx0MC41XG5cblx0XHQvLyBJZiBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgaXMgdW5rbm93biwgdGhlbiB3ZSBjYW4ndCBkZXRlcm1pbmUgY29udGVudC1ib3ggc2Nyb2xsIGd1dHRlclxuXHRcdC8vIFVzZSBhbiBleHBsaWNpdCB6ZXJvIHRvIGF2b2lkIE5hTiAoZ2gtMzk2NClcblx0XHQpICkgfHwgMDtcblx0fVxuXG5cdHJldHVybiBkZWx0YSArIG1hcmdpbkRlbHRhO1xufVxuXG5mdW5jdGlvbiBnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBkaW1lbnNpb24sIGV4dHJhICkge1xuXG5cdC8vIFN0YXJ0IHdpdGggY29tcHV0ZWQgc3R5bGVcblx0dmFyIHN0eWxlcyA9IGdldFN0eWxlcyggZWxlbSApLFxuXG5cdFx0Ly8gVG8gYXZvaWQgZm9yY2luZyBhIHJlZmxvdywgb25seSBmZXRjaCBib3hTaXppbmcgaWYgd2UgbmVlZCBpdCAoZ2gtNDMyMikuXG5cdFx0Ly8gRmFrZSBjb250ZW50LWJveCB1bnRpbCB3ZSBrbm93IGl0J3MgbmVlZGVkIHRvIGtub3cgdGhlIHRydWUgdmFsdWUuXG5cdFx0Ym94U2l6aW5nTmVlZGVkID0gIXN1cHBvcnQuYm94U2l6aW5nUmVsaWFibGUoKSB8fCBleHRyYSxcblx0XHRpc0JvcmRlckJveCA9IGJveFNpemluZ05lZWRlZCAmJlxuXHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgXCJib3hTaXppbmdcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImJvcmRlci1ib3hcIixcblx0XHR2YWx1ZUlzQm9yZGVyQm94ID0gaXNCb3JkZXJCb3gsXG5cblx0XHR2YWwgPSBjdXJDU1MoIGVsZW0sIGRpbWVuc2lvbiwgc3R5bGVzICksXG5cdFx0b2Zmc2V0UHJvcCA9IFwib2Zmc2V0XCIgKyBkaW1lbnNpb25bIDAgXS50b1VwcGVyQ2FzZSgpICsgZGltZW5zaW9uLnNsaWNlKCAxICk7XG5cblx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTU0XG5cdC8vIFJldHVybiBhIGNvbmZvdW5kaW5nIG5vbi1waXhlbCB2YWx1ZSBvciBmZWlnbiBpZ25vcmFuY2UsIGFzIGFwcHJvcHJpYXRlLlxuXHRpZiAoIHJudW1ub25weC50ZXN0KCB2YWwgKSApIHtcblx0XHRpZiAoICFleHRyYSApIHtcblx0XHRcdHJldHVybiB2YWw7XG5cdFx0fVxuXHRcdHZhbCA9IFwiYXV0b1wiO1xuXHR9XG5cblxuXHQvLyBTdXBwb3J0OiBJRSA5IC0gMTEgb25seVxuXHQvLyBVc2Ugb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IGZvciB3aGVuIGJveCBzaXppbmcgaXMgdW5yZWxpYWJsZS5cblx0Ly8gSW4gdGhvc2UgY2FzZXMsIHRoZSBjb21wdXRlZCB2YWx1ZSBjYW4gYmUgdHJ1c3RlZCB0byBiZSBib3JkZXItYm94LlxuXHRpZiAoICggIXN1cHBvcnQuYm94U2l6aW5nUmVsaWFibGUoKSAmJiBpc0JvcmRlckJveCB8fFxuXG5cdFx0Ly8gU3VwcG9ydDogSUUgMTAgLSAxMSssIEVkZ2UgMTUgLSAxOCtcblx0XHQvLyBJRS9FZGdlIG1pc3JlcG9ydCBgZ2V0Q29tcHV0ZWRTdHlsZWAgb2YgdGFibGUgcm93cyB3aXRoIHdpZHRoL2hlaWdodFxuXHRcdC8vIHNldCBpbiBDU1Mgd2hpbGUgYG9mZnNldCpgIHByb3BlcnRpZXMgcmVwb3J0IGNvcnJlY3QgdmFsdWVzLlxuXHRcdC8vIEludGVyZXN0aW5nbHksIGluIHNvbWUgY2FzZXMgSUUgOSBkb2Vzbid0IHN1ZmZlciBmcm9tIHRoaXMgaXNzdWUuXG5cdFx0IXN1cHBvcnQucmVsaWFibGVUckRpbWVuc2lvbnMoKSAmJiBub2RlTmFtZSggZWxlbSwgXCJ0clwiICkgfHxcblxuXHRcdC8vIEZhbGwgYmFjayB0byBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgd2hlbiB2YWx1ZSBpcyBcImF1dG9cIlxuXHRcdC8vIFRoaXMgaGFwcGVucyBmb3IgaW5saW5lIGVsZW1lbnRzIHdpdGggbm8gZXhwbGljaXQgc2V0dGluZyAoZ2gtMzU3MSlcblx0XHR2YWwgPT09IFwiYXV0b1wiIHx8XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4xIC0gNC4zIG9ubHlcblx0XHQvLyBBbHNvIHVzZSBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgZm9yIG1pc3JlcG9ydGVkIGlubGluZSBkaW1lbnNpb25zIChnaC0zNjAyKVxuXHRcdCFwYXJzZUZsb2F0KCB2YWwgKSAmJiBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImlubGluZVwiICkgJiZcblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGUgZWxlbWVudCBpcyB2aXNpYmxlICYgY29ubmVjdGVkXG5cdFx0ZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCApIHtcblxuXHRcdGlzQm9yZGVyQm94ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3hTaXppbmdcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImJvcmRlci1ib3hcIjtcblxuXHRcdC8vIFdoZXJlIGF2YWlsYWJsZSwgb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IGFwcHJveGltYXRlIGJvcmRlciBib3ggZGltZW5zaW9ucy5cblx0XHQvLyBXaGVyZSBub3QgYXZhaWxhYmxlIChlLmcuLCBTVkcpLCBhc3N1bWUgdW5yZWxpYWJsZSBib3gtc2l6aW5nIGFuZCBpbnRlcnByZXQgdGhlXG5cdFx0Ly8gcmV0cmlldmVkIHZhbHVlIGFzIGEgY29udGVudCBib3ggZGltZW5zaW9uLlxuXHRcdHZhbHVlSXNCb3JkZXJCb3ggPSBvZmZzZXRQcm9wIGluIGVsZW07XG5cdFx0aWYgKCB2YWx1ZUlzQm9yZGVyQm94ICkge1xuXHRcdFx0dmFsID0gZWxlbVsgb2Zmc2V0UHJvcCBdO1xuXHRcdH1cblx0fVxuXG5cdC8vIE5vcm1hbGl6ZSBcIlwiIGFuZCBhdXRvXG5cdHZhbCA9IHBhcnNlRmxvYXQoIHZhbCApIHx8IDA7XG5cblx0Ly8gQWRqdXN0IGZvciB0aGUgZWxlbWVudCdzIGJveCBtb2RlbFxuXHRyZXR1cm4gKCB2YWwgK1xuXHRcdGJveE1vZGVsQWRqdXN0bWVudChcblx0XHRcdGVsZW0sXG5cdFx0XHRkaW1lbnNpb24sXG5cdFx0XHRleHRyYSB8fCAoIGlzQm9yZGVyQm94ID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiICksXG5cdFx0XHR2YWx1ZUlzQm9yZGVyQm94LFxuXHRcdFx0c3R5bGVzLFxuXG5cdFx0XHQvLyBQcm92aWRlIHRoZSBjdXJyZW50IGNvbXB1dGVkIHNpemUgdG8gcmVxdWVzdCBzY3JvbGwgZ3V0dGVyIGNhbGN1bGF0aW9uIChnaC0zNTg5KVxuXHRcdFx0dmFsXG5cdFx0KVxuXHQpICsgXCJweFwiO1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gQWRkIGluIHN0eWxlIHByb3BlcnR5IGhvb2tzIGZvciBvdmVycmlkaW5nIHRoZSBkZWZhdWx0XG5cdC8vIGJlaGF2aW9yIG9mIGdldHRpbmcgYW5kIHNldHRpbmcgYSBzdHlsZSBwcm9wZXJ0eVxuXHRjc3NIb29rczoge1xuXHRcdG9wYWNpdHk6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXG5cdFx0XHRcdFx0Ly8gV2Ugc2hvdWxkIGFsd2F5cyBnZXQgYSBudW1iZXIgYmFjayBmcm9tIG9wYWNpdHlcblx0XHRcdFx0XHR2YXIgcmV0ID0gY3VyQ1NTKCBlbGVtLCBcIm9wYWNpdHlcIiApO1xuXHRcdFx0XHRcdHJldHVybiByZXQgPT09IFwiXCIgPyBcIjFcIiA6IHJldDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvLyBEb24ndCBhdXRvbWF0aWNhbGx5IGFkZCBcInB4XCIgdG8gdGhlc2UgcG9zc2libHktdW5pdGxlc3MgcHJvcGVydGllc1xuXHRjc3NOdW1iZXI6IHtcblx0XHRhbmltYXRpb25JdGVyYXRpb25Db3VudDogdHJ1ZSxcblx0XHRhc3BlY3RSYXRpbzogdHJ1ZSxcblx0XHRib3JkZXJJbWFnZVNsaWNlOiB0cnVlLFxuXHRcdGNvbHVtbkNvdW50OiB0cnVlLFxuXHRcdGZsZXhHcm93OiB0cnVlLFxuXHRcdGZsZXhTaHJpbms6IHRydWUsXG5cdFx0Zm9udFdlaWdodDogdHJ1ZSxcblx0XHRncmlkQXJlYTogdHJ1ZSxcblx0XHRncmlkQ29sdW1uOiB0cnVlLFxuXHRcdGdyaWRDb2x1bW5FbmQ6IHRydWUsXG5cdFx0Z3JpZENvbHVtblN0YXJ0OiB0cnVlLFxuXHRcdGdyaWRSb3c6IHRydWUsXG5cdFx0Z3JpZFJvd0VuZDogdHJ1ZSxcblx0XHRncmlkUm93U3RhcnQ6IHRydWUsXG5cdFx0bGluZUhlaWdodDogdHJ1ZSxcblx0XHRvcGFjaXR5OiB0cnVlLFxuXHRcdG9yZGVyOiB0cnVlLFxuXHRcdG9ycGhhbnM6IHRydWUsXG5cdFx0c2NhbGU6IHRydWUsXG5cdFx0d2lkb3dzOiB0cnVlLFxuXHRcdHpJbmRleDogdHJ1ZSxcblx0XHR6b29tOiB0cnVlLFxuXG5cdFx0Ly8gU1ZHLXJlbGF0ZWRcblx0XHRmaWxsT3BhY2l0eTogdHJ1ZSxcblx0XHRmbG9vZE9wYWNpdHk6IHRydWUsXG5cdFx0c3RvcE9wYWNpdHk6IHRydWUsXG5cdFx0c3Ryb2tlTWl0ZXJsaW1pdDogdHJ1ZSxcblx0XHRzdHJva2VPcGFjaXR5OiB0cnVlXG5cdH0sXG5cblx0Ly8gQWRkIGluIHByb3BlcnRpZXMgd2hvc2UgbmFtZXMgeW91IHdpc2ggdG8gZml4IGJlZm9yZVxuXHQvLyBzZXR0aW5nIG9yIGdldHRpbmcgdGhlIHZhbHVlXG5cdGNzc1Byb3BzOiB7fSxcblxuXHQvLyBHZXQgYW5kIHNldCB0aGUgc3R5bGUgcHJvcGVydHkgb24gYSBET00gTm9kZVxuXHRzdHlsZTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlLCBleHRyYSApIHtcblxuXHRcdC8vIERvbid0IHNldCBzdHlsZXMgb24gdGV4dCBhbmQgY29tbWVudCBub2Rlc1xuXHRcdGlmICggIWVsZW0gfHwgZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4IHx8ICFlbGVtLnN0eWxlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZVxuXHRcdHZhciByZXQsIHR5cGUsIGhvb2tzLFxuXHRcdFx0b3JpZ05hbWUgPSBjYW1lbENhc2UoIG5hbWUgKSxcblx0XHRcdGlzQ3VzdG9tUHJvcCA9IHJjdXN0b21Qcm9wLnRlc3QoIG5hbWUgKSxcblx0XHRcdHN0eWxlID0gZWxlbS5zdHlsZTtcblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZS4gV2UgZG9uJ3Rcblx0XHQvLyB3YW50IHRvIHF1ZXJ5IHRoZSB2YWx1ZSBpZiBpdCBpcyBhIENTUyBjdXN0b20gcHJvcGVydHlcblx0XHQvLyBzaW5jZSB0aGV5IGFyZSB1c2VyLWRlZmluZWQuXG5cdFx0aWYgKCAhaXNDdXN0b21Qcm9wICkge1xuXHRcdFx0bmFtZSA9IGZpbmFsUHJvcE5hbWUoIG9yaWdOYW1lICk7XG5cdFx0fVxuXG5cdFx0Ly8gR2V0cyBob29rIGZvciB0aGUgcHJlZml4ZWQgdmVyc2lvbiwgdGhlbiB1bnByZWZpeGVkIHZlcnNpb25cblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdIHx8IGpRdWVyeS5jc3NIb29rc1sgb3JpZ05hbWUgXTtcblxuXHRcdC8vIENoZWNrIGlmIHdlJ3JlIHNldHRpbmcgYSB2YWx1ZVxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cblx0XHRcdC8vIENvbnZlcnQgXCIrPVwiIG9yIFwiLT1cIiB0byByZWxhdGl2ZSBudW1iZXJzICh0cmFjLTczNDUpXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwic3RyaW5nXCIgJiYgKCByZXQgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICkgKSAmJiByZXRbIDEgXSApIHtcblx0XHRcdFx0dmFsdWUgPSBhZGp1c3RDU1MoIGVsZW0sIG5hbWUsIHJldCApO1xuXG5cdFx0XHRcdC8vIEZpeGVzIGJ1ZyB0cmFjLTkyMzdcblx0XHRcdFx0dHlwZSA9IFwibnVtYmVyXCI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1ha2Ugc3VyZSB0aGF0IG51bGwgYW5kIE5hTiB2YWx1ZXMgYXJlbid0IHNldCAodHJhYy03MTE2KVxuXHRcdFx0aWYgKCB2YWx1ZSA9PSBudWxsIHx8IHZhbHVlICE9PSB2YWx1ZSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBhIG51bWJlciB3YXMgcGFzc2VkIGluLCBhZGQgdGhlIHVuaXQgKGV4Y2VwdCBmb3IgY2VydGFpbiBDU1MgcHJvcGVydGllcylcblx0XHRcdC8vIFRoZSBpc0N1c3RvbVByb3AgY2hlY2sgY2FuIGJlIHJlbW92ZWQgaW4galF1ZXJ5IDQuMCB3aGVuIHdlIG9ubHkgYXV0by1hcHBlbmRcblx0XHRcdC8vIFwicHhcIiB0byBhIGZldyBoYXJkY29kZWQgdmFsdWVzLlxuXHRcdFx0aWYgKCB0eXBlID09PSBcIm51bWJlclwiICYmICFpc0N1c3RvbVByb3AgKSB7XG5cdFx0XHRcdHZhbHVlICs9IHJldCAmJiByZXRbIDMgXSB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIG9yaWdOYW1lIF0gPyBcIlwiIDogXCJweFwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGJhY2tncm91bmQtKiBwcm9wcyBhZmZlY3Qgb3JpZ2luYWwgY2xvbmUncyB2YWx1ZXNcblx0XHRcdGlmICggIXN1cHBvcnQuY2xlYXJDbG9uZVN0eWxlICYmIHZhbHVlID09PSBcIlwiICYmIG5hbWUuaW5kZXhPZiggXCJiYWNrZ3JvdW5kXCIgKSA9PT0gMCApIHtcblx0XHRcdFx0c3R5bGVbIG5hbWUgXSA9IFwiaW5oZXJpdFwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkLCB1c2UgdGhhdCB2YWx1ZSwgb3RoZXJ3aXNlIGp1c3Qgc2V0IHRoZSBzcGVjaWZpZWQgdmFsdWVcblx0XHRcdGlmICggIWhvb2tzIHx8ICEoIFwic2V0XCIgaW4gaG9va3MgKSB8fFxuXHRcdFx0XHQoIHZhbHVlID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgZXh0cmEgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0aWYgKCBpc0N1c3RvbVByb3AgKSB7XG5cdFx0XHRcdFx0c3R5bGUuc2V0UHJvcGVydHkoIG5hbWUsIHZhbHVlICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c3R5bGVbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkIGdldCB0aGUgbm9uLWNvbXB1dGVkIHZhbHVlIGZyb20gdGhlcmVcblx0XHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHQoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgZmFsc2UsIGV4dHJhICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE90aGVyd2lzZSBqdXN0IGdldCB0aGUgdmFsdWUgZnJvbSB0aGUgc3R5bGUgb2JqZWN0XG5cdFx0XHRyZXR1cm4gc3R5bGVbIG5hbWUgXTtcblx0XHR9XG5cdH0sXG5cblx0Y3NzOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZXh0cmEsIHN0eWxlcyApIHtcblx0XHR2YXIgdmFsLCBudW0sIGhvb2tzLFxuXHRcdFx0b3JpZ05hbWUgPSBjYW1lbENhc2UoIG5hbWUgKSxcblx0XHRcdGlzQ3VzdG9tUHJvcCA9IHJjdXN0b21Qcm9wLnRlc3QoIG5hbWUgKTtcblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZS4gV2UgZG9uJ3Rcblx0XHQvLyB3YW50IHRvIG1vZGlmeSB0aGUgdmFsdWUgaWYgaXQgaXMgYSBDU1MgY3VzdG9tIHByb3BlcnR5XG5cdFx0Ly8gc2luY2UgdGhleSBhcmUgdXNlci1kZWZpbmVkLlxuXHRcdGlmICggIWlzQ3VzdG9tUHJvcCApIHtcblx0XHRcdG5hbWUgPSBmaW5hbFByb3BOYW1lKCBvcmlnTmFtZSApO1xuXHRcdH1cblxuXHRcdC8vIFRyeSBwcmVmaXhlZCBuYW1lIGZvbGxvd2VkIGJ5IHRoZSB1bnByZWZpeGVkIG5hbWVcblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdIHx8IGpRdWVyeS5jc3NIb29rc1sgb3JpZ05hbWUgXTtcblxuXHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQgZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICkge1xuXHRcdFx0dmFsID0gaG9va3MuZ2V0KCBlbGVtLCB0cnVlLCBleHRyYSApO1xuXHRcdH1cblxuXHRcdC8vIE90aGVyd2lzZSwgaWYgYSB3YXkgdG8gZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBleGlzdHMsIHVzZSB0aGF0XG5cdFx0aWYgKCB2YWwgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHZhbCA9IGN1ckNTUyggZWxlbSwgbmFtZSwgc3R5bGVzICk7XG5cdFx0fVxuXG5cdFx0Ly8gQ29udmVydCBcIm5vcm1hbFwiIHRvIGNvbXB1dGVkIHZhbHVlXG5cdFx0aWYgKCB2YWwgPT09IFwibm9ybWFsXCIgJiYgbmFtZSBpbiBjc3NOb3JtYWxUcmFuc2Zvcm0gKSB7XG5cdFx0XHR2YWwgPSBjc3NOb3JtYWxUcmFuc2Zvcm1bIG5hbWUgXTtcblx0XHR9XG5cblx0XHQvLyBNYWtlIG51bWVyaWMgaWYgZm9yY2VkIG9yIGEgcXVhbGlmaWVyIHdhcyBwcm92aWRlZCBhbmQgdmFsIGxvb2tzIG51bWVyaWNcblx0XHRpZiAoIGV4dHJhID09PSBcIlwiIHx8IGV4dHJhICkge1xuXHRcdFx0bnVtID0gcGFyc2VGbG9hdCggdmFsICk7XG5cdFx0XHRyZXR1cm4gZXh0cmEgPT09IHRydWUgfHwgaXNGaW5pdGUoIG51bSApID8gbnVtIHx8IDAgOiB2YWw7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZhbDtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggWyBcImhlaWdodFwiLCBcIndpZHRoXCIgXSwgZnVuY3Rpb24oIF9pLCBkaW1lbnNpb24gKSB7XG5cdGpRdWVyeS5jc3NIb29rc1sgZGltZW5zaW9uIF0gPSB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQsIGV4dHJhICkge1xuXHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblxuXHRcdFx0XHQvLyBDZXJ0YWluIGVsZW1lbnRzIGNhbiBoYXZlIGRpbWVuc2lvbiBpbmZvIGlmIHdlIGludmlzaWJseSBzaG93IHRoZW1cblx0XHRcdFx0Ly8gYnV0IGl0IG11c3QgaGF2ZSBhIGN1cnJlbnQgZGlzcGxheSBzdHlsZSB0aGF0IHdvdWxkIGJlbmVmaXRcblx0XHRcdFx0cmV0dXJuIHJkaXNwbGF5c3dhcC50ZXN0KCBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApICkgJiZcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFNhZmFyaSA4K1xuXHRcdFx0XHRcdC8vIFRhYmxlIGNvbHVtbnMgaW4gU2FmYXJpIGhhdmUgbm9uLXplcm8gb2Zmc2V0V2lkdGggJiB6ZXJvXG5cdFx0XHRcdFx0Ly8gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggdW5sZXNzIGRpc3BsYXkgaXMgY2hhbmdlZC5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0XHRcdFx0XHQvLyBSdW5uaW5nIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBvbiBhIGRpc2Nvbm5lY3RlZCBub2RlXG5cdFx0XHRcdFx0Ly8gaW4gSUUgdGhyb3dzIGFuIGVycm9yLlxuXHRcdFx0XHRcdCggIWVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggfHwgIWVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggKSA/XG5cdFx0XHRcdFx0c3dhcCggZWxlbSwgY3NzU2hvdywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZ2V0V2lkdGhPckhlaWdodCggZWxlbSwgZGltZW5zaW9uLCBleHRyYSApO1xuXHRcdFx0XHRcdH0gKSA6XG5cdFx0XHRcdFx0Z2V0V2lkdGhPckhlaWdodCggZWxlbSwgZGltZW5zaW9uLCBleHRyYSApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgZXh0cmEgKSB7XG5cdFx0XHR2YXIgbWF0Y2hlcyxcblx0XHRcdFx0c3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICksXG5cblx0XHRcdFx0Ly8gT25seSByZWFkIHN0eWxlcy5wb3NpdGlvbiBpZiB0aGUgdGVzdCBoYXMgYSBjaGFuY2UgdG8gZmFpbFxuXHRcdFx0XHQvLyB0byBhdm9pZCBmb3JjaW5nIGEgcmVmbG93LlxuXHRcdFx0XHRzY3JvbGxib3hTaXplQnVnZ3kgPSAhc3VwcG9ydC5zY3JvbGxib3hTaXplKCkgJiZcblx0XHRcdFx0XHRzdHlsZXMucG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIixcblxuXHRcdFx0XHQvLyBUbyBhdm9pZCBmb3JjaW5nIGEgcmVmbG93LCBvbmx5IGZldGNoIGJveFNpemluZyBpZiB3ZSBuZWVkIGl0IChnaC0zOTkxKVxuXHRcdFx0XHRib3hTaXppbmdOZWVkZWQgPSBzY3JvbGxib3hTaXplQnVnZ3kgfHwgZXh0cmEsXG5cdFx0XHRcdGlzQm9yZGVyQm94ID0gYm94U2l6aW5nTmVlZGVkICYmXG5cdFx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgXCJib3hTaXppbmdcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImJvcmRlci1ib3hcIixcblx0XHRcdFx0c3VidHJhY3QgPSBleHRyYSA/XG5cdFx0XHRcdFx0Ym94TW9kZWxBZGp1c3RtZW50KFxuXHRcdFx0XHRcdFx0ZWxlbSxcblx0XHRcdFx0XHRcdGRpbWVuc2lvbixcblx0XHRcdFx0XHRcdGV4dHJhLFxuXHRcdFx0XHRcdFx0aXNCb3JkZXJCb3gsXG5cdFx0XHRcdFx0XHRzdHlsZXNcblx0XHRcdFx0XHQpIDpcblx0XHRcdFx0XHQwO1xuXG5cdFx0XHQvLyBBY2NvdW50IGZvciB1bnJlbGlhYmxlIGJvcmRlci1ib3ggZGltZW5zaW9ucyBieSBjb21wYXJpbmcgb2Zmc2V0KiB0byBjb21wdXRlZCBhbmRcblx0XHRcdC8vIGZha2luZyBhIGNvbnRlbnQtYm94IHRvIGdldCBib3JkZXIgYW5kIHBhZGRpbmcgKGdoLTM2OTkpXG5cdFx0XHRpZiAoIGlzQm9yZGVyQm94ICYmIHNjcm9sbGJveFNpemVCdWdneSApIHtcblx0XHRcdFx0c3VidHJhY3QgLT0gTWF0aC5jZWlsKFxuXHRcdFx0XHRcdGVsZW1bIFwib2Zmc2V0XCIgKyBkaW1lbnNpb25bIDAgXS50b1VwcGVyQ2FzZSgpICsgZGltZW5zaW9uLnNsaWNlKCAxICkgXSAtXG5cdFx0XHRcdFx0cGFyc2VGbG9hdCggc3R5bGVzWyBkaW1lbnNpb24gXSApIC1cblx0XHRcdFx0XHRib3hNb2RlbEFkanVzdG1lbnQoIGVsZW0sIGRpbWVuc2lvbiwgXCJib3JkZXJcIiwgZmFsc2UsIHN0eWxlcyApIC1cblx0XHRcdFx0XHQwLjVcblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29udmVydCB0byBwaXhlbHMgaWYgdmFsdWUgYWRqdXN0bWVudCBpcyBuZWVkZWRcblx0XHRcdGlmICggc3VidHJhY3QgJiYgKCBtYXRjaGVzID0gcmNzc051bS5leGVjKCB2YWx1ZSApICkgJiZcblx0XHRcdFx0KCBtYXRjaGVzWyAzIF0gfHwgXCJweFwiICkgIT09IFwicHhcIiApIHtcblxuXHRcdFx0XHRlbGVtLnN0eWxlWyBkaW1lbnNpb24gXSA9IHZhbHVlO1xuXHRcdFx0XHR2YWx1ZSA9IGpRdWVyeS5jc3MoIGVsZW0sIGRpbWVuc2lvbiApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gc2V0UG9zaXRpdmVOdW1iZXIoIGVsZW0sIHZhbHVlLCBzdWJ0cmFjdCApO1xuXHRcdH1cblx0fTtcbn0gKTtcblxualF1ZXJ5LmNzc0hvb2tzLm1hcmdpbkxlZnQgPSBhZGRHZXRIb29rSWYoIHN1cHBvcnQucmVsaWFibGVNYXJnaW5MZWZ0LFxuXHRmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRcdHJldHVybiAoIHBhcnNlRmxvYXQoIGN1ckNTUyggZWxlbSwgXCJtYXJnaW5MZWZ0XCIgKSApIHx8XG5cdFx0XHRcdGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCAtXG5cdFx0XHRcdFx0c3dhcCggZWxlbSwgeyBtYXJnaW5MZWZ0OiAwIH0sIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdDtcblx0XHRcdFx0XHR9IClcblx0XHRcdCkgKyBcInB4XCI7XG5cdFx0fVxuXHR9XG4pO1xuXG4vLyBUaGVzZSBob29rcyBhcmUgdXNlZCBieSBhbmltYXRlIHRvIGV4cGFuZCBwcm9wZXJ0aWVzXG5qUXVlcnkuZWFjaCgge1xuXHRtYXJnaW46IFwiXCIsXG5cdHBhZGRpbmc6IFwiXCIsXG5cdGJvcmRlcjogXCJXaWR0aFwiXG59LCBmdW5jdGlvbiggcHJlZml4LCBzdWZmaXggKSB7XG5cdGpRdWVyeS5jc3NIb29rc1sgcHJlZml4ICsgc3VmZml4IF0gPSB7XG5cdFx0ZXhwYW5kOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgaSA9IDAsXG5cdFx0XHRcdGV4cGFuZGVkID0ge30sXG5cblx0XHRcdFx0Ly8gQXNzdW1lcyBhIHNpbmdsZSBudW1iZXIgaWYgbm90IGEgc3RyaW5nXG5cdFx0XHRcdHBhcnRzID0gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiID8gdmFsdWUuc3BsaXQoIFwiIFwiICkgOiBbIHZhbHVlIF07XG5cblx0XHRcdGZvciAoIDsgaSA8IDQ7IGkrKyApIHtcblx0XHRcdFx0ZXhwYW5kZWRbIHByZWZpeCArIGNzc0V4cGFuZFsgaSBdICsgc3VmZml4IF0gPVxuXHRcdFx0XHRcdHBhcnRzWyBpIF0gfHwgcGFydHNbIGkgLSAyIF0gfHwgcGFydHNbIDAgXTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGV4cGFuZGVkO1xuXHRcdH1cblx0fTtcblxuXHRpZiAoIHByZWZpeCAhPT0gXCJtYXJnaW5cIiApIHtcblx0XHRqUXVlcnkuY3NzSG9va3NbIHByZWZpeCArIHN1ZmZpeCBdLnNldCA9IHNldFBvc2l0aXZlTnVtYmVyO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0Y3NzOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdFx0dmFyIHN0eWxlcywgbGVuLFxuXHRcdFx0XHRtYXAgPSB7fSxcblx0XHRcdFx0aSA9IDA7XG5cblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggbmFtZSApICkge1xuXHRcdFx0XHRzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKTtcblx0XHRcdFx0bGVuID0gbmFtZS5sZW5ndGg7XG5cblx0XHRcdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdFx0bWFwWyBuYW1lWyBpIF0gXSA9IGpRdWVyeS5jc3MoIGVsZW0sIG5hbWVbIGkgXSwgZmFsc2UsIHN0eWxlcyApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIG1hcDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIG5hbWUsIHZhbHVlICkgOlxuXHRcdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCBuYW1lICk7XG5cdFx0fSwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH1cbn0gKTtcblxuXG5mdW5jdGlvbiBUd2VlbiggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcgKSB7XG5cdHJldHVybiBuZXcgVHdlZW4ucHJvdG90eXBlLmluaXQoIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nICk7XG59XG5qUXVlcnkuVHdlZW4gPSBUd2VlbjtcblxuVHdlZW4ucHJvdG90eXBlID0ge1xuXHRjb25zdHJ1Y3RvcjogVHdlZW4sXG5cdGluaXQ6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZywgdW5pdCApIHtcblx0XHR0aGlzLmVsZW0gPSBlbGVtO1xuXHRcdHRoaXMucHJvcCA9IHByb3A7XG5cdFx0dGhpcy5lYXNpbmcgPSBlYXNpbmcgfHwgalF1ZXJ5LmVhc2luZy5fZGVmYXVsdDtcblx0XHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXHRcdHRoaXMuc3RhcnQgPSB0aGlzLm5vdyA9IHRoaXMuY3VyKCk7XG5cdFx0dGhpcy5lbmQgPSBlbmQ7XG5cdFx0dGhpcy51bml0ID0gdW5pdCB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSA/IFwiXCIgOiBcInB4XCIgKTtcblx0fSxcblx0Y3VyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaG9va3MgPSBUd2Vlbi5wcm9wSG9va3NbIHRoaXMucHJvcCBdO1xuXG5cdFx0cmV0dXJuIGhvb2tzICYmIGhvb2tzLmdldCA/XG5cdFx0XHRob29rcy5nZXQoIHRoaXMgKSA6XG5cdFx0XHRUd2Vlbi5wcm9wSG9va3MuX2RlZmF1bHQuZ2V0KCB0aGlzICk7XG5cdH0sXG5cdHJ1bjogZnVuY3Rpb24oIHBlcmNlbnQgKSB7XG5cdFx0dmFyIGVhc2VkLFxuXHRcdFx0aG9va3MgPSBUd2Vlbi5wcm9wSG9va3NbIHRoaXMucHJvcCBdO1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuZHVyYXRpb24gKSB7XG5cdFx0XHR0aGlzLnBvcyA9IGVhc2VkID0galF1ZXJ5LmVhc2luZ1sgdGhpcy5lYXNpbmcgXShcblx0XHRcdFx0cGVyY2VudCwgdGhpcy5vcHRpb25zLmR1cmF0aW9uICogcGVyY2VudCwgMCwgMSwgdGhpcy5vcHRpb25zLmR1cmF0aW9uXG5cdFx0XHQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnBvcyA9IGVhc2VkID0gcGVyY2VudDtcblx0XHR9XG5cdFx0dGhpcy5ub3cgPSAoIHRoaXMuZW5kIC0gdGhpcy5zdGFydCApICogZWFzZWQgKyB0aGlzLnN0YXJ0O1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuc3RlcCApIHtcblx0XHRcdHRoaXMub3B0aW9ucy5zdGVwLmNhbGwoIHRoaXMuZWxlbSwgdGhpcy5ub3csIHRoaXMgKTtcblx0XHR9XG5cblx0XHRpZiAoIGhvb2tzICYmIGhvb2tzLnNldCApIHtcblx0XHRcdGhvb2tzLnNldCggdGhpcyApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRUd2Vlbi5wcm9wSG9va3MuX2RlZmF1bHQuc2V0KCB0aGlzICk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59O1xuXG5Ud2Vlbi5wcm90b3R5cGUuaW5pdC5wcm90b3R5cGUgPSBUd2Vlbi5wcm90b3R5cGU7XG5cblR3ZWVuLnByb3BIb29rcyA9IHtcblx0X2RlZmF1bHQ6IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcblx0XHRcdHZhciByZXN1bHQ7XG5cblx0XHRcdC8vIFVzZSBhIHByb3BlcnR5IG9uIHRoZSBlbGVtZW50IGRpcmVjdGx5IHdoZW4gaXQgaXMgbm90IGEgRE9NIGVsZW1lbnQsXG5cdFx0XHQvLyBvciB3aGVuIHRoZXJlIGlzIG5vIG1hdGNoaW5nIHN0eWxlIHByb3BlcnR5IHRoYXQgZXhpc3RzLlxuXHRcdFx0aWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlICE9PSAxIHx8XG5cdFx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSAhPSBudWxsICYmIHR3ZWVuLmVsZW0uc3R5bGVbIHR3ZWVuLnByb3AgXSA9PSBudWxsICkge1xuXHRcdFx0XHRyZXR1cm4gdHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBQYXNzaW5nIGFuIGVtcHR5IHN0cmluZyBhcyBhIDNyZCBwYXJhbWV0ZXIgdG8gLmNzcyB3aWxsIGF1dG9tYXRpY2FsbHlcblx0XHRcdC8vIGF0dGVtcHQgYSBwYXJzZUZsb2F0IGFuZCBmYWxsYmFjayB0byBhIHN0cmluZyBpZiB0aGUgcGFyc2UgZmFpbHMuXG5cdFx0XHQvLyBTaW1wbGUgdmFsdWVzIHN1Y2ggYXMgXCIxMHB4XCIgYXJlIHBhcnNlZCB0byBGbG9hdDtcblx0XHRcdC8vIGNvbXBsZXggdmFsdWVzIHN1Y2ggYXMgXCJyb3RhdGUoMXJhZClcIiBhcmUgcmV0dXJuZWQgYXMtaXMuXG5cdFx0XHRyZXN1bHQgPSBqUXVlcnkuY3NzKCB0d2Vlbi5lbGVtLCB0d2Vlbi5wcm9wLCBcIlwiICk7XG5cblx0XHRcdC8vIEVtcHR5IHN0cmluZ3MsIG51bGwsIHVuZGVmaW5lZCBhbmQgXCJhdXRvXCIgYXJlIGNvbnZlcnRlZCB0byAwLlxuXHRcdFx0cmV0dXJuICFyZXN1bHQgfHwgcmVzdWx0ID09PSBcImF1dG9cIiA/IDAgOiByZXN1bHQ7XG5cdFx0fSxcblx0XHRzZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcblxuXHRcdFx0Ly8gVXNlIHN0ZXAgaG9vayBmb3IgYmFjayBjb21wYXQuXG5cdFx0XHQvLyBVc2UgY3NzSG9vayBpZiBpdHMgdGhlcmUuXG5cdFx0XHQvLyBVc2UgLnN0eWxlIGlmIGF2YWlsYWJsZSBhbmQgdXNlIHBsYWluIHByb3BlcnRpZXMgd2hlcmUgYXZhaWxhYmxlLlxuXHRcdFx0aWYgKCBqUXVlcnkuZnguc3RlcFsgdHdlZW4ucHJvcCBdICkge1xuXHRcdFx0XHRqUXVlcnkuZnguc3RlcFsgdHdlZW4ucHJvcCBdKCB0d2VlbiApO1xuXHRcdFx0fSBlbHNlIGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAoXG5cdFx0XHRcdGpRdWVyeS5jc3NIb29rc1sgdHdlZW4ucHJvcCBdIHx8XG5cdFx0XHRcdFx0dHdlZW4uZWxlbS5zdHlsZVsgZmluYWxQcm9wTmFtZSggdHdlZW4ucHJvcCApIF0gIT0gbnVsbCApICkge1xuXHRcdFx0XHRqUXVlcnkuc3R5bGUoIHR3ZWVuLmVsZW0sIHR3ZWVuLnByb3AsIHR3ZWVuLm5vdyArIHR3ZWVuLnVuaXQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSA9IHR3ZWVuLm5vdztcblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG5cbi8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG4vLyBQYW5pYyBiYXNlZCBhcHByb2FjaCB0byBzZXR0aW5nIHRoaW5ncyBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcblR3ZWVuLnByb3BIb29rcy5zY3JvbGxUb3AgPSBUd2Vlbi5wcm9wSG9va3Muc2Nyb2xsTGVmdCA9IHtcblx0c2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cdFx0aWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlICYmIHR3ZWVuLmVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSA9IHR3ZWVuLm5vdztcblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5lYXNpbmcgPSB7XG5cdGxpbmVhcjogZnVuY3Rpb24oIHAgKSB7XG5cdFx0cmV0dXJuIHA7XG5cdH0sXG5cdHN3aW5nOiBmdW5jdGlvbiggcCApIHtcblx0XHRyZXR1cm4gMC41IC0gTWF0aC5jb3MoIHAgKiBNYXRoLlBJICkgLyAyO1xuXHR9LFxuXHRfZGVmYXVsdDogXCJzd2luZ1wiXG59O1xuXG5qUXVlcnkuZnggPSBUd2Vlbi5wcm90b3R5cGUuaW5pdDtcblxuLy8gQmFjayBjb21wYXQgPDEuOCBleHRlbnNpb24gcG9pbnRcbmpRdWVyeS5meC5zdGVwID0ge307XG5cblxuXG5cbnZhclxuXHRmeE5vdywgaW5Qcm9ncmVzcyxcblx0cmZ4dHlwZXMgPSAvXig/OnRvZ2dsZXxzaG93fGhpZGUpJC8sXG5cdHJydW4gPSAvcXVldWVIb29rcyQvO1xuXG5mdW5jdGlvbiBzY2hlZHVsZSgpIHtcblx0aWYgKCBpblByb2dyZXNzICkge1xuXHRcdGlmICggZG9jdW1lbnQuaGlkZGVuID09PSBmYWxzZSAmJiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lICkge1xuXHRcdFx0d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSggc2NoZWR1bGUgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0d2luZG93LnNldFRpbWVvdXQoIHNjaGVkdWxlLCBqUXVlcnkuZnguaW50ZXJ2YWwgKTtcblx0XHR9XG5cblx0XHRqUXVlcnkuZngudGljaygpO1xuXHR9XG59XG5cbi8vIEFuaW1hdGlvbnMgY3JlYXRlZCBzeW5jaHJvbm91c2x5IHdpbGwgcnVuIHN5bmNocm9ub3VzbHlcbmZ1bmN0aW9uIGNyZWF0ZUZ4Tm93KCkge1xuXHR3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0ZnhOb3cgPSB1bmRlZmluZWQ7XG5cdH0gKTtcblx0cmV0dXJuICggZnhOb3cgPSBEYXRlLm5vdygpICk7XG59XG5cbi8vIEdlbmVyYXRlIHBhcmFtZXRlcnMgdG8gY3JlYXRlIGEgc3RhbmRhcmQgYW5pbWF0aW9uXG5mdW5jdGlvbiBnZW5GeCggdHlwZSwgaW5jbHVkZVdpZHRoICkge1xuXHR2YXIgd2hpY2gsXG5cdFx0aSA9IDAsXG5cdFx0YXR0cnMgPSB7IGhlaWdodDogdHlwZSB9O1xuXG5cdC8vIElmIHdlIGluY2x1ZGUgd2lkdGgsIHN0ZXAgdmFsdWUgaXMgMSB0byBkbyBhbGwgY3NzRXhwYW5kIHZhbHVlcyxcblx0Ly8gb3RoZXJ3aXNlIHN0ZXAgdmFsdWUgaXMgMiB0byBza2lwIG92ZXIgTGVmdCBhbmQgUmlnaHRcblx0aW5jbHVkZVdpZHRoID0gaW5jbHVkZVdpZHRoID8gMSA6IDA7XG5cdGZvciAoIDsgaSA8IDQ7IGkgKz0gMiAtIGluY2x1ZGVXaWR0aCApIHtcblx0XHR3aGljaCA9IGNzc0V4cGFuZFsgaSBdO1xuXHRcdGF0dHJzWyBcIm1hcmdpblwiICsgd2hpY2ggXSA9IGF0dHJzWyBcInBhZGRpbmdcIiArIHdoaWNoIF0gPSB0eXBlO1xuXHR9XG5cblx0aWYgKCBpbmNsdWRlV2lkdGggKSB7XG5cdFx0YXR0cnMub3BhY2l0eSA9IGF0dHJzLndpZHRoID0gdHlwZTtcblx0fVxuXG5cdHJldHVybiBhdHRycztcbn1cblxuZnVuY3Rpb24gY3JlYXRlVHdlZW4oIHZhbHVlLCBwcm9wLCBhbmltYXRpb24gKSB7XG5cdHZhciB0d2Vlbixcblx0XHRjb2xsZWN0aW9uID0gKCBBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSB8fCBbXSApLmNvbmNhdCggQW5pbWF0aW9uLnR3ZWVuZXJzWyBcIipcIiBdICksXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xuXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdGlmICggKCB0d2VlbiA9IGNvbGxlY3Rpb25bIGluZGV4IF0uY2FsbCggYW5pbWF0aW9uLCBwcm9wLCB2YWx1ZSApICkgKSB7XG5cblx0XHRcdC8vIFdlJ3JlIGRvbmUgd2l0aCB0aGlzIHByb3BlcnR5XG5cdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRQcmVmaWx0ZXIoIGVsZW0sIHByb3BzLCBvcHRzICkge1xuXHR2YXIgcHJvcCwgdmFsdWUsIHRvZ2dsZSwgaG9va3MsIG9sZGZpcmUsIHByb3BUd2VlbiwgcmVzdG9yZURpc3BsYXksIGRpc3BsYXksXG5cdFx0aXNCb3ggPSBcIndpZHRoXCIgaW4gcHJvcHMgfHwgXCJoZWlnaHRcIiBpbiBwcm9wcyxcblx0XHRhbmltID0gdGhpcyxcblx0XHRvcmlnID0ge30sXG5cdFx0c3R5bGUgPSBlbGVtLnN0eWxlLFxuXHRcdGhpZGRlbiA9IGVsZW0ubm9kZVR5cGUgJiYgaXNIaWRkZW5XaXRoaW5UcmVlKCBlbGVtICksXG5cdFx0ZGF0YVNob3cgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFwiZnhzaG93XCIgKTtcblxuXHQvLyBRdWV1ZS1za2lwcGluZyBhbmltYXRpb25zIGhpamFjayB0aGUgZnggaG9va3Ncblx0aWYgKCAhb3B0cy5xdWV1ZSApIHtcblx0XHRob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyggZWxlbSwgXCJmeFwiICk7XG5cdFx0aWYgKCBob29rcy51bnF1ZXVlZCA9PSBudWxsICkge1xuXHRcdFx0aG9va3MudW5xdWV1ZWQgPSAwO1xuXHRcdFx0b2xkZmlyZSA9IGhvb2tzLmVtcHR5LmZpcmU7XG5cdFx0XHRob29rcy5lbXB0eS5maXJlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggIWhvb2tzLnVucXVldWVkICkge1xuXHRcdFx0XHRcdG9sZGZpcmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9XG5cdFx0aG9va3MudW5xdWV1ZWQrKztcblxuXHRcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRW5zdXJlIHRoZSBjb21wbGV0ZSBoYW5kbGVyIGlzIGNhbGxlZCBiZWZvcmUgdGhpcyBjb21wbGV0ZXNcblx0XHRcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0aG9va3MudW5xdWV1ZWQtLTtcblx0XHRcdFx0aWYgKCAhalF1ZXJ5LnF1ZXVlKCBlbGVtLCBcImZ4XCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdFx0aG9va3MuZW1wdHkuZmlyZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gRGV0ZWN0IHNob3cvaGlkZSBhbmltYXRpb25zXG5cdGZvciAoIHByb3AgaW4gcHJvcHMgKSB7XG5cdFx0dmFsdWUgPSBwcm9wc1sgcHJvcCBdO1xuXHRcdGlmICggcmZ4dHlwZXMudGVzdCggdmFsdWUgKSApIHtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgcHJvcCBdO1xuXHRcdFx0dG9nZ2xlID0gdG9nZ2xlIHx8IHZhbHVlID09PSBcInRvZ2dsZVwiO1xuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gKCBoaWRkZW4gPyBcImhpZGVcIiA6IFwic2hvd1wiICkgKSB7XG5cblx0XHRcdFx0Ly8gUHJldGVuZCB0byBiZSBoaWRkZW4gaWYgdGhpcyBpcyBhIFwic2hvd1wiIGFuZFxuXHRcdFx0XHQvLyB0aGVyZSBpcyBzdGlsbCBkYXRhIGZyb20gYSBzdG9wcGVkIHNob3cvaGlkZVxuXHRcdFx0XHRpZiAoIHZhbHVlID09PSBcInNob3dcIiAmJiBkYXRhU2hvdyAmJiBkYXRhU2hvd1sgcHJvcCBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0aGlkZGVuID0gdHJ1ZTtcblxuXHRcdFx0XHQvLyBJZ25vcmUgYWxsIG90aGVyIG5vLW9wIHNob3cvaGlkZSBkYXRhXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdG9yaWdbIHByb3AgXSA9IGRhdGFTaG93ICYmIGRhdGFTaG93WyBwcm9wIF0gfHwgalF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQmFpbCBvdXQgaWYgdGhpcyBpcyBhIG5vLW9wIGxpa2UgLmhpZGUoKS5oaWRlKClcblx0cHJvcFR3ZWVuID0gIWpRdWVyeS5pc0VtcHR5T2JqZWN0KCBwcm9wcyApO1xuXHRpZiAoICFwcm9wVHdlZW4gJiYgalF1ZXJ5LmlzRW1wdHlPYmplY3QoIG9yaWcgKSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBSZXN0cmljdCBcIm92ZXJmbG93XCIgYW5kIFwiZGlzcGxheVwiIHN0eWxlcyBkdXJpbmcgYm94IGFuaW1hdGlvbnNcblx0aWYgKCBpc0JveCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEsIEVkZ2UgMTIgLSAxNVxuXHRcdC8vIFJlY29yZCBhbGwgMyBvdmVyZmxvdyBhdHRyaWJ1dGVzIGJlY2F1c2UgSUUgZG9lcyBub3QgaW5mZXIgdGhlIHNob3J0aGFuZFxuXHRcdC8vIGZyb20gaWRlbnRpY2FsbHktdmFsdWVkIG92ZXJmbG93WCBhbmQgb3ZlcmZsb3dZIGFuZCBFZGdlIGp1c3QgbWlycm9yc1xuXHRcdC8vIHRoZSBvdmVyZmxvd1ggdmFsdWUgdGhlcmUuXG5cdFx0b3B0cy5vdmVyZmxvdyA9IFsgc3R5bGUub3ZlcmZsb3csIHN0eWxlLm92ZXJmbG93WCwgc3R5bGUub3ZlcmZsb3dZIF07XG5cblx0XHQvLyBJZGVudGlmeSBhIGRpc3BsYXkgdHlwZSwgcHJlZmVycmluZyBvbGQgc2hvdy9oaWRlIGRhdGEgb3ZlciB0aGUgQ1NTIGNhc2NhZGVcblx0XHRyZXN0b3JlRGlzcGxheSA9IGRhdGFTaG93ICYmIGRhdGFTaG93LmRpc3BsYXk7XG5cdFx0aWYgKCByZXN0b3JlRGlzcGxheSA9PSBudWxsICkge1xuXHRcdFx0cmVzdG9yZURpc3BsYXkgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFwiZGlzcGxheVwiICk7XG5cdFx0fVxuXHRcdGRpc3BsYXkgPSBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApO1xuXHRcdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0XHRpZiAoIHJlc3RvcmVEaXNwbGF5ICkge1xuXHRcdFx0XHRkaXNwbGF5ID0gcmVzdG9yZURpc3BsYXk7XG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIEdldCBub25lbXB0eSB2YWx1ZShzKSBieSB0ZW1wb3JhcmlseSBmb3JjaW5nIHZpc2liaWxpdHlcblx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdLCB0cnVlICk7XG5cdFx0XHRcdHJlc3RvcmVEaXNwbGF5ID0gZWxlbS5zdHlsZS5kaXNwbGF5IHx8IHJlc3RvcmVEaXNwbGF5O1xuXHRcdFx0XHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKTtcblx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQW5pbWF0ZSBpbmxpbmUgZWxlbWVudHMgYXMgaW5saW5lLWJsb2NrXG5cdFx0aWYgKCBkaXNwbGF5ID09PSBcImlubGluZVwiIHx8IGRpc3BsYXkgPT09IFwiaW5saW5lLWJsb2NrXCIgJiYgcmVzdG9yZURpc3BsYXkgIT0gbnVsbCApIHtcblx0XHRcdGlmICggalF1ZXJ5LmNzcyggZWxlbSwgXCJmbG9hdFwiICkgPT09IFwibm9uZVwiICkge1xuXG5cdFx0XHRcdC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIGRpc3BsYXkgdmFsdWUgYXQgdGhlIGVuZCBvZiBwdXJlIHNob3cvaGlkZSBhbmltYXRpb25zXG5cdFx0XHRcdGlmICggIXByb3BUd2VlbiApIHtcblx0XHRcdFx0XHRhbmltLmRvbmUoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0c3R5bGUuZGlzcGxheSA9IHJlc3RvcmVEaXNwbGF5O1xuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRpZiAoIHJlc3RvcmVEaXNwbGF5ID09IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRkaXNwbGF5ID0gc3R5bGUuZGlzcGxheTtcblx0XHRcdFx0XHRcdHJlc3RvcmVEaXNwbGF5ID0gZGlzcGxheSA9PT0gXCJub25lXCIgPyBcIlwiIDogZGlzcGxheTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0c3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCI7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0aWYgKCBvcHRzLm92ZXJmbG93ICkge1xuXHRcdHN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcblx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cdFx0XHRzdHlsZS5vdmVyZmxvdyA9IG9wdHMub3ZlcmZsb3dbIDAgXTtcblx0XHRcdHN0eWxlLm92ZXJmbG93WCA9IG9wdHMub3ZlcmZsb3dbIDEgXTtcblx0XHRcdHN0eWxlLm92ZXJmbG93WSA9IG9wdHMub3ZlcmZsb3dbIDIgXTtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBJbXBsZW1lbnQgc2hvdy9oaWRlIGFuaW1hdGlvbnNcblx0cHJvcFR3ZWVuID0gZmFsc2U7XG5cdGZvciAoIHByb3AgaW4gb3JpZyApIHtcblxuXHRcdC8vIEdlbmVyYWwgc2hvdy9oaWRlIHNldHVwIGZvciB0aGlzIGVsZW1lbnQgYW5pbWF0aW9uXG5cdFx0aWYgKCAhcHJvcFR3ZWVuICkge1xuXHRcdFx0aWYgKCBkYXRhU2hvdyApIHtcblx0XHRcdFx0aWYgKCBcImhpZGRlblwiIGluIGRhdGFTaG93ICkge1xuXHRcdFx0XHRcdGhpZGRlbiA9IGRhdGFTaG93LmhpZGRlbjtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGF0YVNob3cgPSBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIFwiZnhzaG93XCIsIHsgZGlzcGxheTogcmVzdG9yZURpc3BsYXkgfSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdG9yZSBoaWRkZW4vdmlzaWJsZSBmb3IgdG9nZ2xlIHNvIGAuc3RvcCgpLnRvZ2dsZSgpYCBcInJldmVyc2VzXCJcblx0XHRcdGlmICggdG9nZ2xlICkge1xuXHRcdFx0XHRkYXRhU2hvdy5oaWRkZW4gPSAhaGlkZGVuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTaG93IGVsZW1lbnRzIGJlZm9yZSBhbmltYXRpbmcgdGhlbVxuXHRcdFx0aWYgKCBoaWRkZW4gKSB7XG5cdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSwgdHJ1ZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvKiBlc2xpbnQtZGlzYWJsZSBuby1sb29wLWZ1bmMgKi9cblxuXHRcdFx0YW5pbS5kb25lKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvKiBlc2xpbnQtZW5hYmxlIG5vLWxvb3AtZnVuYyAqL1xuXG5cdFx0XHRcdC8vIFRoZSBmaW5hbCBzdGVwIG9mIGEgXCJoaWRlXCIgYW5pbWF0aW9uIGlzIGFjdHVhbGx5IGhpZGluZyB0aGUgZWxlbWVudFxuXHRcdFx0XHRpZiAoICFoaWRkZW4gKSB7XG5cdFx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBcImZ4c2hvd1wiICk7XG5cdFx0XHRcdGZvciAoIHByb3AgaW4gb3JpZyApIHtcblx0XHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIG9yaWdbIHByb3AgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0Ly8gUGVyLXByb3BlcnR5IHNldHVwXG5cdFx0cHJvcFR3ZWVuID0gY3JlYXRlVHdlZW4oIGhpZGRlbiA/IGRhdGFTaG93WyBwcm9wIF0gOiAwLCBwcm9wLCBhbmltICk7XG5cdFx0aWYgKCAhKCBwcm9wIGluIGRhdGFTaG93ICkgKSB7XG5cdFx0XHRkYXRhU2hvd1sgcHJvcCBdID0gcHJvcFR3ZWVuLnN0YXJ0O1xuXHRcdFx0aWYgKCBoaWRkZW4gKSB7XG5cdFx0XHRcdHByb3BUd2Vlbi5lbmQgPSBwcm9wVHdlZW4uc3RhcnQ7XG5cdFx0XHRcdHByb3BUd2Vlbi5zdGFydCA9IDA7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIHByb3BGaWx0ZXIoIHByb3BzLCBzcGVjaWFsRWFzaW5nICkge1xuXHR2YXIgaW5kZXgsIG5hbWUsIGVhc2luZywgdmFsdWUsIGhvb2tzO1xuXG5cdC8vIGNhbWVsQ2FzZSwgc3BlY2lhbEVhc2luZyBhbmQgZXhwYW5kIGNzc0hvb2sgcGFzc1xuXHRmb3IgKCBpbmRleCBpbiBwcm9wcyApIHtcblx0XHRuYW1lID0gY2FtZWxDYXNlKCBpbmRleCApO1xuXHRcdGVhc2luZyA9IHNwZWNpYWxFYXNpbmdbIG5hbWUgXTtcblx0XHR2YWx1ZSA9IHByb3BzWyBpbmRleCBdO1xuXHRcdGlmICggQXJyYXkuaXNBcnJheSggdmFsdWUgKSApIHtcblx0XHRcdGVhc2luZyA9IHZhbHVlWyAxIF07XG5cdFx0XHR2YWx1ZSA9IHByb3BzWyBpbmRleCBdID0gdmFsdWVbIDAgXTtcblx0XHR9XG5cblx0XHRpZiAoIGluZGV4ICE9PSBuYW1lICkge1xuXHRcdFx0cHJvcHNbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBpbmRleCBdO1xuXHRcdH1cblxuXHRcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF07XG5cdFx0aWYgKCBob29rcyAmJiBcImV4cGFuZFwiIGluIGhvb2tzICkge1xuXHRcdFx0dmFsdWUgPSBob29rcy5leHBhbmQoIHZhbHVlICk7XG5cdFx0XHRkZWxldGUgcHJvcHNbIG5hbWUgXTtcblxuXHRcdFx0Ly8gTm90IHF1aXRlICQuZXh0ZW5kLCB0aGlzIHdvbid0IG92ZXJ3cml0ZSBleGlzdGluZyBrZXlzLlxuXHRcdFx0Ly8gUmV1c2luZyAnaW5kZXgnIGJlY2F1c2Ugd2UgaGF2ZSB0aGUgY29ycmVjdCBcIm5hbWVcIlxuXHRcdFx0Zm9yICggaW5kZXggaW4gdmFsdWUgKSB7XG5cdFx0XHRcdGlmICggISggaW5kZXggaW4gcHJvcHMgKSApIHtcblx0XHRcdFx0XHRwcm9wc1sgaW5kZXggXSA9IHZhbHVlWyBpbmRleCBdO1xuXHRcdFx0XHRcdHNwZWNpYWxFYXNpbmdbIGluZGV4IF0gPSBlYXNpbmc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0c3BlY2lhbEVhc2luZ1sgbmFtZSBdID0gZWFzaW5nO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBBbmltYXRpb24oIGVsZW0sIHByb3BlcnRpZXMsIG9wdGlvbnMgKSB7XG5cdHZhciByZXN1bHQsXG5cdFx0c3RvcHBlZCxcblx0XHRpbmRleCA9IDAsXG5cdFx0bGVuZ3RoID0gQW5pbWF0aW9uLnByZWZpbHRlcnMubGVuZ3RoLFxuXHRcdGRlZmVycmVkID0galF1ZXJ5LkRlZmVycmVkKCkuYWx3YXlzKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRG9uJ3QgbWF0Y2ggZWxlbSBpbiB0aGUgOmFuaW1hdGVkIHNlbGVjdG9yXG5cdFx0XHRkZWxldGUgdGljay5lbGVtO1xuXHRcdH0gKSxcblx0XHR0aWNrID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIHN0b3BwZWQgKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHZhciBjdXJyZW50VGltZSA9IGZ4Tm93IHx8IGNyZWF0ZUZ4Tm93KCksXG5cdFx0XHRcdHJlbWFpbmluZyA9IE1hdGgubWF4KCAwLCBhbmltYXRpb24uc3RhcnRUaW1lICsgYW5pbWF0aW9uLmR1cmF0aW9uIC0gY3VycmVudFRpbWUgKSxcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDIuMyBvbmx5XG5cdFx0XHRcdC8vIEFyY2hhaWMgY3Jhc2ggYnVnIHdvbid0IGFsbG93IHVzIHRvIHVzZSBgMSAtICggMC41IHx8IDAgKWAgKHRyYWMtMTI0OTcpXG5cdFx0XHRcdHRlbXAgPSByZW1haW5pbmcgLyBhbmltYXRpb24uZHVyYXRpb24gfHwgMCxcblx0XHRcdFx0cGVyY2VudCA9IDEgLSB0ZW1wLFxuXHRcdFx0XHRpbmRleCA9IDAsXG5cdFx0XHRcdGxlbmd0aCA9IGFuaW1hdGlvbi50d2VlbnMubGVuZ3RoO1xuXG5cdFx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0XHRhbmltYXRpb24udHdlZW5zWyBpbmRleCBdLnJ1biggcGVyY2VudCApO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgcGVyY2VudCwgcmVtYWluaW5nIF0gKTtcblxuXHRcdFx0Ly8gSWYgdGhlcmUncyBtb3JlIHRvIGRvLCB5aWVsZFxuXHRcdFx0aWYgKCBwZXJjZW50IDwgMSAmJiBsZW5ndGggKSB7XG5cdFx0XHRcdHJldHVybiByZW1haW5pbmc7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHRoaXMgd2FzIGFuIGVtcHR5IGFuaW1hdGlvbiwgc3ludGhlc2l6ZSBhIGZpbmFsIHByb2dyZXNzIG5vdGlmaWNhdGlvblxuXHRcdFx0aWYgKCAhbGVuZ3RoICkge1xuXHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgMSwgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlc29sdmUgdGhlIGFuaW1hdGlvbiBhbmQgcmVwb3J0IGl0cyBjb25jbHVzaW9uXG5cdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggZWxlbSwgWyBhbmltYXRpb24gXSApO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0sXG5cdFx0YW5pbWF0aW9uID0gZGVmZXJyZWQucHJvbWlzZSgge1xuXHRcdFx0ZWxlbTogZWxlbSxcblx0XHRcdHByb3BzOiBqUXVlcnkuZXh0ZW5kKCB7fSwgcHJvcGVydGllcyApLFxuXHRcdFx0b3B0czogalF1ZXJ5LmV4dGVuZCggdHJ1ZSwge1xuXHRcdFx0XHRzcGVjaWFsRWFzaW5nOiB7fSxcblx0XHRcdFx0ZWFzaW5nOiBqUXVlcnkuZWFzaW5nLl9kZWZhdWx0XG5cdFx0XHR9LCBvcHRpb25zICksXG5cdFx0XHRvcmlnaW5hbFByb3BlcnRpZXM6IHByb3BlcnRpZXMsXG5cdFx0XHRvcmlnaW5hbE9wdGlvbnM6IG9wdGlvbnMsXG5cdFx0XHRzdGFydFRpbWU6IGZ4Tm93IHx8IGNyZWF0ZUZ4Tm93KCksXG5cdFx0XHRkdXJhdGlvbjogb3B0aW9ucy5kdXJhdGlvbixcblx0XHRcdHR3ZWVuczogW10sXG5cdFx0XHRjcmVhdGVUd2VlbjogZnVuY3Rpb24oIHByb3AsIGVuZCApIHtcblx0XHRcdFx0dmFyIHR3ZWVuID0galF1ZXJ5LlR3ZWVuKCBlbGVtLCBhbmltYXRpb24ub3B0cywgcHJvcCwgZW5kLFxuXHRcdFx0XHRcdGFuaW1hdGlvbi5vcHRzLnNwZWNpYWxFYXNpbmdbIHByb3AgXSB8fCBhbmltYXRpb24ub3B0cy5lYXNpbmcgKTtcblx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVucy5wdXNoKCB0d2VlbiApO1xuXHRcdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0XHR9LFxuXHRcdFx0c3RvcDogZnVuY3Rpb24oIGdvdG9FbmQgKSB7XG5cdFx0XHRcdHZhciBpbmRleCA9IDAsXG5cblx0XHRcdFx0XHQvLyBJZiB3ZSBhcmUgZ29pbmcgdG8gdGhlIGVuZCwgd2Ugd2FudCB0byBydW4gYWxsIHRoZSB0d2VlbnNcblx0XHRcdFx0XHQvLyBvdGhlcndpc2Ugd2Ugc2tpcCB0aGlzIHBhcnRcblx0XHRcdFx0XHRsZW5ndGggPSBnb3RvRW5kID8gYW5pbWF0aW9uLnR3ZWVucy5sZW5ndGggOiAwO1xuXHRcdFx0XHRpZiAoIHN0b3BwZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblx0XHRcdFx0c3RvcHBlZCA9IHRydWU7XG5cdFx0XHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVuc1sgaW5kZXggXS5ydW4oIDEgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlc29sdmUgd2hlbiB3ZSBwbGF5ZWQgdGhlIGxhc3QgZnJhbWU7IG90aGVyd2lzZSwgcmVqZWN0XG5cdFx0XHRcdGlmICggZ290b0VuZCApIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgMSwgMCBdICk7XG5cdFx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBnb3RvRW5kIF0gKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5yZWplY3RXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgZ290b0VuZCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9XG5cdFx0fSApLFxuXHRcdHByb3BzID0gYW5pbWF0aW9uLnByb3BzO1xuXG5cdHByb3BGaWx0ZXIoIHByb3BzLCBhbmltYXRpb24ub3B0cy5zcGVjaWFsRWFzaW5nICk7XG5cblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRyZXN1bHQgPSBBbmltYXRpb24ucHJlZmlsdGVyc1sgaW5kZXggXS5jYWxsKCBhbmltYXRpb24sIGVsZW0sIHByb3BzLCBhbmltYXRpb24ub3B0cyApO1xuXHRcdGlmICggcmVzdWx0ICkge1xuXHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCByZXN1bHQuc3RvcCApICkge1xuXHRcdFx0XHRqUXVlcnkuX3F1ZXVlSG9va3MoIGFuaW1hdGlvbi5lbGVtLCBhbmltYXRpb24ub3B0cy5xdWV1ZSApLnN0b3AgPVxuXHRcdFx0XHRcdHJlc3VsdC5zdG9wLmJpbmQoIHJlc3VsdCApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9XG5cdH1cblxuXHRqUXVlcnkubWFwKCBwcm9wcywgY3JlYXRlVHdlZW4sIGFuaW1hdGlvbiApO1xuXG5cdGlmICggaXNGdW5jdGlvbiggYW5pbWF0aW9uLm9wdHMuc3RhcnQgKSApIHtcblx0XHRhbmltYXRpb24ub3B0cy5zdGFydC5jYWxsKCBlbGVtLCBhbmltYXRpb24gKTtcblx0fVxuXG5cdC8vIEF0dGFjaCBjYWxsYmFja3MgZnJvbSBvcHRpb25zXG5cdGFuaW1hdGlvblxuXHRcdC5wcm9ncmVzcyggYW5pbWF0aW9uLm9wdHMucHJvZ3Jlc3MgKVxuXHRcdC5kb25lKCBhbmltYXRpb24ub3B0cy5kb25lLCBhbmltYXRpb24ub3B0cy5jb21wbGV0ZSApXG5cdFx0LmZhaWwoIGFuaW1hdGlvbi5vcHRzLmZhaWwgKVxuXHRcdC5hbHdheXMoIGFuaW1hdGlvbi5vcHRzLmFsd2F5cyApO1xuXG5cdGpRdWVyeS5meC50aW1lcihcblx0XHRqUXVlcnkuZXh0ZW5kKCB0aWNrLCB7XG5cdFx0XHRlbGVtOiBlbGVtLFxuXHRcdFx0YW5pbTogYW5pbWF0aW9uLFxuXHRcdFx0cXVldWU6IGFuaW1hdGlvbi5vcHRzLnF1ZXVlXG5cdFx0fSApXG5cdCk7XG5cblx0cmV0dXJuIGFuaW1hdGlvbjtcbn1cblxualF1ZXJ5LkFuaW1hdGlvbiA9IGpRdWVyeS5leHRlbmQoIEFuaW1hdGlvbiwge1xuXG5cdHR3ZWVuZXJzOiB7XG5cdFx0XCIqXCI6IFsgZnVuY3Rpb24oIHByb3AsIHZhbHVlICkge1xuXHRcdFx0dmFyIHR3ZWVuID0gdGhpcy5jcmVhdGVUd2VlbiggcHJvcCwgdmFsdWUgKTtcblx0XHRcdGFkanVzdENTUyggdHdlZW4uZWxlbSwgcHJvcCwgcmNzc051bS5leGVjKCB2YWx1ZSApLCB0d2VlbiApO1xuXHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdH0gXVxuXHR9LFxuXG5cdHR3ZWVuZXI6IGZ1bmN0aW9uKCBwcm9wcywgY2FsbGJhY2sgKSB7XG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBwcm9wcyApICkge1xuXHRcdFx0Y2FsbGJhY2sgPSBwcm9wcztcblx0XHRcdHByb3BzID0gWyBcIipcIiBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwcm9wcyA9IHByb3BzLm1hdGNoKCBybm90aHRtbHdoaXRlICk7XG5cdFx0fVxuXG5cdFx0dmFyIHByb3AsXG5cdFx0XHRpbmRleCA9IDAsXG5cdFx0XHRsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cblx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0cHJvcCA9IHByb3BzWyBpbmRleCBdO1xuXHRcdFx0QW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gPSBBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSB8fCBbXTtcblx0XHRcdEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdLnVuc2hpZnQoIGNhbGxiYWNrICk7XG5cdFx0fVxuXHR9LFxuXG5cdHByZWZpbHRlcnM6IFsgZGVmYXVsdFByZWZpbHRlciBdLFxuXG5cdHByZWZpbHRlcjogZnVuY3Rpb24oIGNhbGxiYWNrLCBwcmVwZW5kICkge1xuXHRcdGlmICggcHJlcGVuZCApIHtcblx0XHRcdEFuaW1hdGlvbi5wcmVmaWx0ZXJzLnVuc2hpZnQoIGNhbGxiYWNrICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdEFuaW1hdGlvbi5wcmVmaWx0ZXJzLnB1c2goIGNhbGxiYWNrICk7XG5cdFx0fVxuXHR9XG59ICk7XG5cbmpRdWVyeS5zcGVlZCA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBmbiApIHtcblx0dmFyIG9wdCA9IHNwZWVkICYmIHR5cGVvZiBzcGVlZCA9PT0gXCJvYmplY3RcIiA/IGpRdWVyeS5leHRlbmQoIHt9LCBzcGVlZCApIDoge1xuXHRcdGNvbXBsZXRlOiBmbiB8fCAhZm4gJiYgZWFzaW5nIHx8XG5cdFx0XHRpc0Z1bmN0aW9uKCBzcGVlZCApICYmIHNwZWVkLFxuXHRcdGR1cmF0aW9uOiBzcGVlZCxcblx0XHRlYXNpbmc6IGZuICYmIGVhc2luZyB8fCBlYXNpbmcgJiYgIWlzRnVuY3Rpb24oIGVhc2luZyApICYmIGVhc2luZ1xuXHR9O1xuXG5cdC8vIEdvIHRvIHRoZSBlbmQgc3RhdGUgaWYgZnggYXJlIG9mZlxuXHRpZiAoIGpRdWVyeS5meC5vZmYgKSB7XG5cdFx0b3B0LmR1cmF0aW9uID0gMDtcblxuXHR9IGVsc2Uge1xuXHRcdGlmICggdHlwZW9mIG9wdC5kdXJhdGlvbiAhPT0gXCJudW1iZXJcIiApIHtcblx0XHRcdGlmICggb3B0LmR1cmF0aW9uIGluIGpRdWVyeS5meC5zcGVlZHMgKSB7XG5cdFx0XHRcdG9wdC5kdXJhdGlvbiA9IGpRdWVyeS5meC5zcGVlZHNbIG9wdC5kdXJhdGlvbiBdO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvcHQuZHVyYXRpb24gPSBqUXVlcnkuZnguc3BlZWRzLl9kZWZhdWx0O1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIE5vcm1hbGl6ZSBvcHQucXVldWUgLSB0cnVlL3VuZGVmaW5lZC9udWxsIC0+IFwiZnhcIlxuXHRpZiAoIG9wdC5xdWV1ZSA9PSBudWxsIHx8IG9wdC5xdWV1ZSA9PT0gdHJ1ZSApIHtcblx0XHRvcHQucXVldWUgPSBcImZ4XCI7XG5cdH1cblxuXHQvLyBRdWV1ZWluZ1xuXHRvcHQub2xkID0gb3B0LmNvbXBsZXRlO1xuXG5cdG9wdC5jb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggaXNGdW5jdGlvbiggb3B0Lm9sZCApICkge1xuXHRcdFx0b3B0Lm9sZC5jYWxsKCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBvcHQucXVldWUgKSB7XG5cdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgb3B0LnF1ZXVlICk7XG5cdFx0fVxuXHR9O1xuXG5cdHJldHVybiBvcHQ7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGZhZGVUbzogZnVuY3Rpb24oIHNwZWVkLCB0bywgZWFzaW5nLCBjYWxsYmFjayApIHtcblxuXHRcdC8vIFNob3cgYW55IGhpZGRlbiBlbGVtZW50cyBhZnRlciBzZXR0aW5nIG9wYWNpdHkgdG8gMFxuXHRcdHJldHVybiB0aGlzLmZpbHRlciggaXNIaWRkZW5XaXRoaW5UcmVlICkuY3NzKCBcIm9wYWNpdHlcIiwgMCApLnNob3coKVxuXG5cdFx0XHQvLyBBbmltYXRlIHRvIHRoZSB2YWx1ZSBzcGVjaWZpZWRcblx0XHRcdC5lbmQoKS5hbmltYXRlKCB7IG9wYWNpdHk6IHRvIH0sIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH0sXG5cdGFuaW1hdGU6IGZ1bmN0aW9uKCBwcm9wLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHR2YXIgZW1wdHkgPSBqUXVlcnkuaXNFbXB0eU9iamVjdCggcHJvcCApLFxuXHRcdFx0b3B0YWxsID0galF1ZXJ5LnNwZWVkKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApLFxuXHRcdFx0ZG9BbmltYXRpb24gPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvLyBPcGVyYXRlIG9uIGEgY29weSBvZiBwcm9wIHNvIHBlci1wcm9wZXJ0eSBlYXNpbmcgd29uJ3QgYmUgbG9zdFxuXHRcdFx0XHR2YXIgYW5pbSA9IEFuaW1hdGlvbiggdGhpcywgalF1ZXJ5LmV4dGVuZCgge30sIHByb3AgKSwgb3B0YWxsICk7XG5cblx0XHRcdFx0Ly8gRW1wdHkgYW5pbWF0aW9ucywgb3IgZmluaXNoaW5nIHJlc29sdmVzIGltbWVkaWF0ZWx5XG5cdFx0XHRcdGlmICggZW1wdHkgfHwgZGF0YVByaXYuZ2V0KCB0aGlzLCBcImZpbmlzaFwiICkgKSB7XG5cdFx0XHRcdFx0YW5pbS5zdG9wKCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRkb0FuaW1hdGlvbi5maW5pc2ggPSBkb0FuaW1hdGlvbjtcblxuXHRcdHJldHVybiBlbXB0eSB8fCBvcHRhbGwucXVldWUgPT09IGZhbHNlID9cblx0XHRcdHRoaXMuZWFjaCggZG9BbmltYXRpb24gKSA6XG5cdFx0XHR0aGlzLnF1ZXVlKCBvcHRhbGwucXVldWUsIGRvQW5pbWF0aW9uICk7XG5cdH0sXG5cdHN0b3A6IGZ1bmN0aW9uKCB0eXBlLCBjbGVhclF1ZXVlLCBnb3RvRW5kICkge1xuXHRcdHZhciBzdG9wUXVldWUgPSBmdW5jdGlvbiggaG9va3MgKSB7XG5cdFx0XHR2YXIgc3RvcCA9IGhvb2tzLnN0b3A7XG5cdFx0XHRkZWxldGUgaG9va3Muc3RvcDtcblx0XHRcdHN0b3AoIGdvdG9FbmQgKTtcblx0XHR9O1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGdvdG9FbmQgPSBjbGVhclF1ZXVlO1xuXHRcdFx0Y2xlYXJRdWV1ZSA9IHR5cGU7XG5cdFx0XHR0eXBlID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRpZiAoIGNsZWFyUXVldWUgKSB7XG5cdFx0XHR0aGlzLnF1ZXVlKCB0eXBlIHx8IFwiZnhcIiwgW10gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBkZXF1ZXVlID0gdHJ1ZSxcblx0XHRcdFx0aW5kZXggPSB0eXBlICE9IG51bGwgJiYgdHlwZSArIFwicXVldWVIb29rc1wiLFxuXHRcdFx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzLFxuXHRcdFx0XHRkYXRhID0gZGF0YVByaXYuZ2V0KCB0aGlzICk7XG5cblx0XHRcdGlmICggaW5kZXggKSB7XG5cdFx0XHRcdGlmICggZGF0YVsgaW5kZXggXSAmJiBkYXRhWyBpbmRleCBdLnN0b3AgKSB7XG5cdFx0XHRcdFx0c3RvcFF1ZXVlKCBkYXRhWyBpbmRleCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZvciAoIGluZGV4IGluIGRhdGEgKSB7XG5cdFx0XHRcdFx0aWYgKCBkYXRhWyBpbmRleCBdICYmIGRhdGFbIGluZGV4IF0uc3RvcCAmJiBycnVuLnRlc3QoIGluZGV4ICkgKSB7XG5cdFx0XHRcdFx0XHRzdG9wUXVldWUoIGRhdGFbIGluZGV4IF0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggaW5kZXggPSB0aW1lcnMubGVuZ3RoOyBpbmRleC0tOyApIHtcblx0XHRcdFx0aWYgKCB0aW1lcnNbIGluZGV4IF0uZWxlbSA9PT0gdGhpcyAmJlxuXHRcdFx0XHRcdCggdHlwZSA9PSBudWxsIHx8IHRpbWVyc1sgaW5kZXggXS5xdWV1ZSA9PT0gdHlwZSApICkge1xuXG5cdFx0XHRcdFx0dGltZXJzWyBpbmRleCBdLmFuaW0uc3RvcCggZ290b0VuZCApO1xuXHRcdFx0XHRcdGRlcXVldWUgPSBmYWxzZTtcblx0XHRcdFx0XHR0aW1lcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0YXJ0IHRoZSBuZXh0IGluIHRoZSBxdWV1ZSBpZiB0aGUgbGFzdCBzdGVwIHdhc24ndCBmb3JjZWQuXG5cdFx0XHQvLyBUaW1lcnMgY3VycmVudGx5IHdpbGwgY2FsbCB0aGVpciBjb21wbGV0ZSBjYWxsYmFja3MsIHdoaWNoXG5cdFx0XHQvLyB3aWxsIGRlcXVldWUgYnV0IG9ubHkgaWYgdGhleSB3ZXJlIGdvdG9FbmQuXG5cdFx0XHRpZiAoIGRlcXVldWUgfHwgIWdvdG9FbmQgKSB7XG5cdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXHRmaW5pc2g6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdGlmICggdHlwZSAhPT0gZmFsc2UgKSB7XG5cdFx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGluZGV4LFxuXHRcdFx0XHRkYXRhID0gZGF0YVByaXYuZ2V0KCB0aGlzICksXG5cdFx0XHRcdHF1ZXVlID0gZGF0YVsgdHlwZSArIFwicXVldWVcIiBdLFxuXHRcdFx0XHRob29rcyA9IGRhdGFbIHR5cGUgKyBcInF1ZXVlSG9va3NcIiBdLFxuXHRcdFx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzLFxuXHRcdFx0XHRsZW5ndGggPSBxdWV1ZSA/IHF1ZXVlLmxlbmd0aCA6IDA7XG5cblx0XHRcdC8vIEVuYWJsZSBmaW5pc2hpbmcgZmxhZyBvbiBwcml2YXRlIGRhdGFcblx0XHRcdGRhdGEuZmluaXNoID0gdHJ1ZTtcblxuXHRcdFx0Ly8gRW1wdHkgdGhlIHF1ZXVlIGZpcnN0XG5cdFx0XHRqUXVlcnkucXVldWUoIHRoaXMsIHR5cGUsIFtdICk7XG5cblx0XHRcdGlmICggaG9va3MgJiYgaG9va3Muc3RvcCApIHtcblx0XHRcdFx0aG9va3Muc3RvcC5jYWxsKCB0aGlzLCB0cnVlICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIExvb2sgZm9yIGFueSBhY3RpdmUgYW5pbWF0aW9ucywgYW5kIGZpbmlzaCB0aGVtXG5cdFx0XHRmb3IgKCBpbmRleCA9IHRpbWVycy5sZW5ndGg7IGluZGV4LS07ICkge1xuXHRcdFx0XHRpZiAoIHRpbWVyc1sgaW5kZXggXS5lbGVtID09PSB0aGlzICYmIHRpbWVyc1sgaW5kZXggXS5xdWV1ZSA9PT0gdHlwZSApIHtcblx0XHRcdFx0XHR0aW1lcnNbIGluZGV4IF0uYW5pbS5zdG9wKCB0cnVlICk7XG5cdFx0XHRcdFx0dGltZXJzLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBMb29rIGZvciBhbnkgYW5pbWF0aW9ucyBpbiB0aGUgb2xkIHF1ZXVlIGFuZCBmaW5pc2ggdGhlbVxuXHRcdFx0Zm9yICggaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdFx0aWYgKCBxdWV1ZVsgaW5kZXggXSAmJiBxdWV1ZVsgaW5kZXggXS5maW5pc2ggKSB7XG5cdFx0XHRcdFx0cXVldWVbIGluZGV4IF0uZmluaXNoLmNhbGwoIHRoaXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBUdXJuIG9mZiBmaW5pc2hpbmcgZmxhZ1xuXHRcdFx0ZGVsZXRlIGRhdGEuZmluaXNoO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggWyBcInRvZ2dsZVwiLCBcInNob3dcIiwgXCJoaWRlXCIgXSwgZnVuY3Rpb24oIF9pLCBuYW1lICkge1xuXHR2YXIgY3NzRm4gPSBqUXVlcnkuZm5bIG5hbWUgXTtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHNwZWVkID09IG51bGwgfHwgdHlwZW9mIHNwZWVkID09PSBcImJvb2xlYW5cIiA/XG5cdFx0XHRjc3NGbi5hcHBseSggdGhpcywgYXJndW1lbnRzICkgOlxuXHRcdFx0dGhpcy5hbmltYXRlKCBnZW5GeCggbmFtZSwgdHJ1ZSApLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHR9O1xufSApO1xuXG4vLyBHZW5lcmF0ZSBzaG9ydGN1dHMgZm9yIGN1c3RvbSBhbmltYXRpb25zXG5qUXVlcnkuZWFjaCgge1xuXHRzbGlkZURvd246IGdlbkZ4KCBcInNob3dcIiApLFxuXHRzbGlkZVVwOiBnZW5GeCggXCJoaWRlXCIgKSxcblx0c2xpZGVUb2dnbGU6IGdlbkZ4KCBcInRvZ2dsZVwiICksXG5cdGZhZGVJbjogeyBvcGFjaXR5OiBcInNob3dcIiB9LFxuXHRmYWRlT3V0OiB7IG9wYWNpdHk6IFwiaGlkZVwiIH0sXG5cdGZhZGVUb2dnbGU6IHsgb3BhY2l0eTogXCJ0b2dnbGVcIiB9XG59LCBmdW5jdGlvbiggbmFtZSwgcHJvcHMgKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiB0aGlzLmFuaW1hdGUoIHByb3BzLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHR9O1xufSApO1xuXG5qUXVlcnkudGltZXJzID0gW107XG5qUXVlcnkuZngudGljayA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgdGltZXIsXG5cdFx0aSA9IDAsXG5cdFx0dGltZXJzID0galF1ZXJ5LnRpbWVycztcblxuXHRmeE5vdyA9IERhdGUubm93KCk7XG5cblx0Zm9yICggOyBpIDwgdGltZXJzLmxlbmd0aDsgaSsrICkge1xuXHRcdHRpbWVyID0gdGltZXJzWyBpIF07XG5cblx0XHQvLyBSdW4gdGhlIHRpbWVyIGFuZCBzYWZlbHkgcmVtb3ZlIGl0IHdoZW4gZG9uZSAoYWxsb3dpbmcgZm9yIGV4dGVybmFsIHJlbW92YWwpXG5cdFx0aWYgKCAhdGltZXIoKSAmJiB0aW1lcnNbIGkgXSA9PT0gdGltZXIgKSB7XG5cdFx0XHR0aW1lcnMuc3BsaWNlKCBpLS0sIDEgKTtcblx0XHR9XG5cdH1cblxuXHRpZiAoICF0aW1lcnMubGVuZ3RoICkge1xuXHRcdGpRdWVyeS5meC5zdG9wKCk7XG5cdH1cblx0ZnhOb3cgPSB1bmRlZmluZWQ7XG59O1xuXG5qUXVlcnkuZngudGltZXIgPSBmdW5jdGlvbiggdGltZXIgKSB7XG5cdGpRdWVyeS50aW1lcnMucHVzaCggdGltZXIgKTtcblx0alF1ZXJ5LmZ4LnN0YXJ0KCk7XG59O1xuXG5qUXVlcnkuZnguaW50ZXJ2YWwgPSAxMztcbmpRdWVyeS5meC5zdGFydCA9IGZ1bmN0aW9uKCkge1xuXHRpZiAoIGluUHJvZ3Jlc3MgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0aW5Qcm9ncmVzcyA9IHRydWU7XG5cdHNjaGVkdWxlKCk7XG59O1xuXG5qUXVlcnkuZnguc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHRpblByb2dyZXNzID0gbnVsbDtcbn07XG5cbmpRdWVyeS5meC5zcGVlZHMgPSB7XG5cdHNsb3c6IDYwMCxcblx0ZmFzdDogMjAwLFxuXG5cdC8vIERlZmF1bHQgc3BlZWRcblx0X2RlZmF1bHQ6IDQwMFxufTtcblxuXG4vLyBCYXNlZCBvZmYgb2YgdGhlIHBsdWdpbiBieSBDbGludCBIZWxmZXJzLCB3aXRoIHBlcm1pc3Npb24uXG5qUXVlcnkuZm4uZGVsYXkgPSBmdW5jdGlvbiggdGltZSwgdHlwZSApIHtcblx0dGltZSA9IGpRdWVyeS5meCA/IGpRdWVyeS5meC5zcGVlZHNbIHRpbWUgXSB8fCB0aW1lIDogdGltZTtcblx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdHJldHVybiB0aGlzLnF1ZXVlKCB0eXBlLCBmdW5jdGlvbiggbmV4dCwgaG9va3MgKSB7XG5cdFx0dmFyIHRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCggbmV4dCwgdGltZSApO1xuXHRcdGhvb2tzLnN0b3AgPSBmdW5jdGlvbigpIHtcblx0XHRcdHdpbmRvdy5jbGVhclRpbWVvdXQoIHRpbWVvdXQgKTtcblx0XHR9O1xuXHR9ICk7XG59O1xuXG5cbiggZnVuY3Rpb24oKSB7XG5cdHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApLFxuXHRcdHNlbGVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwic2VsZWN0XCIgKSxcblx0XHRvcHQgPSBzZWxlY3QuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwib3B0aW9uXCIgKSApO1xuXG5cdGlucHV0LnR5cGUgPSBcImNoZWNrYm94XCI7XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMyBvbmx5XG5cdC8vIERlZmF1bHQgdmFsdWUgZm9yIGEgY2hlY2tib3ggc2hvdWxkIGJlIFwib25cIlxuXHRzdXBwb3J0LmNoZWNrT24gPSBpbnB1dC52YWx1ZSAhPT0gXCJcIjtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0Ly8gTXVzdCBhY2Nlc3Mgc2VsZWN0ZWRJbmRleCB0byBtYWtlIGRlZmF1bHQgb3B0aW9ucyBzZWxlY3Rcblx0c3VwcG9ydC5vcHRTZWxlY3RlZCA9IG9wdC5zZWxlY3RlZDtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0Ly8gQW4gaW5wdXQgbG9zZXMgaXRzIHZhbHVlIGFmdGVyIGJlY29taW5nIGEgcmFkaW9cblx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKTtcblx0aW5wdXQudmFsdWUgPSBcInRcIjtcblx0aW5wdXQudHlwZSA9IFwicmFkaW9cIjtcblx0c3VwcG9ydC5yYWRpb1ZhbHVlID0gaW5wdXQudmFsdWUgPT09IFwidFwiO1xufSApKCk7XG5cblxudmFyIGJvb2xIb29rLFxuXHRhdHRySGFuZGxlID0galF1ZXJ5LmV4cHIuYXR0ckhhbmRsZTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRhdHRyOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgalF1ZXJ5LmF0dHIsIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9LFxuXG5cdHJlbW92ZUF0dHI6IGZ1bmN0aW9uKCBuYW1lICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIHRoaXMsIG5hbWUgKTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXHRhdHRyOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0dmFyIHJldCwgaG9va3MsXG5cdFx0XHRuVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0XHQvLyBEb24ndCBnZXQvc2V0IGF0dHJpYnV0ZXMgb24gdGV4dCwgY29tbWVudCBhbmQgYXR0cmlidXRlIG5vZGVzXG5cdFx0aWYgKCBuVHlwZSA9PT0gMyB8fCBuVHlwZSA9PT0gOCB8fCBuVHlwZSA9PT0gMiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBGYWxsYmFjayB0byBwcm9wIHdoZW4gYXR0cmlidXRlcyBhcmUgbm90IHN1cHBvcnRlZFxuXHRcdGlmICggdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlID09PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5wcm9wKCBlbGVtLCBuYW1lLCB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdC8vIEF0dHJpYnV0ZSBob29rcyBhcmUgZGV0ZXJtaW5lZCBieSB0aGUgbG93ZXJjYXNlIHZlcnNpb25cblx0XHQvLyBHcmFiIG5lY2Vzc2FyeSBob29rIGlmIG9uZSBpcyBkZWZpbmVkXG5cdFx0aWYgKCBuVHlwZSAhPT0gMSB8fCAhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XG5cdFx0XHRob29rcyA9IGpRdWVyeS5hdHRySG9va3NbIG5hbWUudG9Mb3dlckNhc2UoKSBdIHx8XG5cdFx0XHRcdCggalF1ZXJ5LmV4cHIubWF0Y2guYm9vbC50ZXN0KCBuYW1lICkgPyBib29sSG9vayA6IHVuZGVmaW5lZCApO1xuXHRcdH1cblxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggdmFsdWUgPT09IG51bGwgKSB7XG5cdFx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCBlbGVtLCBuYW1lICk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBob29rcyAmJiBcInNldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdCggcmV0ID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgbmFtZSApICkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblxuXHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIG5hbWUsIHZhbHVlICsgXCJcIiApO1xuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH1cblxuXHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJiAoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgbmFtZSApICkgIT09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblxuXHRcdHJldCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIG5hbWUgKTtcblxuXHRcdC8vIE5vbi1leGlzdGVudCBhdHRyaWJ1dGVzIHJldHVybiBudWxsLCB3ZSBub3JtYWxpemUgdG8gdW5kZWZpbmVkXG5cdFx0cmV0dXJuIHJldCA9PSBudWxsID8gdW5kZWZpbmVkIDogcmV0O1xuXHR9LFxuXG5cdGF0dHJIb29rczoge1xuXHRcdHR5cGU6IHtcblx0XHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0XHRpZiAoICFzdXBwb3J0LnJhZGlvVmFsdWUgJiYgdmFsdWUgPT09IFwicmFkaW9cIiAmJlxuXHRcdFx0XHRcdG5vZGVOYW1lKCBlbGVtLCBcImlucHV0XCIgKSApIHtcblx0XHRcdFx0XHR2YXIgdmFsID0gZWxlbS52YWx1ZTtcblx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIHZhbHVlICk7XG5cdFx0XHRcdFx0aWYgKCB2YWwgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnZhbHVlID0gdmFsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0cmVtb3ZlQXR0cjogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdHZhciBuYW1lLFxuXHRcdFx0aSA9IDAsXG5cblx0XHRcdC8vIEF0dHJpYnV0ZSBuYW1lcyBjYW4gY29udGFpbiBub24tSFRNTCB3aGl0ZXNwYWNlIGNoYXJhY3RlcnNcblx0XHRcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2F0dHJpYnV0ZXMtMlxuXHRcdFx0YXR0ck5hbWVzID0gdmFsdWUgJiYgdmFsdWUubWF0Y2goIHJub3RodG1sd2hpdGUgKTtcblxuXHRcdGlmICggYXR0ck5hbWVzICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHR3aGlsZSAoICggbmFtZSA9IGF0dHJOYW1lc1sgaSsrIF0gKSApIHtcblx0XHRcdFx0ZWxlbS5yZW1vdmVBdHRyaWJ1dGUoIG5hbWUgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gSG9va3MgZm9yIGJvb2xlYW4gYXR0cmlidXRlc1xuYm9vbEhvb2sgPSB7XG5cdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBuYW1lICkge1xuXHRcdGlmICggdmFsdWUgPT09IGZhbHNlICkge1xuXG5cdFx0XHQvLyBSZW1vdmUgYm9vbGVhbiBhdHRyaWJ1dGVzIHdoZW4gc2V0IHRvIGZhbHNlXG5cdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggZWxlbSwgbmFtZSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggbmFtZSwgbmFtZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gbmFtZTtcblx0fVxufTtcblxualF1ZXJ5LmVhY2goIGpRdWVyeS5leHByLm1hdGNoLmJvb2wuc291cmNlLm1hdGNoKCAvXFx3Ky9nICksIGZ1bmN0aW9uKCBfaSwgbmFtZSApIHtcblx0dmFyIGdldHRlciA9IGF0dHJIYW5kbGVbIG5hbWUgXSB8fCBqUXVlcnkuZmluZC5hdHRyO1xuXG5cdGF0dHJIYW5kbGVbIG5hbWUgXSA9IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHR2YXIgcmV0LCBoYW5kbGUsXG5cdFx0XHRsb3dlcmNhc2VOYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0aWYgKCAhaXNYTUwgKSB7XG5cblx0XHRcdC8vIEF2b2lkIGFuIGluZmluaXRlIGxvb3AgYnkgdGVtcG9yYXJpbHkgcmVtb3ZpbmcgdGhpcyBmdW5jdGlvbiBmcm9tIHRoZSBnZXR0ZXJcblx0XHRcdGhhbmRsZSA9IGF0dHJIYW5kbGVbIGxvd2VyY2FzZU5hbWUgXTtcblx0XHRcdGF0dHJIYW5kbGVbIGxvd2VyY2FzZU5hbWUgXSA9IHJldDtcblx0XHRcdHJldCA9IGdldHRlciggZWxlbSwgbmFtZSwgaXNYTUwgKSAhPSBudWxsID9cblx0XHRcdFx0bG93ZXJjYXNlTmFtZSA6XG5cdFx0XHRcdG51bGw7XG5cdFx0XHRhdHRySGFuZGxlWyBsb3dlcmNhc2VOYW1lIF0gPSBoYW5kbGU7XG5cdFx0fVxuXHRcdHJldHVybiByZXQ7XG5cdH07XG59ICk7XG5cblxuXG5cbnZhciByZm9jdXNhYmxlID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSxcblx0cmNsaWNrYWJsZSA9IC9eKD86YXxhcmVhKSQvaTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRwcm9wOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgalF1ZXJ5LnByb3AsIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9LFxuXG5cdHJlbW92ZVByb3A6IGZ1bmN0aW9uKCBuYW1lICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0ZGVsZXRlIHRoaXNbIGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZSBdO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdHByb3A6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHR2YXIgcmV0LCBob29rcyxcblx0XHRcdG5UeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRcdC8vIERvbid0IGdldC9zZXQgcHJvcGVydGllcyBvbiB0ZXh0LCBjb21tZW50IGFuZCBhdHRyaWJ1dGUgbm9kZXNcblx0XHRpZiAoIG5UeXBlID09PSAzIHx8IG5UeXBlID09PSA4IHx8IG5UeXBlID09PSAyICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggblR5cGUgIT09IDEgfHwgIWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXG5cdFx0XHQvLyBGaXggbmFtZSBhbmQgYXR0YWNoIGhvb2tzXG5cdFx0XHRuYW1lID0galF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lO1xuXHRcdFx0aG9va3MgPSBqUXVlcnkucHJvcEhvb2tzWyBuYW1lIF07XG5cdFx0fVxuXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCBob29rcyAmJiBcInNldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdCggcmV0ID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgbmFtZSApICkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuICggZWxlbVsgbmFtZSBdID0gdmFsdWUgKTtcblx0XHR9XG5cblx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKCByZXQgPSBob29rcy5nZXQoIGVsZW0sIG5hbWUgKSApICE9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cblx0XHRyZXR1cm4gZWxlbVsgbmFtZSBdO1xuXHR9LFxuXG5cdHByb3BIb29rczoge1xuXHRcdHRhYkluZGV4OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcblx0XHRcdFx0Ly8gZWxlbS50YWJJbmRleCBkb2Vzbid0IGFsd2F5cyByZXR1cm4gdGhlXG5cdFx0XHRcdC8vIGNvcnJlY3QgdmFsdWUgd2hlbiBpdCBoYXNuJ3QgYmVlbiBleHBsaWNpdGx5IHNldFxuXHRcdFx0XHQvLyBVc2UgcHJvcGVyIGF0dHJpYnV0ZSByZXRyaWV2YWwgKHRyYWMtMTIwNzIpXG5cdFx0XHRcdHZhciB0YWJpbmRleCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIFwidGFiaW5kZXhcIiApO1xuXG5cdFx0XHRcdGlmICggdGFiaW5kZXggKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHBhcnNlSW50KCB0YWJpbmRleCwgMTAgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHRyZm9jdXNhYmxlLnRlc3QoIGVsZW0ubm9kZU5hbWUgKSB8fFxuXHRcdFx0XHRcdHJjbGlja2FibGUudGVzdCggZWxlbS5ub2RlTmFtZSApICYmXG5cdFx0XHRcdFx0ZWxlbS5ocmVmXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdHJldHVybiAwO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRwcm9wRml4OiB7XG5cdFx0XCJmb3JcIjogXCJodG1sRm9yXCIsXG5cdFx0XCJjbGFzc1wiOiBcImNsYXNzTmFtZVwiXG5cdH1cbn0gKTtcblxuLy8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG4vLyBBY2Nlc3NpbmcgdGhlIHNlbGVjdGVkSW5kZXggcHJvcGVydHlcbi8vIGZvcmNlcyB0aGUgYnJvd3NlciB0byByZXNwZWN0IHNldHRpbmcgc2VsZWN0ZWRcbi8vIG9uIHRoZSBvcHRpb25cbi8vIFRoZSBnZXR0ZXIgZW5zdXJlcyBhIGRlZmF1bHQgb3B0aW9uIGlzIHNlbGVjdGVkXG4vLyB3aGVuIGluIGFuIG9wdGdyb3VwXG4vLyBlc2xpbnQgcnVsZSBcIm5vLXVudXNlZC1leHByZXNzaW9uc1wiIGlzIGRpc2FibGVkIGZvciB0aGlzIGNvZGVcbi8vIHNpbmNlIGl0IGNvbnNpZGVycyBzdWNoIGFjY2Vzc2lvbnMgbm9vcFxuaWYgKCAhc3VwcG9ydC5vcHRTZWxlY3RlZCApIHtcblx0alF1ZXJ5LnByb3BIb29rcy5zZWxlY3RlZCA9IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHQvKiBlc2xpbnQgbm8tdW51c2VkLWV4cHJlc3Npb25zOiBcIm9mZlwiICovXG5cblx0XHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRpZiAoIHBhcmVudCAmJiBwYXJlbnQucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0cGFyZW50LnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0LyogZXNsaW50IG5vLXVudXNlZC1leHByZXNzaW9uczogXCJvZmZcIiAqL1xuXG5cdFx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cdFx0XHRcdHBhcmVudC5zZWxlY3RlZEluZGV4O1xuXG5cdFx0XHRcdGlmICggcGFyZW50LnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdFx0cGFyZW50LnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn1cblxualF1ZXJ5LmVhY2goIFtcblx0XCJ0YWJJbmRleFwiLFxuXHRcInJlYWRPbmx5XCIsXG5cdFwibWF4TGVuZ3RoXCIsXG5cdFwiY2VsbFNwYWNpbmdcIixcblx0XCJjZWxsUGFkZGluZ1wiLFxuXHRcInJvd1NwYW5cIixcblx0XCJjb2xTcGFuXCIsXG5cdFwidXNlTWFwXCIsXG5cdFwiZnJhbWVCb3JkZXJcIixcblx0XCJjb250ZW50RWRpdGFibGVcIlxuXSwgZnVuY3Rpb24oKSB7XG5cdGpRdWVyeS5wcm9wRml4WyB0aGlzLnRvTG93ZXJDYXNlKCkgXSA9IHRoaXM7XG59ICk7XG5cblxuXG5cblx0Ly8gU3RyaXAgYW5kIGNvbGxhcHNlIHdoaXRlc3BhY2UgYWNjb3JkaW5nIHRvIEhUTUwgc3BlY1xuXHQvLyBodHRwczovL2luZnJhLnNwZWMud2hhdHdnLm9yZy8jc3RyaXAtYW5kLWNvbGxhcHNlLWFzY2lpLXdoaXRlc3BhY2Vcblx0ZnVuY3Rpb24gc3RyaXBBbmRDb2xsYXBzZSggdmFsdWUgKSB7XG5cdFx0dmFyIHRva2VucyA9IHZhbHVlLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW107XG5cdFx0cmV0dXJuIHRva2Vucy5qb2luKCBcIiBcIiApO1xuXHR9XG5cblxuZnVuY3Rpb24gZ2V0Q2xhc3MoIGVsZW0gKSB7XG5cdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSAmJiBlbGVtLmdldEF0dHJpYnV0ZSggXCJjbGFzc1wiICkgfHwgXCJcIjtcbn1cblxuZnVuY3Rpb24gY2xhc3Nlc1RvQXJyYXkoIHZhbHVlICkge1xuXHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9XG5cdGlmICggdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiB2YWx1ZS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdO1xuXHR9XG5cdHJldHVybiBbXTtcbn1cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRhZGRDbGFzczogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBjbGFzc05hbWVzLCBjdXIsIGN1clZhbHVlLCBjbGFzc05hbWUsIGksIGZpbmFsVmFsdWU7XG5cblx0XHRpZiAoIGlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaiApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuYWRkQ2xhc3MoIHZhbHVlLmNhbGwoIHRoaXMsIGosIGdldENsYXNzKCB0aGlzICkgKSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdGNsYXNzTmFtZXMgPSBjbGFzc2VzVG9BcnJheSggdmFsdWUgKTtcblxuXHRcdGlmICggY2xhc3NOYW1lcy5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0Y3VyVmFsdWUgPSBnZXRDbGFzcyggdGhpcyApO1xuXHRcdFx0XHRjdXIgPSB0aGlzLm5vZGVUeXBlID09PSAxICYmICggXCIgXCIgKyBzdHJpcEFuZENvbGxhcHNlKCBjdXJWYWx1ZSApICsgXCIgXCIgKTtcblxuXHRcdFx0XHRpZiAoIGN1ciApIHtcblx0XHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGNsYXNzTmFtZXMubGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdFx0XHRjbGFzc05hbWUgPSBjbGFzc05hbWVzWyBpIF07XG5cdFx0XHRcdFx0XHRpZiAoIGN1ci5pbmRleE9mKCBcIiBcIiArIGNsYXNzTmFtZSArIFwiIFwiICkgPCAwICkge1xuXHRcdFx0XHRcdFx0XHRjdXIgKz0gY2xhc3NOYW1lICsgXCIgXCI7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gT25seSBhc3NpZ24gaWYgZGlmZmVyZW50IHRvIGF2b2lkIHVubmVlZGVkIHJlbmRlcmluZy5cblx0XHRcdFx0XHRmaW5hbFZhbHVlID0gc3RyaXBBbmRDb2xsYXBzZSggY3VyICk7XG5cdFx0XHRcdFx0aWYgKCBjdXJWYWx1ZSAhPT0gZmluYWxWYWx1ZSApIHtcblx0XHRcdFx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKCBcImNsYXNzXCIsIGZpbmFsVmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRyZW1vdmVDbGFzczogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBjbGFzc05hbWVzLCBjdXIsIGN1clZhbHVlLCBjbGFzc05hbWUsIGksIGZpbmFsVmFsdWU7XG5cblx0XHRpZiAoIGlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaiApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkucmVtb3ZlQ2xhc3MoIHZhbHVlLmNhbGwoIHRoaXMsIGosIGdldENsYXNzKCB0aGlzICkgKSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdGlmICggIWFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5hdHRyKCBcImNsYXNzXCIsIFwiXCIgKTtcblx0XHR9XG5cblx0XHRjbGFzc05hbWVzID0gY2xhc3Nlc1RvQXJyYXkoIHZhbHVlICk7XG5cblx0XHRpZiAoIGNsYXNzTmFtZXMubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGN1clZhbHVlID0gZ2V0Q2xhc3MoIHRoaXMgKTtcblxuXHRcdFx0XHQvLyBUaGlzIGV4cHJlc3Npb24gaXMgaGVyZSBmb3IgYmV0dGVyIGNvbXByZXNzaWJpbGl0eSAoc2VlIGFkZENsYXNzKVxuXHRcdFx0XHRjdXIgPSB0aGlzLm5vZGVUeXBlID09PSAxICYmICggXCIgXCIgKyBzdHJpcEFuZENvbGxhcHNlKCBjdXJWYWx1ZSApICsgXCIgXCIgKTtcblxuXHRcdFx0XHRpZiAoIGN1ciApIHtcblx0XHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGNsYXNzTmFtZXMubGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdFx0XHRjbGFzc05hbWUgPSBjbGFzc05hbWVzWyBpIF07XG5cblx0XHRcdFx0XHRcdC8vIFJlbW92ZSAqYWxsKiBpbnN0YW5jZXNcblx0XHRcdFx0XHRcdHdoaWxlICggY3VyLmluZGV4T2YoIFwiIFwiICsgY2xhc3NOYW1lICsgXCIgXCIgKSA+IC0xICkge1xuXHRcdFx0XHRcdFx0XHRjdXIgPSBjdXIucmVwbGFjZSggXCIgXCIgKyBjbGFzc05hbWUgKyBcIiBcIiwgXCIgXCIgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBPbmx5IGFzc2lnbiBpZiBkaWZmZXJlbnQgdG8gYXZvaWQgdW5uZWVkZWQgcmVuZGVyaW5nLlxuXHRcdFx0XHRcdGZpbmFsVmFsdWUgPSBzdHJpcEFuZENvbGxhcHNlKCBjdXIgKTtcblx0XHRcdFx0XHRpZiAoIGN1clZhbHVlICE9PSBmaW5hbFZhbHVlICkge1xuXHRcdFx0XHRcdFx0dGhpcy5zZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIiwgZmluYWxWYWx1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHRvZ2dsZUNsYXNzOiBmdW5jdGlvbiggdmFsdWUsIHN0YXRlVmFsICkge1xuXHRcdHZhciBjbGFzc05hbWVzLCBjbGFzc05hbWUsIGksIHNlbGYsXG5cdFx0XHR0eXBlID0gdHlwZW9mIHZhbHVlLFxuXHRcdFx0aXNWYWxpZFZhbHVlID0gdHlwZSA9PT0gXCJzdHJpbmdcIiB8fCBBcnJheS5pc0FycmF5KCB2YWx1ZSApO1xuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnRvZ2dsZUNsYXNzKFxuXHRcdFx0XHRcdHZhbHVlLmNhbGwoIHRoaXMsIGksIGdldENsYXNzKCB0aGlzICksIHN0YXRlVmFsICksXG5cdFx0XHRcdFx0c3RhdGVWYWxcblx0XHRcdFx0KTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRpZiAoIHR5cGVvZiBzdGF0ZVZhbCA9PT0gXCJib29sZWFuXCIgJiYgaXNWYWxpZFZhbHVlICkge1xuXHRcdFx0cmV0dXJuIHN0YXRlVmFsID8gdGhpcy5hZGRDbGFzcyggdmFsdWUgKSA6IHRoaXMucmVtb3ZlQ2xhc3MoIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0Y2xhc3NOYW1lcyA9IGNsYXNzZXNUb0FycmF5KCB2YWx1ZSApO1xuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIGlzVmFsaWRWYWx1ZSApIHtcblxuXHRcdFx0XHQvLyBUb2dnbGUgaW5kaXZpZHVhbCBjbGFzcyBuYW1lc1xuXHRcdFx0XHRzZWxmID0galF1ZXJ5KCB0aGlzICk7XG5cblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBjbGFzc05hbWVzLmxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHRcdGNsYXNzTmFtZSA9IGNsYXNzTmFtZXNbIGkgXTtcblxuXHRcdFx0XHRcdC8vIENoZWNrIGVhY2ggY2xhc3NOYW1lIGdpdmVuLCBzcGFjZSBzZXBhcmF0ZWQgbGlzdFxuXHRcdFx0XHRcdGlmICggc2VsZi5oYXNDbGFzcyggY2xhc3NOYW1lICkgKSB7XG5cdFx0XHRcdFx0XHRzZWxmLnJlbW92ZUNsYXNzKCBjbGFzc05hbWUgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c2VsZi5hZGRDbGFzcyggY2xhc3NOYW1lICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdC8vIFRvZ2dsZSB3aG9sZSBjbGFzcyBuYW1lXG5cdFx0XHR9IGVsc2UgaWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGUgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdFx0XHRjbGFzc05hbWUgPSBnZXRDbGFzcyggdGhpcyApO1xuXHRcdFx0XHRpZiAoIGNsYXNzTmFtZSApIHtcblxuXHRcdFx0XHRcdC8vIFN0b3JlIGNsYXNzTmFtZSBpZiBzZXRcblx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIHRoaXMsIFwiX19jbGFzc05hbWVfX1wiLCBjbGFzc05hbWUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIElmIHRoZSBlbGVtZW50IGhhcyBhIGNsYXNzIG5hbWUgb3IgaWYgd2UncmUgcGFzc2VkIGBmYWxzZWAsXG5cdFx0XHRcdC8vIHRoZW4gcmVtb3ZlIHRoZSB3aG9sZSBjbGFzc25hbWUgKGlmIHRoZXJlIHdhcyBvbmUsIHRoZSBhYm92ZSBzYXZlZCBpdCkuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBicmluZyBiYWNrIHdoYXRldmVyIHdhcyBwcmV2aW91c2x5IHNhdmVkIChpZiBhbnl0aGluZyksXG5cdFx0XHRcdC8vIGZhbGxpbmcgYmFjayB0byB0aGUgZW1wdHkgc3RyaW5nIGlmIG5vdGhpbmcgd2FzIHN0b3JlZC5cblx0XHRcdFx0aWYgKCB0aGlzLnNldEF0dHJpYnV0ZSApIHtcblx0XHRcdFx0XHR0aGlzLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLFxuXHRcdFx0XHRcdFx0Y2xhc3NOYW1lIHx8IHZhbHVlID09PSBmYWxzZSA/XG5cdFx0XHRcdFx0XHRcdFwiXCIgOlxuXHRcdFx0XHRcdFx0XHRkYXRhUHJpdi5nZXQoIHRoaXMsIFwiX19jbGFzc05hbWVfX1wiICkgfHwgXCJcIlxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0aGFzQ2xhc3M6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgY2xhc3NOYW1lLCBlbGVtLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRjbGFzc05hbWUgPSBcIiBcIiArIHNlbGVjdG9yICsgXCIgXCI7XG5cdFx0d2hpbGUgKCAoIGVsZW0gPSB0aGlzWyBpKysgXSApICkge1xuXHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdCggXCIgXCIgKyBzdHJpcEFuZENvbGxhcHNlKCBnZXRDbGFzcyggZWxlbSApICkgKyBcIiBcIiApLmluZGV4T2YoIGNsYXNzTmFtZSApID4gLTEgKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufSApO1xuXG5cblxuXG52YXIgcnJldHVybiA9IC9cXHIvZztcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHR2YWw6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgaG9va3MsIHJldCwgdmFsdWVJc0Z1bmN0aW9uLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXTtcblxuXHRcdGlmICggIWFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRcdGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzWyBlbGVtLnR5cGUgXSB8fFxuXHRcdFx0XHRcdGpRdWVyeS52YWxIb29rc1sgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIF07XG5cblx0XHRcdFx0aWYgKCBob29rcyAmJlxuXHRcdFx0XHRcdFwiZ2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0XHQoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgXCJ2YWx1ZVwiICkgKSAhPT0gdW5kZWZpbmVkXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXQgPSBlbGVtLnZhbHVlO1xuXG5cdFx0XHRcdC8vIEhhbmRsZSBtb3N0IGNvbW1vbiBzdHJpbmcgY2FzZXNcblx0XHRcdFx0aWYgKCB0eXBlb2YgcmV0ID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0XHRcdHJldHVybiByZXQucmVwbGFjZSggcnJldHVybiwgXCJcIiApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSGFuZGxlIGNhc2VzIHdoZXJlIHZhbHVlIGlzIG51bGwvdW5kZWYgb3IgbnVtYmVyXG5cdFx0XHRcdHJldHVybiByZXQgPT0gbnVsbCA/IFwiXCIgOiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YWx1ZUlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uKCB2YWx1ZSApO1xuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHR2YXIgdmFsO1xuXG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgIT09IDEgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB2YWx1ZUlzRnVuY3Rpb24gKSB7XG5cdFx0XHRcdHZhbCA9IHZhbHVlLmNhbGwoIHRoaXMsIGksIGpRdWVyeSggdGhpcyApLnZhbCgpICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YWwgPSB2YWx1ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVHJlYXQgbnVsbC91bmRlZmluZWQgYXMgXCJcIjsgY29udmVydCBudW1iZXJzIHRvIHN0cmluZ1xuXHRcdFx0aWYgKCB2YWwgPT0gbnVsbCApIHtcblx0XHRcdFx0dmFsID0gXCJcIjtcblxuXHRcdFx0fSBlbHNlIGlmICggdHlwZW9mIHZhbCA9PT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0dmFsICs9IFwiXCI7XG5cblx0XHRcdH0gZWxzZSBpZiAoIEFycmF5LmlzQXJyYXkoIHZhbCApICkge1xuXHRcdFx0XHR2YWwgPSBqUXVlcnkubWFwKCB2YWwsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZSArIFwiXCI7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblxuXHRcdFx0aG9va3MgPSBqUXVlcnkudmFsSG9va3NbIHRoaXMudHlwZSBdIHx8IGpRdWVyeS52YWxIb29rc1sgdGhpcy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIF07XG5cblx0XHRcdC8vIElmIHNldCByZXR1cm5zIHVuZGVmaW5lZCwgZmFsbCBiYWNrIHRvIG5vcm1hbCBzZXR0aW5nXG5cdFx0XHRpZiAoICFob29rcyB8fCAhKCBcInNldFwiIGluIGhvb2tzICkgfHwgaG9va3Muc2V0KCB0aGlzLCB2YWwsIFwidmFsdWVcIiApID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHRoaXMudmFsdWUgPSB2YWw7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0dmFsSG9va3M6IHtcblx0XHRvcHRpb246IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdFx0dmFyIHZhbCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIFwidmFsdWVcIiApO1xuXHRcdFx0XHRyZXR1cm4gdmFsICE9IG51bGwgP1xuXHRcdFx0XHRcdHZhbCA6XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTEwIC0gMTEgb25seVxuXHRcdFx0XHRcdC8vIG9wdGlvbi50ZXh0IHRocm93cyBleGNlcHRpb25zICh0cmFjLTE0Njg2LCB0cmFjLTE0ODU4KVxuXHRcdFx0XHRcdC8vIFN0cmlwIGFuZCBjb2xsYXBzZSB3aGl0ZXNwYWNlXG5cdFx0XHRcdFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jc3RyaXAtYW5kLWNvbGxhcHNlLXdoaXRlc3BhY2Vcblx0XHRcdFx0XHRzdHJpcEFuZENvbGxhcHNlKCBqUXVlcnkudGV4dCggZWxlbSApICk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRzZWxlY3Q6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciB2YWx1ZSwgb3B0aW9uLCBpLFxuXHRcdFx0XHRcdG9wdGlvbnMgPSBlbGVtLm9wdGlvbnMsXG5cdFx0XHRcdFx0aW5kZXggPSBlbGVtLnNlbGVjdGVkSW5kZXgsXG5cdFx0XHRcdFx0b25lID0gZWxlbS50eXBlID09PSBcInNlbGVjdC1vbmVcIixcblx0XHRcdFx0XHR2YWx1ZXMgPSBvbmUgPyBudWxsIDogW10sXG5cdFx0XHRcdFx0bWF4ID0gb25lID8gaW5kZXggKyAxIDogb3B0aW9ucy5sZW5ndGg7XG5cblx0XHRcdFx0aWYgKCBpbmRleCA8IDAgKSB7XG5cdFx0XHRcdFx0aSA9IG1heDtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGkgPSBvbmUgPyBpbmRleCA6IDA7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBMb29wIHRocm91Z2ggYWxsIHRoZSBzZWxlY3RlZCBvcHRpb25zXG5cdFx0XHRcdGZvciAoIDsgaSA8IG1heDsgaSsrICkge1xuXHRcdFx0XHRcdG9wdGlvbiA9IG9wdGlvbnNbIGkgXTtcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdFx0XHRcdFx0Ly8gSUU4LTkgZG9lc24ndCB1cGRhdGUgc2VsZWN0ZWQgYWZ0ZXIgZm9ybSByZXNldCAodHJhYy0yNTUxKVxuXHRcdFx0XHRcdGlmICggKCBvcHRpb24uc2VsZWN0ZWQgfHwgaSA9PT0gaW5kZXggKSAmJlxuXG5cdFx0XHRcdFx0XHRcdC8vIERvbid0IHJldHVybiBvcHRpb25zIHRoYXQgYXJlIGRpc2FibGVkIG9yIGluIGEgZGlzYWJsZWQgb3B0Z3JvdXBcblx0XHRcdFx0XHRcdFx0IW9wdGlvbi5kaXNhYmxlZCAmJlxuXHRcdFx0XHRcdFx0XHQoICFvcHRpb24ucGFyZW50Tm9kZS5kaXNhYmxlZCB8fFxuXHRcdFx0XHRcdFx0XHRcdCFub2RlTmFtZSggb3B0aW9uLnBhcmVudE5vZGUsIFwib3B0Z3JvdXBcIiApICkgKSB7XG5cblx0XHRcdFx0XHRcdC8vIEdldCB0aGUgc3BlY2lmaWMgdmFsdWUgZm9yIHRoZSBvcHRpb25cblx0XHRcdFx0XHRcdHZhbHVlID0galF1ZXJ5KCBvcHRpb24gKS52YWwoKTtcblxuXHRcdFx0XHRcdFx0Ly8gV2UgZG9uJ3QgbmVlZCBhbiBhcnJheSBmb3Igb25lIHNlbGVjdHNcblx0XHRcdFx0XHRcdGlmICggb25lICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIE11bHRpLVNlbGVjdHMgcmV0dXJuIGFuIGFycmF5XG5cdFx0XHRcdFx0XHR2YWx1ZXMucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdmFsdWVzO1xuXHRcdFx0fSxcblxuXHRcdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRcdHZhciBvcHRpb25TZXQsIG9wdGlvbixcblx0XHRcdFx0XHRvcHRpb25zID0gZWxlbS5vcHRpb25zLFxuXHRcdFx0XHRcdHZhbHVlcyA9IGpRdWVyeS5tYWtlQXJyYXkoIHZhbHVlICksXG5cdFx0XHRcdFx0aSA9IG9wdGlvbnMubGVuZ3RoO1xuXG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdG9wdGlvbiA9IG9wdGlvbnNbIGkgXTtcblxuXHRcdFx0XHRcdC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbmQtYXNzaWduICovXG5cblx0XHRcdFx0XHRpZiAoIG9wdGlvbi5zZWxlY3RlZCA9XG5cdFx0XHRcdFx0XHRqUXVlcnkuaW5BcnJheSggalF1ZXJ5LnZhbEhvb2tzLm9wdGlvbi5nZXQoIG9wdGlvbiApLCB2YWx1ZXMgKSA+IC0xXG5cdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRvcHRpb25TZXQgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8qIGVzbGludC1lbmFibGUgbm8tY29uZC1hc3NpZ24gKi9cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEZvcmNlIGJyb3dzZXJzIHRvIGJlaGF2ZSBjb25zaXN0ZW50bHkgd2hlbiBub24tbWF0Y2hpbmcgdmFsdWUgaXMgc2V0XG5cdFx0XHRcdGlmICggIW9wdGlvblNldCApIHtcblx0XHRcdFx0XHRlbGVtLnNlbGVjdGVkSW5kZXggPSAtMTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdmFsdWVzO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSApO1xuXG4vLyBSYWRpb3MgYW5kIGNoZWNrYm94ZXMgZ2V0dGVyL3NldHRlclxualF1ZXJ5LmVhY2goIFsgXCJyYWRpb1wiLCBcImNoZWNrYm94XCIgXSwgZnVuY3Rpb24oKSB7XG5cdGpRdWVyeS52YWxIb29rc1sgdGhpcyBdID0ge1xuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWx1ZSApICkge1xuXHRcdFx0XHRyZXR1cm4gKCBlbGVtLmNoZWNrZWQgPSBqUXVlcnkuaW5BcnJheSggalF1ZXJ5KCBlbGVtICkudmFsKCksIHZhbHVlICkgPiAtMSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0aWYgKCAhc3VwcG9ydC5jaGVja09uICkge1xuXHRcdGpRdWVyeS52YWxIb29rc1sgdGhpcyBdLmdldCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKCBcInZhbHVlXCIgKSA9PT0gbnVsbCA/IFwib25cIiA6IGVsZW0udmFsdWU7XG5cdFx0fTtcblx0fVxufSApO1xuXG5cblxuXG4vLyBSZXR1cm4galF1ZXJ5IGZvciBhdHRyaWJ1dGVzLW9ubHkgaW5jbHVzaW9uXG52YXIgbG9jYXRpb24gPSB3aW5kb3cubG9jYXRpb247XG5cbnZhciBub25jZSA9IHsgZ3VpZDogRGF0ZS5ub3coKSB9O1xuXG52YXIgcnF1ZXJ5ID0gKCAvXFw/LyApO1xuXG5cblxuLy8gQ3Jvc3MtYnJvd3NlciB4bWwgcGFyc2luZ1xualF1ZXJ5LnBhcnNlWE1MID0gZnVuY3Rpb24oIGRhdGEgKSB7XG5cdHZhciB4bWwsIHBhcnNlckVycm9yRWxlbTtcblx0aWYgKCAhZGF0YSB8fCB0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSBvbmx5XG5cdC8vIElFIHRocm93cyBvbiBwYXJzZUZyb21TdHJpbmcgd2l0aCBpbnZhbGlkIGlucHV0LlxuXHR0cnkge1xuXHRcdHhtbCA9ICggbmV3IHdpbmRvdy5ET01QYXJzZXIoKSApLnBhcnNlRnJvbVN0cmluZyggZGF0YSwgXCJ0ZXh0L3htbFwiICk7XG5cdH0gY2F0Y2ggKCBlICkge31cblxuXHRwYXJzZXJFcnJvckVsZW0gPSB4bWwgJiYgeG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKCBcInBhcnNlcmVycm9yXCIgKVsgMCBdO1xuXHRpZiAoICF4bWwgfHwgcGFyc2VyRXJyb3JFbGVtICkge1xuXHRcdGpRdWVyeS5lcnJvciggXCJJbnZhbGlkIFhNTDogXCIgKyAoXG5cdFx0XHRwYXJzZXJFcnJvckVsZW0gP1xuXHRcdFx0XHRqUXVlcnkubWFwKCBwYXJzZXJFcnJvckVsZW0uY2hpbGROb2RlcywgZnVuY3Rpb24oIGVsICkge1xuXHRcdFx0XHRcdHJldHVybiBlbC50ZXh0Q29udGVudDtcblx0XHRcdFx0fSApLmpvaW4oIFwiXFxuXCIgKSA6XG5cdFx0XHRcdGRhdGFcblx0XHQpICk7XG5cdH1cblx0cmV0dXJuIHhtbDtcbn07XG5cblxudmFyIHJmb2N1c01vcnBoID0gL14oPzpmb2N1c2luZm9jdXN8Zm9jdXNvdXRibHVyKSQvLFxuXHRzdG9wUHJvcGFnYXRpb25DYWxsYmFjayA9IGZ1bmN0aW9uKCBlICkge1xuXHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdH07XG5cbmpRdWVyeS5leHRlbmQoIGpRdWVyeS5ldmVudCwge1xuXG5cdHRyaWdnZXI6IGZ1bmN0aW9uKCBldmVudCwgZGF0YSwgZWxlbSwgb25seUhhbmRsZXJzICkge1xuXG5cdFx0dmFyIGksIGN1ciwgdG1wLCBidWJibGVUeXBlLCBvbnR5cGUsIGhhbmRsZSwgc3BlY2lhbCwgbGFzdEVsZW1lbnQsXG5cdFx0XHRldmVudFBhdGggPSBbIGVsZW0gfHwgZG9jdW1lbnQgXSxcblx0XHRcdHR5cGUgPSBoYXNPd24uY2FsbCggZXZlbnQsIFwidHlwZVwiICkgPyBldmVudC50eXBlIDogZXZlbnQsXG5cdFx0XHRuYW1lc3BhY2VzID0gaGFzT3duLmNhbGwoIGV2ZW50LCBcIm5hbWVzcGFjZVwiICkgPyBldmVudC5uYW1lc3BhY2Uuc3BsaXQoIFwiLlwiICkgOiBbXTtcblxuXHRcdGN1ciA9IGxhc3RFbGVtZW50ID0gdG1wID0gZWxlbSA9IGVsZW0gfHwgZG9jdW1lbnQ7XG5cblx0XHQvLyBEb24ndCBkbyBldmVudHMgb24gdGV4dCBhbmQgY29tbWVudCBub2Rlc1xuXHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIGZvY3VzL2JsdXIgbW9ycGhzIHRvIGZvY3VzaW4vb3V0OyBlbnN1cmUgd2UncmUgbm90IGZpcmluZyB0aGVtIHJpZ2h0IG5vd1xuXHRcdGlmICggcmZvY3VzTW9ycGgudGVzdCggdHlwZSArIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIHR5cGUuaW5kZXhPZiggXCIuXCIgKSA+IC0xICkge1xuXG5cdFx0XHQvLyBOYW1lc3BhY2VkIHRyaWdnZXI7IGNyZWF0ZSBhIHJlZ2V4cCB0byBtYXRjaCBldmVudCB0eXBlIGluIGhhbmRsZSgpXG5cdFx0XHRuYW1lc3BhY2VzID0gdHlwZS5zcGxpdCggXCIuXCIgKTtcblx0XHRcdHR5cGUgPSBuYW1lc3BhY2VzLnNoaWZ0KCk7XG5cdFx0XHRuYW1lc3BhY2VzLnNvcnQoKTtcblx0XHR9XG5cdFx0b250eXBlID0gdHlwZS5pbmRleE9mKCBcIjpcIiApIDwgMCAmJiBcIm9uXCIgKyB0eXBlO1xuXG5cdFx0Ly8gQ2FsbGVyIGNhbiBwYXNzIGluIGEgalF1ZXJ5LkV2ZW50IG9iamVjdCwgT2JqZWN0LCBvciBqdXN0IGFuIGV2ZW50IHR5cGUgc3RyaW5nXG5cdFx0ZXZlbnQgPSBldmVudFsgalF1ZXJ5LmV4cGFuZG8gXSA/XG5cdFx0XHRldmVudCA6XG5cdFx0XHRuZXcgalF1ZXJ5LkV2ZW50KCB0eXBlLCB0eXBlb2YgZXZlbnQgPT09IFwib2JqZWN0XCIgJiYgZXZlbnQgKTtcblxuXHRcdC8vIFRyaWdnZXIgYml0bWFzazogJiAxIGZvciBuYXRpdmUgaGFuZGxlcnM7ICYgMiBmb3IgalF1ZXJ5IChhbHdheXMgdHJ1ZSlcblx0XHRldmVudC5pc1RyaWdnZXIgPSBvbmx5SGFuZGxlcnMgPyAyIDogMztcblx0XHRldmVudC5uYW1lc3BhY2UgPSBuYW1lc3BhY2VzLmpvaW4oIFwiLlwiICk7XG5cdFx0ZXZlbnQucm5hbWVzcGFjZSA9IGV2ZW50Lm5hbWVzcGFjZSA/XG5cdFx0XHRuZXcgUmVnRXhwKCBcIihefFxcXFwuKVwiICsgbmFtZXNwYWNlcy5qb2luKCBcIlxcXFwuKD86LipcXFxcLnwpXCIgKSArIFwiKFxcXFwufCQpXCIgKSA6XG5cdFx0XHRudWxsO1xuXG5cdFx0Ly8gQ2xlYW4gdXAgdGhlIGV2ZW50IGluIGNhc2UgaXQgaXMgYmVpbmcgcmV1c2VkXG5cdFx0ZXZlbnQucmVzdWx0ID0gdW5kZWZpbmVkO1xuXHRcdGlmICggIWV2ZW50LnRhcmdldCApIHtcblx0XHRcdGV2ZW50LnRhcmdldCA9IGVsZW07XG5cdFx0fVxuXG5cdFx0Ly8gQ2xvbmUgYW55IGluY29taW5nIGRhdGEgYW5kIHByZXBlbmQgdGhlIGV2ZW50LCBjcmVhdGluZyB0aGUgaGFuZGxlciBhcmcgbGlzdFxuXHRcdGRhdGEgPSBkYXRhID09IG51bGwgP1xuXHRcdFx0WyBldmVudCBdIDpcblx0XHRcdGpRdWVyeS5tYWtlQXJyYXkoIGRhdGEsIFsgZXZlbnQgXSApO1xuXG5cdFx0Ly8gQWxsb3cgc3BlY2lhbCBldmVudHMgdG8gZHJhdyBvdXRzaWRlIHRoZSBsaW5lc1xuXHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiBzcGVjaWFsLnRyaWdnZXIgJiYgc3BlY2lhbC50cmlnZ2VyLmFwcGx5KCBlbGVtLCBkYXRhICkgPT09IGZhbHNlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIERldGVybWluZSBldmVudCBwcm9wYWdhdGlvbiBwYXRoIGluIGFkdmFuY2UsIHBlciBXM0MgZXZlbnRzIHNwZWMgKHRyYWMtOTk1MSlcblx0XHQvLyBCdWJibGUgdXAgdG8gZG9jdW1lbnQsIHRoZW4gdG8gd2luZG93OyB3YXRjaCBmb3IgYSBnbG9iYWwgb3duZXJEb2N1bWVudCB2YXIgKHRyYWMtOTcyNClcblx0XHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgIXNwZWNpYWwubm9CdWJibGUgJiYgIWlzV2luZG93KCBlbGVtICkgKSB7XG5cblx0XHRcdGJ1YmJsZVR5cGUgPSBzcGVjaWFsLmRlbGVnYXRlVHlwZSB8fCB0eXBlO1xuXHRcdFx0aWYgKCAhcmZvY3VzTW9ycGgudGVzdCggYnViYmxlVHlwZSArIHR5cGUgKSApIHtcblx0XHRcdFx0Y3VyID0gY3VyLnBhcmVudE5vZGU7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKCA7IGN1cjsgY3VyID0gY3VyLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdGV2ZW50UGF0aC5wdXNoKCBjdXIgKTtcblx0XHRcdFx0dG1wID0gY3VyO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPbmx5IGFkZCB3aW5kb3cgaWYgd2UgZ290IHRvIGRvY3VtZW50IChlLmcuLCBub3QgcGxhaW4gb2JqIG9yIGRldGFjaGVkIERPTSlcblx0XHRcdGlmICggdG1wID09PSAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudCApICkge1xuXHRcdFx0XHRldmVudFBhdGgucHVzaCggdG1wLmRlZmF1bHRWaWV3IHx8IHRtcC5wYXJlbnRXaW5kb3cgfHwgd2luZG93ICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gRmlyZSBoYW5kbGVycyBvbiB0aGUgZXZlbnQgcGF0aFxuXHRcdGkgPSAwO1xuXHRcdHdoaWxlICggKCBjdXIgPSBldmVudFBhdGhbIGkrKyBdICkgJiYgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cdFx0XHRsYXN0RWxlbWVudCA9IGN1cjtcblx0XHRcdGV2ZW50LnR5cGUgPSBpID4gMSA/XG5cdFx0XHRcdGJ1YmJsZVR5cGUgOlxuXHRcdFx0XHRzcGVjaWFsLmJpbmRUeXBlIHx8IHR5cGU7XG5cblx0XHRcdC8vIGpRdWVyeSBoYW5kbGVyXG5cdFx0XHRoYW5kbGUgPSAoIGRhdGFQcml2LmdldCggY3VyLCBcImV2ZW50c1wiICkgfHwgT2JqZWN0LmNyZWF0ZSggbnVsbCApIClbIGV2ZW50LnR5cGUgXSAmJlxuXHRcdFx0XHRkYXRhUHJpdi5nZXQoIGN1ciwgXCJoYW5kbGVcIiApO1xuXHRcdFx0aWYgKCBoYW5kbGUgKSB7XG5cdFx0XHRcdGhhbmRsZS5hcHBseSggY3VyLCBkYXRhICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE5hdGl2ZSBoYW5kbGVyXG5cdFx0XHRoYW5kbGUgPSBvbnR5cGUgJiYgY3VyWyBvbnR5cGUgXTtcblx0XHRcdGlmICggaGFuZGxlICYmIGhhbmRsZS5hcHBseSAmJiBhY2NlcHREYXRhKCBjdXIgKSApIHtcblx0XHRcdFx0ZXZlbnQucmVzdWx0ID0gaGFuZGxlLmFwcGx5KCBjdXIsIGRhdGEgKTtcblx0XHRcdFx0aWYgKCBldmVudC5yZXN1bHQgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0ZXZlbnQudHlwZSA9IHR5cGU7XG5cblx0XHQvLyBJZiBub2JvZHkgcHJldmVudGVkIHRoZSBkZWZhdWx0IGFjdGlvbiwgZG8gaXQgbm93XG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmICFldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSApIHtcblxuXHRcdFx0aWYgKCAoICFzcGVjaWFsLl9kZWZhdWx0IHx8XG5cdFx0XHRcdHNwZWNpYWwuX2RlZmF1bHQuYXBwbHkoIGV2ZW50UGF0aC5wb3AoKSwgZGF0YSApID09PSBmYWxzZSApICYmXG5cdFx0XHRcdGFjY2VwdERhdGEoIGVsZW0gKSApIHtcblxuXHRcdFx0XHQvLyBDYWxsIGEgbmF0aXZlIERPTSBtZXRob2Qgb24gdGhlIHRhcmdldCB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgdGhlIGV2ZW50LlxuXHRcdFx0XHQvLyBEb24ndCBkbyBkZWZhdWx0IGFjdGlvbnMgb24gd2luZG93LCB0aGF0J3Mgd2hlcmUgZ2xvYmFsIHZhcmlhYmxlcyBiZSAodHJhYy02MTcwKVxuXHRcdFx0XHRpZiAoIG9udHlwZSAmJiBpc0Z1bmN0aW9uKCBlbGVtWyB0eXBlIF0gKSAmJiAhaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0XHRcdC8vIERvbid0IHJlLXRyaWdnZXIgYW4gb25GT08gZXZlbnQgd2hlbiB3ZSBjYWxsIGl0cyBGT08oKSBtZXRob2Rcblx0XHRcdFx0XHR0bXAgPSBlbGVtWyBvbnR5cGUgXTtcblxuXHRcdFx0XHRcdGlmICggdG1wICkge1xuXHRcdFx0XHRcdFx0ZWxlbVsgb250eXBlIF0gPSBudWxsO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFByZXZlbnQgcmUtdHJpZ2dlcmluZyBvZiB0aGUgc2FtZSBldmVudCwgc2luY2Ugd2UgYWxyZWFkeSBidWJibGVkIGl0IGFib3ZlXG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCA9IHR5cGU7XG5cblx0XHRcdFx0XHRpZiAoIGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cdFx0XHRcdFx0XHRsYXN0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCB0eXBlLCBzdG9wUHJvcGFnYXRpb25DYWxsYmFjayApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGVsZW1bIHR5cGUgXSgpO1xuXG5cdFx0XHRcdFx0aWYgKCBldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXHRcdFx0XHRcdFx0bGFzdEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggdHlwZSwgc3RvcFByb3BhZ2F0aW9uQ2FsbGJhY2sgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlcmVkID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRcdFx0aWYgKCB0bXAgKSB7XG5cdFx0XHRcdFx0XHRlbGVtWyBvbnR5cGUgXSA9IHRtcDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQucmVzdWx0O1xuXHR9LFxuXG5cdC8vIFBpZ2d5YmFjayBvbiBhIGRvbm9yIGV2ZW50IHRvIHNpbXVsYXRlIGEgZGlmZmVyZW50IG9uZVxuXHQvLyBVc2VkIG9ubHkgZm9yIGBmb2N1cyhpbiB8IG91dClgIGV2ZW50c1xuXHRzaW11bGF0ZTogZnVuY3Rpb24oIHR5cGUsIGVsZW0sIGV2ZW50ICkge1xuXHRcdHZhciBlID0galF1ZXJ5LmV4dGVuZChcblx0XHRcdG5ldyBqUXVlcnkuRXZlbnQoKSxcblx0XHRcdGV2ZW50LFxuXHRcdFx0e1xuXHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRpc1NpbXVsYXRlZDogdHJ1ZVxuXHRcdFx0fVxuXHRcdCk7XG5cblx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggZSwgbnVsbCwgZWxlbSApO1xuXHR9XG5cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdHRyaWdnZXI6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIHR5cGUsIGRhdGEsIHRoaXMgKTtcblx0XHR9ICk7XG5cdH0sXG5cdHRyaWdnZXJIYW5kbGVyOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgZWxlbSA9IHRoaXNbIDAgXTtcblx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmV2ZW50LnRyaWdnZXIoIHR5cGUsIGRhdGEsIGVsZW0sIHRydWUgKTtcblx0XHR9XG5cdH1cbn0gKTtcblxuXG52YXJcblx0cmJyYWNrZXQgPSAvXFxbXFxdJC8sXG5cdHJDUkxGID0gL1xccj9cXG4vZyxcblx0cnN1Ym1pdHRlclR5cGVzID0gL14oPzpzdWJtaXR8YnV0dG9ufGltYWdlfHJlc2V0fGZpbGUpJC9pLFxuXHRyc3VibWl0dGFibGUgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxrZXlnZW4pL2k7XG5cbmZ1bmN0aW9uIGJ1aWxkUGFyYW1zKCBwcmVmaXgsIG9iaiwgdHJhZGl0aW9uYWwsIGFkZCApIHtcblx0dmFyIG5hbWU7XG5cblx0aWYgKCBBcnJheS5pc0FycmF5KCBvYmogKSApIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSBhcnJheSBpdGVtLlxuXHRcdGpRdWVyeS5lYWNoKCBvYmosIGZ1bmN0aW9uKCBpLCB2ICkge1xuXHRcdFx0aWYgKCB0cmFkaXRpb25hbCB8fCByYnJhY2tldC50ZXN0KCBwcmVmaXggKSApIHtcblxuXHRcdFx0XHQvLyBUcmVhdCBlYWNoIGFycmF5IGl0ZW0gYXMgYSBzY2FsYXIuXG5cdFx0XHRcdGFkZCggcHJlZml4LCB2ICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gSXRlbSBpcyBub24tc2NhbGFyIChhcnJheSBvciBvYmplY3QpLCBlbmNvZGUgaXRzIG51bWVyaWMgaW5kZXguXG5cdFx0XHRcdGJ1aWxkUGFyYW1zKFxuXHRcdFx0XHRcdHByZWZpeCArIFwiW1wiICsgKCB0eXBlb2YgdiA9PT0gXCJvYmplY3RcIiAmJiB2ICE9IG51bGwgPyBpIDogXCJcIiApICsgXCJdXCIsXG5cdFx0XHRcdFx0dixcblx0XHRcdFx0XHR0cmFkaXRpb25hbCxcblx0XHRcdFx0XHRhZGRcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9ICk7XG5cblx0fSBlbHNlIGlmICggIXRyYWRpdGlvbmFsICYmIHRvVHlwZSggb2JqICkgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHQvLyBTZXJpYWxpemUgb2JqZWN0IGl0ZW0uXG5cdFx0Zm9yICggbmFtZSBpbiBvYmogKSB7XG5cdFx0XHRidWlsZFBhcmFtcyggcHJlZml4ICsgXCJbXCIgKyBuYW1lICsgXCJdXCIsIG9ialsgbmFtZSBdLCB0cmFkaXRpb25hbCwgYWRkICk7XG5cdFx0fVxuXG5cdH0gZWxzZSB7XG5cblx0XHQvLyBTZXJpYWxpemUgc2NhbGFyIGl0ZW0uXG5cdFx0YWRkKCBwcmVmaXgsIG9iaiApO1xuXHR9XG59XG5cbi8vIFNlcmlhbGl6ZSBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzIG9yIGEgc2V0IG9mXG4vLyBrZXkvdmFsdWVzIGludG8gYSBxdWVyeSBzdHJpbmdcbmpRdWVyeS5wYXJhbSA9IGZ1bmN0aW9uKCBhLCB0cmFkaXRpb25hbCApIHtcblx0dmFyIHByZWZpeCxcblx0XHRzID0gW10sXG5cdFx0YWRkID0gZnVuY3Rpb24oIGtleSwgdmFsdWVPckZ1bmN0aW9uICkge1xuXG5cdFx0XHQvLyBJZiB2YWx1ZSBpcyBhIGZ1bmN0aW9uLCBpbnZva2UgaXQgYW5kIHVzZSBpdHMgcmV0dXJuIHZhbHVlXG5cdFx0XHR2YXIgdmFsdWUgPSBpc0Z1bmN0aW9uKCB2YWx1ZU9yRnVuY3Rpb24gKSA/XG5cdFx0XHRcdHZhbHVlT3JGdW5jdGlvbigpIDpcblx0XHRcdFx0dmFsdWVPckZ1bmN0aW9uO1xuXG5cdFx0XHRzWyBzLmxlbmd0aCBdID0gZW5jb2RlVVJJQ29tcG9uZW50KCBrZXkgKSArIFwiPVwiICtcblx0XHRcdFx0ZW5jb2RlVVJJQ29tcG9uZW50KCB2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlICk7XG5cdFx0fTtcblxuXHRpZiAoIGEgPT0gbnVsbCApIHtcblx0XHRyZXR1cm4gXCJcIjtcblx0fVxuXG5cdC8vIElmIGFuIGFycmF5IHdhcyBwYXNzZWQgaW4sIGFzc3VtZSB0aGF0IGl0IGlzIGFuIGFycmF5IG9mIGZvcm0gZWxlbWVudHMuXG5cdGlmICggQXJyYXkuaXNBcnJheSggYSApIHx8ICggYS5qcXVlcnkgJiYgIWpRdWVyeS5pc1BsYWluT2JqZWN0KCBhICkgKSApIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSB0aGUgZm9ybSBlbGVtZW50c1xuXHRcdGpRdWVyeS5lYWNoKCBhLCBmdW5jdGlvbigpIHtcblx0XHRcdGFkZCggdGhpcy5uYW1lLCB0aGlzLnZhbHVlICk7XG5cdFx0fSApO1xuXG5cdH0gZWxzZSB7XG5cblx0XHQvLyBJZiB0cmFkaXRpb25hbCwgZW5jb2RlIHRoZSBcIm9sZFwiIHdheSAodGhlIHdheSAxLjMuMiBvciBvbGRlclxuXHRcdC8vIGRpZCBpdCksIG90aGVyd2lzZSBlbmNvZGUgcGFyYW1zIHJlY3Vyc2l2ZWx5LlxuXHRcdGZvciAoIHByZWZpeCBpbiBhICkge1xuXHRcdFx0YnVpbGRQYXJhbXMoIHByZWZpeCwgYVsgcHJlZml4IF0sIHRyYWRpdGlvbmFsLCBhZGQgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIHJlc3VsdGluZyBzZXJpYWxpemF0aW9uXG5cdHJldHVybiBzLmpvaW4oIFwiJlwiICk7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHNlcmlhbGl6ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5wYXJhbSggdGhpcy5zZXJpYWxpemVBcnJheSgpICk7XG5cdH0sXG5cdHNlcmlhbGl6ZUFycmF5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBDYW4gYWRkIHByb3BIb29rIGZvciBcImVsZW1lbnRzXCIgdG8gZmlsdGVyIG9yIGFkZCBmb3JtIGVsZW1lbnRzXG5cdFx0XHR2YXIgZWxlbWVudHMgPSBqUXVlcnkucHJvcCggdGhpcywgXCJlbGVtZW50c1wiICk7XG5cdFx0XHRyZXR1cm4gZWxlbWVudHMgPyBqUXVlcnkubWFrZUFycmF5KCBlbGVtZW50cyApIDogdGhpcztcblx0XHR9ICkuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB0eXBlID0gdGhpcy50eXBlO1xuXG5cdFx0XHQvLyBVc2UgLmlzKCBcIjpkaXNhYmxlZFwiICkgc28gdGhhdCBmaWVsZHNldFtkaXNhYmxlZF0gd29ya3Ncblx0XHRcdHJldHVybiB0aGlzLm5hbWUgJiYgIWpRdWVyeSggdGhpcyApLmlzKCBcIjpkaXNhYmxlZFwiICkgJiZcblx0XHRcdFx0cnN1Ym1pdHRhYmxlLnRlc3QoIHRoaXMubm9kZU5hbWUgKSAmJiAhcnN1Ym1pdHRlclR5cGVzLnRlc3QoIHR5cGUgKSAmJlxuXHRcdFx0XHQoIHRoaXMuY2hlY2tlZCB8fCAhcmNoZWNrYWJsZVR5cGUudGVzdCggdHlwZSApICk7XG5cdFx0fSApLm1hcCggZnVuY3Rpb24oIF9pLCBlbGVtICkge1xuXHRcdFx0dmFyIHZhbCA9IGpRdWVyeSggdGhpcyApLnZhbCgpO1xuXG5cdFx0XHRpZiAoIHZhbCA9PSBudWxsICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWwgKSApIHtcblx0XHRcdFx0cmV0dXJuIGpRdWVyeS5tYXAoIHZhbCwgZnVuY3Rpb24oIHZhbCApIHtcblx0XHRcdFx0XHRyZXR1cm4geyBuYW1lOiBlbGVtLm5hbWUsIHZhbHVlOiB2YWwucmVwbGFjZSggckNSTEYsIFwiXFxyXFxuXCIgKSB9O1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB7IG5hbWU6IGVsZW0ubmFtZSwgdmFsdWU6IHZhbC5yZXBsYWNlKCByQ1JMRiwgXCJcXHJcXG5cIiApIH07XG5cdFx0fSApLmdldCgpO1xuXHR9XG59ICk7XG5cblxudmFyXG5cdHIyMCA9IC8lMjAvZyxcblx0cmhhc2ggPSAvIy4qJC8sXG5cdHJhbnRpQ2FjaGUgPSAvKFs/Jl0pXz1bXiZdKi8sXG5cdHJoZWFkZXJzID0gL14oLio/KTpbIFxcdF0qKFteXFxyXFxuXSopJC9tZyxcblxuXHQvLyB0cmFjLTc2NTMsIHRyYWMtODEyNSwgdHJhYy04MTUyOiBsb2NhbCBwcm90b2NvbCBkZXRlY3Rpb25cblx0cmxvY2FsUHJvdG9jb2wgPSAvXig/OmFib3V0fGFwcHxhcHAtc3RvcmFnZXwuKy1leHRlbnNpb258ZmlsZXxyZXN8d2lkZ2V0KTokLyxcblx0cm5vQ29udGVudCA9IC9eKD86R0VUfEhFQUQpJC8sXG5cdHJwcm90b2NvbCA9IC9eXFwvXFwvLyxcblxuXHQvKiBQcmVmaWx0ZXJzXG5cdCAqIDEpIFRoZXkgYXJlIHVzZWZ1bCB0byBpbnRyb2R1Y2UgY3VzdG9tIGRhdGFUeXBlcyAoc2VlIGFqYXgvanNvbnAuanMgZm9yIGFuIGV4YW1wbGUpXG5cdCAqIDIpIFRoZXNlIGFyZSBjYWxsZWQ6XG5cdCAqICAgIC0gQkVGT1JFIGFza2luZyBmb3IgYSB0cmFuc3BvcnRcblx0ICogICAgLSBBRlRFUiBwYXJhbSBzZXJpYWxpemF0aW9uIChzLmRhdGEgaXMgYSBzdHJpbmcgaWYgcy5wcm9jZXNzRGF0YSBpcyB0cnVlKVxuXHQgKiAzKSBrZXkgaXMgdGhlIGRhdGFUeXBlXG5cdCAqIDQpIHRoZSBjYXRjaGFsbCBzeW1ib2wgXCIqXCIgY2FuIGJlIHVzZWRcblx0ICogNSkgZXhlY3V0aW9uIHdpbGwgc3RhcnQgd2l0aCB0cmFuc3BvcnQgZGF0YVR5cGUgYW5kIFRIRU4gY29udGludWUgZG93biB0byBcIipcIiBpZiBuZWVkZWRcblx0ICovXG5cdHByZWZpbHRlcnMgPSB7fSxcblxuXHQvKiBUcmFuc3BvcnRzIGJpbmRpbmdzXG5cdCAqIDEpIGtleSBpcyB0aGUgZGF0YVR5cGVcblx0ICogMikgdGhlIGNhdGNoYWxsIHN5bWJvbCBcIipcIiBjYW4gYmUgdXNlZFxuXHQgKiAzKSBzZWxlY3Rpb24gd2lsbCBzdGFydCB3aXRoIHRyYW5zcG9ydCBkYXRhVHlwZSBhbmQgVEhFTiBnbyB0byBcIipcIiBpZiBuZWVkZWRcblx0ICovXG5cdHRyYW5zcG9ydHMgPSB7fSxcblxuXHQvLyBBdm9pZCBjb21tZW50LXByb2xvZyBjaGFyIHNlcXVlbmNlICh0cmFjLTEwMDk4KTsgbXVzdCBhcHBlYXNlIGxpbnQgYW5kIGV2YWRlIGNvbXByZXNzaW9uXG5cdGFsbFR5cGVzID0gXCIqL1wiLmNvbmNhdCggXCIqXCIgKSxcblxuXHQvLyBBbmNob3IgdGFnIGZvciBwYXJzaW5nIHRoZSBkb2N1bWVudCBvcmlnaW5cblx0b3JpZ2luQW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJhXCIgKTtcblxub3JpZ2luQW5jaG9yLmhyZWYgPSBsb2NhdGlvbi5ocmVmO1xuXG4vLyBCYXNlIFwiY29uc3RydWN0b3JcIiBmb3IgalF1ZXJ5LmFqYXhQcmVmaWx0ZXIgYW5kIGpRdWVyeS5hamF4VHJhbnNwb3J0XG5mdW5jdGlvbiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHN0cnVjdHVyZSApIHtcblxuXHQvLyBkYXRhVHlwZUV4cHJlc3Npb24gaXMgb3B0aW9uYWwgYW5kIGRlZmF1bHRzIHRvIFwiKlwiXG5cdHJldHVybiBmdW5jdGlvbiggZGF0YVR5cGVFeHByZXNzaW9uLCBmdW5jICkge1xuXG5cdFx0aWYgKCB0eXBlb2YgZGF0YVR5cGVFeHByZXNzaW9uICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0ZnVuYyA9IGRhdGFUeXBlRXhwcmVzc2lvbjtcblx0XHRcdGRhdGFUeXBlRXhwcmVzc2lvbiA9IFwiKlwiO1xuXHRcdH1cblxuXHRcdHZhciBkYXRhVHlwZSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0ZGF0YVR5cGVzID0gZGF0YVR5cGVFeHByZXNzaW9uLnRvTG93ZXJDYXNlKCkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXTtcblxuXHRcdGlmICggaXNGdW5jdGlvbiggZnVuYyApICkge1xuXG5cdFx0XHQvLyBGb3IgZWFjaCBkYXRhVHlwZSBpbiB0aGUgZGF0YVR5cGVFeHByZXNzaW9uXG5cdFx0XHR3aGlsZSAoICggZGF0YVR5cGUgPSBkYXRhVHlwZXNbIGkrKyBdICkgKSB7XG5cblx0XHRcdFx0Ly8gUHJlcGVuZCBpZiByZXF1ZXN0ZWRcblx0XHRcdFx0aWYgKCBkYXRhVHlwZVsgMCBdID09PSBcIitcIiApIHtcblx0XHRcdFx0XHRkYXRhVHlwZSA9IGRhdGFUeXBlLnNsaWNlKCAxICkgfHwgXCIqXCI7XG5cdFx0XHRcdFx0KCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gPSBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10gKS51bnNoaWZ0KCBmdW5jICk7XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIGFwcGVuZFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdCggc3RydWN0dXJlWyBkYXRhVHlwZSBdID0gc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdICkucHVzaCggZnVuYyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufVxuXG4vLyBCYXNlIGluc3BlY3Rpb24gZnVuY3Rpb24gZm9yIHByZWZpbHRlcnMgYW5kIHRyYW5zcG9ydHNcbmZ1bmN0aW9uIGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBzdHJ1Y3R1cmUsIG9wdGlvbnMsIG9yaWdpbmFsT3B0aW9ucywganFYSFIgKSB7XG5cblx0dmFyIGluc3BlY3RlZCA9IHt9LFxuXHRcdHNlZWtpbmdUcmFuc3BvcnQgPSAoIHN0cnVjdHVyZSA9PT0gdHJhbnNwb3J0cyApO1xuXG5cdGZ1bmN0aW9uIGluc3BlY3QoIGRhdGFUeXBlICkge1xuXHRcdHZhciBzZWxlY3RlZDtcblx0XHRpbnNwZWN0ZWRbIGRhdGFUeXBlIF0gPSB0cnVlO1xuXHRcdGpRdWVyeS5lYWNoKCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10sIGZ1bmN0aW9uKCBfLCBwcmVmaWx0ZXJPckZhY3RvcnkgKSB7XG5cdFx0XHR2YXIgZGF0YVR5cGVPclRyYW5zcG9ydCA9IHByZWZpbHRlck9yRmFjdG9yeSggb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCBqcVhIUiApO1xuXHRcdFx0aWYgKCB0eXBlb2YgZGF0YVR5cGVPclRyYW5zcG9ydCA9PT0gXCJzdHJpbmdcIiAmJlxuXHRcdFx0XHQhc2Vla2luZ1RyYW5zcG9ydCAmJiAhaW5zcGVjdGVkWyBkYXRhVHlwZU9yVHJhbnNwb3J0IF0gKSB7XG5cblx0XHRcdFx0b3B0aW9ucy5kYXRhVHlwZXMudW5zaGlmdCggZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0XHRpbnNwZWN0KCBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH0gZWxzZSBpZiAoIHNlZWtpbmdUcmFuc3BvcnQgKSB7XG5cdFx0XHRcdHJldHVybiAhKCBzZWxlY3RlZCA9IGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdFx0cmV0dXJuIHNlbGVjdGVkO1xuXHR9XG5cblx0cmV0dXJuIGluc3BlY3QoIG9wdGlvbnMuZGF0YVR5cGVzWyAwIF0gKSB8fCAhaW5zcGVjdGVkWyBcIipcIiBdICYmIGluc3BlY3QoIFwiKlwiICk7XG59XG5cbi8vIEEgc3BlY2lhbCBleHRlbmQgZm9yIGFqYXggb3B0aW9uc1xuLy8gdGhhdCB0YWtlcyBcImZsYXRcIiBvcHRpb25zIChub3QgdG8gYmUgZGVlcCBleHRlbmRlZClcbi8vIEZpeGVzIHRyYWMtOTg4N1xuZnVuY3Rpb24gYWpheEV4dGVuZCggdGFyZ2V0LCBzcmMgKSB7XG5cdHZhciBrZXksIGRlZXAsXG5cdFx0ZmxhdE9wdGlvbnMgPSBqUXVlcnkuYWpheFNldHRpbmdzLmZsYXRPcHRpb25zIHx8IHt9O1xuXG5cdGZvciAoIGtleSBpbiBzcmMgKSB7XG5cdFx0aWYgKCBzcmNbIGtleSBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHQoIGZsYXRPcHRpb25zWyBrZXkgXSA/IHRhcmdldCA6ICggZGVlcCB8fCAoIGRlZXAgPSB7fSApICkgKVsga2V5IF0gPSBzcmNbIGtleSBdO1xuXHRcdH1cblx0fVxuXHRpZiAoIGRlZXAgKSB7XG5cdFx0alF1ZXJ5LmV4dGVuZCggdHJ1ZSwgdGFyZ2V0LCBkZWVwICk7XG5cdH1cblxuXHRyZXR1cm4gdGFyZ2V0O1xufVxuXG4vKiBIYW5kbGVzIHJlc3BvbnNlcyB0byBhbiBhamF4IHJlcXVlc3Q6XG4gKiAtIGZpbmRzIHRoZSByaWdodCBkYXRhVHlwZSAobWVkaWF0ZXMgYmV0d2VlbiBjb250ZW50LXR5cGUgYW5kIGV4cGVjdGVkIGRhdGFUeXBlKVxuICogLSByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHJlc3BvbnNlXG4gKi9cbmZ1bmN0aW9uIGFqYXhIYW5kbGVSZXNwb25zZXMoIHMsIGpxWEhSLCByZXNwb25zZXMgKSB7XG5cblx0dmFyIGN0LCB0eXBlLCBmaW5hbERhdGFUeXBlLCBmaXJzdERhdGFUeXBlLFxuXHRcdGNvbnRlbnRzID0gcy5jb250ZW50cyxcblx0XHRkYXRhVHlwZXMgPSBzLmRhdGFUeXBlcztcblxuXHQvLyBSZW1vdmUgYXV0byBkYXRhVHlwZSBhbmQgZ2V0IGNvbnRlbnQtdHlwZSBpbiB0aGUgcHJvY2Vzc1xuXHR3aGlsZSAoIGRhdGFUeXBlc1sgMCBdID09PSBcIipcIiApIHtcblx0XHRkYXRhVHlwZXMuc2hpZnQoKTtcblx0XHRpZiAoIGN0ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRjdCA9IHMubWltZVR5cGUgfHwganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiQ29udGVudC1UeXBlXCIgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBDaGVjayBpZiB3ZSdyZSBkZWFsaW5nIHdpdGggYSBrbm93biBjb250ZW50LXR5cGVcblx0aWYgKCBjdCApIHtcblx0XHRmb3IgKCB0eXBlIGluIGNvbnRlbnRzICkge1xuXHRcdFx0aWYgKCBjb250ZW50c1sgdHlwZSBdICYmIGNvbnRlbnRzWyB0eXBlIF0udGVzdCggY3QgKSApIHtcblx0XHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIHR5cGUgKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2hlY2sgdG8gc2VlIGlmIHdlIGhhdmUgYSByZXNwb25zZSBmb3IgdGhlIGV4cGVjdGVkIGRhdGFUeXBlXG5cdGlmICggZGF0YVR5cGVzWyAwIF0gaW4gcmVzcG9uc2VzICkge1xuXHRcdGZpbmFsRGF0YVR5cGUgPSBkYXRhVHlwZXNbIDAgXTtcblx0fSBlbHNlIHtcblxuXHRcdC8vIFRyeSBjb252ZXJ0aWJsZSBkYXRhVHlwZXNcblx0XHRmb3IgKCB0eXBlIGluIHJlc3BvbnNlcyApIHtcblx0XHRcdGlmICggIWRhdGFUeXBlc1sgMCBdIHx8IHMuY29udmVydGVyc1sgdHlwZSArIFwiIFwiICsgZGF0YVR5cGVzWyAwIF0gXSApIHtcblx0XHRcdFx0ZmluYWxEYXRhVHlwZSA9IHR5cGU7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAhZmlyc3REYXRhVHlwZSApIHtcblx0XHRcdFx0Zmlyc3REYXRhVHlwZSA9IHR5cGU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gT3IganVzdCB1c2UgZmlyc3Qgb25lXG5cdFx0ZmluYWxEYXRhVHlwZSA9IGZpbmFsRGF0YVR5cGUgfHwgZmlyc3REYXRhVHlwZTtcblx0fVxuXG5cdC8vIElmIHdlIGZvdW5kIGEgZGF0YVR5cGVcblx0Ly8gV2UgYWRkIHRoZSBkYXRhVHlwZSB0byB0aGUgbGlzdCBpZiBuZWVkZWRcblx0Ly8gYW5kIHJldHVybiB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxuXHRpZiAoIGZpbmFsRGF0YVR5cGUgKSB7XG5cdFx0aWYgKCBmaW5hbERhdGFUeXBlICE9PSBkYXRhVHlwZXNbIDAgXSApIHtcblx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCBmaW5hbERhdGFUeXBlICk7XG5cdFx0fVxuXHRcdHJldHVybiByZXNwb25zZXNbIGZpbmFsRGF0YVR5cGUgXTtcblx0fVxufVxuXG4vKiBDaGFpbiBjb252ZXJzaW9ucyBnaXZlbiB0aGUgcmVxdWVzdCBhbmQgdGhlIG9yaWdpbmFsIHJlc3BvbnNlXG4gKiBBbHNvIHNldHMgdGhlIHJlc3BvbnNlWFhYIGZpZWxkcyBvbiB0aGUganFYSFIgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gYWpheENvbnZlcnQoIHMsIHJlc3BvbnNlLCBqcVhIUiwgaXNTdWNjZXNzICkge1xuXHR2YXIgY29udjIsIGN1cnJlbnQsIGNvbnYsIHRtcCwgcHJldixcblx0XHRjb252ZXJ0ZXJzID0ge30sXG5cblx0XHQvLyBXb3JrIHdpdGggYSBjb3B5IG9mIGRhdGFUeXBlcyBpbiBjYXNlIHdlIG5lZWQgdG8gbW9kaWZ5IGl0IGZvciBjb252ZXJzaW9uXG5cdFx0ZGF0YVR5cGVzID0gcy5kYXRhVHlwZXMuc2xpY2UoKTtcblxuXHQvLyBDcmVhdGUgY29udmVydGVycyBtYXAgd2l0aCBsb3dlcmNhc2VkIGtleXNcblx0aWYgKCBkYXRhVHlwZXNbIDEgXSApIHtcblx0XHRmb3IgKCBjb252IGluIHMuY29udmVydGVycyApIHtcblx0XHRcdGNvbnZlcnRlcnNbIGNvbnYudG9Mb3dlckNhc2UoKSBdID0gcy5jb252ZXJ0ZXJzWyBjb252IF07XG5cdFx0fVxuXHR9XG5cblx0Y3VycmVudCA9IGRhdGFUeXBlcy5zaGlmdCgpO1xuXG5cdC8vIENvbnZlcnQgdG8gZWFjaCBzZXF1ZW50aWFsIGRhdGFUeXBlXG5cdHdoaWxlICggY3VycmVudCApIHtcblxuXHRcdGlmICggcy5yZXNwb25zZUZpZWxkc1sgY3VycmVudCBdICkge1xuXHRcdFx0anFYSFJbIHMucmVzcG9uc2VGaWVsZHNbIGN1cnJlbnQgXSBdID0gcmVzcG9uc2U7XG5cdFx0fVxuXG5cdFx0Ly8gQXBwbHkgdGhlIGRhdGFGaWx0ZXIgaWYgcHJvdmlkZWRcblx0XHRpZiAoICFwcmV2ICYmIGlzU3VjY2VzcyAmJiBzLmRhdGFGaWx0ZXIgKSB7XG5cdFx0XHRyZXNwb25zZSA9IHMuZGF0YUZpbHRlciggcmVzcG9uc2UsIHMuZGF0YVR5cGUgKTtcblx0XHR9XG5cblx0XHRwcmV2ID0gY3VycmVudDtcblx0XHRjdXJyZW50ID0gZGF0YVR5cGVzLnNoaWZ0KCk7XG5cblx0XHRpZiAoIGN1cnJlbnQgKSB7XG5cblx0XHRcdC8vIFRoZXJlJ3Mgb25seSB3b3JrIHRvIGRvIGlmIGN1cnJlbnQgZGF0YVR5cGUgaXMgbm9uLWF1dG9cblx0XHRcdGlmICggY3VycmVudCA9PT0gXCIqXCIgKSB7XG5cblx0XHRcdFx0Y3VycmVudCA9IHByZXY7XG5cblx0XHRcdC8vIENvbnZlcnQgcmVzcG9uc2UgaWYgcHJldiBkYXRhVHlwZSBpcyBub24tYXV0byBhbmQgZGlmZmVycyBmcm9tIGN1cnJlbnRcblx0XHRcdH0gZWxzZSBpZiAoIHByZXYgIT09IFwiKlwiICYmIHByZXYgIT09IGN1cnJlbnQgKSB7XG5cblx0XHRcdFx0Ly8gU2VlayBhIGRpcmVjdCBjb252ZXJ0ZXJcblx0XHRcdFx0Y29udiA9IGNvbnZlcnRlcnNbIHByZXYgKyBcIiBcIiArIGN1cnJlbnQgXSB8fCBjb252ZXJ0ZXJzWyBcIiogXCIgKyBjdXJyZW50IF07XG5cblx0XHRcdFx0Ly8gSWYgbm9uZSBmb3VuZCwgc2VlayBhIHBhaXJcblx0XHRcdFx0aWYgKCAhY29udiApIHtcblx0XHRcdFx0XHRmb3IgKCBjb252MiBpbiBjb252ZXJ0ZXJzICkge1xuXG5cdFx0XHRcdFx0XHQvLyBJZiBjb252MiBvdXRwdXRzIGN1cnJlbnRcblx0XHRcdFx0XHRcdHRtcCA9IGNvbnYyLnNwbGl0KCBcIiBcIiApO1xuXHRcdFx0XHRcdFx0aWYgKCB0bXBbIDEgXSA9PT0gY3VycmVudCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBJZiBwcmV2IGNhbiBiZSBjb252ZXJ0ZWQgdG8gYWNjZXB0ZWQgaW5wdXRcblx0XHRcdFx0XHRcdFx0Y29udiA9IGNvbnZlcnRlcnNbIHByZXYgKyBcIiBcIiArIHRtcFsgMCBdIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRjb252ZXJ0ZXJzWyBcIiogXCIgKyB0bXBbIDAgXSBdO1xuXHRcdFx0XHRcdFx0XHRpZiAoIGNvbnYgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBDb25kZW5zZSBlcXVpdmFsZW5jZSBjb252ZXJ0ZXJzXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBjb252ID09PSB0cnVlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29udiA9IGNvbnZlcnRlcnNbIGNvbnYyIF07XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBPdGhlcndpc2UsIGluc2VydCB0aGUgaW50ZXJtZWRpYXRlIGRhdGFUeXBlXG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggY29udmVydGVyc1sgY29udjIgXSAhPT0gdHJ1ZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGN1cnJlbnQgPSB0bXBbIDAgXTtcblx0XHRcdFx0XHRcdFx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCB0bXBbIDEgXSApO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEFwcGx5IGNvbnZlcnRlciAoaWYgbm90IGFuIGVxdWl2YWxlbmNlKVxuXHRcdFx0XHRpZiAoIGNvbnYgIT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHQvLyBVbmxlc3MgZXJyb3JzIGFyZSBhbGxvd2VkIHRvIGJ1YmJsZSwgY2F0Y2ggYW5kIHJldHVybiB0aGVtXG5cdFx0XHRcdFx0aWYgKCBjb252ICYmIHMudGhyb3dzICkge1xuXHRcdFx0XHRcdFx0cmVzcG9uc2UgPSBjb252KCByZXNwb25zZSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRyZXNwb25zZSA9IGNvbnYoIHJlc3BvbnNlICk7XG5cdFx0XHRcdFx0XHR9IGNhdGNoICggZSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdFx0XHRzdGF0ZTogXCJwYXJzZXJlcnJvclwiLFxuXHRcdFx0XHRcdFx0XHRcdGVycm9yOiBjb252ID8gZSA6IFwiTm8gY29udmVyc2lvbiBmcm9tIFwiICsgcHJldiArIFwiIHRvIFwiICsgY3VycmVudFxuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB7IHN0YXRlOiBcInN1Y2Nlc3NcIiwgZGF0YTogcmVzcG9uc2UgfTtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIENvdW50ZXIgZm9yIGhvbGRpbmcgdGhlIG51bWJlciBvZiBhY3RpdmUgcXVlcmllc1xuXHRhY3RpdmU6IDAsXG5cblx0Ly8gTGFzdC1Nb2RpZmllZCBoZWFkZXIgY2FjaGUgZm9yIG5leHQgcmVxdWVzdFxuXHRsYXN0TW9kaWZpZWQ6IHt9LFxuXHRldGFnOiB7fSxcblxuXHRhamF4U2V0dGluZ3M6IHtcblx0XHR1cmw6IGxvY2F0aW9uLmhyZWYsXG5cdFx0dHlwZTogXCJHRVRcIixcblx0XHRpc0xvY2FsOiBybG9jYWxQcm90b2NvbC50ZXN0KCBsb2NhdGlvbi5wcm90b2NvbCApLFxuXHRcdGdsb2JhbDogdHJ1ZSxcblx0XHRwcm9jZXNzRGF0YTogdHJ1ZSxcblx0XHRhc3luYzogdHJ1ZSxcblx0XHRjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7IGNoYXJzZXQ9VVRGLThcIixcblxuXHRcdC8qXG5cdFx0dGltZW91dDogMCxcblx0XHRkYXRhOiBudWxsLFxuXHRcdGRhdGFUeXBlOiBudWxsLFxuXHRcdHVzZXJuYW1lOiBudWxsLFxuXHRcdHBhc3N3b3JkOiBudWxsLFxuXHRcdGNhY2hlOiBudWxsLFxuXHRcdHRocm93czogZmFsc2UsXG5cdFx0dHJhZGl0aW9uYWw6IGZhbHNlLFxuXHRcdGhlYWRlcnM6IHt9LFxuXHRcdCovXG5cblx0XHRhY2NlcHRzOiB7XG5cdFx0XHRcIipcIjogYWxsVHlwZXMsXG5cdFx0XHR0ZXh0OiBcInRleHQvcGxhaW5cIixcblx0XHRcdGh0bWw6IFwidGV4dC9odG1sXCIsXG5cdFx0XHR4bWw6IFwiYXBwbGljYXRpb24veG1sLCB0ZXh0L3htbFwiLFxuXHRcdFx0anNvbjogXCJhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L2phdmFzY3JpcHRcIlxuXHRcdH0sXG5cblx0XHRjb250ZW50czoge1xuXHRcdFx0eG1sOiAvXFxieG1sXFxiLyxcblx0XHRcdGh0bWw6IC9cXGJodG1sLyxcblx0XHRcdGpzb246IC9cXGJqc29uXFxiL1xuXHRcdH0sXG5cblx0XHRyZXNwb25zZUZpZWxkczoge1xuXHRcdFx0eG1sOiBcInJlc3BvbnNlWE1MXCIsXG5cdFx0XHR0ZXh0OiBcInJlc3BvbnNlVGV4dFwiLFxuXHRcdFx0anNvbjogXCJyZXNwb25zZUpTT05cIlxuXHRcdH0sXG5cblx0XHQvLyBEYXRhIGNvbnZlcnRlcnNcblx0XHQvLyBLZXlzIHNlcGFyYXRlIHNvdXJjZSAob3IgY2F0Y2hhbGwgXCIqXCIpIGFuZCBkZXN0aW5hdGlvbiB0eXBlcyB3aXRoIGEgc2luZ2xlIHNwYWNlXG5cdFx0Y29udmVydGVyczoge1xuXG5cdFx0XHQvLyBDb252ZXJ0IGFueXRoaW5nIHRvIHRleHRcblx0XHRcdFwiKiB0ZXh0XCI6IFN0cmluZyxcblxuXHRcdFx0Ly8gVGV4dCB0byBodG1sICh0cnVlID0gbm8gdHJhbnNmb3JtYXRpb24pXG5cdFx0XHRcInRleHQgaHRtbFwiOiB0cnVlLFxuXG5cdFx0XHQvLyBFdmFsdWF0ZSB0ZXh0IGFzIGEganNvbiBleHByZXNzaW9uXG5cdFx0XHRcInRleHQganNvblwiOiBKU09OLnBhcnNlLFxuXG5cdFx0XHQvLyBQYXJzZSB0ZXh0IGFzIHhtbFxuXHRcdFx0XCJ0ZXh0IHhtbFwiOiBqUXVlcnkucGFyc2VYTUxcblx0XHR9LFxuXG5cdFx0Ly8gRm9yIG9wdGlvbnMgdGhhdCBzaG91bGRuJ3QgYmUgZGVlcCBleHRlbmRlZDpcblx0XHQvLyB5b3UgY2FuIGFkZCB5b3VyIG93biBjdXN0b20gb3B0aW9ucyBoZXJlIGlmXG5cdFx0Ly8gYW5kIHdoZW4geW91IGNyZWF0ZSBvbmUgdGhhdCBzaG91bGRuJ3QgYmVcblx0XHQvLyBkZWVwIGV4dGVuZGVkIChzZWUgYWpheEV4dGVuZClcblx0XHRmbGF0T3B0aW9uczoge1xuXHRcdFx0dXJsOiB0cnVlLFxuXHRcdFx0Y29udGV4dDogdHJ1ZVxuXHRcdH1cblx0fSxcblxuXHQvLyBDcmVhdGVzIGEgZnVsbCBmbGVkZ2VkIHNldHRpbmdzIG9iamVjdCBpbnRvIHRhcmdldFxuXHQvLyB3aXRoIGJvdGggYWpheFNldHRpbmdzIGFuZCBzZXR0aW5ncyBmaWVsZHMuXG5cdC8vIElmIHRhcmdldCBpcyBvbWl0dGVkLCB3cml0ZXMgaW50byBhamF4U2V0dGluZ3MuXG5cdGFqYXhTZXR1cDogZnVuY3Rpb24oIHRhcmdldCwgc2V0dGluZ3MgKSB7XG5cdFx0cmV0dXJuIHNldHRpbmdzID9cblxuXHRcdFx0Ly8gQnVpbGRpbmcgYSBzZXR0aW5ncyBvYmplY3Rcblx0XHRcdGFqYXhFeHRlbmQoIGFqYXhFeHRlbmQoIHRhcmdldCwgalF1ZXJ5LmFqYXhTZXR0aW5ncyApLCBzZXR0aW5ncyApIDpcblxuXHRcdFx0Ly8gRXh0ZW5kaW5nIGFqYXhTZXR0aW5nc1xuXHRcdFx0YWpheEV4dGVuZCggalF1ZXJ5LmFqYXhTZXR0aW5ncywgdGFyZ2V0ICk7XG5cdH0sXG5cblx0YWpheFByZWZpbHRlcjogYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBwcmVmaWx0ZXJzICksXG5cdGFqYXhUcmFuc3BvcnQ6IGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggdHJhbnNwb3J0cyApLFxuXG5cdC8vIE1haW4gbWV0aG9kXG5cdGFqYXg6IGZ1bmN0aW9uKCB1cmwsIG9wdGlvbnMgKSB7XG5cblx0XHQvLyBJZiB1cmwgaXMgYW4gb2JqZWN0LCBzaW11bGF0ZSBwcmUtMS41IHNpZ25hdHVyZVxuXHRcdGlmICggdHlwZW9mIHVybCA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdG9wdGlvbnMgPSB1cmw7XG5cdFx0XHR1cmwgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gRm9yY2Ugb3B0aW9ucyB0byBiZSBhbiBvYmplY3Rcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRcdHZhciB0cmFuc3BvcnQsXG5cblx0XHRcdC8vIFVSTCB3aXRob3V0IGFudGktY2FjaGUgcGFyYW1cblx0XHRcdGNhY2hlVVJMLFxuXG5cdFx0XHQvLyBSZXNwb25zZSBoZWFkZXJzXG5cdFx0XHRyZXNwb25zZUhlYWRlcnNTdHJpbmcsXG5cdFx0XHRyZXNwb25zZUhlYWRlcnMsXG5cblx0XHRcdC8vIHRpbWVvdXQgaGFuZGxlXG5cdFx0XHR0aW1lb3V0VGltZXIsXG5cblx0XHRcdC8vIFVybCBjbGVhbnVwIHZhclxuXHRcdFx0dXJsQW5jaG9yLFxuXG5cdFx0XHQvLyBSZXF1ZXN0IHN0YXRlIChiZWNvbWVzIGZhbHNlIHVwb24gc2VuZCBhbmQgdHJ1ZSB1cG9uIGNvbXBsZXRpb24pXG5cdFx0XHRjb21wbGV0ZWQsXG5cblx0XHRcdC8vIFRvIGtub3cgaWYgZ2xvYmFsIGV2ZW50cyBhcmUgdG8gYmUgZGlzcGF0Y2hlZFxuXHRcdFx0ZmlyZUdsb2JhbHMsXG5cblx0XHRcdC8vIExvb3AgdmFyaWFibGVcblx0XHRcdGksXG5cblx0XHRcdC8vIHVuY2FjaGVkIHBhcnQgb2YgdGhlIHVybFxuXHRcdFx0dW5jYWNoZWQsXG5cblx0XHRcdC8vIENyZWF0ZSB0aGUgZmluYWwgb3B0aW9ucyBvYmplY3Rcblx0XHRcdHMgPSBqUXVlcnkuYWpheFNldHVwKCB7fSwgb3B0aW9ucyApLFxuXG5cdFx0XHQvLyBDYWxsYmFja3MgY29udGV4dFxuXHRcdFx0Y2FsbGJhY2tDb250ZXh0ID0gcy5jb250ZXh0IHx8IHMsXG5cblx0XHRcdC8vIENvbnRleHQgZm9yIGdsb2JhbCBldmVudHMgaXMgY2FsbGJhY2tDb250ZXh0IGlmIGl0IGlzIGEgRE9NIG5vZGUgb3IgalF1ZXJ5IGNvbGxlY3Rpb25cblx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dCA9IHMuY29udGV4dCAmJlxuXHRcdFx0XHQoIGNhbGxiYWNrQ29udGV4dC5ub2RlVHlwZSB8fCBjYWxsYmFja0NvbnRleHQuanF1ZXJ5ICkgP1xuXHRcdFx0XHRqUXVlcnkoIGNhbGxiYWNrQ29udGV4dCApIDpcblx0XHRcdFx0alF1ZXJ5LmV2ZW50LFxuXG5cdFx0XHQvLyBEZWZlcnJlZHNcblx0XHRcdGRlZmVycmVkID0galF1ZXJ5LkRlZmVycmVkKCksXG5cdFx0XHRjb21wbGV0ZURlZmVycmVkID0galF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksXG5cblx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRzdGF0dXNDb2RlID0gcy5zdGF0dXNDb2RlIHx8IHt9LFxuXG5cdFx0XHQvLyBIZWFkZXJzICh0aGV5IGFyZSBzZW50IGFsbCBhdCBvbmNlKVxuXHRcdFx0cmVxdWVzdEhlYWRlcnMgPSB7fSxcblx0XHRcdHJlcXVlc3RIZWFkZXJzTmFtZXMgPSB7fSxcblxuXHRcdFx0Ly8gRGVmYXVsdCBhYm9ydCBtZXNzYWdlXG5cdFx0XHRzdHJBYm9ydCA9IFwiY2FuY2VsZWRcIixcblxuXHRcdFx0Ly8gRmFrZSB4aHJcblx0XHRcdGpxWEhSID0ge1xuXHRcdFx0XHRyZWFkeVN0YXRlOiAwLFxuXG5cdFx0XHRcdC8vIEJ1aWxkcyBoZWFkZXJzIGhhc2h0YWJsZSBpZiBuZWVkZWRcblx0XHRcdFx0Z2V0UmVzcG9uc2VIZWFkZXI6IGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0XHRcdFx0dmFyIG1hdGNoO1xuXHRcdFx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRcdFx0aWYgKCAhcmVzcG9uc2VIZWFkZXJzICkge1xuXHRcdFx0XHRcdFx0XHRyZXNwb25zZUhlYWRlcnMgPSB7fTtcblx0XHRcdFx0XHRcdFx0d2hpbGUgKCAoIG1hdGNoID0gcmhlYWRlcnMuZXhlYyggcmVzcG9uc2VIZWFkZXJzU3RyaW5nICkgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZUhlYWRlcnNbIG1hdGNoWyAxIF0udG9Mb3dlckNhc2UoKSArIFwiIFwiIF0gPVxuXHRcdFx0XHRcdFx0XHRcdFx0KCByZXNwb25zZUhlYWRlcnNbIG1hdGNoWyAxIF0udG9Mb3dlckNhc2UoKSArIFwiIFwiIF0gfHwgW10gKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuY29uY2F0KCBtYXRjaFsgMiBdICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdG1hdGNoID0gcmVzcG9uc2VIZWFkZXJzWyBrZXkudG9Mb3dlckNhc2UoKSArIFwiIFwiIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBtYXRjaCA9PSBudWxsID8gbnVsbCA6IG1hdGNoLmpvaW4oIFwiLCBcIiApO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIFJhdyBzdHJpbmdcblx0XHRcdFx0Z2V0QWxsUmVzcG9uc2VIZWFkZXJzOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gY29tcGxldGVkID8gcmVzcG9uc2VIZWFkZXJzU3RyaW5nIDogbnVsbDtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBDYWNoZXMgdGhlIGhlYWRlclxuXHRcdFx0XHRzZXRSZXF1ZXN0SGVhZGVyOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdG5hbWUgPSByZXF1ZXN0SGVhZGVyc05hbWVzWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSA9XG5cdFx0XHRcdFx0XHRcdHJlcXVlc3RIZWFkZXJzTmFtZXNbIG5hbWUudG9Mb3dlckNhc2UoKSBdIHx8IG5hbWU7XG5cdFx0XHRcdFx0XHRyZXF1ZXN0SGVhZGVyc1sgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIE92ZXJyaWRlcyByZXNwb25zZSBjb250ZW50LXR5cGUgaGVhZGVyXG5cdFx0XHRcdG92ZXJyaWRlTWltZVR5cGU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdFx0XHRcdGlmICggY29tcGxldGVkID09IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRzLm1pbWVUeXBlID0gdHlwZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdFx0c3RhdHVzQ29kZTogZnVuY3Rpb24oIG1hcCApIHtcblx0XHRcdFx0XHR2YXIgY29kZTtcblx0XHRcdFx0XHRpZiAoIG1hcCApIHtcblx0XHRcdFx0XHRcdGlmICggY29tcGxldGVkICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEV4ZWN1dGUgdGhlIGFwcHJvcHJpYXRlIGNhbGxiYWNrc1xuXHRcdFx0XHRcdFx0XHRqcVhIUi5hbHdheXMoIG1hcFsganFYSFIuc3RhdHVzIF0gKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gTGF6eS1hZGQgdGhlIG5ldyBjYWxsYmFja3MgaW4gYSB3YXkgdGhhdCBwcmVzZXJ2ZXMgb2xkIG9uZXNcblx0XHRcdFx0XHRcdFx0Zm9yICggY29kZSBpbiBtYXAgKSB7XG5cdFx0XHRcdFx0XHRcdFx0c3RhdHVzQ29kZVsgY29kZSBdID0gWyBzdGF0dXNDb2RlWyBjb2RlIF0sIG1hcFsgY29kZSBdIF07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gQ2FuY2VsIHRoZSByZXF1ZXN0XG5cdFx0XHRcdGFib3J0OiBmdW5jdGlvbiggc3RhdHVzVGV4dCApIHtcblx0XHRcdFx0XHR2YXIgZmluYWxUZXh0ID0gc3RhdHVzVGV4dCB8fCBzdHJBYm9ydDtcblx0XHRcdFx0XHRpZiAoIHRyYW5zcG9ydCApIHtcblx0XHRcdFx0XHRcdHRyYW5zcG9ydC5hYm9ydCggZmluYWxUZXh0ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRvbmUoIDAsIGZpbmFsVGV4dCApO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0Ly8gQXR0YWNoIGRlZmVycmVkc1xuXHRcdGRlZmVycmVkLnByb21pc2UoIGpxWEhSICk7XG5cblx0XHQvLyBBZGQgcHJvdG9jb2wgaWYgbm90IHByb3ZpZGVkIChwcmVmaWx0ZXJzIG1pZ2h0IGV4cGVjdCBpdClcblx0XHQvLyBIYW5kbGUgZmFsc3kgdXJsIGluIHRoZSBzZXR0aW5ncyBvYmplY3QgKHRyYWMtMTAwOTM6IGNvbnNpc3RlbmN5IHdpdGggb2xkIHNpZ25hdHVyZSlcblx0XHQvLyBXZSBhbHNvIHVzZSB0aGUgdXJsIHBhcmFtZXRlciBpZiBhdmFpbGFibGVcblx0XHRzLnVybCA9ICggKCB1cmwgfHwgcy51cmwgfHwgbG9jYXRpb24uaHJlZiApICsgXCJcIiApXG5cdFx0XHQucmVwbGFjZSggcnByb3RvY29sLCBsb2NhdGlvbi5wcm90b2NvbCArIFwiLy9cIiApO1xuXG5cdFx0Ly8gQWxpYXMgbWV0aG9kIG9wdGlvbiB0byB0eXBlIGFzIHBlciB0aWNrZXQgdHJhYy0xMjAwNFxuXHRcdHMudHlwZSA9IG9wdGlvbnMubWV0aG9kIHx8IG9wdGlvbnMudHlwZSB8fCBzLm1ldGhvZCB8fCBzLnR5cGU7XG5cblx0XHQvLyBFeHRyYWN0IGRhdGFUeXBlcyBsaXN0XG5cdFx0cy5kYXRhVHlwZXMgPSAoIHMuZGF0YVR5cGUgfHwgXCIqXCIgKS50b0xvd2VyQ2FzZSgpLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgWyBcIlwiIF07XG5cblx0XHQvLyBBIGNyb3NzLWRvbWFpbiByZXF1ZXN0IGlzIGluIG9yZGVyIHdoZW4gdGhlIG9yaWdpbiBkb2Vzbid0IG1hdGNoIHRoZSBjdXJyZW50IG9yaWdpbi5cblx0XHRpZiAoIHMuY3Jvc3NEb21haW4gPT0gbnVsbCApIHtcblx0XHRcdHVybEFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiYVwiICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OCAtIDExLCBFZGdlIDEyIC0gMTVcblx0XHRcdC8vIElFIHRocm93cyBleGNlcHRpb24gb24gYWNjZXNzaW5nIHRoZSBocmVmIHByb3BlcnR5IGlmIHVybCBpcyBtYWxmb3JtZWQsXG5cdFx0XHQvLyBlLmcuIGh0dHA6Ly9leGFtcGxlLmNvbTo4MHgvXG5cdFx0XHR0cnkge1xuXHRcdFx0XHR1cmxBbmNob3IuaHJlZiA9IHMudXJsO1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OCAtIDExIG9ubHlcblx0XHRcdFx0Ly8gQW5jaG9yJ3MgaG9zdCBwcm9wZXJ0eSBpc24ndCBjb3JyZWN0bHkgc2V0IHdoZW4gcy51cmwgaXMgcmVsYXRpdmVcblx0XHRcdFx0dXJsQW5jaG9yLmhyZWYgPSB1cmxBbmNob3IuaHJlZjtcblx0XHRcdFx0cy5jcm9zc0RvbWFpbiA9IG9yaWdpbkFuY2hvci5wcm90b2NvbCArIFwiLy9cIiArIG9yaWdpbkFuY2hvci5ob3N0ICE9PVxuXHRcdFx0XHRcdHVybEFuY2hvci5wcm90b2NvbCArIFwiLy9cIiArIHVybEFuY2hvci5ob3N0O1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0Ly8gSWYgdGhlcmUgaXMgYW4gZXJyb3IgcGFyc2luZyB0aGUgVVJMLCBhc3N1bWUgaXQgaXMgY3Jvc3NEb21haW4sXG5cdFx0XHRcdC8vIGl0IGNhbiBiZSByZWplY3RlZCBieSB0aGUgdHJhbnNwb3J0IGlmIGl0IGlzIGludmFsaWRcblx0XHRcdFx0cy5jcm9zc0RvbWFpbiA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ29udmVydCBkYXRhIGlmIG5vdCBhbHJlYWR5IGEgc3RyaW5nXG5cdFx0aWYgKCBzLmRhdGEgJiYgcy5wcm9jZXNzRGF0YSAmJiB0eXBlb2Ygcy5kYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cy5kYXRhID0galF1ZXJ5LnBhcmFtKCBzLmRhdGEsIHMudHJhZGl0aW9uYWwgKTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSBwcmVmaWx0ZXJzXG5cdFx0aW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHByZWZpbHRlcnMsIHMsIG9wdGlvbnMsIGpxWEhSICk7XG5cblx0XHQvLyBJZiByZXF1ZXN0IHdhcyBhYm9ydGVkIGluc2lkZSBhIHByZWZpbHRlciwgc3RvcCB0aGVyZVxuXHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0cmV0dXJuIGpxWEhSO1xuXHRcdH1cblxuXHRcdC8vIFdlIGNhbiBmaXJlIGdsb2JhbCBldmVudHMgYXMgb2Ygbm93IGlmIGFza2VkIHRvXG5cdFx0Ly8gRG9uJ3QgZmlyZSBldmVudHMgaWYgalF1ZXJ5LmV2ZW50IGlzIHVuZGVmaW5lZCBpbiBhbiBBTUQtdXNhZ2Ugc2NlbmFyaW8gKHRyYWMtMTUxMTgpXG5cdFx0ZmlyZUdsb2JhbHMgPSBqUXVlcnkuZXZlbnQgJiYgcy5nbG9iYWw7XG5cblx0XHQvLyBXYXRjaCBmb3IgYSBuZXcgc2V0IG9mIHJlcXVlc3RzXG5cdFx0aWYgKCBmaXJlR2xvYmFscyAmJiBqUXVlcnkuYWN0aXZlKysgPT09IDAgKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggXCJhamF4U3RhcnRcIiApO1xuXHRcdH1cblxuXHRcdC8vIFVwcGVyY2FzZSB0aGUgdHlwZVxuXHRcdHMudHlwZSA9IHMudHlwZS50b1VwcGVyQ2FzZSgpO1xuXG5cdFx0Ly8gRGV0ZXJtaW5lIGlmIHJlcXVlc3QgaGFzIGNvbnRlbnRcblx0XHRzLmhhc0NvbnRlbnQgPSAhcm5vQ29udGVudC50ZXN0KCBzLnR5cGUgKTtcblxuXHRcdC8vIFNhdmUgdGhlIFVSTCBpbiBjYXNlIHdlJ3JlIHRveWluZyB3aXRoIHRoZSBJZi1Nb2RpZmllZC1TaW5jZVxuXHRcdC8vIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciBsYXRlciBvblxuXHRcdC8vIFJlbW92ZSBoYXNoIHRvIHNpbXBsaWZ5IHVybCBtYW5pcHVsYXRpb25cblx0XHRjYWNoZVVSTCA9IHMudXJsLnJlcGxhY2UoIHJoYXNoLCBcIlwiICk7XG5cblx0XHQvLyBNb3JlIG9wdGlvbnMgaGFuZGxpbmcgZm9yIHJlcXVlc3RzIHdpdGggbm8gY29udGVudFxuXHRcdGlmICggIXMuaGFzQ29udGVudCApIHtcblxuXHRcdFx0Ly8gUmVtZW1iZXIgdGhlIGhhc2ggc28gd2UgY2FuIHB1dCBpdCBiYWNrXG5cdFx0XHR1bmNhY2hlZCA9IHMudXJsLnNsaWNlKCBjYWNoZVVSTC5sZW5ndGggKTtcblxuXHRcdFx0Ly8gSWYgZGF0YSBpcyBhdmFpbGFibGUgYW5kIHNob3VsZCBiZSBwcm9jZXNzZWQsIGFwcGVuZCBkYXRhIHRvIHVybFxuXHRcdFx0aWYgKCBzLmRhdGEgJiYgKCBzLnByb2Nlc3NEYXRhIHx8IHR5cGVvZiBzLmRhdGEgPT09IFwic3RyaW5nXCIgKSApIHtcblx0XHRcdFx0Y2FjaGVVUkwgKz0gKCBycXVlcnkudGVzdCggY2FjaGVVUkwgKSA/IFwiJlwiIDogXCI/XCIgKSArIHMuZGF0YTtcblxuXHRcdFx0XHQvLyB0cmFjLTk2ODI6IHJlbW92ZSBkYXRhIHNvIHRoYXQgaXQncyBub3QgdXNlZCBpbiBhbiBldmVudHVhbCByZXRyeVxuXHRcdFx0XHRkZWxldGUgcy5kYXRhO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgb3IgdXBkYXRlIGFudGktY2FjaGUgcGFyYW0gaWYgbmVlZGVkXG5cdFx0XHRpZiAoIHMuY2FjaGUgPT09IGZhbHNlICkge1xuXHRcdFx0XHRjYWNoZVVSTCA9IGNhY2hlVVJMLnJlcGxhY2UoIHJhbnRpQ2FjaGUsIFwiJDFcIiApO1xuXHRcdFx0XHR1bmNhY2hlZCA9ICggcnF1ZXJ5LnRlc3QoIGNhY2hlVVJMICkgPyBcIiZcIiA6IFwiP1wiICkgKyBcIl89XCIgKyAoIG5vbmNlLmd1aWQrKyApICtcblx0XHRcdFx0XHR1bmNhY2hlZDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUHV0IGhhc2ggYW5kIGFudGktY2FjaGUgb24gdGhlIFVSTCB0aGF0IHdpbGwgYmUgcmVxdWVzdGVkIChnaC0xNzMyKVxuXHRcdFx0cy51cmwgPSBjYWNoZVVSTCArIHVuY2FjaGVkO1xuXG5cdFx0Ly8gQ2hhbmdlICclMjAnIHRvICcrJyBpZiB0aGlzIGlzIGVuY29kZWQgZm9ybSBib2R5IGNvbnRlbnQgKGdoLTI2NTgpXG5cdFx0fSBlbHNlIGlmICggcy5kYXRhICYmIHMucHJvY2Vzc0RhdGEgJiZcblx0XHRcdCggcy5jb250ZW50VHlwZSB8fCBcIlwiICkuaW5kZXhPZiggXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiApID09PSAwICkge1xuXHRcdFx0cy5kYXRhID0gcy5kYXRhLnJlcGxhY2UoIHIyMCwgXCIrXCIgKTtcblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIElmLU1vZGlmaWVkLVNpbmNlIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciwgaWYgaW4gaWZNb2RpZmllZCBtb2RlLlxuXHRcdGlmICggcy5pZk1vZGlmaWVkICkge1xuXHRcdFx0aWYgKCBqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdICkge1xuXHRcdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIklmLU1vZGlmaWVkLVNpbmNlXCIsIGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gKTtcblx0XHRcdH1cblx0XHRcdGlmICggalF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gKSB7XG5cdFx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiSWYtTm9uZS1NYXRjaFwiLCBqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgY29ycmVjdCBoZWFkZXIsIGlmIGRhdGEgaXMgYmVpbmcgc2VudFxuXHRcdGlmICggcy5kYXRhICYmIHMuaGFzQ29udGVudCAmJiBzLmNvbnRlbnRUeXBlICE9PSBmYWxzZSB8fCBvcHRpb25zLmNvbnRlbnRUeXBlICkge1xuXHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJDb250ZW50LVR5cGVcIiwgcy5jb250ZW50VHlwZSApO1xuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgQWNjZXB0cyBoZWFkZXIgZm9yIHRoZSBzZXJ2ZXIsIGRlcGVuZGluZyBvbiB0aGUgZGF0YVR5cGVcblx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKFxuXHRcdFx0XCJBY2NlcHRcIixcblx0XHRcdHMuZGF0YVR5cGVzWyAwIF0gJiYgcy5hY2NlcHRzWyBzLmRhdGFUeXBlc1sgMCBdIF0gP1xuXHRcdFx0XHRzLmFjY2VwdHNbIHMuZGF0YVR5cGVzWyAwIF0gXSArXG5cdFx0XHRcdFx0KCBzLmRhdGFUeXBlc1sgMCBdICE9PSBcIipcIiA/IFwiLCBcIiArIGFsbFR5cGVzICsgXCI7IHE9MC4wMVwiIDogXCJcIiApIDpcblx0XHRcdFx0cy5hY2NlcHRzWyBcIipcIiBdXG5cdFx0KTtcblxuXHRcdC8vIENoZWNrIGZvciBoZWFkZXJzIG9wdGlvblxuXHRcdGZvciAoIGkgaW4gcy5oZWFkZXJzICkge1xuXHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggaSwgcy5oZWFkZXJzWyBpIF0gKTtcblx0XHR9XG5cblx0XHQvLyBBbGxvdyBjdXN0b20gaGVhZGVycy9taW1ldHlwZXMgYW5kIGVhcmx5IGFib3J0XG5cdFx0aWYgKCBzLmJlZm9yZVNlbmQgJiZcblx0XHRcdCggcy5iZWZvcmVTZW5kLmNhbGwoIGNhbGxiYWNrQ29udGV4dCwganFYSFIsIHMgKSA9PT0gZmFsc2UgfHwgY29tcGxldGVkICkgKSB7XG5cblx0XHRcdC8vIEFib3J0IGlmIG5vdCBkb25lIGFscmVhZHkgYW5kIHJldHVyblxuXHRcdFx0cmV0dXJuIGpxWEhSLmFib3J0KCk7XG5cdFx0fVxuXG5cdFx0Ly8gQWJvcnRpbmcgaXMgbm8gbG9uZ2VyIGEgY2FuY2VsbGF0aW9uXG5cdFx0c3RyQWJvcnQgPSBcImFib3J0XCI7XG5cblx0XHQvLyBJbnN0YWxsIGNhbGxiYWNrcyBvbiBkZWZlcnJlZHNcblx0XHRjb21wbGV0ZURlZmVycmVkLmFkZCggcy5jb21wbGV0ZSApO1xuXHRcdGpxWEhSLmRvbmUoIHMuc3VjY2VzcyApO1xuXHRcdGpxWEhSLmZhaWwoIHMuZXJyb3IgKTtcblxuXHRcdC8vIEdldCB0cmFuc3BvcnRcblx0XHR0cmFuc3BvcnQgPSBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggdHJhbnNwb3J0cywgcywgb3B0aW9ucywganFYSFIgKTtcblxuXHRcdC8vIElmIG5vIHRyYW5zcG9ydCwgd2UgYXV0by1hYm9ydFxuXHRcdGlmICggIXRyYW5zcG9ydCApIHtcblx0XHRcdGRvbmUoIC0xLCBcIk5vIFRyYW5zcG9ydFwiICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGpxWEhSLnJlYWR5U3RhdGUgPSAxO1xuXG5cdFx0XHQvLyBTZW5kIGdsb2JhbCBldmVudFxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIFwiYWpheFNlbmRcIiwgWyBqcVhIUiwgcyBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHJlcXVlc3Qgd2FzIGFib3J0ZWQgaW5zaWRlIGFqYXhTZW5kLCBzdG9wIHRoZXJlXG5cdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0cmV0dXJuIGpxWEhSO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUaW1lb3V0XG5cdFx0XHRpZiAoIHMuYXN5bmMgJiYgcy50aW1lb3V0ID4gMCApIHtcblx0XHRcdFx0dGltZW91dFRpbWVyID0gd2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGpxWEhSLmFib3J0KCBcInRpbWVvdXRcIiApO1xuXHRcdFx0XHR9LCBzLnRpbWVvdXQgKTtcblx0XHRcdH1cblxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Y29tcGxldGVkID0gZmFsc2U7XG5cdFx0XHRcdHRyYW5zcG9ydC5zZW5kKCByZXF1ZXN0SGVhZGVycywgZG9uZSApO1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0Ly8gUmV0aHJvdyBwb3N0LWNvbXBsZXRpb24gZXhjZXB0aW9uc1xuXHRcdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0XHR0aHJvdyBlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUHJvcGFnYXRlIG90aGVycyBhcyByZXN1bHRzXG5cdFx0XHRcdGRvbmUoIC0xLCBlICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbGJhY2sgZm9yIHdoZW4gZXZlcnl0aGluZyBpcyBkb25lXG5cdFx0ZnVuY3Rpb24gZG9uZSggc3RhdHVzLCBuYXRpdmVTdGF0dXNUZXh0LCByZXNwb25zZXMsIGhlYWRlcnMgKSB7XG5cdFx0XHR2YXIgaXNTdWNjZXNzLCBzdWNjZXNzLCBlcnJvciwgcmVzcG9uc2UsIG1vZGlmaWVkLFxuXHRcdFx0XHRzdGF0dXNUZXh0ID0gbmF0aXZlU3RhdHVzVGV4dDtcblxuXHRcdFx0Ly8gSWdub3JlIHJlcGVhdCBpbnZvY2F0aW9uc1xuXHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Y29tcGxldGVkID0gdHJ1ZTtcblxuXHRcdFx0Ly8gQ2xlYXIgdGltZW91dCBpZiBpdCBleGlzdHNcblx0XHRcdGlmICggdGltZW91dFRpbWVyICkge1xuXHRcdFx0XHR3aW5kb3cuY2xlYXJUaW1lb3V0KCB0aW1lb3V0VGltZXIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRGVyZWZlcmVuY2UgdHJhbnNwb3J0IGZvciBlYXJseSBnYXJiYWdlIGNvbGxlY3Rpb25cblx0XHRcdC8vIChubyBtYXR0ZXIgaG93IGxvbmcgdGhlIGpxWEhSIG9iamVjdCB3aWxsIGJlIHVzZWQpXG5cdFx0XHR0cmFuc3BvcnQgPSB1bmRlZmluZWQ7XG5cblx0XHRcdC8vIENhY2hlIHJlc3BvbnNlIGhlYWRlcnNcblx0XHRcdHJlc3BvbnNlSGVhZGVyc1N0cmluZyA9IGhlYWRlcnMgfHwgXCJcIjtcblxuXHRcdFx0Ly8gU2V0IHJlYWR5U3RhdGVcblx0XHRcdGpxWEhSLnJlYWR5U3RhdGUgPSBzdGF0dXMgPiAwID8gNCA6IDA7XG5cblx0XHRcdC8vIERldGVybWluZSBpZiBzdWNjZXNzZnVsXG5cdFx0XHRpc1N1Y2Nlc3MgPSBzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMCB8fCBzdGF0dXMgPT09IDMwNDtcblxuXHRcdFx0Ly8gR2V0IHJlc3BvbnNlIGRhdGFcblx0XHRcdGlmICggcmVzcG9uc2VzICkge1xuXHRcdFx0XHRyZXNwb25zZSA9IGFqYXhIYW5kbGVSZXNwb25zZXMoIHMsIGpxWEhSLCByZXNwb25zZXMgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVXNlIGEgbm9vcCBjb252ZXJ0ZXIgZm9yIG1pc3Npbmcgc2NyaXB0IGJ1dCBub3QgaWYganNvbnBcblx0XHRcdGlmICggIWlzU3VjY2VzcyAmJlxuXHRcdFx0XHRqUXVlcnkuaW5BcnJheSggXCJzY3JpcHRcIiwgcy5kYXRhVHlwZXMgKSA+IC0xICYmXG5cdFx0XHRcdGpRdWVyeS5pbkFycmF5KCBcImpzb25cIiwgcy5kYXRhVHlwZXMgKSA8IDAgKSB7XG5cdFx0XHRcdHMuY29udmVydGVyc1sgXCJ0ZXh0IHNjcmlwdFwiIF0gPSBmdW5jdGlvbigpIHt9O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb252ZXJ0IG5vIG1hdHRlciB3aGF0ICh0aGF0IHdheSByZXNwb25zZVhYWCBmaWVsZHMgYXJlIGFsd2F5cyBzZXQpXG5cdFx0XHRyZXNwb25zZSA9IGFqYXhDb252ZXJ0KCBzLCByZXNwb25zZSwganFYSFIsIGlzU3VjY2VzcyApO1xuXG5cdFx0XHQvLyBJZiBzdWNjZXNzZnVsLCBoYW5kbGUgdHlwZSBjaGFpbmluZ1xuXHRcdFx0aWYgKCBpc1N1Y2Nlc3MgKSB7XG5cblx0XHRcdFx0Ly8gU2V0IHRoZSBJZi1Nb2RpZmllZC1TaW5jZSBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIsIGlmIGluIGlmTW9kaWZpZWQgbW9kZS5cblx0XHRcdFx0aWYgKCBzLmlmTW9kaWZpZWQgKSB7XG5cdFx0XHRcdFx0bW9kaWZpZWQgPSBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJMYXN0LU1vZGlmaWVkXCIgKTtcblx0XHRcdFx0XHRpZiAoIG1vZGlmaWVkICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSA9IG1vZGlmaWVkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRtb2RpZmllZCA9IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcImV0YWdcIiApO1xuXHRcdFx0XHRcdGlmICggbW9kaWZpZWQgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSA9IG1vZGlmaWVkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGlmIG5vIGNvbnRlbnRcblx0XHRcdFx0aWYgKCBzdGF0dXMgPT09IDIwNCB8fCBzLnR5cGUgPT09IFwiSEVBRFwiICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcIm5vY29udGVudFwiO1xuXG5cdFx0XHRcdC8vIGlmIG5vdCBtb2RpZmllZFxuXHRcdFx0XHR9IGVsc2UgaWYgKCBzdGF0dXMgPT09IDMwNCApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJub3Rtb2RpZmllZFwiO1xuXG5cdFx0XHRcdC8vIElmIHdlIGhhdmUgZGF0YSwgbGV0J3MgY29udmVydCBpdFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSByZXNwb25zZS5zdGF0ZTtcblx0XHRcdFx0XHRzdWNjZXNzID0gcmVzcG9uc2UuZGF0YTtcblx0XHRcdFx0XHRlcnJvciA9IHJlc3BvbnNlLmVycm9yO1xuXHRcdFx0XHRcdGlzU3VjY2VzcyA9ICFlcnJvcjtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBFeHRyYWN0IGVycm9yIGZyb20gc3RhdHVzVGV4dCBhbmQgbm9ybWFsaXplIGZvciBub24tYWJvcnRzXG5cdFx0XHRcdGVycm9yID0gc3RhdHVzVGV4dDtcblx0XHRcdFx0aWYgKCBzdGF0dXMgfHwgIXN0YXR1c1RleHQgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwiZXJyb3JcIjtcblx0XHRcdFx0XHRpZiAoIHN0YXR1cyA8IDAgKSB7XG5cdFx0XHRcdFx0XHRzdGF0dXMgPSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZXQgZGF0YSBmb3IgdGhlIGZha2UgeGhyIG9iamVjdFxuXHRcdFx0anFYSFIuc3RhdHVzID0gc3RhdHVzO1xuXHRcdFx0anFYSFIuc3RhdHVzVGV4dCA9ICggbmF0aXZlU3RhdHVzVGV4dCB8fCBzdGF0dXNUZXh0ICkgKyBcIlwiO1xuXG5cdFx0XHQvLyBTdWNjZXNzL0Vycm9yXG5cdFx0XHRpZiAoIGlzU3VjY2VzcyApIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBzdWNjZXNzLCBzdGF0dXNUZXh0LCBqcVhIUiBdICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZWZlcnJlZC5yZWplY3RXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsganFYSFIsIHN0YXR1c1RleHQsIGVycm9yIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdGpxWEhSLnN0YXR1c0NvZGUoIHN0YXR1c0NvZGUgKTtcblx0XHRcdHN0YXR1c0NvZGUgPSB1bmRlZmluZWQ7XG5cblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBpc1N1Y2Nlc3MgPyBcImFqYXhTdWNjZXNzXCIgOiBcImFqYXhFcnJvclwiLFxuXHRcdFx0XHRcdFsganFYSFIsIHMsIGlzU3VjY2VzcyA/IHN1Y2Nlc3MgOiBlcnJvciBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbXBsZXRlXG5cdFx0XHRjb21wbGV0ZURlZmVycmVkLmZpcmVXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsganFYSFIsIHN0YXR1c1RleHQgXSApO1xuXG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggXCJhamF4Q29tcGxldGVcIiwgWyBqcVhIUiwgcyBdICk7XG5cblx0XHRcdFx0Ly8gSGFuZGxlIHRoZSBnbG9iYWwgQUpBWCBjb3VudGVyXG5cdFx0XHRcdGlmICggISggLS1qUXVlcnkuYWN0aXZlICkgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIFwiYWpheFN0b3BcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGpxWEhSO1xuXHR9LFxuXG5cdGdldEpTT046IGZ1bmN0aW9uKCB1cmwsIGRhdGEsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ2V0KCB1cmwsIGRhdGEsIGNhbGxiYWNrLCBcImpzb25cIiApO1xuXHR9LFxuXG5cdGdldFNjcmlwdDogZnVuY3Rpb24oIHVybCwgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5nZXQoIHVybCwgdW5kZWZpbmVkLCBjYWxsYmFjaywgXCJzY3JpcHRcIiApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCBbIFwiZ2V0XCIsIFwicG9zdFwiIF0sIGZ1bmN0aW9uKCBfaSwgbWV0aG9kICkge1xuXHRqUXVlcnlbIG1ldGhvZCBdID0gZnVuY3Rpb24oIHVybCwgZGF0YSwgY2FsbGJhY2ssIHR5cGUgKSB7XG5cblx0XHQvLyBTaGlmdCBhcmd1bWVudHMgaWYgZGF0YSBhcmd1bWVudCB3YXMgb21pdHRlZFxuXHRcdGlmICggaXNGdW5jdGlvbiggZGF0YSApICkge1xuXHRcdFx0dHlwZSA9IHR5cGUgfHwgY2FsbGJhY2s7XG5cdFx0XHRjYWxsYmFjayA9IGRhdGE7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIFRoZSB1cmwgY2FuIGJlIGFuIG9wdGlvbnMgb2JqZWN0ICh3aGljaCB0aGVuIG11c3QgaGF2ZSAudXJsKVxuXHRcdHJldHVybiBqUXVlcnkuYWpheCggalF1ZXJ5LmV4dGVuZCgge1xuXHRcdFx0dXJsOiB1cmwsXG5cdFx0XHR0eXBlOiBtZXRob2QsXG5cdFx0XHRkYXRhVHlwZTogdHlwZSxcblx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHRzdWNjZXNzOiBjYWxsYmFja1xuXHRcdH0sIGpRdWVyeS5pc1BsYWluT2JqZWN0KCB1cmwgKSAmJiB1cmwgKSApO1xuXHR9O1xufSApO1xuXG5qUXVlcnkuYWpheFByZWZpbHRlciggZnVuY3Rpb24oIHMgKSB7XG5cdHZhciBpO1xuXHRmb3IgKCBpIGluIHMuaGVhZGVycyApIHtcblx0XHRpZiAoIGkudG9Mb3dlckNhc2UoKSA9PT0gXCJjb250ZW50LXR5cGVcIiApIHtcblx0XHRcdHMuY29udGVudFR5cGUgPSBzLmhlYWRlcnNbIGkgXSB8fCBcIlwiO1xuXHRcdH1cblx0fVxufSApO1xuXG5cbmpRdWVyeS5fZXZhbFVybCA9IGZ1bmN0aW9uKCB1cmwsIG9wdGlvbnMsIGRvYyApIHtcblx0cmV0dXJuIGpRdWVyeS5hamF4KCB7XG5cdFx0dXJsOiB1cmwsXG5cblx0XHQvLyBNYWtlIHRoaXMgZXhwbGljaXQsIHNpbmNlIHVzZXIgY2FuIG92ZXJyaWRlIHRoaXMgdGhyb3VnaCBhamF4U2V0dXAgKHRyYWMtMTEyNjQpXG5cdFx0dHlwZTogXCJHRVRcIixcblx0XHRkYXRhVHlwZTogXCJzY3JpcHRcIixcblx0XHRjYWNoZTogdHJ1ZSxcblx0XHRhc3luYzogZmFsc2UsXG5cdFx0Z2xvYmFsOiBmYWxzZSxcblxuXHRcdC8vIE9ubHkgZXZhbHVhdGUgdGhlIHJlc3BvbnNlIGlmIGl0IGlzIHN1Y2Nlc3NmdWwgKGdoLTQxMjYpXG5cdFx0Ly8gZGF0YUZpbHRlciBpcyBub3QgaW52b2tlZCBmb3IgZmFpbHVyZSByZXNwb25zZXMsIHNvIHVzaW5nIGl0IGluc3RlYWRcblx0XHQvLyBvZiB0aGUgZGVmYXVsdCBjb252ZXJ0ZXIgaXMga2x1ZGd5IGJ1dCBpdCB3b3Jrcy5cblx0XHRjb252ZXJ0ZXJzOiB7XG5cdFx0XHRcInRleHQgc2NyaXB0XCI6IGZ1bmN0aW9uKCkge31cblx0XHR9LFxuXHRcdGRhdGFGaWx0ZXI6IGZ1bmN0aW9uKCByZXNwb25zZSApIHtcblx0XHRcdGpRdWVyeS5nbG9iYWxFdmFsKCByZXNwb25zZSwgb3B0aW9ucywgZG9jICk7XG5cdFx0fVxuXHR9ICk7XG59O1xuXG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0d3JhcEFsbDogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0dmFyIHdyYXA7XG5cblx0XHRpZiAoIHRoaXNbIDAgXSApIHtcblx0XHRcdGlmICggaXNGdW5jdGlvbiggaHRtbCApICkge1xuXHRcdFx0XHRodG1sID0gaHRtbC5jYWxsKCB0aGlzWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVGhlIGVsZW1lbnRzIHRvIHdyYXAgdGhlIHRhcmdldCBhcm91bmRcblx0XHRcdHdyYXAgPSBqUXVlcnkoIGh0bWwsIHRoaXNbIDAgXS5vd25lckRvY3VtZW50ICkuZXEoIDAgKS5jbG9uZSggdHJ1ZSApO1xuXG5cdFx0XHRpZiAoIHRoaXNbIDAgXS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR3cmFwLmluc2VydEJlZm9yZSggdGhpc1sgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHdyYXAubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGVsZW0gPSB0aGlzO1xuXG5cdFx0XHRcdHdoaWxlICggZWxlbS5maXJzdEVsZW1lbnRDaGlsZCApIHtcblx0XHRcdFx0XHRlbGVtID0gZWxlbS5maXJzdEVsZW1lbnRDaGlsZDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBlbGVtO1xuXHRcdFx0fSApLmFwcGVuZCggdGhpcyApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHdyYXBJbm5lcjogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBodG1sICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkud3JhcElubmVyKCBodG1sLmNhbGwoIHRoaXMsIGkgKSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHNlbGYgPSBqUXVlcnkoIHRoaXMgKSxcblx0XHRcdFx0Y29udGVudHMgPSBzZWxmLmNvbnRlbnRzKCk7XG5cblx0XHRcdGlmICggY29udGVudHMubGVuZ3RoICkge1xuXHRcdFx0XHRjb250ZW50cy53cmFwQWxsKCBodG1sICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHNlbGYuYXBwZW5kKCBodG1sICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdHdyYXA6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHZhciBodG1sSXNGdW5jdGlvbiA9IGlzRnVuY3Rpb24oIGh0bWwgKTtcblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0alF1ZXJ5KCB0aGlzICkud3JhcEFsbCggaHRtbElzRnVuY3Rpb24gPyBodG1sLmNhbGwoIHRoaXMsIGkgKSA6IGh0bWwgKTtcblx0XHR9ICk7XG5cdH0sXG5cblx0dW53cmFwOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dGhpcy5wYXJlbnQoIHNlbGVjdG9yICkubm90KCBcImJvZHlcIiApLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5KCB0aGlzICkucmVwbGFjZVdpdGgoIHRoaXMuY2hpbGROb2RlcyApO1xuXHRcdH0gKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxufSApO1xuXG5cbmpRdWVyeS5leHByLnBzZXVkb3MuaGlkZGVuID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHJldHVybiAhalF1ZXJ5LmV4cHIucHNldWRvcy52aXNpYmxlKCBlbGVtICk7XG59O1xualF1ZXJ5LmV4cHIucHNldWRvcy52aXNpYmxlID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHJldHVybiAhISggZWxlbS5vZmZzZXRXaWR0aCB8fCBlbGVtLm9mZnNldEhlaWdodCB8fCBlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoICk7XG59O1xuXG5cblxuXG5qUXVlcnkuYWpheFNldHRpbmdzLnhociA9IGZ1bmN0aW9uKCkge1xuXHR0cnkge1xuXHRcdHJldHVybiBuZXcgd2luZG93LlhNTEh0dHBSZXF1ZXN0KCk7XG5cdH0gY2F0Y2ggKCBlICkge31cbn07XG5cbnZhciB4aHJTdWNjZXNzU3RhdHVzID0ge1xuXG5cdFx0Ly8gRmlsZSBwcm90b2NvbCBhbHdheXMgeWllbGRzIHN0YXR1cyBjb2RlIDAsIGFzc3VtZSAyMDBcblx0XHQwOiAyMDAsXG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRcdC8vIHRyYWMtMTQ1MDogc29tZXRpbWVzIElFIHJldHVybnMgMTIyMyB3aGVuIGl0IHNob3VsZCBiZSAyMDRcblx0XHQxMjIzOiAyMDRcblx0fSxcblx0eGhyU3VwcG9ydGVkID0galF1ZXJ5LmFqYXhTZXR0aW5ncy54aHIoKTtcblxuc3VwcG9ydC5jb3JzID0gISF4aHJTdXBwb3J0ZWQgJiYgKCBcIndpdGhDcmVkZW50aWFsc1wiIGluIHhoclN1cHBvcnRlZCApO1xuc3VwcG9ydC5hamF4ID0geGhyU3VwcG9ydGVkID0gISF4aHJTdXBwb3J0ZWQ7XG5cbmpRdWVyeS5hamF4VHJhbnNwb3J0KCBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0dmFyIGNhbGxiYWNrLCBlcnJvckNhbGxiYWNrO1xuXG5cdC8vIENyb3NzIGRvbWFpbiBvbmx5IGFsbG93ZWQgaWYgc3VwcG9ydGVkIHRocm91Z2ggWE1MSHR0cFJlcXVlc3Rcblx0aWYgKCBzdXBwb3J0LmNvcnMgfHwgeGhyU3VwcG9ydGVkICYmICFvcHRpb25zLmNyb3NzRG9tYWluICkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRzZW5kOiBmdW5jdGlvbiggaGVhZGVycywgY29tcGxldGUgKSB7XG5cdFx0XHRcdHZhciBpLFxuXHRcdFx0XHRcdHhociA9IG9wdGlvbnMueGhyKCk7XG5cblx0XHRcdFx0eGhyLm9wZW4oXG5cdFx0XHRcdFx0b3B0aW9ucy50eXBlLFxuXHRcdFx0XHRcdG9wdGlvbnMudXJsLFxuXHRcdFx0XHRcdG9wdGlvbnMuYXN5bmMsXG5cdFx0XHRcdFx0b3B0aW9ucy51c2VybmFtZSxcblx0XHRcdFx0XHRvcHRpb25zLnBhc3N3b3JkXG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0Ly8gQXBwbHkgY3VzdG9tIGZpZWxkcyBpZiBwcm92aWRlZFxuXHRcdFx0XHRpZiAoIG9wdGlvbnMueGhyRmllbGRzICkge1xuXHRcdFx0XHRcdGZvciAoIGkgaW4gb3B0aW9ucy54aHJGaWVsZHMgKSB7XG5cdFx0XHRcdFx0XHR4aHJbIGkgXSA9IG9wdGlvbnMueGhyRmllbGRzWyBpIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gT3ZlcnJpZGUgbWltZSB0eXBlIGlmIG5lZWRlZFxuXHRcdFx0XHRpZiAoIG9wdGlvbnMubWltZVR5cGUgJiYgeGhyLm92ZXJyaWRlTWltZVR5cGUgKSB7XG5cdFx0XHRcdFx0eGhyLm92ZXJyaWRlTWltZVR5cGUoIG9wdGlvbnMubWltZVR5cGUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFgtUmVxdWVzdGVkLVdpdGggaGVhZGVyXG5cdFx0XHRcdC8vIEZvciBjcm9zcy1kb21haW4gcmVxdWVzdHMsIHNlZWluZyBhcyBjb25kaXRpb25zIGZvciBhIHByZWZsaWdodCBhcmVcblx0XHRcdFx0Ly8gYWtpbiB0byBhIGppZ3NhdyBwdXp6bGUsIHdlIHNpbXBseSBuZXZlciBzZXQgaXQgdG8gYmUgc3VyZS5cblx0XHRcdFx0Ly8gKGl0IGNhbiBhbHdheXMgYmUgc2V0IG9uIGEgcGVyLXJlcXVlc3QgYmFzaXMgb3IgZXZlbiB1c2luZyBhamF4U2V0dXApXG5cdFx0XHRcdC8vIEZvciBzYW1lLWRvbWFpbiByZXF1ZXN0cywgd29uJ3QgY2hhbmdlIGhlYWRlciBpZiBhbHJlYWR5IHByb3ZpZGVkLlxuXHRcdFx0XHRpZiAoICFvcHRpb25zLmNyb3NzRG9tYWluICYmICFoZWFkZXJzWyBcIlgtUmVxdWVzdGVkLVdpdGhcIiBdICkge1xuXHRcdFx0XHRcdGhlYWRlcnNbIFwiWC1SZXF1ZXN0ZWQtV2l0aFwiIF0gPSBcIlhNTEh0dHBSZXF1ZXN0XCI7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTZXQgaGVhZGVyc1xuXHRcdFx0XHRmb3IgKCBpIGluIGhlYWRlcnMgKSB7XG5cdFx0XHRcdFx0eGhyLnNldFJlcXVlc3RIZWFkZXIoIGksIGhlYWRlcnNbIGkgXSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ2FsbGJhY2tcblx0XHRcdFx0Y2FsbGJhY2sgPSBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0XHRjYWxsYmFjayA9IGVycm9yQ2FsbGJhY2sgPSB4aHIub25sb2FkID1cblx0XHRcdFx0XHRcdFx0XHR4aHIub25lcnJvciA9IHhoci5vbmFib3J0ID0geGhyLm9udGltZW91dCA9XG5cdFx0XHRcdFx0XHRcdFx0XHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIHR5cGUgPT09IFwiYWJvcnRcIiApIHtcblx0XHRcdFx0XHRcdFx0XHR4aHIuYWJvcnQoKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gXCJlcnJvclwiICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHRcdFx0XHRcdFx0XHQvLyBPbiBhIG1hbnVhbCBuYXRpdmUgYWJvcnQsIElFOSB0aHJvd3Ncblx0XHRcdFx0XHRcdFx0XHQvLyBlcnJvcnMgb24gYW55IHByb3BlcnR5IGFjY2VzcyB0aGF0IGlzIG5vdCByZWFkeVN0YXRlXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCB0eXBlb2YgeGhyLnN0YXR1cyAhPT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKCAwLCBcImVycm9yXCIgKTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoXG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gRmlsZTogcHJvdG9jb2wgYWx3YXlzIHlpZWxkcyBzdGF0dXMgMDsgc2VlIHRyYWMtODYwNSwgdHJhYy0xNDIwN1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR4aHIuc3RhdHVzLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR4aHIuc3RhdHVzVGV4dFxuXHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHJTdWNjZXNzU3RhdHVzWyB4aHIuc3RhdHVzIF0gfHwgeGhyLnN0YXR1cyxcblx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXNUZXh0LFxuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSUU5IGhhcyBubyBYSFIyIGJ1dCB0aHJvd3Mgb24gYmluYXJ5ICh0cmFjLTExNDI2KVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gRm9yIFhIUjIgbm9uLXRleHQsIGxldCB0aGUgY2FsbGVyIGhhbmRsZSBpdCAoZ2gtMjQ5OClcblx0XHRcdFx0XHRcdFx0XHRcdCggeGhyLnJlc3BvbnNlVHlwZSB8fCBcInRleHRcIiApICE9PSBcInRleHRcIiAgfHxcblx0XHRcdFx0XHRcdFx0XHRcdHR5cGVvZiB4aHIucmVzcG9uc2VUZXh0ICE9PSBcInN0cmluZ1wiID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0eyBiaW5hcnk6IHhoci5yZXNwb25zZSB9IDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0eyB0ZXh0OiB4aHIucmVzcG9uc2VUZXh0IH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKClcblx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fTtcblxuXHRcdFx0XHQvLyBMaXN0ZW4gdG8gZXZlbnRzXG5cdFx0XHRcdHhoci5vbmxvYWQgPSBjYWxsYmFjaygpO1xuXHRcdFx0XHRlcnJvckNhbGxiYWNrID0geGhyLm9uZXJyb3IgPSB4aHIub250aW1lb3V0ID0gY2FsbGJhY2soIFwiZXJyb3JcIiApO1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDkgb25seVxuXHRcdFx0XHQvLyBVc2Ugb25yZWFkeXN0YXRlY2hhbmdlIHRvIHJlcGxhY2Ugb25hYm9ydFxuXHRcdFx0XHQvLyB0byBoYW5kbGUgdW5jYXVnaHQgYWJvcnRzXG5cdFx0XHRcdGlmICggeGhyLm9uYWJvcnQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHR4aHIub25hYm9ydCA9IGVycm9yQ2FsbGJhY2s7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0eGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdFx0XHQvLyBDaGVjayByZWFkeVN0YXRlIGJlZm9yZSB0aW1lb3V0IGFzIGl0IGNoYW5nZXNcblx0XHRcdFx0XHRcdGlmICggeGhyLnJlYWR5U3RhdGUgPT09IDQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQWxsb3cgb25lcnJvciB0byBiZSBjYWxsZWQgZmlyc3QsXG5cdFx0XHRcdFx0XHRcdC8vIGJ1dCB0aGF0IHdpbGwgbm90IGhhbmRsZSBhIG5hdGl2ZSBhYm9ydFxuXHRcdFx0XHRcdFx0XHQvLyBBbHNvLCBzYXZlIGVycm9yQ2FsbGJhY2sgdG8gYSB2YXJpYWJsZVxuXHRcdFx0XHRcdFx0XHQvLyBhcyB4aHIub25lcnJvciBjYW5ub3QgYmUgYWNjZXNzZWRcblx0XHRcdFx0XHRcdFx0d2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRlcnJvckNhbGxiYWNrKCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENyZWF0ZSB0aGUgYWJvcnQgY2FsbGJhY2tcblx0XHRcdFx0Y2FsbGJhY2sgPSBjYWxsYmFjayggXCJhYm9ydFwiICk7XG5cblx0XHRcdFx0dHJ5IHtcblxuXHRcdFx0XHRcdC8vIERvIHNlbmQgdGhlIHJlcXVlc3QgKHRoaXMgbWF5IHJhaXNlIGFuIGV4Y2VwdGlvbilcblx0XHRcdFx0XHR4aHIuc2VuZCggb3B0aW9ucy5oYXNDb250ZW50ICYmIG9wdGlvbnMuZGF0YSB8fCBudWxsICk7XG5cdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdFx0Ly8gdHJhYy0xNDY4MzogT25seSByZXRocm93IGlmIHRoaXMgaGFzbid0IGJlZW4gbm90aWZpZWQgYXMgYW4gZXJyb3IgeWV0XG5cdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdHRocm93IGU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRhYm9ydDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH1cbn0gKTtcblxuXG5cblxuLy8gUHJldmVudCBhdXRvLWV4ZWN1dGlvbiBvZiBzY3JpcHRzIHdoZW4gbm8gZXhwbGljaXQgZGF0YVR5cGUgd2FzIHByb3ZpZGVkIChTZWUgZ2gtMjQzMilcbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBmdW5jdGlvbiggcyApIHtcblx0aWYgKCBzLmNyb3NzRG9tYWluICkge1xuXHRcdHMuY29udGVudHMuc2NyaXB0ID0gZmFsc2U7XG5cdH1cbn0gKTtcblxuLy8gSW5zdGFsbCBzY3JpcHQgZGF0YVR5cGVcbmpRdWVyeS5hamF4U2V0dXAoIHtcblx0YWNjZXB0czoge1xuXHRcdHNjcmlwdDogXCJ0ZXh0L2phdmFzY3JpcHQsIGFwcGxpY2F0aW9uL2phdmFzY3JpcHQsIFwiICtcblx0XHRcdFwiYXBwbGljYXRpb24vZWNtYXNjcmlwdCwgYXBwbGljYXRpb24veC1lY21hc2NyaXB0XCJcblx0fSxcblx0Y29udGVudHM6IHtcblx0XHRzY3JpcHQ6IC9cXGIoPzpqYXZhfGVjbWEpc2NyaXB0XFxiL1xuXHR9LFxuXHRjb252ZXJ0ZXJzOiB7XG5cdFx0XCJ0ZXh0IHNjcmlwdFwiOiBmdW5jdGlvbiggdGV4dCApIHtcblx0XHRcdGpRdWVyeS5nbG9iYWxFdmFsKCB0ZXh0ICk7XG5cdFx0XHRyZXR1cm4gdGV4dDtcblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gSGFuZGxlIGNhY2hlJ3Mgc3BlY2lhbCBjYXNlIGFuZCBjcm9zc0RvbWFpblxualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIFwic2NyaXB0XCIsIGZ1bmN0aW9uKCBzICkge1xuXHRpZiAoIHMuY2FjaGUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRzLmNhY2hlID0gZmFsc2U7XG5cdH1cblx0aWYgKCBzLmNyb3NzRG9tYWluICkge1xuXHRcdHMudHlwZSA9IFwiR0VUXCI7XG5cdH1cbn0gKTtcblxuLy8gQmluZCBzY3JpcHQgdGFnIGhhY2sgdHJhbnNwb3J0XG5qUXVlcnkuYWpheFRyYW5zcG9ydCggXCJzY3JpcHRcIiwgZnVuY3Rpb24oIHMgKSB7XG5cblx0Ly8gVGhpcyB0cmFuc3BvcnQgb25seSBkZWFscyB3aXRoIGNyb3NzIGRvbWFpbiBvciBmb3JjZWQtYnktYXR0cnMgcmVxdWVzdHNcblx0aWYgKCBzLmNyb3NzRG9tYWluIHx8IHMuc2NyaXB0QXR0cnMgKSB7XG5cdFx0dmFyIHNjcmlwdCwgY2FsbGJhY2s7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHNlbmQ6IGZ1bmN0aW9uKCBfLCBjb21wbGV0ZSApIHtcblx0XHRcdFx0c2NyaXB0ID0galF1ZXJ5KCBcIjxzY3JpcHQ+XCIgKVxuXHRcdFx0XHRcdC5hdHRyKCBzLnNjcmlwdEF0dHJzIHx8IHt9IClcblx0XHRcdFx0XHQucHJvcCggeyBjaGFyc2V0OiBzLnNjcmlwdENoYXJzZXQsIHNyYzogcy51cmwgfSApXG5cdFx0XHRcdFx0Lm9uKCBcImxvYWQgZXJyb3JcIiwgY2FsbGJhY2sgPSBmdW5jdGlvbiggZXZ0ICkge1xuXHRcdFx0XHRcdFx0c2NyaXB0LnJlbW92ZSgpO1xuXHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSBudWxsO1xuXHRcdFx0XHRcdFx0aWYgKCBldnQgKSB7XG5cdFx0XHRcdFx0XHRcdGNvbXBsZXRlKCBldnQudHlwZSA9PT0gXCJlcnJvclwiID8gNDA0IDogMjAwLCBldnQudHlwZSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gKTtcblxuXHRcdFx0XHQvLyBVc2UgbmF0aXZlIERPTSBtYW5pcHVsYXRpb24gdG8gYXZvaWQgb3VyIGRvbU1hbmlwIEFKQVggdHJpY2tlcnlcblx0XHRcdFx0ZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCggc2NyaXB0WyAwIF0gKTtcblx0XHRcdH0sXG5cdFx0XHRhYm9ydDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH1cbn0gKTtcblxuXG5cblxudmFyIG9sZENhbGxiYWNrcyA9IFtdLFxuXHRyanNvbnAgPSAvKD0pXFw/KD89JnwkKXxcXD9cXD8vO1xuXG4vLyBEZWZhdWx0IGpzb25wIHNldHRpbmdzXG5qUXVlcnkuYWpheFNldHVwKCB7XG5cdGpzb25wOiBcImNhbGxiYWNrXCIsXG5cdGpzb25wQ2FsbGJhY2s6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjYWxsYmFjayA9IG9sZENhbGxiYWNrcy5wb3AoKSB8fCAoIGpRdWVyeS5leHBhbmRvICsgXCJfXCIgKyAoIG5vbmNlLmd1aWQrKyApICk7XG5cdFx0dGhpc1sgY2FsbGJhY2sgXSA9IHRydWU7XG5cdFx0cmV0dXJuIGNhbGxiYWNrO1xuXHR9XG59ICk7XG5cbi8vIERldGVjdCwgbm9ybWFsaXplIG9wdGlvbnMgYW5kIGluc3RhbGwgY2FsbGJhY2tzIGZvciBqc29ucCByZXF1ZXN0c1xualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIFwianNvbiBqc29ucFwiLCBmdW5jdGlvbiggcywgb3JpZ2luYWxTZXR0aW5ncywganFYSFIgKSB7XG5cblx0dmFyIGNhbGxiYWNrTmFtZSwgb3ZlcndyaXR0ZW4sIHJlc3BvbnNlQ29udGFpbmVyLFxuXHRcdGpzb25Qcm9wID0gcy5qc29ucCAhPT0gZmFsc2UgJiYgKCByanNvbnAudGVzdCggcy51cmwgKSA/XG5cdFx0XHRcInVybFwiIDpcblx0XHRcdHR5cGVvZiBzLmRhdGEgPT09IFwic3RyaW5nXCIgJiZcblx0XHRcdFx0KCBzLmNvbnRlbnRUeXBlIHx8IFwiXCIgKVxuXHRcdFx0XHRcdC5pbmRleE9mKCBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiICkgPT09IDAgJiZcblx0XHRcdFx0cmpzb25wLnRlc3QoIHMuZGF0YSApICYmIFwiZGF0YVwiXG5cdFx0KTtcblxuXHQvLyBIYW5kbGUgaWZmIHRoZSBleHBlY3RlZCBkYXRhIHR5cGUgaXMgXCJqc29ucFwiIG9yIHdlIGhhdmUgYSBwYXJhbWV0ZXIgdG8gc2V0XG5cdGlmICgganNvblByb3AgfHwgcy5kYXRhVHlwZXNbIDAgXSA9PT0gXCJqc29ucFwiICkge1xuXG5cdFx0Ly8gR2V0IGNhbGxiYWNrIG5hbWUsIHJlbWVtYmVyaW5nIHByZWV4aXN0aW5nIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCBpdFxuXHRcdGNhbGxiYWNrTmFtZSA9IHMuanNvbnBDYWxsYmFjayA9IGlzRnVuY3Rpb24oIHMuanNvbnBDYWxsYmFjayApID9cblx0XHRcdHMuanNvbnBDYWxsYmFjaygpIDpcblx0XHRcdHMuanNvbnBDYWxsYmFjaztcblxuXHRcdC8vIEluc2VydCBjYWxsYmFjayBpbnRvIHVybCBvciBmb3JtIGRhdGFcblx0XHRpZiAoIGpzb25Qcm9wICkge1xuXHRcdFx0c1sganNvblByb3AgXSA9IHNbIGpzb25Qcm9wIF0ucmVwbGFjZSggcmpzb25wLCBcIiQxXCIgKyBjYWxsYmFja05hbWUgKTtcblx0XHR9IGVsc2UgaWYgKCBzLmpzb25wICE9PSBmYWxzZSApIHtcblx0XHRcdHMudXJsICs9ICggcnF1ZXJ5LnRlc3QoIHMudXJsICkgPyBcIiZcIiA6IFwiP1wiICkgKyBzLmpzb25wICsgXCI9XCIgKyBjYWxsYmFja05hbWU7XG5cdFx0fVxuXG5cdFx0Ly8gVXNlIGRhdGEgY29udmVydGVyIHRvIHJldHJpZXZlIGpzb24gYWZ0ZXIgc2NyaXB0IGV4ZWN1dGlvblxuXHRcdHMuY29udmVydGVyc1sgXCJzY3JpcHQganNvblwiIF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggIXJlc3BvbnNlQ29udGFpbmVyICkge1xuXHRcdFx0XHRqUXVlcnkuZXJyb3IoIGNhbGxiYWNrTmFtZSArIFwiIHdhcyBub3QgY2FsbGVkXCIgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXNwb25zZUNvbnRhaW5lclsgMCBdO1xuXHRcdH07XG5cblx0XHQvLyBGb3JjZSBqc29uIGRhdGFUeXBlXG5cdFx0cy5kYXRhVHlwZXNbIDAgXSA9IFwianNvblwiO1xuXG5cdFx0Ly8gSW5zdGFsbCBjYWxsYmFja1xuXHRcdG92ZXJ3cml0dGVuID0gd2luZG93WyBjYWxsYmFja05hbWUgXTtcblx0XHR3aW5kb3dbIGNhbGxiYWNrTmFtZSBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXNwb25zZUNvbnRhaW5lciA9IGFyZ3VtZW50cztcblx0XHR9O1xuXG5cdFx0Ly8gQ2xlYW4tdXAgZnVuY3Rpb24gKGZpcmVzIGFmdGVyIGNvbnZlcnRlcnMpXG5cdFx0anFYSFIuYWx3YXlzKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gSWYgcHJldmlvdXMgdmFsdWUgZGlkbid0IGV4aXN0IC0gcmVtb3ZlIGl0XG5cdFx0XHRpZiAoIG92ZXJ3cml0dGVuID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdGpRdWVyeSggd2luZG93ICkucmVtb3ZlUHJvcCggY2FsbGJhY2tOYW1lICk7XG5cblx0XHRcdC8vIE90aGVyd2lzZSByZXN0b3JlIHByZWV4aXN0aW5nIHZhbHVlXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3aW5kb3dbIGNhbGxiYWNrTmFtZSBdID0gb3ZlcndyaXR0ZW47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNhdmUgYmFjayBhcyBmcmVlXG5cdFx0XHRpZiAoIHNbIGNhbGxiYWNrTmFtZSBdICkge1xuXG5cdFx0XHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHJlLXVzaW5nIHRoZSBvcHRpb25zIGRvZXNuJ3Qgc2NyZXcgdGhpbmdzIGFyb3VuZFxuXHRcdFx0XHRzLmpzb25wQ2FsbGJhY2sgPSBvcmlnaW5hbFNldHRpbmdzLmpzb25wQ2FsbGJhY2s7XG5cblx0XHRcdFx0Ly8gU2F2ZSB0aGUgY2FsbGJhY2sgbmFtZSBmb3IgZnV0dXJlIHVzZVxuXHRcdFx0XHRvbGRDYWxsYmFja3MucHVzaCggY2FsbGJhY2tOYW1lICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENhbGwgaWYgaXQgd2FzIGEgZnVuY3Rpb24gYW5kIHdlIGhhdmUgYSByZXNwb25zZVxuXHRcdFx0aWYgKCByZXNwb25zZUNvbnRhaW5lciAmJiBpc0Z1bmN0aW9uKCBvdmVyd3JpdHRlbiApICkge1xuXHRcdFx0XHRvdmVyd3JpdHRlbiggcmVzcG9uc2VDb250YWluZXJbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXNwb25zZUNvbnRhaW5lciA9IG92ZXJ3cml0dGVuID0gdW5kZWZpbmVkO1xuXHRcdH0gKTtcblxuXHRcdC8vIERlbGVnYXRlIHRvIHNjcmlwdFxuXHRcdHJldHVybiBcInNjcmlwdFwiO1xuXHR9XG59ICk7XG5cblxuXG5cbi8vIFN1cHBvcnQ6IFNhZmFyaSA4IG9ubHlcbi8vIEluIFNhZmFyaSA4IGRvY3VtZW50cyBjcmVhdGVkIHZpYSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnRcbi8vIGNvbGxhcHNlIHNpYmxpbmcgZm9ybXM6IHRoZSBzZWNvbmQgb25lIGJlY29tZXMgYSBjaGlsZCBvZiB0aGUgZmlyc3Qgb25lLlxuLy8gQmVjYXVzZSBvZiB0aGF0LCB0aGlzIHNlY3VyaXR5IG1lYXN1cmUgaGFzIHRvIGJlIGRpc2FibGVkIGluIFNhZmFyaSA4LlxuLy8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTEzNzMzN1xuc3VwcG9ydC5jcmVhdGVIVE1MRG9jdW1lbnQgPSAoIGZ1bmN0aW9uKCkge1xuXHR2YXIgYm9keSA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCggXCJcIiApLmJvZHk7XG5cdGJvZHkuaW5uZXJIVE1MID0gXCI8Zm9ybT48L2Zvcm0+PGZvcm0+PC9mb3JtPlwiO1xuXHRyZXR1cm4gYm9keS5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMjtcbn0gKSgpO1xuXG5cbi8vIEFyZ3VtZW50IFwiZGF0YVwiIHNob3VsZCBiZSBzdHJpbmcgb2YgaHRtbFxuLy8gY29udGV4dCAob3B0aW9uYWwpOiBJZiBzcGVjaWZpZWQsIHRoZSBmcmFnbWVudCB3aWxsIGJlIGNyZWF0ZWQgaW4gdGhpcyBjb250ZXh0LFxuLy8gZGVmYXVsdHMgdG8gZG9jdW1lbnRcbi8vIGtlZXBTY3JpcHRzIChvcHRpb25hbCk6IElmIHRydWUsIHdpbGwgaW5jbHVkZSBzY3JpcHRzIHBhc3NlZCBpbiB0aGUgaHRtbCBzdHJpbmdcbmpRdWVyeS5wYXJzZUhUTUwgPSBmdW5jdGlvbiggZGF0YSwgY29udGV4dCwga2VlcFNjcmlwdHMgKSB7XG5cdGlmICggdHlwZW9mIGRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIFtdO1xuXHR9XG5cdGlmICggdHlwZW9mIGNvbnRleHQgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdGtlZXBTY3JpcHRzID0gY29udGV4dDtcblx0XHRjb250ZXh0ID0gZmFsc2U7XG5cdH1cblxuXHR2YXIgYmFzZSwgcGFyc2VkLCBzY3JpcHRzO1xuXG5cdGlmICggIWNvbnRleHQgKSB7XG5cblx0XHQvLyBTdG9wIHNjcmlwdHMgb3IgaW5saW5lIGV2ZW50IGhhbmRsZXJzIGZyb20gYmVpbmcgZXhlY3V0ZWQgaW1tZWRpYXRlbHlcblx0XHQvLyBieSB1c2luZyBkb2N1bWVudC5pbXBsZW1lbnRhdGlvblxuXHRcdGlmICggc3VwcG9ydC5jcmVhdGVIVE1MRG9jdW1lbnQgKSB7XG5cdFx0XHRjb250ZXh0ID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCBcIlwiICk7XG5cblx0XHRcdC8vIFNldCB0aGUgYmFzZSBocmVmIGZvciB0aGUgY3JlYXRlZCBkb2N1bWVudFxuXHRcdFx0Ly8gc28gYW55IHBhcnNlZCBlbGVtZW50cyB3aXRoIFVSTHNcblx0XHRcdC8vIGFyZSBiYXNlZCBvbiB0aGUgZG9jdW1lbnQncyBVUkwgKGdoLTI5NjUpXG5cdFx0XHRiYXNlID0gY29udGV4dC5jcmVhdGVFbGVtZW50KCBcImJhc2VcIiApO1xuXHRcdFx0YmFzZS5ocmVmID0gZG9jdW1lbnQubG9jYXRpb24uaHJlZjtcblx0XHRcdGNvbnRleHQuaGVhZC5hcHBlbmRDaGlsZCggYmFzZSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb250ZXh0ID0gZG9jdW1lbnQ7XG5cdFx0fVxuXHR9XG5cblx0cGFyc2VkID0gcnNpbmdsZVRhZy5leGVjKCBkYXRhICk7XG5cdHNjcmlwdHMgPSAha2VlcFNjcmlwdHMgJiYgW107XG5cblx0Ly8gU2luZ2xlIHRhZ1xuXHRpZiAoIHBhcnNlZCApIHtcblx0XHRyZXR1cm4gWyBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIHBhcnNlZFsgMSBdICkgXTtcblx0fVxuXG5cdHBhcnNlZCA9IGJ1aWxkRnJhZ21lbnQoIFsgZGF0YSBdLCBjb250ZXh0LCBzY3JpcHRzICk7XG5cblx0aWYgKCBzY3JpcHRzICYmIHNjcmlwdHMubGVuZ3RoICkge1xuXHRcdGpRdWVyeSggc2NyaXB0cyApLnJlbW92ZSgpO1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeS5tZXJnZSggW10sIHBhcnNlZC5jaGlsZE5vZGVzICk7XG59O1xuXG5cbi8qKlxuICogTG9hZCBhIHVybCBpbnRvIGEgcGFnZVxuICovXG5qUXVlcnkuZm4ubG9hZCA9IGZ1bmN0aW9uKCB1cmwsIHBhcmFtcywgY2FsbGJhY2sgKSB7XG5cdHZhciBzZWxlY3RvciwgdHlwZSwgcmVzcG9uc2UsXG5cdFx0c2VsZiA9IHRoaXMsXG5cdFx0b2ZmID0gdXJsLmluZGV4T2YoIFwiIFwiICk7XG5cblx0aWYgKCBvZmYgPiAtMSApIHtcblx0XHRzZWxlY3RvciA9IHN0cmlwQW5kQ29sbGFwc2UoIHVybC5zbGljZSggb2ZmICkgKTtcblx0XHR1cmwgPSB1cmwuc2xpY2UoIDAsIG9mZiApO1xuXHR9XG5cblx0Ly8gSWYgaXQncyBhIGZ1bmN0aW9uXG5cdGlmICggaXNGdW5jdGlvbiggcGFyYW1zICkgKSB7XG5cblx0XHQvLyBXZSBhc3N1bWUgdGhhdCBpdCdzIHRoZSBjYWxsYmFja1xuXHRcdGNhbGxiYWNrID0gcGFyYW1zO1xuXHRcdHBhcmFtcyA9IHVuZGVmaW5lZDtcblxuXHQvLyBPdGhlcndpc2UsIGJ1aWxkIGEgcGFyYW0gc3RyaW5nXG5cdH0gZWxzZSBpZiAoIHBhcmFtcyAmJiB0eXBlb2YgcGFyYW1zID09PSBcIm9iamVjdFwiICkge1xuXHRcdHR5cGUgPSBcIlBPU1RcIjtcblx0fVxuXG5cdC8vIElmIHdlIGhhdmUgZWxlbWVudHMgdG8gbW9kaWZ5LCBtYWtlIHRoZSByZXF1ZXN0XG5cdGlmICggc2VsZi5sZW5ndGggPiAwICkge1xuXHRcdGpRdWVyeS5hamF4KCB7XG5cdFx0XHR1cmw6IHVybCxcblxuXHRcdFx0Ly8gSWYgXCJ0eXBlXCIgdmFyaWFibGUgaXMgdW5kZWZpbmVkLCB0aGVuIFwiR0VUXCIgbWV0aG9kIHdpbGwgYmUgdXNlZC5cblx0XHRcdC8vIE1ha2UgdmFsdWUgb2YgdGhpcyBmaWVsZCBleHBsaWNpdCBzaW5jZVxuXHRcdFx0Ly8gdXNlciBjYW4gb3ZlcnJpZGUgaXQgdGhyb3VnaCBhamF4U2V0dXAgbWV0aG9kXG5cdFx0XHR0eXBlOiB0eXBlIHx8IFwiR0VUXCIsXG5cdFx0XHRkYXRhVHlwZTogXCJodG1sXCIsXG5cdFx0XHRkYXRhOiBwYXJhbXNcblx0XHR9ICkuZG9uZSggZnVuY3Rpb24oIHJlc3BvbnNlVGV4dCApIHtcblxuXHRcdFx0Ly8gU2F2ZSByZXNwb25zZSBmb3IgdXNlIGluIGNvbXBsZXRlIGNhbGxiYWNrXG5cdFx0XHRyZXNwb25zZSA9IGFyZ3VtZW50cztcblxuXHRcdFx0c2VsZi5odG1sKCBzZWxlY3RvciA/XG5cblx0XHRcdFx0Ly8gSWYgYSBzZWxlY3RvciB3YXMgc3BlY2lmaWVkLCBsb2NhdGUgdGhlIHJpZ2h0IGVsZW1lbnRzIGluIGEgZHVtbXkgZGl2XG5cdFx0XHRcdC8vIEV4Y2x1ZGUgc2NyaXB0cyB0byBhdm9pZCBJRSAnUGVybWlzc2lvbiBEZW5pZWQnIGVycm9yc1xuXHRcdFx0XHRqUXVlcnkoIFwiPGRpdj5cIiApLmFwcGVuZCggalF1ZXJ5LnBhcnNlSFRNTCggcmVzcG9uc2VUZXh0ICkgKS5maW5kKCBzZWxlY3RvciApIDpcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UgdXNlIHRoZSBmdWxsIHJlc3VsdFxuXHRcdFx0XHRyZXNwb25zZVRleHQgKTtcblxuXHRcdC8vIElmIHRoZSByZXF1ZXN0IHN1Y2NlZWRzLCB0aGlzIGZ1bmN0aW9uIGdldHMgXCJkYXRhXCIsIFwic3RhdHVzXCIsIFwianFYSFJcIlxuXHRcdC8vIGJ1dCB0aGV5IGFyZSBpZ25vcmVkIGJlY2F1c2UgcmVzcG9uc2Ugd2FzIHNldCBhYm92ZS5cblx0XHQvLyBJZiBpdCBmYWlscywgdGhpcyBmdW5jdGlvbiBnZXRzIFwianFYSFJcIiwgXCJzdGF0dXNcIiwgXCJlcnJvclwiXG5cdFx0fSApLmFsd2F5cyggY2FsbGJhY2sgJiYgZnVuY3Rpb24oIGpxWEhSLCBzdGF0dXMgKSB7XG5cdFx0XHRzZWxmLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRjYWxsYmFjay5hcHBseSggdGhpcywgcmVzcG9uc2UgfHwgWyBqcVhIUi5yZXNwb25zZVRleHQsIHN0YXR1cywganFYSFIgXSApO1xuXHRcdFx0fSApO1xuXHRcdH0gKTtcblx0fVxuXG5cdHJldHVybiB0aGlzO1xufTtcblxuXG5cblxualF1ZXJ5LmV4cHIucHNldWRvcy5hbmltYXRlZCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRyZXR1cm4galF1ZXJ5LmdyZXAoIGpRdWVyeS50aW1lcnMsIGZ1bmN0aW9uKCBmbiApIHtcblx0XHRyZXR1cm4gZWxlbSA9PT0gZm4uZWxlbTtcblx0fSApLmxlbmd0aDtcbn07XG5cblxuXG5cbmpRdWVyeS5vZmZzZXQgPSB7XG5cdHNldE9mZnNldDogZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIGkgKSB7XG5cdFx0dmFyIGN1clBvc2l0aW9uLCBjdXJMZWZ0LCBjdXJDU1NUb3AsIGN1clRvcCwgY3VyT2Zmc2V0LCBjdXJDU1NMZWZ0LCBjYWxjdWxhdGVQb3NpdGlvbixcblx0XHRcdHBvc2l0aW9uID0galF1ZXJ5LmNzcyggZWxlbSwgXCJwb3NpdGlvblwiICksXG5cdFx0XHRjdXJFbGVtID0galF1ZXJ5KCBlbGVtICksXG5cdFx0XHRwcm9wcyA9IHt9O1xuXG5cdFx0Ly8gU2V0IHBvc2l0aW9uIGZpcnN0LCBpbi1jYXNlIHRvcC9sZWZ0IGFyZSBzZXQgZXZlbiBvbiBzdGF0aWMgZWxlbVxuXHRcdGlmICggcG9zaXRpb24gPT09IFwic3RhdGljXCIgKSB7XG5cdFx0XHRlbGVtLnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuXHRcdH1cblxuXHRcdGN1ck9mZnNldCA9IGN1ckVsZW0ub2Zmc2V0KCk7XG5cdFx0Y3VyQ1NTVG9wID0galF1ZXJ5LmNzcyggZWxlbSwgXCJ0b3BcIiApO1xuXHRcdGN1ckNTU0xlZnQgPSBqUXVlcnkuY3NzKCBlbGVtLCBcImxlZnRcIiApO1xuXHRcdGNhbGN1bGF0ZVBvc2l0aW9uID0gKCBwb3NpdGlvbiA9PT0gXCJhYnNvbHV0ZVwiIHx8IHBvc2l0aW9uID09PSBcImZpeGVkXCIgKSAmJlxuXHRcdFx0KCBjdXJDU1NUb3AgKyBjdXJDU1NMZWZ0ICkuaW5kZXhPZiggXCJhdXRvXCIgKSA+IC0xO1xuXG5cdFx0Ly8gTmVlZCB0byBiZSBhYmxlIHRvIGNhbGN1bGF0ZSBwb3NpdGlvbiBpZiBlaXRoZXJcblx0XHQvLyB0b3Agb3IgbGVmdCBpcyBhdXRvIGFuZCBwb3NpdGlvbiBpcyBlaXRoZXIgYWJzb2x1dGUgb3IgZml4ZWRcblx0XHRpZiAoIGNhbGN1bGF0ZVBvc2l0aW9uICkge1xuXHRcdFx0Y3VyUG9zaXRpb24gPSBjdXJFbGVtLnBvc2l0aW9uKCk7XG5cdFx0XHRjdXJUb3AgPSBjdXJQb3NpdGlvbi50b3A7XG5cdFx0XHRjdXJMZWZ0ID0gY3VyUG9zaXRpb24ubGVmdDtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjdXJUb3AgPSBwYXJzZUZsb2F0KCBjdXJDU1NUb3AgKSB8fCAwO1xuXHRcdFx0Y3VyTGVmdCA9IHBhcnNlRmxvYXQoIGN1ckNTU0xlZnQgKSB8fCAwO1xuXHRcdH1cblxuXHRcdGlmICggaXNGdW5jdGlvbiggb3B0aW9ucyApICkge1xuXG5cdFx0XHQvLyBVc2UgalF1ZXJ5LmV4dGVuZCBoZXJlIHRvIGFsbG93IG1vZGlmaWNhdGlvbiBvZiBjb29yZGluYXRlcyBhcmd1bWVudCAoZ2gtMTg0OClcblx0XHRcdG9wdGlvbnMgPSBvcHRpb25zLmNhbGwoIGVsZW0sIGksIGpRdWVyeS5leHRlbmQoIHt9LCBjdXJPZmZzZXQgKSApO1xuXHRcdH1cblxuXHRcdGlmICggb3B0aW9ucy50b3AgIT0gbnVsbCApIHtcblx0XHRcdHByb3BzLnRvcCA9ICggb3B0aW9ucy50b3AgLSBjdXJPZmZzZXQudG9wICkgKyBjdXJUb3A7XG5cdFx0fVxuXHRcdGlmICggb3B0aW9ucy5sZWZ0ICE9IG51bGwgKSB7XG5cdFx0XHRwcm9wcy5sZWZ0ID0gKCBvcHRpb25zLmxlZnQgLSBjdXJPZmZzZXQubGVmdCApICsgY3VyTGVmdDtcblx0XHR9XG5cblx0XHRpZiAoIFwidXNpbmdcIiBpbiBvcHRpb25zICkge1xuXHRcdFx0b3B0aW9ucy51c2luZy5jYWxsKCBlbGVtLCBwcm9wcyApO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGN1ckVsZW0uY3NzKCBwcm9wcyApO1xuXHRcdH1cblx0fVxufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdC8vIG9mZnNldCgpIHJlbGF0ZXMgYW4gZWxlbWVudCdzIGJvcmRlciBib3ggdG8gdGhlIGRvY3VtZW50IG9yaWdpblxuXHRvZmZzZXQ6IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXG5cdFx0Ly8gUHJlc2VydmUgY2hhaW5pbmcgZm9yIHNldHRlclxuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiBvcHRpb25zID09PSB1bmRlZmluZWQgP1xuXHRcdFx0XHR0aGlzIDpcblx0XHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0XHRqUXVlcnkub2Zmc2V0LnNldE9mZnNldCggdGhpcywgb3B0aW9ucywgaSApO1xuXHRcdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0dmFyIHJlY3QsIHdpbixcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF07XG5cblx0XHRpZiAoICFlbGVtICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFJldHVybiB6ZXJvcyBmb3IgZGlzY29ubmVjdGVkIGFuZCBoaWRkZW4gKGRpc3BsYXk6IG5vbmUpIGVsZW1lbnRzIChnaC0yMzEwKVxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHRcdC8vIFJ1bm5pbmcgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IG9uIGFcblx0XHQvLyBkaXNjb25uZWN0ZWQgbm9kZSBpbiBJRSB0aHJvd3MgYW4gZXJyb3Jcblx0XHRpZiAoICFlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIHsgdG9wOiAwLCBsZWZ0OiAwIH07XG5cdFx0fVxuXG5cdFx0Ly8gR2V0IGRvY3VtZW50LXJlbGF0aXZlIHBvc2l0aW9uIGJ5IGFkZGluZyB2aWV3cG9ydCBzY3JvbGwgdG8gdmlld3BvcnQtcmVsYXRpdmUgZ0JDUlxuXHRcdHJlY3QgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdHdpbiA9IGVsZW0ub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldztcblx0XHRyZXR1cm4ge1xuXHRcdFx0dG9wOiByZWN0LnRvcCArIHdpbi5wYWdlWU9mZnNldCxcblx0XHRcdGxlZnQ6IHJlY3QubGVmdCArIHdpbi5wYWdlWE9mZnNldFxuXHRcdH07XG5cdH0sXG5cblx0Ly8gcG9zaXRpb24oKSByZWxhdGVzIGFuIGVsZW1lbnQncyBtYXJnaW4gYm94IHRvIGl0cyBvZmZzZXQgcGFyZW50J3MgcGFkZGluZyBib3hcblx0Ly8gVGhpcyBjb3JyZXNwb25kcyB0byB0aGUgYmVoYXZpb3Igb2YgQ1NTIGFic29sdXRlIHBvc2l0aW9uaW5nXG5cdHBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoICF0aGlzWyAwIF0gKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIG9mZnNldFBhcmVudCwgb2Zmc2V0LCBkb2MsXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdLFxuXHRcdFx0cGFyZW50T2Zmc2V0ID0geyB0b3A6IDAsIGxlZnQ6IDAgfTtcblxuXHRcdC8vIHBvc2l0aW9uOmZpeGVkIGVsZW1lbnRzIGFyZSBvZmZzZXQgZnJvbSB0aGUgdmlld3BvcnQsIHdoaWNoIGl0c2VsZiBhbHdheXMgaGFzIHplcm8gb2Zmc2V0XG5cdFx0aWYgKCBqUXVlcnkuY3NzKCBlbGVtLCBcInBvc2l0aW9uXCIgKSA9PT0gXCJmaXhlZFwiICkge1xuXG5cdFx0XHQvLyBBc3N1bWUgcG9zaXRpb246Zml4ZWQgaW1wbGllcyBhdmFpbGFiaWxpdHkgb2YgZ2V0Qm91bmRpbmdDbGllbnRSZWN0XG5cdFx0XHRvZmZzZXQgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdG9mZnNldCA9IHRoaXMub2Zmc2V0KCk7XG5cblx0XHRcdC8vIEFjY291bnQgZm9yIHRoZSAqcmVhbCogb2Zmc2V0IHBhcmVudCwgd2hpY2ggY2FuIGJlIHRoZSBkb2N1bWVudCBvciBpdHMgcm9vdCBlbGVtZW50XG5cdFx0XHQvLyB3aGVuIGEgc3RhdGljYWxseSBwb3NpdGlvbmVkIGVsZW1lbnQgaXMgaWRlbnRpZmllZFxuXHRcdFx0ZG9jID0gZWxlbS5vd25lckRvY3VtZW50O1xuXHRcdFx0b2Zmc2V0UGFyZW50ID0gZWxlbS5vZmZzZXRQYXJlbnQgfHwgZG9jLmRvY3VtZW50RWxlbWVudDtcblx0XHRcdHdoaWxlICggb2Zmc2V0UGFyZW50ICYmXG5cdFx0XHRcdCggb2Zmc2V0UGFyZW50ID09PSBkb2MuYm9keSB8fCBvZmZzZXRQYXJlbnQgPT09IGRvYy5kb2N1bWVudEVsZW1lbnQgKSAmJlxuXHRcdFx0XHRqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnQsIFwicG9zaXRpb25cIiApID09PSBcInN0YXRpY1wiICkge1xuXG5cdFx0XHRcdG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudC5wYXJlbnROb2RlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBvZmZzZXRQYXJlbnQgJiYgb2Zmc2V0UGFyZW50ICE9PSBlbGVtICYmIG9mZnNldFBhcmVudC5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdFx0XHQvLyBJbmNvcnBvcmF0ZSBib3JkZXJzIGludG8gaXRzIG9mZnNldCwgc2luY2UgdGhleSBhcmUgb3V0c2lkZSBpdHMgY29udGVudCBvcmlnaW5cblx0XHRcdFx0cGFyZW50T2Zmc2V0ID0galF1ZXJ5KCBvZmZzZXRQYXJlbnQgKS5vZmZzZXQoKTtcblx0XHRcdFx0cGFyZW50T2Zmc2V0LnRvcCArPSBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnQsIFwiYm9yZGVyVG9wV2lkdGhcIiwgdHJ1ZSApO1xuXHRcdFx0XHRwYXJlbnRPZmZzZXQubGVmdCArPSBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnQsIFwiYm9yZGVyTGVmdFdpZHRoXCIsIHRydWUgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBTdWJ0cmFjdCBwYXJlbnQgb2Zmc2V0cyBhbmQgZWxlbWVudCBtYXJnaW5zXG5cdFx0cmV0dXJuIHtcblx0XHRcdHRvcDogb2Zmc2V0LnRvcCAtIHBhcmVudE9mZnNldC50b3AgLSBqUXVlcnkuY3NzKCBlbGVtLCBcIm1hcmdpblRvcFwiLCB0cnVlICksXG5cdFx0XHRsZWZ0OiBvZmZzZXQubGVmdCAtIHBhcmVudE9mZnNldC5sZWZ0IC0galF1ZXJ5LmNzcyggZWxlbSwgXCJtYXJnaW5MZWZ0XCIsIHRydWUgKVxuXHRcdH07XG5cdH0sXG5cblx0Ly8gVGhpcyBtZXRob2Qgd2lsbCByZXR1cm4gZG9jdW1lbnRFbGVtZW50IGluIHRoZSBmb2xsb3dpbmcgY2FzZXM6XG5cdC8vIDEpIEZvciB0aGUgZWxlbWVudCBpbnNpZGUgdGhlIGlmcmFtZSB3aXRob3V0IG9mZnNldFBhcmVudCwgdGhpcyBtZXRob2Qgd2lsbCByZXR1cm5cblx0Ly8gICAgZG9jdW1lbnRFbGVtZW50IG9mIHRoZSBwYXJlbnQgd2luZG93XG5cdC8vIDIpIEZvciB0aGUgaGlkZGVuIG9yIGRldGFjaGVkIGVsZW1lbnRcblx0Ly8gMykgRm9yIGJvZHkgb3IgaHRtbCBlbGVtZW50LCBpLmUuIGluIGNhc2Ugb2YgdGhlIGh0bWwgbm9kZSAtIGl0IHdpbGwgcmV0dXJuIGl0c2VsZlxuXHQvL1xuXHQvLyBidXQgdGhvc2UgZXhjZXB0aW9ucyB3ZXJlIG5ldmVyIHByZXNlbnRlZCBhcyBhIHJlYWwgbGlmZSB1c2UtY2FzZXNcblx0Ly8gYW5kIG1pZ2h0IGJlIGNvbnNpZGVyZWQgYXMgbW9yZSBwcmVmZXJhYmxlIHJlc3VsdHMuXG5cdC8vXG5cdC8vIFRoaXMgbG9naWMsIGhvd2V2ZXIsIGlzIG5vdCBndWFyYW50ZWVkIGFuZCBjYW4gY2hhbmdlIGF0IGFueSBwb2ludCBpbiB0aGUgZnV0dXJlXG5cdG9mZnNldFBhcmVudDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBvZmZzZXRQYXJlbnQgPSB0aGlzLm9mZnNldFBhcmVudDtcblxuXHRcdFx0d2hpbGUgKCBvZmZzZXRQYXJlbnQgJiYgalF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcInBvc2l0aW9uXCIgKSA9PT0gXCJzdGF0aWNcIiApIHtcblx0XHRcdFx0b2Zmc2V0UGFyZW50ID0gb2Zmc2V0UGFyZW50Lm9mZnNldFBhcmVudDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG9mZnNldFBhcmVudCB8fCBkb2N1bWVudEVsZW1lbnQ7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbi8vIENyZWF0ZSBzY3JvbGxMZWZ0IGFuZCBzY3JvbGxUb3AgbWV0aG9kc1xualF1ZXJ5LmVhY2goIHsgc2Nyb2xsTGVmdDogXCJwYWdlWE9mZnNldFwiLCBzY3JvbGxUb3A6IFwicGFnZVlPZmZzZXRcIiB9LCBmdW5jdGlvbiggbWV0aG9kLCBwcm9wICkge1xuXHR2YXIgdG9wID0gXCJwYWdlWU9mZnNldFwiID09PSBwcm9wO1xuXG5cdGpRdWVyeS5mblsgbWV0aG9kIF0gPSBmdW5jdGlvbiggdmFsICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBtZXRob2QsIHZhbCApIHtcblxuXHRcdFx0Ly8gQ29hbGVzY2UgZG9jdW1lbnRzIGFuZCB3aW5kb3dzXG5cdFx0XHR2YXIgd2luO1xuXHRcdFx0aWYgKCBpc1dpbmRvdyggZWxlbSApICkge1xuXHRcdFx0XHR3aW4gPSBlbGVtO1xuXHRcdFx0fSBlbHNlIGlmICggZWxlbS5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0d2luID0gZWxlbS5kZWZhdWx0Vmlldztcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB2YWwgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHdpbiA/IHdpblsgcHJvcCBdIDogZWxlbVsgbWV0aG9kIF07XG5cdFx0XHR9XG5cblx0XHRcdGlmICggd2luICkge1xuXHRcdFx0XHR3aW4uc2Nyb2xsVG8oXG5cdFx0XHRcdFx0IXRvcCA/IHZhbCA6IHdpbi5wYWdlWE9mZnNldCxcblx0XHRcdFx0XHR0b3AgPyB2YWwgOiB3aW4ucGFnZVlPZmZzZXRcblx0XHRcdFx0KTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWxlbVsgbWV0aG9kIF0gPSB2YWw7XG5cdFx0XHR9XG5cdFx0fSwgbWV0aG9kLCB2YWwsIGFyZ3VtZW50cy5sZW5ndGggKTtcblx0fTtcbn0gKTtcblxuLy8gU3VwcG9ydDogU2FmYXJpIDw9NyAtIDkuMSwgQ2hyb21lIDw9MzcgLSA0OVxuLy8gQWRkIHRoZSB0b3AvbGVmdCBjc3NIb29rcyB1c2luZyBqUXVlcnkuZm4ucG9zaXRpb25cbi8vIFdlYmtpdCBidWc6IGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yOTA4NFxuLy8gQmxpbmsgYnVnOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD01ODkzNDdcbi8vIGdldENvbXB1dGVkU3R5bGUgcmV0dXJucyBwZXJjZW50IHdoZW4gc3BlY2lmaWVkIGZvciB0b3AvbGVmdC9ib3R0b20vcmlnaHQ7XG4vLyByYXRoZXIgdGhhbiBtYWtlIHRoZSBjc3MgbW9kdWxlIGRlcGVuZCBvbiB0aGUgb2Zmc2V0IG1vZHVsZSwganVzdCBjaGVjayBmb3IgaXQgaGVyZVxualF1ZXJ5LmVhY2goIFsgXCJ0b3BcIiwgXCJsZWZ0XCIgXSwgZnVuY3Rpb24oIF9pLCBwcm9wICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIHByb3AgXSA9IGFkZEdldEhvb2tJZiggc3VwcG9ydC5waXhlbFBvc2l0aW9uLFxuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0XHRcdGNvbXB1dGVkID0gY3VyQ1NTKCBlbGVtLCBwcm9wICk7XG5cblx0XHRcdFx0Ly8gSWYgY3VyQ1NTIHJldHVybnMgcGVyY2VudGFnZSwgZmFsbGJhY2sgdG8gb2Zmc2V0XG5cdFx0XHRcdHJldHVybiBybnVtbm9ucHgudGVzdCggY29tcHV0ZWQgKSA/XG5cdFx0XHRcdFx0alF1ZXJ5KCBlbGVtICkucG9zaXRpb24oKVsgcHJvcCBdICsgXCJweFwiIDpcblx0XHRcdFx0XHRjb21wdXRlZDtcblx0XHRcdH1cblx0XHR9XG5cdCk7XG59ICk7XG5cblxuLy8gQ3JlYXRlIGlubmVySGVpZ2h0LCBpbm5lcldpZHRoLCBoZWlnaHQsIHdpZHRoLCBvdXRlckhlaWdodCBhbmQgb3V0ZXJXaWR0aCBtZXRob2RzXG5qUXVlcnkuZWFjaCggeyBIZWlnaHQ6IFwiaGVpZ2h0XCIsIFdpZHRoOiBcIndpZHRoXCIgfSwgZnVuY3Rpb24oIG5hbWUsIHR5cGUgKSB7XG5cdGpRdWVyeS5lYWNoKCB7XG5cdFx0cGFkZGluZzogXCJpbm5lclwiICsgbmFtZSxcblx0XHRjb250ZW50OiB0eXBlLFxuXHRcdFwiXCI6IFwib3V0ZXJcIiArIG5hbWVcblx0fSwgZnVuY3Rpb24oIGRlZmF1bHRFeHRyYSwgZnVuY05hbWUgKSB7XG5cblx0XHQvLyBNYXJnaW4gaXMgb25seSBmb3Igb3V0ZXJIZWlnaHQsIG91dGVyV2lkdGhcblx0XHRqUXVlcnkuZm5bIGZ1bmNOYW1lIF0gPSBmdW5jdGlvbiggbWFyZ2luLCB2YWx1ZSApIHtcblx0XHRcdHZhciBjaGFpbmFibGUgPSBhcmd1bWVudHMubGVuZ3RoICYmICggZGVmYXVsdEV4dHJhIHx8IHR5cGVvZiBtYXJnaW4gIT09IFwiYm9vbGVhblwiICksXG5cdFx0XHRcdGV4dHJhID0gZGVmYXVsdEV4dHJhIHx8ICggbWFyZ2luID09PSB0cnVlIHx8IHZhbHVlID09PSB0cnVlID8gXCJtYXJnaW5cIiA6IFwiYm9yZGVyXCIgKTtcblxuXHRcdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIHR5cGUsIHZhbHVlICkge1xuXHRcdFx0XHR2YXIgZG9jO1xuXG5cdFx0XHRcdGlmICggaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0XHRcdC8vICQoIHdpbmRvdyApLm91dGVyV2lkdGgvSGVpZ2h0IHJldHVybiB3L2ggaW5jbHVkaW5nIHNjcm9sbGJhcnMgKGdoLTE3MjkpXG5cdFx0XHRcdFx0cmV0dXJuIGZ1bmNOYW1lLmluZGV4T2YoIFwib3V0ZXJcIiApID09PSAwID9cblx0XHRcdFx0XHRcdGVsZW1bIFwiaW5uZXJcIiArIG5hbWUgXSA6XG5cdFx0XHRcdFx0XHRlbGVtLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudFsgXCJjbGllbnRcIiArIG5hbWUgXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEdldCBkb2N1bWVudCB3aWR0aCBvciBoZWlnaHRcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdGRvYyA9IGVsZW0uZG9jdW1lbnRFbGVtZW50O1xuXG5cdFx0XHRcdFx0Ly8gRWl0aGVyIHNjcm9sbFtXaWR0aC9IZWlnaHRdIG9yIG9mZnNldFtXaWR0aC9IZWlnaHRdIG9yIGNsaWVudFtXaWR0aC9IZWlnaHRdLFxuXHRcdFx0XHRcdC8vIHdoaWNoZXZlciBpcyBncmVhdGVzdFxuXHRcdFx0XHRcdHJldHVybiBNYXRoLm1heChcblx0XHRcdFx0XHRcdGVsZW0uYm9keVsgXCJzY3JvbGxcIiArIG5hbWUgXSwgZG9jWyBcInNjcm9sbFwiICsgbmFtZSBdLFxuXHRcdFx0XHRcdFx0ZWxlbS5ib2R5WyBcIm9mZnNldFwiICsgbmFtZSBdLCBkb2NbIFwib2Zmc2V0XCIgKyBuYW1lIF0sXG5cdFx0XHRcdFx0XHRkb2NbIFwiY2xpZW50XCIgKyBuYW1lIF1cblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgP1xuXG5cdFx0XHRcdFx0Ly8gR2V0IHdpZHRoIG9yIGhlaWdodCBvbiB0aGUgZWxlbWVudCwgcmVxdWVzdGluZyBidXQgbm90IGZvcmNpbmcgcGFyc2VGbG9hdFxuXHRcdFx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIHR5cGUsIGV4dHJhICkgOlxuXG5cdFx0XHRcdFx0Ly8gU2V0IHdpZHRoIG9yIGhlaWdodCBvbiB0aGUgZWxlbWVudFxuXHRcdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgdHlwZSwgdmFsdWUsIGV4dHJhICk7XG5cdFx0XHR9LCB0eXBlLCBjaGFpbmFibGUgPyBtYXJnaW4gOiB1bmRlZmluZWQsIGNoYWluYWJsZSApO1xuXHRcdH07XG5cdH0gKTtcbn0gKTtcblxuXG5qUXVlcnkuZWFjaCggW1xuXHRcImFqYXhTdGFydFwiLFxuXHRcImFqYXhTdG9wXCIsXG5cdFwiYWpheENvbXBsZXRlXCIsXG5cdFwiYWpheEVycm9yXCIsXG5cdFwiYWpheFN1Y2Nlc3NcIixcblx0XCJhamF4U2VuZFwiXG5dLCBmdW5jdGlvbiggX2ksIHR5cGUgKSB7XG5cdGpRdWVyeS5mblsgdHlwZSBdID0gZnVuY3Rpb24oIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlLCBmbiApO1xuXHR9O1xufSApO1xuXG5cblxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0YmluZDogZnVuY3Rpb24oIHR5cGVzLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZXMsIG51bGwsIGRhdGEsIGZuICk7XG5cdH0sXG5cdHVuYmluZDogZnVuY3Rpb24oIHR5cGVzLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vZmYoIHR5cGVzLCBudWxsLCBmbiApO1xuXHR9LFxuXG5cdGRlbGVnYXRlOiBmdW5jdGlvbiggc2VsZWN0b3IsIHR5cGVzLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApO1xuXHR9LFxuXHR1bmRlbGVnYXRlOiBmdW5jdGlvbiggc2VsZWN0b3IsIHR5cGVzLCBmbiApIHtcblxuXHRcdC8vICggbmFtZXNwYWNlICkgb3IgKCBzZWxlY3RvciwgdHlwZXMgWywgZm5dIClcblx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/XG5cdFx0XHR0aGlzLm9mZiggc2VsZWN0b3IsIFwiKipcIiApIDpcblx0XHRcdHRoaXMub2ZmKCB0eXBlcywgc2VsZWN0b3IgfHwgXCIqKlwiLCBmbiApO1xuXHR9LFxuXG5cdGhvdmVyOiBmdW5jdGlvbiggZm5PdmVyLCBmbk91dCApIHtcblx0XHRyZXR1cm4gdGhpc1xuXHRcdFx0Lm9uKCBcIm1vdXNlZW50ZXJcIiwgZm5PdmVyIClcblx0XHRcdC5vbiggXCJtb3VzZWxlYXZlXCIsIGZuT3V0IHx8IGZuT3ZlciApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKFxuXHQoIFwiYmx1ciBmb2N1cyBmb2N1c2luIGZvY3Vzb3V0IHJlc2l6ZSBzY3JvbGwgY2xpY2sgZGJsY2xpY2sgXCIgK1xuXHRcIm1vdXNlZG93biBtb3VzZXVwIG1vdXNlbW92ZSBtb3VzZW92ZXIgbW91c2VvdXQgbW91c2VlbnRlciBtb3VzZWxlYXZlIFwiICtcblx0XCJjaGFuZ2Ugc2VsZWN0IHN1Ym1pdCBrZXlkb3duIGtleXByZXNzIGtleXVwIGNvbnRleHRtZW51XCIgKS5zcGxpdCggXCIgXCIgKSxcblx0ZnVuY3Rpb24oIF9pLCBuYW1lICkge1xuXG5cdFx0Ly8gSGFuZGxlIGV2ZW50IGJpbmRpbmdcblx0XHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBkYXRhLCBmbiApIHtcblx0XHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMCA/XG5cdFx0XHRcdHRoaXMub24oIG5hbWUsIG51bGwsIGRhdGEsIGZuICkgOlxuXHRcdFx0XHR0aGlzLnRyaWdnZXIoIG5hbWUgKTtcblx0XHR9O1xuXHR9XG4pO1xuXG5cblxuXG4vLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHlcbi8vIE1ha2Ugc3VyZSB3ZSB0cmltIEJPTSBhbmQgTkJTUFxuLy8gUmVxdWlyZSB0aGF0IHRoZSBcIndoaXRlc3BhY2UgcnVuXCIgc3RhcnRzIGZyb20gYSBub24td2hpdGVzcGFjZVxuLy8gdG8gYXZvaWQgTyhOXjIpIGJlaGF2aW9yIHdoZW4gdGhlIGVuZ2luZSB3b3VsZCB0cnkgbWF0Y2hpbmcgXCJcXHMrJFwiIGF0IGVhY2ggc3BhY2UgcG9zaXRpb24uXG52YXIgcnRyaW0gPSAvXltcXHNcXHVGRUZGXFx4QTBdK3woW15cXHNcXHVGRUZGXFx4QTBdKVtcXHNcXHVGRUZGXFx4QTBdKyQvZztcblxuLy8gQmluZCBhIGZ1bmN0aW9uIHRvIGEgY29udGV4dCwgb3B0aW9uYWxseSBwYXJ0aWFsbHkgYXBwbHlpbmcgYW55XG4vLyBhcmd1bWVudHMuXG4vLyBqUXVlcnkucHJveHkgaXMgZGVwcmVjYXRlZCB0byBwcm9tb3RlIHN0YW5kYXJkcyAoc3BlY2lmaWNhbGx5IEZ1bmN0aW9uI2JpbmQpXG4vLyBIb3dldmVyLCBpdCBpcyBub3Qgc2xhdGVkIGZvciByZW1vdmFsIGFueSB0aW1lIHNvb25cbmpRdWVyeS5wcm94eSA9IGZ1bmN0aW9uKCBmbiwgY29udGV4dCApIHtcblx0dmFyIHRtcCwgYXJncywgcHJveHk7XG5cblx0aWYgKCB0eXBlb2YgY29udGV4dCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHR0bXAgPSBmblsgY29udGV4dCBdO1xuXHRcdGNvbnRleHQgPSBmbjtcblx0XHRmbiA9IHRtcDtcblx0fVxuXG5cdC8vIFF1aWNrIGNoZWNrIHRvIGRldGVybWluZSBpZiB0YXJnZXQgaXMgY2FsbGFibGUsIGluIHRoZSBzcGVjXG5cdC8vIHRoaXMgdGhyb3dzIGEgVHlwZUVycm9yLCBidXQgd2Ugd2lsbCBqdXN0IHJldHVybiB1bmRlZmluZWQuXG5cdGlmICggIWlzRnVuY3Rpb24oIGZuICkgKSB7XG5cdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0fVxuXG5cdC8vIFNpbXVsYXRlZCBiaW5kXG5cdGFyZ3MgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMsIDIgKTtcblx0cHJveHkgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZm4uYXBwbHkoIGNvbnRleHQgfHwgdGhpcywgYXJncy5jb25jYXQoIHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApICkgKTtcblx0fTtcblxuXHQvLyBTZXQgdGhlIGd1aWQgb2YgdW5pcXVlIGhhbmRsZXIgdG8gdGhlIHNhbWUgb2Ygb3JpZ2luYWwgaGFuZGxlciwgc28gaXQgY2FuIGJlIHJlbW92ZWRcblx0cHJveHkuZ3VpZCA9IGZuLmd1aWQgPSBmbi5ndWlkIHx8IGpRdWVyeS5ndWlkKys7XG5cblx0cmV0dXJuIHByb3h5O1xufTtcblxualF1ZXJ5LmhvbGRSZWFkeSA9IGZ1bmN0aW9uKCBob2xkICkge1xuXHRpZiAoIGhvbGQgKSB7XG5cdFx0alF1ZXJ5LnJlYWR5V2FpdCsrO1xuXHR9IGVsc2Uge1xuXHRcdGpRdWVyeS5yZWFkeSggdHJ1ZSApO1xuXHR9XG59O1xualF1ZXJ5LmlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xualF1ZXJ5LnBhcnNlSlNPTiA9IEpTT04ucGFyc2U7XG5qUXVlcnkubm9kZU5hbWUgPSBub2RlTmFtZTtcbmpRdWVyeS5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcbmpRdWVyeS5pc1dpbmRvdyA9IGlzV2luZG93O1xualF1ZXJ5LmNhbWVsQ2FzZSA9IGNhbWVsQ2FzZTtcbmpRdWVyeS50eXBlID0gdG9UeXBlO1xuXG5qUXVlcnkubm93ID0gRGF0ZS5ub3c7XG5cbmpRdWVyeS5pc051bWVyaWMgPSBmdW5jdGlvbiggb2JqICkge1xuXG5cdC8vIEFzIG9mIGpRdWVyeSAzLjAsIGlzTnVtZXJpYyBpcyBsaW1pdGVkIHRvXG5cdC8vIHN0cmluZ3MgYW5kIG51bWJlcnMgKHByaW1pdGl2ZXMgb3Igb2JqZWN0cylcblx0Ly8gdGhhdCBjYW4gYmUgY29lcmNlZCB0byBmaW5pdGUgbnVtYmVycyAoZ2gtMjY2Milcblx0dmFyIHR5cGUgPSBqUXVlcnkudHlwZSggb2JqICk7XG5cdHJldHVybiAoIHR5cGUgPT09IFwibnVtYmVyXCIgfHwgdHlwZSA9PT0gXCJzdHJpbmdcIiApICYmXG5cblx0XHQvLyBwYXJzZUZsb2F0IE5hTnMgbnVtZXJpYy1jYXN0IGZhbHNlIHBvc2l0aXZlcyAoXCJcIilcblx0XHQvLyAuLi5idXQgbWlzaW50ZXJwcmV0cyBsZWFkaW5nLW51bWJlciBzdHJpbmdzLCBwYXJ0aWN1bGFybHkgaGV4IGxpdGVyYWxzIChcIjB4Li4uXCIpXG5cdFx0Ly8gc3VidHJhY3Rpb24gZm9yY2VzIGluZmluaXRpZXMgdG8gTmFOXG5cdFx0IWlzTmFOKCBvYmogLSBwYXJzZUZsb2F0KCBvYmogKSApO1xufTtcblxualF1ZXJ5LnRyaW0gPSBmdW5jdGlvbiggdGV4dCApIHtcblx0cmV0dXJuIHRleHQgPT0gbnVsbCA/XG5cdFx0XCJcIiA6XG5cdFx0KCB0ZXh0ICsgXCJcIiApLnJlcGxhY2UoIHJ0cmltLCBcIiQxXCIgKTtcbn07XG5cblxuXG4vLyBSZWdpc3RlciBhcyBhIG5hbWVkIEFNRCBtb2R1bGUsIHNpbmNlIGpRdWVyeSBjYW4gYmUgY29uY2F0ZW5hdGVkIHdpdGggb3RoZXJcbi8vIGZpbGVzIHRoYXQgbWF5IHVzZSBkZWZpbmUsIGJ1dCBub3QgdmlhIGEgcHJvcGVyIGNvbmNhdGVuYXRpb24gc2NyaXB0IHRoYXRcbi8vIHVuZGVyc3RhbmRzIGFub255bW91cyBBTUQgbW9kdWxlcy4gQSBuYW1lZCBBTUQgaXMgc2FmZXN0IGFuZCBtb3N0IHJvYnVzdFxuLy8gd2F5IHRvIHJlZ2lzdGVyLiBMb3dlcmNhc2UganF1ZXJ5IGlzIHVzZWQgYmVjYXVzZSBBTUQgbW9kdWxlIG5hbWVzIGFyZVxuLy8gZGVyaXZlZCBmcm9tIGZpbGUgbmFtZXMsIGFuZCBqUXVlcnkgaXMgbm9ybWFsbHkgZGVsaXZlcmVkIGluIGEgbG93ZXJjYXNlXG4vLyBmaWxlIG5hbWUuIERvIHRoaXMgYWZ0ZXIgY3JlYXRpbmcgdGhlIGdsb2JhbCBzbyB0aGF0IGlmIGFuIEFNRCBtb2R1bGUgd2FudHNcbi8vIHRvIGNhbGwgbm9Db25mbGljdCB0byBoaWRlIHRoaXMgdmVyc2lvbiBvZiBqUXVlcnksIGl0IHdpbGwgd29yay5cblxuLy8gTm90ZSB0aGF0IGZvciBtYXhpbXVtIHBvcnRhYmlsaXR5LCBsaWJyYXJpZXMgdGhhdCBhcmUgbm90IGpRdWVyeSBzaG91bGRcbi8vIGRlY2xhcmUgdGhlbXNlbHZlcyBhcyBhbm9ueW1vdXMgbW9kdWxlcywgYW5kIGF2b2lkIHNldHRpbmcgYSBnbG9iYWwgaWYgYW5cbi8vIEFNRCBsb2FkZXIgaXMgcHJlc2VudC4galF1ZXJ5IGlzIGEgc3BlY2lhbCBjYXNlLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlXG4vLyBodHRwczovL2dpdGh1Yi5jb20vanJidXJrZS9yZXF1aXJlanMvd2lraS9VcGRhdGluZy1leGlzdGluZy1saWJyYXJpZXMjd2lraS1hbm9uXG5cbmlmICggdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQgKSB7XG5cdGRlZmluZSggXCJqcXVlcnlcIiwgW10sIGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBqUXVlcnk7XG5cdH0gKTtcbn1cblxuXG5cblxudmFyXG5cblx0Ly8gTWFwIG92ZXIgalF1ZXJ5IGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG5cdF9qUXVlcnkgPSB3aW5kb3cualF1ZXJ5LFxuXG5cdC8vIE1hcCBvdmVyIHRoZSAkIGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG5cdF8kID0gd2luZG93LiQ7XG5cbmpRdWVyeS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oIGRlZXAgKSB7XG5cdGlmICggd2luZG93LiQgPT09IGpRdWVyeSApIHtcblx0XHR3aW5kb3cuJCA9IF8kO1xuXHR9XG5cblx0aWYgKCBkZWVwICYmIHdpbmRvdy5qUXVlcnkgPT09IGpRdWVyeSApIHtcblx0XHR3aW5kb3cualF1ZXJ5ID0gX2pRdWVyeTtcblx0fVxuXG5cdHJldHVybiBqUXVlcnk7XG59O1xuXG4vLyBFeHBvc2UgalF1ZXJ5IGFuZCAkIGlkZW50aWZpZXJzLCBldmVuIGluIEFNRFxuLy8gKHRyYWMtNzEwMiNjb21tZW50OjEwLCBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9wdWxsLzU1Nylcbi8vIGFuZCBDb21tb25KUyBmb3IgYnJvd3NlciBlbXVsYXRvcnMgKHRyYWMtMTM1NjYpXG5pZiAoIHR5cGVvZiBub0dsb2JhbCA9PT0gXCJ1bmRlZmluZWRcIiApIHtcblx0d2luZG93LmpRdWVyeSA9IHdpbmRvdy4kID0galF1ZXJ5O1xufVxuXG5cblxuXG5yZXR1cm4galF1ZXJ5O1xufSApO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGlzQ2FsbGFibGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtY2FsbGFibGUnKTtcbnZhciB0cnlUb1N0cmluZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90cnktdG8tc3RyaW5nJyk7XG5cbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xuXG4vLyBgQXNzZXJ0OiBJc0NhbGxhYmxlKGFyZ3VtZW50KSBpcyB0cnVlYFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgaWYgKGlzQ2FsbGFibGUoYXJndW1lbnQpKSByZXR1cm4gYXJndW1lbnQ7XG4gIHRocm93IG5ldyAkVHlwZUVycm9yKHRyeVRvU3RyaW5nKGFyZ3VtZW50KSArICcgaXMgbm90IGEgZnVuY3Rpb24nKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgaXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1jb25zdHJ1Y3RvcicpO1xudmFyIHRyeVRvU3RyaW5nID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RyeS10by1zdHJpbmcnKTtcblxudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG5cbi8vIGBBc3NlcnQ6IElzQ29uc3RydWN0b3IoYXJndW1lbnQpIGlzIHRydWVgXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICBpZiAoaXNDb25zdHJ1Y3Rvcihhcmd1bWVudCkpIHJldHVybiBhcmd1bWVudDtcbiAgdGhyb3cgbmV3ICRUeXBlRXJyb3IodHJ5VG9TdHJpbmcoYXJndW1lbnQpICsgJyBpcyBub3QgYSBjb25zdHJ1Y3RvcicpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBpc1Bvc3NpYmxlUHJvdG90eXBlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLXBvc3NpYmxlLXByb3RvdHlwZScpO1xuXG52YXIgJFN0cmluZyA9IFN0cmluZztcbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICBpZiAoaXNQb3NzaWJsZVByb3RvdHlwZShhcmd1bWVudCkpIHJldHVybiBhcmd1bWVudDtcbiAgdGhyb3cgbmV3ICRUeXBlRXJyb3IoXCJDYW4ndCBzZXQgXCIgKyAkU3RyaW5nKGFyZ3VtZW50KSArICcgYXMgYSBwcm90b3R5cGUnKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG52YXIgY3JlYXRlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1jcmVhdGUnKTtcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5JykuZjtcblxudmFyIFVOU0NPUEFCTEVTID0gd2VsbEtub3duU3ltYm9sKCd1bnNjb3BhYmxlcycpO1xudmFyIEFycmF5UHJvdG90eXBlID0gQXJyYXkucHJvdG90eXBlO1xuXG4vLyBBcnJheS5wcm90b3R5cGVbQEB1bnNjb3BhYmxlc11cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLUBAdW5zY29wYWJsZXNcbmlmIChBcnJheVByb3RvdHlwZVtVTlNDT1BBQkxFU10gPT09IHVuZGVmaW5lZCkge1xuICBkZWZpbmVQcm9wZXJ0eShBcnJheVByb3RvdHlwZSwgVU5TQ09QQUJMRVMsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgdmFsdWU6IGNyZWF0ZShudWxsKVxuICB9KTtcbn1cblxuLy8gYWRkIGEga2V5IHRvIEFycmF5LnByb3RvdHlwZVtAQHVuc2NvcGFibGVzXVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIEFycmF5UHJvdG90eXBlW1VOU0NPUEFCTEVTXVtrZXldID0gdHJ1ZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgY2hhckF0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3N0cmluZy1tdWx0aWJ5dGUnKS5jaGFyQXQ7XG5cbi8vIGBBZHZhbmNlU3RyaW5nSW5kZXhgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hZHZhbmNlc3RyaW5naW5kZXhcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFMsIGluZGV4LCB1bmljb2RlKSB7XG4gIHJldHVybiBpbmRleCArICh1bmljb2RlID8gY2hhckF0KFMsIGluZGV4KS5sZW5ndGggOiAxKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG5cbnZhciAkU3RyaW5nID0gU3RyaW5nO1xudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG5cbi8vIGBBc3NlcnQ6IFR5cGUoYXJndW1lbnQpIGlzIE9iamVjdGBcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIGlmIChpc09iamVjdChhcmd1bWVudCkpIHJldHVybiBhcmd1bWVudDtcbiAgdGhyb3cgbmV3ICRUeXBlRXJyb3IoJFN0cmluZyhhcmd1bWVudCkgKyAnIGlzIG5vdCBhbiBvYmplY3QnKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tdHlwZWQtYXJyYXlzIC0tIHNhZmVcbm1vZHVsZS5leHBvcnRzID0gdHlwZW9mIEFycmF5QnVmZmVyICE9ICd1bmRlZmluZWQnICYmIHR5cGVvZiBEYXRhVmlldyAhPSAndW5kZWZpbmVkJztcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBOQVRJVkVfQVJSQVlfQlVGRkVSID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWJ1ZmZlci1iYXNpYy1kZXRlY3Rpb24nKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBpc0NhbGxhYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWNhbGxhYmxlJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG52YXIgaGFzT3duID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcy1vd24tcHJvcGVydHknKTtcbnZhciBjbGFzc29mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NsYXNzb2YnKTtcbnZhciB0cnlUb1N0cmluZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90cnktdG8tc3RyaW5nJyk7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1ub24tZW51bWVyYWJsZS1wcm9wZXJ0eScpO1xudmFyIGRlZmluZUJ1aWx0SW4gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVmaW5lLWJ1aWx0LWluJyk7XG52YXIgZGVmaW5lQnVpbHRJbkFjY2Vzc29yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RlZmluZS1idWlsdC1pbi1hY2Nlc3NvcicpO1xudmFyIGlzUHJvdG90eXBlT2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWlzLXByb3RvdHlwZS1vZicpO1xudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtcHJvdG90eXBlLW9mJyk7XG52YXIgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LXNldC1wcm90b3R5cGUtb2YnKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdWlkJyk7XG52YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pbnRlcm5hbC1zdGF0ZScpO1xuXG52YXIgZW5mb3JjZUludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmVuZm9yY2U7XG52YXIgZ2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuZ2V0O1xudmFyIEludDhBcnJheSA9IGdsb2JhbC5JbnQ4QXJyYXk7XG52YXIgSW50OEFycmF5UHJvdG90eXBlID0gSW50OEFycmF5ICYmIEludDhBcnJheS5wcm90b3R5cGU7XG52YXIgVWludDhDbGFtcGVkQXJyYXkgPSBnbG9iYWwuVWludDhDbGFtcGVkQXJyYXk7XG52YXIgVWludDhDbGFtcGVkQXJyYXlQcm90b3R5cGUgPSBVaW50OENsYW1wZWRBcnJheSAmJiBVaW50OENsYW1wZWRBcnJheS5wcm90b3R5cGU7XG52YXIgVHlwZWRBcnJheSA9IEludDhBcnJheSAmJiBnZXRQcm90b3R5cGVPZihJbnQ4QXJyYXkpO1xudmFyIFR5cGVkQXJyYXlQcm90b3R5cGUgPSBJbnQ4QXJyYXlQcm90b3R5cGUgJiYgZ2V0UHJvdG90eXBlT2YoSW50OEFycmF5UHJvdG90eXBlKTtcbnZhciBPYmplY3RQcm90b3R5cGUgPSBPYmplY3QucHJvdG90eXBlO1xudmFyIFR5cGVFcnJvciA9IGdsb2JhbC5UeXBlRXJyb3I7XG5cbnZhciBUT19TVFJJTkdfVEFHID0gd2VsbEtub3duU3ltYm9sKCd0b1N0cmluZ1RhZycpO1xudmFyIFRZUEVEX0FSUkFZX1RBRyA9IHVpZCgnVFlQRURfQVJSQVlfVEFHJyk7XG52YXIgVFlQRURfQVJSQVlfQ09OU1RSVUNUT1IgPSAnVHlwZWRBcnJheUNvbnN0cnVjdG9yJztcbi8vIEZpeGluZyBuYXRpdmUgdHlwZWQgYXJyYXlzIGluIE9wZXJhIFByZXN0byBjcmFzaGVzIHRoZSBicm93c2VyLCBzZWUgIzU5NVxudmFyIE5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MgPSBOQVRJVkVfQVJSQVlfQlVGRkVSICYmICEhc2V0UHJvdG90eXBlT2YgJiYgY2xhc3NvZihnbG9iYWwub3BlcmEpICE9PSAnT3BlcmEnO1xudmFyIFRZUEVEX0FSUkFZX1RBR19SRVFVSVJFRCA9IGZhbHNlO1xudmFyIE5BTUUsIENvbnN0cnVjdG9yLCBQcm90b3R5cGU7XG5cbnZhciBUeXBlZEFycmF5Q29uc3RydWN0b3JzTGlzdCA9IHtcbiAgSW50OEFycmF5OiAxLFxuICBVaW50OEFycmF5OiAxLFxuICBVaW50OENsYW1wZWRBcnJheTogMSxcbiAgSW50MTZBcnJheTogMixcbiAgVWludDE2QXJyYXk6IDIsXG4gIEludDMyQXJyYXk6IDQsXG4gIFVpbnQzMkFycmF5OiA0LFxuICBGbG9hdDMyQXJyYXk6IDQsXG4gIEZsb2F0NjRBcnJheTogOFxufTtcblxudmFyIEJpZ0ludEFycmF5Q29uc3RydWN0b3JzTGlzdCA9IHtcbiAgQmlnSW50NjRBcnJheTogOCxcbiAgQmlnVWludDY0QXJyYXk6IDhcbn07XG5cbnZhciBpc1ZpZXcgPSBmdW5jdGlvbiBpc1ZpZXcoaXQpIHtcbiAgaWYgKCFpc09iamVjdChpdCkpIHJldHVybiBmYWxzZTtcbiAgdmFyIGtsYXNzID0gY2xhc3NvZihpdCk7XG4gIHJldHVybiBrbGFzcyA9PT0gJ0RhdGFWaWV3J1xuICAgIHx8IGhhc093bihUeXBlZEFycmF5Q29uc3RydWN0b3JzTGlzdCwga2xhc3MpXG4gICAgfHwgaGFzT3duKEJpZ0ludEFycmF5Q29uc3RydWN0b3JzTGlzdCwga2xhc3MpO1xufTtcblxudmFyIGdldFR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgcHJvdG8gPSBnZXRQcm90b3R5cGVPZihpdCk7XG4gIGlmICghaXNPYmplY3QocHJvdG8pKSByZXR1cm47XG4gIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUocHJvdG8pO1xuICByZXR1cm4gKHN0YXRlICYmIGhhc093bihzdGF0ZSwgVFlQRURfQVJSQVlfQ09OU1RSVUNUT1IpKSA/IHN0YXRlW1RZUEVEX0FSUkFZX0NPTlNUUlVDVE9SXSA6IGdldFR5cGVkQXJyYXlDb25zdHJ1Y3Rvcihwcm90byk7XG59O1xuXG52YXIgaXNUeXBlZEFycmF5ID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmICghaXNPYmplY3QoaXQpKSByZXR1cm4gZmFsc2U7XG4gIHZhciBrbGFzcyA9IGNsYXNzb2YoaXQpO1xuICByZXR1cm4gaGFzT3duKFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnNMaXN0LCBrbGFzcylcbiAgICB8fCBoYXNPd24oQmlnSW50QXJyYXlDb25zdHJ1Y3RvcnNMaXN0LCBrbGFzcyk7XG59O1xuXG52YXIgYVR5cGVkQXJyYXkgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGlzVHlwZWRBcnJheShpdCkpIHJldHVybiBpdDtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGFyZ2V0IGlzIG5vdCBhIHR5cGVkIGFycmF5Jyk7XG59O1xuXG52YXIgYVR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIChDKSB7XG4gIGlmIChpc0NhbGxhYmxlKEMpICYmICghc2V0UHJvdG90eXBlT2YgfHwgaXNQcm90b3R5cGVPZihUeXBlZEFycmF5LCBDKSkpIHJldHVybiBDO1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKHRyeVRvU3RyaW5nKEMpICsgJyBpcyBub3QgYSB0eXBlZCBhcnJheSBjb25zdHJ1Y3RvcicpO1xufTtcblxudmFyIGV4cG9ydFR5cGVkQXJyYXlNZXRob2QgPSBmdW5jdGlvbiAoS0VZLCBwcm9wZXJ0eSwgZm9yY2VkLCBvcHRpb25zKSB7XG4gIGlmICghREVTQ1JJUFRPUlMpIHJldHVybjtcbiAgaWYgKGZvcmNlZCkgZm9yICh2YXIgQVJSQVkgaW4gVHlwZWRBcnJheUNvbnN0cnVjdG9yc0xpc3QpIHtcbiAgICB2YXIgVHlwZWRBcnJheUNvbnN0cnVjdG9yID0gZ2xvYmFsW0FSUkFZXTtcbiAgICBpZiAoVHlwZWRBcnJheUNvbnN0cnVjdG9yICYmIGhhc093bihUeXBlZEFycmF5Q29uc3RydWN0b3IucHJvdG90eXBlLCBLRVkpKSB0cnkge1xuICAgICAgZGVsZXRlIFR5cGVkQXJyYXlDb25zdHJ1Y3Rvci5wcm90b3R5cGVbS0VZXTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gb2xkIFdlYktpdCBidWcgLSBzb21lIG1ldGhvZHMgYXJlIG5vbi1jb25maWd1cmFibGVcbiAgICAgIHRyeSB7XG4gICAgICAgIFR5cGVkQXJyYXlDb25zdHJ1Y3Rvci5wcm90b3R5cGVbS0VZXSA9IHByb3BlcnR5O1xuICAgICAgfSBjYXRjaCAoZXJyb3IyKSB7IC8qIGVtcHR5ICovIH1cbiAgICB9XG4gIH1cbiAgaWYgKCFUeXBlZEFycmF5UHJvdG90eXBlW0tFWV0gfHwgZm9yY2VkKSB7XG4gICAgZGVmaW5lQnVpbHRJbihUeXBlZEFycmF5UHJvdG90eXBlLCBLRVksIGZvcmNlZCA/IHByb3BlcnR5XG4gICAgICA6IE5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MgJiYgSW50OEFycmF5UHJvdG90eXBlW0tFWV0gfHwgcHJvcGVydHksIG9wdGlvbnMpO1xuICB9XG59O1xuXG52YXIgZXhwb3J0VHlwZWRBcnJheVN0YXRpY01ldGhvZCA9IGZ1bmN0aW9uIChLRVksIHByb3BlcnR5LCBmb3JjZWQpIHtcbiAgdmFyIEFSUkFZLCBUeXBlZEFycmF5Q29uc3RydWN0b3I7XG4gIGlmICghREVTQ1JJUFRPUlMpIHJldHVybjtcbiAgaWYgKHNldFByb3RvdHlwZU9mKSB7XG4gICAgaWYgKGZvcmNlZCkgZm9yIChBUlJBWSBpbiBUeXBlZEFycmF5Q29uc3RydWN0b3JzTGlzdCkge1xuICAgICAgVHlwZWRBcnJheUNvbnN0cnVjdG9yID0gZ2xvYmFsW0FSUkFZXTtcbiAgICAgIGlmIChUeXBlZEFycmF5Q29uc3RydWN0b3IgJiYgaGFzT3duKFR5cGVkQXJyYXlDb25zdHJ1Y3RvciwgS0VZKSkgdHJ5IHtcbiAgICAgICAgZGVsZXRlIFR5cGVkQXJyYXlDb25zdHJ1Y3RvcltLRVldO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICAgIH1cbiAgICBpZiAoIVR5cGVkQXJyYXlbS0VZXSB8fCBmb3JjZWQpIHtcbiAgICAgIC8vIFY4IH4gQ2hyb21lIDQ5LTUwIGAlVHlwZWRBcnJheSVgIG1ldGhvZHMgYXJlIG5vbi13cml0YWJsZSBub24tY29uZmlndXJhYmxlXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gZGVmaW5lQnVpbHRJbihUeXBlZEFycmF5LCBLRVksIGZvcmNlZCA/IHByb3BlcnR5IDogTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUyAmJiBUeXBlZEFycmF5W0tFWV0gfHwgcHJvcGVydHkpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICAgIH0gZWxzZSByZXR1cm47XG4gIH1cbiAgZm9yIChBUlJBWSBpbiBUeXBlZEFycmF5Q29uc3RydWN0b3JzTGlzdCkge1xuICAgIFR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IGdsb2JhbFtBUlJBWV07XG4gICAgaWYgKFR5cGVkQXJyYXlDb25zdHJ1Y3RvciAmJiAoIVR5cGVkQXJyYXlDb25zdHJ1Y3RvcltLRVldIHx8IGZvcmNlZCkpIHtcbiAgICAgIGRlZmluZUJ1aWx0SW4oVHlwZWRBcnJheUNvbnN0cnVjdG9yLCBLRVksIHByb3BlcnR5KTtcbiAgICB9XG4gIH1cbn07XG5cbmZvciAoTkFNRSBpbiBUeXBlZEFycmF5Q29uc3RydWN0b3JzTGlzdCkge1xuICBDb25zdHJ1Y3RvciA9IGdsb2JhbFtOQU1FXTtcbiAgUHJvdG90eXBlID0gQ29uc3RydWN0b3IgJiYgQ29uc3RydWN0b3IucHJvdG90eXBlO1xuICBpZiAoUHJvdG90eXBlKSBlbmZvcmNlSW50ZXJuYWxTdGF0ZShQcm90b3R5cGUpW1RZUEVEX0FSUkFZX0NPTlNUUlVDVE9SXSA9IENvbnN0cnVjdG9yO1xuICBlbHNlIE5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MgPSBmYWxzZTtcbn1cblxuZm9yIChOQU1FIGluIEJpZ0ludEFycmF5Q29uc3RydWN0b3JzTGlzdCkge1xuICBDb25zdHJ1Y3RvciA9IGdsb2JhbFtOQU1FXTtcbiAgUHJvdG90eXBlID0gQ29uc3RydWN0b3IgJiYgQ29uc3RydWN0b3IucHJvdG90eXBlO1xuICBpZiAoUHJvdG90eXBlKSBlbmZvcmNlSW50ZXJuYWxTdGF0ZShQcm90b3R5cGUpW1RZUEVEX0FSUkFZX0NPTlNUUlVDVE9SXSA9IENvbnN0cnVjdG9yO1xufVxuXG4vLyBXZWJLaXQgYnVnIC0gdHlwZWQgYXJyYXlzIGNvbnN0cnVjdG9ycyBwcm90b3R5cGUgaXMgT2JqZWN0LnByb3RvdHlwZVxuaWYgKCFOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTIHx8ICFpc0NhbGxhYmxlKFR5cGVkQXJyYXkpIHx8IFR5cGVkQXJyYXkgPT09IEZ1bmN0aW9uLnByb3RvdHlwZSkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2hhZG93IC0tIHNhZmVcbiAgVHlwZWRBcnJheSA9IGZ1bmN0aW9uIFR5cGVkQXJyYXkoKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW5jb3JyZWN0IGludm9jYXRpb24nKTtcbiAgfTtcbiAgaWYgKE5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MpIGZvciAoTkFNRSBpbiBUeXBlZEFycmF5Q29uc3RydWN0b3JzTGlzdCkge1xuICAgIGlmIChnbG9iYWxbTkFNRV0pIHNldFByb3RvdHlwZU9mKGdsb2JhbFtOQU1FXSwgVHlwZWRBcnJheSk7XG4gIH1cbn1cblxuaWYgKCFOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTIHx8ICFUeXBlZEFycmF5UHJvdG90eXBlIHx8IFR5cGVkQXJyYXlQcm90b3R5cGUgPT09IE9iamVjdFByb3RvdHlwZSkge1xuICBUeXBlZEFycmF5UHJvdG90eXBlID0gVHlwZWRBcnJheS5wcm90b3R5cGU7XG4gIGlmIChOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTKSBmb3IgKE5BTUUgaW4gVHlwZWRBcnJheUNvbnN0cnVjdG9yc0xpc3QpIHtcbiAgICBpZiAoZ2xvYmFsW05BTUVdKSBzZXRQcm90b3R5cGVPZihnbG9iYWxbTkFNRV0ucHJvdG90eXBlLCBUeXBlZEFycmF5UHJvdG90eXBlKTtcbiAgfVxufVxuXG4vLyBXZWJLaXQgYnVnIC0gb25lIG1vcmUgb2JqZWN0IGluIFVpbnQ4Q2xhbXBlZEFycmF5IHByb3RvdHlwZSBjaGFpblxuaWYgKE5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MgJiYgZ2V0UHJvdG90eXBlT2YoVWludDhDbGFtcGVkQXJyYXlQcm90b3R5cGUpICE9PSBUeXBlZEFycmF5UHJvdG90eXBlKSB7XG4gIHNldFByb3RvdHlwZU9mKFVpbnQ4Q2xhbXBlZEFycmF5UHJvdG90eXBlLCBUeXBlZEFycmF5UHJvdG90eXBlKTtcbn1cblxuaWYgKERFU0NSSVBUT1JTICYmICFoYXNPd24oVHlwZWRBcnJheVByb3RvdHlwZSwgVE9fU1RSSU5HX1RBRykpIHtcbiAgVFlQRURfQVJSQVlfVEFHX1JFUVVJUkVEID0gdHJ1ZTtcbiAgZGVmaW5lQnVpbHRJbkFjY2Vzc29yKFR5cGVkQXJyYXlQcm90b3R5cGUsIFRPX1NUUklOR19UQUcsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3QodGhpcykgPyB0aGlzW1RZUEVEX0FSUkFZX1RBR10gOiB1bmRlZmluZWQ7XG4gICAgfVxuICB9KTtcbiAgZm9yIChOQU1FIGluIFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnNMaXN0KSBpZiAoZ2xvYmFsW05BTUVdKSB7XG4gICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KGdsb2JhbFtOQU1FXSwgVFlQRURfQVJSQVlfVEFHLCBOQU1FKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUzogTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUyxcbiAgVFlQRURfQVJSQVlfVEFHOiBUWVBFRF9BUlJBWV9UQUdfUkVRVUlSRUQgJiYgVFlQRURfQVJSQVlfVEFHLFxuICBhVHlwZWRBcnJheTogYVR5cGVkQXJyYXksXG4gIGFUeXBlZEFycmF5Q29uc3RydWN0b3I6IGFUeXBlZEFycmF5Q29uc3RydWN0b3IsXG4gIGV4cG9ydFR5cGVkQXJyYXlNZXRob2Q6IGV4cG9ydFR5cGVkQXJyYXlNZXRob2QsXG4gIGV4cG9ydFR5cGVkQXJyYXlTdGF0aWNNZXRob2Q6IGV4cG9ydFR5cGVkQXJyYXlTdGF0aWNNZXRob2QsXG4gIGdldFR5cGVkQXJyYXlDb25zdHJ1Y3RvcjogZ2V0VHlwZWRBcnJheUNvbnN0cnVjdG9yLFxuICBpc1ZpZXc6IGlzVmlldyxcbiAgaXNUeXBlZEFycmF5OiBpc1R5cGVkQXJyYXksXG4gIFR5cGVkQXJyYXk6IFR5cGVkQXJyYXksXG4gIFR5cGVkQXJyYXlQcm90b3R5cGU6IFR5cGVkQXJyYXlQcm90b3R5cGVcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgdG9JbmRleGVkT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0Jyk7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWFic29sdXRlLWluZGV4Jyk7XG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvbGVuZ3RoLW9mLWFycmF5LWxpa2UnKTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS57IGluZGV4T2YsIGluY2x1ZGVzIH1gIG1ldGhvZHMgaW1wbGVtZW50YXRpb25cbnZhciBjcmVhdGVNZXRob2QgPSBmdW5jdGlvbiAoSVNfSU5DTFVERVMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgZWwsIGZyb21JbmRleCkge1xuICAgIHZhciBPID0gdG9JbmRleGVkT2JqZWN0KCR0aGlzKTtcbiAgICB2YXIgbGVuZ3RoID0gbGVuZ3RoT2ZBcnJheUxpa2UoTyk7XG4gICAgdmFyIGluZGV4ID0gdG9BYnNvbHV0ZUluZGV4KGZyb21JbmRleCwgbGVuZ3RoKTtcbiAgICB2YXIgdmFsdWU7XG4gICAgLy8gQXJyYXkjaW5jbHVkZXMgdXNlcyBTYW1lVmFsdWVaZXJvIGVxdWFsaXR5IGFsZ29yaXRobVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmUgLS0gTmFOIGNoZWNrXG4gICAgaWYgKElTX0lOQ0xVREVTICYmIGVsICE9PSBlbCkgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSB7XG4gICAgICB2YWx1ZSA9IE9baW5kZXgrK107XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlIC0tIE5hTiBjaGVja1xuICAgICAgaWYgKHZhbHVlICE9PSB2YWx1ZSkgcmV0dXJuIHRydWU7XG4gICAgLy8gQXJyYXkjaW5kZXhPZiBpZ25vcmVzIGhvbGVzLCBBcnJheSNpbmNsdWRlcyAtIG5vdFxuICAgIH0gZWxzZSBmb3IgKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xuICAgICAgaWYgKChJU19JTkNMVURFUyB8fCBpbmRleCBpbiBPKSAmJiBPW2luZGV4XSA9PT0gZWwpIHJldHVybiBJU19JTkNMVURFUyB8fCBpbmRleCB8fCAwO1xuICAgIH0gcmV0dXJuICFJU19JTkNMVURFUyAmJiAtMTtcbiAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvLyBgQXJyYXkucHJvdG90eXBlLmluY2x1ZGVzYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuaW5jbHVkZXNcbiAgaW5jbHVkZXM6IGNyZWF0ZU1ldGhvZCh0cnVlKSxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5pbmRleE9mYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuaW5kZXhvZlxuICBpbmRleE9mOiBjcmVhdGVNZXRob2QoZmFsc2UpXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE1FVEhPRF9OQU1FLCBhcmd1bWVudCkge1xuICB2YXIgbWV0aG9kID0gW11bTUVUSE9EX05BTUVdO1xuICByZXR1cm4gISFtZXRob2QgJiYgZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2VsZXNzLWNhbGwgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiAgICBtZXRob2QuY2FsbChudWxsLCBhcmd1bWVudCB8fCBmdW5jdGlvbiAoKSB7IHJldHVybiAxOyB9LCAxKTtcbiAgfSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGFDYWxsYWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hLWNhbGxhYmxlJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tb2JqZWN0Jyk7XG52YXIgSW5kZXhlZE9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pbmRleGVkLW9iamVjdCcpO1xudmFyIGxlbmd0aE9mQXJyYXlMaWtlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2xlbmd0aC1vZi1hcnJheS1saWtlJyk7XG5cbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLnsgcmVkdWNlLCByZWR1Y2VSaWdodCB9YCBtZXRob2RzIGltcGxlbWVudGF0aW9uXG52YXIgY3JlYXRlTWV0aG9kID0gZnVuY3Rpb24gKElTX1JJR0hUKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodGhhdCwgY2FsbGJhY2tmbiwgYXJndW1lbnRzTGVuZ3RoLCBtZW1vKSB7XG4gICAgdmFyIE8gPSB0b09iamVjdCh0aGF0KTtcbiAgICB2YXIgc2VsZiA9IEluZGV4ZWRPYmplY3QoTyk7XG4gICAgdmFyIGxlbmd0aCA9IGxlbmd0aE9mQXJyYXlMaWtlKE8pO1xuICAgIGFDYWxsYWJsZShjYWxsYmFja2ZuKTtcbiAgICB2YXIgaW5kZXggPSBJU19SSUdIVCA/IGxlbmd0aCAtIDEgOiAwO1xuICAgIHZhciBpID0gSVNfUklHSFQgPyAtMSA6IDE7XG4gICAgaWYgKGFyZ3VtZW50c0xlbmd0aCA8IDIpIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAoaW5kZXggaW4gc2VsZikge1xuICAgICAgICBtZW1vID0gc2VsZltpbmRleF07XG4gICAgICAgIGluZGV4ICs9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaW5kZXggKz0gaTtcbiAgICAgIGlmIChJU19SSUdIVCA/IGluZGV4IDwgMCA6IGxlbmd0aCA8PSBpbmRleCkge1xuICAgICAgICB0aHJvdyBuZXcgJFR5cGVFcnJvcignUmVkdWNlIG9mIGVtcHR5IGFycmF5IHdpdGggbm8gaW5pdGlhbCB2YWx1ZScpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKDtJU19SSUdIVCA/IGluZGV4ID49IDAgOiBsZW5ndGggPiBpbmRleDsgaW5kZXggKz0gaSkgaWYgKGluZGV4IGluIHNlbGYpIHtcbiAgICAgIG1lbW8gPSBjYWxsYmFja2ZuKG1lbW8sIHNlbGZbaW5kZXhdLCBpbmRleCwgTyk7XG4gICAgfVxuICAgIHJldHVybiBtZW1vO1xuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vIGBBcnJheS5wcm90b3R5cGUucmVkdWNlYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUucmVkdWNlXG4gIGxlZnQ6IGNyZWF0ZU1ldGhvZChmYWxzZSksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUucmVkdWNlUmlnaHRgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5yZWR1Y2VyaWdodFxuICByaWdodDogY3JlYXRlTWV0aG9kKHRydWUpXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHVuY3VycnlUaGlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHVuY3VycnlUaGlzKFtdLnNsaWNlKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBhcnJheVNsaWNlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LXNsaWNlJyk7XG5cbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG5cbnZhciBzb3J0ID0gZnVuY3Rpb24gKGFycmF5LCBjb21wYXJlZm4pIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBpZiAobGVuZ3RoIDwgOCkge1xuICAgIC8vIGluc2VydGlvbiBzb3J0XG4gICAgdmFyIGkgPSAxO1xuICAgIHZhciBlbGVtZW50LCBqO1xuXG4gICAgd2hpbGUgKGkgPCBsZW5ndGgpIHtcbiAgICAgIGogPSBpO1xuICAgICAgZWxlbWVudCA9IGFycmF5W2ldO1xuICAgICAgd2hpbGUgKGogJiYgY29tcGFyZWZuKGFycmF5W2ogLSAxXSwgZWxlbWVudCkgPiAwKSB7XG4gICAgICAgIGFycmF5W2pdID0gYXJyYXlbLS1qXTtcbiAgICAgIH1cbiAgICAgIGlmIChqICE9PSBpKyspIGFycmF5W2pdID0gZWxlbWVudDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gbWVyZ2Ugc29ydFxuICAgIHZhciBtaWRkbGUgPSBmbG9vcihsZW5ndGggLyAyKTtcbiAgICB2YXIgbGVmdCA9IHNvcnQoYXJyYXlTbGljZShhcnJheSwgMCwgbWlkZGxlKSwgY29tcGFyZWZuKTtcbiAgICB2YXIgcmlnaHQgPSBzb3J0KGFycmF5U2xpY2UoYXJyYXksIG1pZGRsZSksIGNvbXBhcmVmbik7XG4gICAgdmFyIGxsZW5ndGggPSBsZWZ0Lmxlbmd0aDtcbiAgICB2YXIgcmxlbmd0aCA9IHJpZ2h0Lmxlbmd0aDtcbiAgICB2YXIgbGluZGV4ID0gMDtcbiAgICB2YXIgcmluZGV4ID0gMDtcblxuICAgIHdoaWxlIChsaW5kZXggPCBsbGVuZ3RoIHx8IHJpbmRleCA8IHJsZW5ndGgpIHtcbiAgICAgIGFycmF5W2xpbmRleCArIHJpbmRleF0gPSAobGluZGV4IDwgbGxlbmd0aCAmJiByaW5kZXggPCBybGVuZ3RoKVxuICAgICAgICA/IGNvbXBhcmVmbihsZWZ0W2xpbmRleF0sIHJpZ2h0W3JpbmRleF0pIDw9IDAgPyBsZWZ0W2xpbmRleCsrXSA6IHJpZ2h0W3JpbmRleCsrXVxuICAgICAgICA6IGxpbmRleCA8IGxsZW5ndGggPyBsZWZ0W2xpbmRleCsrXSA6IHJpZ2h0W3JpbmRleCsrXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYXJyYXk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHNvcnQ7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgdW5jdXJyeVRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzJyk7XG5cbnZhciB0b1N0cmluZyA9IHVuY3VycnlUaGlzKHt9LnRvU3RyaW5nKTtcbnZhciBzdHJpbmdTbGljZSA9IHVuY3VycnlUaGlzKCcnLnNsaWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHN0cmluZ1NsaWNlKHRvU3RyaW5nKGl0KSwgOCwgLTEpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBUT19TVFJJTkdfVEFHX1NVUFBPUlQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tc3RyaW5nLXRhZy1zdXBwb3J0Jyk7XG52YXIgaXNDYWxsYWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1jYWxsYWJsZScpO1xudmFyIGNsYXNzb2ZSYXcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY2xhc3NvZi1yYXcnKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcblxudmFyIFRPX1NUUklOR19UQUcgPSB3ZWxsS25vd25TeW1ib2woJ3RvU3RyaW5nVGFnJyk7XG52YXIgJE9iamVjdCA9IE9iamVjdDtcblxuLy8gRVMzIHdyb25nIGhlcmVcbnZhciBDT1JSRUNUX0FSR1VNRU5UUyA9IGNsYXNzb2ZSYXcoZnVuY3Rpb24gKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID09PSAnQXJndW1lbnRzJztcblxuLy8gZmFsbGJhY2sgZm9yIElFMTEgU2NyaXB0IEFjY2VzcyBEZW5pZWQgZXJyb3JcbnZhciB0cnlHZXQgPSBmdW5jdGlvbiAoaXQsIGtleSkge1xuICB0cnkge1xuICAgIHJldHVybiBpdFtrZXldO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG59O1xuXG4vLyBnZXR0aW5nIHRhZyBmcm9tIEVTNisgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgXG5tb2R1bGUuZXhwb3J0cyA9IFRPX1NUUklOR19UQUdfU1VQUE9SVCA/IGNsYXNzb2ZSYXcgOiBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIE8sIHRhZywgcmVzdWx0O1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCA/ICdVbmRlZmluZWQnIDogaXQgPT09IG51bGwgPyAnTnVsbCdcbiAgICAvLyBAQHRvU3RyaW5nVGFnIGNhc2VcbiAgICA6IHR5cGVvZiAodGFnID0gdHJ5R2V0KE8gPSAkT2JqZWN0KGl0KSwgVE9fU1RSSU5HX1RBRykpID09ICdzdHJpbmcnID8gdGFnXG4gICAgLy8gYnVpbHRpblRhZyBjYXNlXG4gICAgOiBDT1JSRUNUX0FSR1VNRU5UUyA/IGNsYXNzb2ZSYXcoTylcbiAgICAvLyBFUzMgYXJndW1lbnRzIGZhbGxiYWNrXG4gICAgOiAocmVzdWx0ID0gY2xhc3NvZlJhdyhPKSkgPT09ICdPYmplY3QnICYmIGlzQ2FsbGFibGUoTy5jYWxsZWUpID8gJ0FyZ3VtZW50cycgOiByZXN1bHQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGhhc093biA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMtb3duLXByb3BlcnR5Jyk7XG52YXIgb3duS2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vd24ta2V5cycpO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yJyk7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSwgZXhjZXB0aW9ucykge1xuICB2YXIga2V5cyA9IG93bktleXMoc291cmNlKTtcbiAgdmFyIGRlZmluZVByb3BlcnR5ID0gZGVmaW5lUHJvcGVydHlNb2R1bGUuZjtcbiAgdmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZS5mO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICBpZiAoIWhhc093bih0YXJnZXQsIGtleSkgJiYgIShleGNlcHRpb25zICYmIGhhc093bihleGNlcHRpb25zLCBrZXkpKSkge1xuICAgICAgZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICAgIH1cbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEYoKSB7IC8qIGVtcHR5ICovIH1cbiAgRi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBudWxsO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldHByb3RvdHlwZW9mIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gIHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2YobmV3IEYoKSkgIT09IEYucHJvdG90eXBlO1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBgQ3JlYXRlSXRlclJlc3VsdE9iamVjdGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWNyZWF0ZWl0ZXJyZXN1bHRvYmplY3Rcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbHVlLCBkb25lKSB7XG4gIHJldHVybiB7IHZhbHVlOiB2YWx1ZSwgZG9uZTogZG9uZSB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHknKTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LWRlc2NyaXB0b3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBERVNDUklQVE9SUyA/IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIGRlZmluZVByb3BlcnR5TW9kdWxlLmYob2JqZWN0LCBrZXksIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcigxLCB2YWx1ZSkpO1xufSA6IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgcmV0dXJuIG9iamVjdDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChiaXRtYXAsIHZhbHVlKSB7XG4gIHJldHVybiB7XG4gICAgZW51bWVyYWJsZTogIShiaXRtYXAgJiAxKSxcbiAgICBjb25maWd1cmFibGU6ICEoYml0bWFwICYgMiksXG4gICAgd3JpdGFibGU6ICEoYml0bWFwICYgNCksXG4gICAgdmFsdWU6IHZhbHVlXG4gIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIG1ha2VCdWlsdEluID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL21ha2UtYnVpbHQtaW4nKTtcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRhcmdldCwgbmFtZSwgZGVzY3JpcHRvcikge1xuICBpZiAoZGVzY3JpcHRvci5nZXQpIG1ha2VCdWlsdEluKGRlc2NyaXB0b3IuZ2V0LCBuYW1lLCB7IGdldHRlcjogdHJ1ZSB9KTtcbiAgaWYgKGRlc2NyaXB0b3Iuc2V0KSBtYWtlQnVpbHRJbihkZXNjcmlwdG9yLnNldCwgbmFtZSwgeyBzZXR0ZXI6IHRydWUgfSk7XG4gIHJldHVybiBkZWZpbmVQcm9wZXJ0eS5mKHRhcmdldCwgbmFtZSwgZGVzY3JpcHRvcik7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGlzQ2FsbGFibGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtY2FsbGFibGUnKTtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5Jyk7XG52YXIgbWFrZUJ1aWx0SW4gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvbWFrZS1idWlsdC1pbicpO1xudmFyIGRlZmluZUdsb2JhbFByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RlZmluZS1nbG9iYWwtcHJvcGVydHknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTywga2V5LCB2YWx1ZSwgb3B0aW9ucykge1xuICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fTtcbiAgdmFyIHNpbXBsZSA9IG9wdGlvbnMuZW51bWVyYWJsZTtcbiAgdmFyIG5hbWUgPSBvcHRpb25zLm5hbWUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubmFtZSA6IGtleTtcbiAgaWYgKGlzQ2FsbGFibGUodmFsdWUpKSBtYWtlQnVpbHRJbih2YWx1ZSwgbmFtZSwgb3B0aW9ucyk7XG4gIGlmIChvcHRpb25zLmdsb2JhbCkge1xuICAgIGlmIChzaW1wbGUpIE9ba2V5XSA9IHZhbHVlO1xuICAgIGVsc2UgZGVmaW5lR2xvYmFsUHJvcGVydHkoa2V5LCB2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghb3B0aW9ucy51bnNhZmUpIGRlbGV0ZSBPW2tleV07XG4gICAgICBlbHNlIGlmIChPW2tleV0pIHNpbXBsZSA9IHRydWU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICAgIGlmIChzaW1wbGUpIE9ba2V5XSA9IHZhbHVlO1xuICAgIGVsc2UgZGVmaW5lUHJvcGVydHlNb2R1bGUuZihPLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgY29uZmlndXJhYmxlOiAhb3B0aW9ucy5ub25Db25maWd1cmFibGUsXG4gICAgICB3cml0YWJsZTogIW9wdGlvbnMubm9uV3JpdGFibGVcbiAgICB9KTtcbiAgfSByZXR1cm4gTztcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHNhZmVcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICB0cnkge1xuICAgIGRlZmluZVByb3BlcnR5KGdsb2JhbCwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBnbG9iYWxba2V5XSA9IHZhbHVlO1xuICB9IHJldHVybiB2YWx1ZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcblxuLy8gRGV0ZWN0IElFOCdzIGluY29tcGxldGUgZGVmaW5lUHJvcGVydHkgaW1wbGVtZW50YXRpb25cbm1vZHVsZS5leHBvcnRzID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAxLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfSB9KVsxXSAhPT0gNztcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcblxudmFyIGRvY3VtZW50ID0gZ2xvYmFsLmRvY3VtZW50O1xuLy8gdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgaXMgJ29iamVjdCcgaW4gb2xkIElFXG52YXIgRVhJU1RTID0gaXNPYmplY3QoZG9jdW1lbnQpICYmIGlzT2JqZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gRVhJU1RTID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgdXNlckFnZW50ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2VuZ2luZS11c2VyLWFnZW50Jyk7XG5cbnZhciBmaXJlZm94ID0gdXNlckFnZW50Lm1hdGNoKC9maXJlZm94XFwvKFxcZCspL2kpO1xuXG5tb2R1bGUuZXhwb3J0cyA9ICEhZmlyZWZveCAmJiArZmlyZWZveFsxXTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBVQSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9lbmdpbmUtdXNlci1hZ2VudCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IC9NU0lFfFRyaWRlbnQvLnRlc3QoVUEpO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBjbGFzc29mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NsYXNzb2YtcmF3Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3NvZihnbG9iYWwucHJvY2VzcykgPT09ICdwcm9jZXNzJztcbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gdHlwZW9mIG5hdmlnYXRvciAhPSAndW5kZWZpbmVkJyAmJiBTdHJpbmcobmF2aWdhdG9yLnVzZXJBZ2VudCkgfHwgJyc7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIHVzZXJBZ2VudCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9lbmdpbmUtdXNlci1hZ2VudCcpO1xuXG52YXIgcHJvY2VzcyA9IGdsb2JhbC5wcm9jZXNzO1xudmFyIERlbm8gPSBnbG9iYWwuRGVubztcbnZhciB2ZXJzaW9ucyA9IHByb2Nlc3MgJiYgcHJvY2Vzcy52ZXJzaW9ucyB8fCBEZW5vICYmIERlbm8udmVyc2lvbjtcbnZhciB2OCA9IHZlcnNpb25zICYmIHZlcnNpb25zLnY4O1xudmFyIG1hdGNoLCB2ZXJzaW9uO1xuXG5pZiAodjgpIHtcbiAgbWF0Y2ggPSB2OC5zcGxpdCgnLicpO1xuICAvLyBpbiBvbGQgQ2hyb21lLCB2ZXJzaW9ucyBvZiBWOCBpc24ndCBWOCA9IENocm9tZSAvIDEwXG4gIC8vIGJ1dCB0aGVpciBjb3JyZWN0IHZlcnNpb25zIGFyZSBub3QgaW50ZXJlc3RpbmcgZm9yIHVzXG4gIHZlcnNpb24gPSBtYXRjaFswXSA+IDAgJiYgbWF0Y2hbMF0gPCA0ID8gMSA6ICsobWF0Y2hbMF0gKyBtYXRjaFsxXSk7XG59XG5cbi8vIEJyb3dzZXJGUyBOb2RlSlMgYHByb2Nlc3NgIHBvbHlmaWxsIGluY29ycmVjdGx5IHNldCBgLnY4YCB0byBgMC4wYFxuLy8gc28gY2hlY2sgYHVzZXJBZ2VudGAgZXZlbiBpZiBgLnY4YCBleGlzdHMsIGJ1dCAwXG5pZiAoIXZlcnNpb24gJiYgdXNlckFnZW50KSB7XG4gIG1hdGNoID0gdXNlckFnZW50Lm1hdGNoKC9FZGdlXFwvKFxcZCspLyk7XG4gIGlmICghbWF0Y2ggfHwgbWF0Y2hbMV0gPj0gNzQpIHtcbiAgICBtYXRjaCA9IHVzZXJBZ2VudC5tYXRjaCgvQ2hyb21lXFwvKFxcZCspLyk7XG4gICAgaWYgKG1hdGNoKSB2ZXJzaW9uID0gK21hdGNoWzFdO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdmVyc2lvbjtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciB1c2VyQWdlbnQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZW5naW5lLXVzZXItYWdlbnQnKTtcblxudmFyIHdlYmtpdCA9IHVzZXJBZ2VudC5tYXRjaCgvQXBwbGVXZWJLaXRcXC8oXFxkKylcXC4vKTtcblxubW9kdWxlLmV4cG9ydHMgPSAhIXdlYmtpdCAmJiArd2Via2l0WzFdO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gSUU4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXG5tb2R1bGUuZXhwb3J0cyA9IFtcbiAgJ2NvbnN0cnVjdG9yJyxcbiAgJ2hhc093blByb3BlcnR5JyxcbiAgJ2lzUHJvdG90eXBlT2YnLFxuICAncHJvcGVydHlJc0VudW1lcmFibGUnLFxuICAndG9Mb2NhbGVTdHJpbmcnLFxuICAndG9TdHJpbmcnLFxuICAndmFsdWVPZidcbl07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yJykuZjtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLW5vbi1lbnVtZXJhYmxlLXByb3BlcnR5Jyk7XG52YXIgZGVmaW5lQnVpbHRJbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZWZpbmUtYnVpbHQtaW4nKTtcbnZhciBkZWZpbmVHbG9iYWxQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZWZpbmUtZ2xvYmFsLXByb3BlcnR5Jyk7XG52YXIgY29weUNvbnN0cnVjdG9yUHJvcGVydGllcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jb3B5LWNvbnN0cnVjdG9yLXByb3BlcnRpZXMnKTtcbnZhciBpc0ZvcmNlZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1mb3JjZWQnKTtcblxuLypcbiAgb3B0aW9ucy50YXJnZXQgICAgICAgICAtIG5hbWUgb2YgdGhlIHRhcmdldCBvYmplY3RcbiAgb3B0aW9ucy5nbG9iYWwgICAgICAgICAtIHRhcmdldCBpcyB0aGUgZ2xvYmFsIG9iamVjdFxuICBvcHRpb25zLnN0YXQgICAgICAgICAgIC0gZXhwb3J0IGFzIHN0YXRpYyBtZXRob2RzIG9mIHRhcmdldFxuICBvcHRpb25zLnByb3RvICAgICAgICAgIC0gZXhwb3J0IGFzIHByb3RvdHlwZSBtZXRob2RzIG9mIHRhcmdldFxuICBvcHRpb25zLnJlYWwgICAgICAgICAgIC0gcmVhbCBwcm90b3R5cGUgbWV0aG9kIGZvciB0aGUgYHB1cmVgIHZlcnNpb25cbiAgb3B0aW9ucy5mb3JjZWQgICAgICAgICAtIGV4cG9ydCBldmVuIGlmIHRoZSBuYXRpdmUgZmVhdHVyZSBpcyBhdmFpbGFibGVcbiAgb3B0aW9ucy5iaW5kICAgICAgICAgICAtIGJpbmQgbWV0aG9kcyB0byB0aGUgdGFyZ2V0LCByZXF1aXJlZCBmb3IgdGhlIGBwdXJlYCB2ZXJzaW9uXG4gIG9wdGlvbnMud3JhcCAgICAgICAgICAgLSB3cmFwIGNvbnN0cnVjdG9ycyB0byBwcmV2ZW50aW5nIGdsb2JhbCBwb2xsdXRpb24sIHJlcXVpcmVkIGZvciB0aGUgYHB1cmVgIHZlcnNpb25cbiAgb3B0aW9ucy51bnNhZmUgICAgICAgICAtIHVzZSB0aGUgc2ltcGxlIGFzc2lnbm1lbnQgb2YgcHJvcGVydHkgaW5zdGVhZCBvZiBkZWxldGUgKyBkZWZpbmVQcm9wZXJ0eVxuICBvcHRpb25zLnNoYW0gICAgICAgICAgIC0gYWRkIGEgZmxhZyB0byBub3QgY29tcGxldGVseSBmdWxsIHBvbHlmaWxsc1xuICBvcHRpb25zLmVudW1lcmFibGUgICAgIC0gZXhwb3J0IGFzIGVudW1lcmFibGUgcHJvcGVydHlcbiAgb3B0aW9ucy5kb250Q2FsbEdldFNldCAtIHByZXZlbnQgY2FsbGluZyBhIGdldHRlciBvbiB0YXJnZXRcbiAgb3B0aW9ucy5uYW1lICAgICAgICAgICAtIHRoZSAubmFtZSBvZiB0aGUgZnVuY3Rpb24gaWYgaXQgZG9lcyBub3QgbWF0Y2ggdGhlIGtleVxuKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9wdGlvbnMsIHNvdXJjZSkge1xuICB2YXIgVEFSR0VUID0gb3B0aW9ucy50YXJnZXQ7XG4gIHZhciBHTE9CQUwgPSBvcHRpb25zLmdsb2JhbDtcbiAgdmFyIFNUQVRJQyA9IG9wdGlvbnMuc3RhdDtcbiAgdmFyIEZPUkNFRCwgdGFyZ2V0LCBrZXksIHRhcmdldFByb3BlcnR5LCBzb3VyY2VQcm9wZXJ0eSwgZGVzY3JpcHRvcjtcbiAgaWYgKEdMT0JBTCkge1xuICAgIHRhcmdldCA9IGdsb2JhbDtcbiAgfSBlbHNlIGlmIChTVEFUSUMpIHtcbiAgICB0YXJnZXQgPSBnbG9iYWxbVEFSR0VUXSB8fCBkZWZpbmVHbG9iYWxQcm9wZXJ0eShUQVJHRVQsIHt9KTtcbiAgfSBlbHNlIHtcbiAgICB0YXJnZXQgPSBnbG9iYWxbVEFSR0VUXSAmJiBnbG9iYWxbVEFSR0VUXS5wcm90b3R5cGU7XG4gIH1cbiAgaWYgKHRhcmdldCkgZm9yIChrZXkgaW4gc291cmNlKSB7XG4gICAgc291cmNlUHJvcGVydHkgPSBzb3VyY2Vba2V5XTtcbiAgICBpZiAob3B0aW9ucy5kb250Q2FsbEdldFNldCkge1xuICAgICAgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSk7XG4gICAgICB0YXJnZXRQcm9wZXJ0eSA9IGRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci52YWx1ZTtcbiAgICB9IGVsc2UgdGFyZ2V0UHJvcGVydHkgPSB0YXJnZXRba2V5XTtcbiAgICBGT1JDRUQgPSBpc0ZvcmNlZChHTE9CQUwgPyBrZXkgOiBUQVJHRVQgKyAoU1RBVElDID8gJy4nIDogJyMnKSArIGtleSwgb3B0aW9ucy5mb3JjZWQpO1xuICAgIC8vIGNvbnRhaW5lZCBpbiB0YXJnZXRcbiAgICBpZiAoIUZPUkNFRCAmJiB0YXJnZXRQcm9wZXJ0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAodHlwZW9mIHNvdXJjZVByb3BlcnR5ID09IHR5cGVvZiB0YXJnZXRQcm9wZXJ0eSkgY29udGludWU7XG4gICAgICBjb3B5Q29uc3RydWN0b3JQcm9wZXJ0aWVzKHNvdXJjZVByb3BlcnR5LCB0YXJnZXRQcm9wZXJ0eSk7XG4gICAgfVxuICAgIC8vIGFkZCBhIGZsYWcgdG8gbm90IGNvbXBsZXRlbHkgZnVsbCBwb2x5ZmlsbHNcbiAgICBpZiAob3B0aW9ucy5zaGFtIHx8ICh0YXJnZXRQcm9wZXJ0eSAmJiB0YXJnZXRQcm9wZXJ0eS5zaGFtKSkge1xuICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KHNvdXJjZVByb3BlcnR5LCAnc2hhbScsIHRydWUpO1xuICAgIH1cbiAgICBkZWZpbmVCdWlsdEluKHRhcmdldCwga2V5LCBzb3VyY2VQcm9wZXJ0eSwgb3B0aW9ucyk7XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChleGVjKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuICEhZXhlYygpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIE5BVElWRV9CSU5EID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWJpbmQtbmF0aXZlJyk7XG5cbnZhciBGdW5jdGlvblByb3RvdHlwZSA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbnZhciBhcHBseSA9IEZ1bmN0aW9uUHJvdG90eXBlLmFwcGx5O1xudmFyIGNhbGwgPSBGdW5jdGlvblByb3RvdHlwZS5jYWxsO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tcmVmbGVjdCAtLSBzYWZlXG5tb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiBSZWZsZWN0ID09ICdvYmplY3QnICYmIFJlZmxlY3QuYXBwbHkgfHwgKE5BVElWRV9CSU5EID8gY2FsbC5iaW5kKGFwcGx5KSA6IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGNhbGwuYXBwbHkoYXBwbHksIGFyZ3VtZW50cyk7XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1mdW5jdGlvbi1wcm90b3R5cGUtYmluZCAtLSBzYWZlXG4gIHZhciB0ZXN0ID0gKGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSkuYmluZCgpO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zIC0tIHNhZmVcbiAgcmV0dXJuIHR5cGVvZiB0ZXN0ICE9ICdmdW5jdGlvbicgfHwgdGVzdC5oYXNPd25Qcm9wZXJ0eSgncHJvdG90eXBlJyk7XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBOQVRJVkVfQklORCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi1iaW5kLW5hdGl2ZScpO1xuXG52YXIgY2FsbCA9IEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE5BVElWRV9CSU5EID8gY2FsbC5iaW5kKGNhbGwpIDogZnVuY3Rpb24gKCkge1xuICByZXR1cm4gY2FsbC5hcHBseShjYWxsLCBhcmd1bWVudHMpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIGhhc093biA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMtb3duLXByb3BlcnR5Jyk7XG5cbnZhciBGdW5jdGlvblByb3RvdHlwZSA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yIC0tIHNhZmVcbnZhciBnZXREZXNjcmlwdG9yID0gREVTQ1JJUFRPUlMgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxudmFyIEVYSVNUUyA9IGhhc093bihGdW5jdGlvblByb3RvdHlwZSwgJ25hbWUnKTtcbi8vIGFkZGl0aW9uYWwgcHJvdGVjdGlvbiBmcm9tIG1pbmlmaWVkIC8gbWFuZ2xlZCAvIGRyb3BwZWQgZnVuY3Rpb24gbmFtZXNcbnZhciBQUk9QRVIgPSBFWElTVFMgJiYgKGZ1bmN0aW9uIHNvbWV0aGluZygpIHsgLyogZW1wdHkgKi8gfSkubmFtZSA9PT0gJ3NvbWV0aGluZyc7XG52YXIgQ09ORklHVVJBQkxFID0gRVhJU1RTICYmICghREVTQ1JJUFRPUlMgfHwgKERFU0NSSVBUT1JTICYmIGdldERlc2NyaXB0b3IoRnVuY3Rpb25Qcm90b3R5cGUsICduYW1lJykuY29uZmlndXJhYmxlKSk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBFWElTVFM6IEVYSVNUUyxcbiAgUFJPUEVSOiBQUk9QRVIsXG4gIENPTkZJR1VSQUJMRTogQ09ORklHVVJBQkxFXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHVuY3VycnlUaGlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcycpO1xudmFyIGFDYWxsYWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hLWNhbGxhYmxlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iamVjdCwga2V5LCBtZXRob2QpIHtcbiAgdHJ5IHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvciAtLSBzYWZlXG4gICAgcmV0dXJuIHVuY3VycnlUaGlzKGFDYWxsYWJsZShPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwga2V5KVttZXRob2RdKSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgY2xhc3NvZlJhdyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jbGFzc29mLXJhdycpO1xudmFyIHVuY3VycnlUaGlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmbikge1xuICAvLyBOYXNob3JuIGJ1ZzpcbiAgLy8gICBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMTEyOFxuICAvLyAgIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8xMTMwXG4gIGlmIChjbGFzc29mUmF3KGZuKSA9PT0gJ0Z1bmN0aW9uJykgcmV0dXJuIHVuY3VycnlUaGlzKGZuKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgTkFUSVZFX0JJTkQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tYmluZC1uYXRpdmUnKTtcblxudmFyIEZ1bmN0aW9uUHJvdG90eXBlID0gRnVuY3Rpb24ucHJvdG90eXBlO1xudmFyIGNhbGwgPSBGdW5jdGlvblByb3RvdHlwZS5jYWxsO1xudmFyIHVuY3VycnlUaGlzV2l0aEJpbmQgPSBOQVRJVkVfQklORCAmJiBGdW5jdGlvblByb3RvdHlwZS5iaW5kLmJpbmQoY2FsbCwgY2FsbCk7XG5cbm1vZHVsZS5leHBvcnRzID0gTkFUSVZFX0JJTkQgPyB1bmN1cnJ5VGhpc1dpdGhCaW5kIDogZnVuY3Rpb24gKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNhbGwuYXBwbHkoZm4sIGFyZ3VtZW50cyk7XG4gIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBpc0NhbGxhYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWNhbGxhYmxlJyk7XG5cbnZhciBhRnVuY3Rpb24gPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuIGlzQ2FsbGFibGUoYXJndW1lbnQpID8gYXJndW1lbnQgOiB1bmRlZmluZWQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChuYW1lc3BhY2UsIG1ldGhvZCkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA8IDIgPyBhRnVuY3Rpb24oZ2xvYmFsW25hbWVzcGFjZV0pIDogZ2xvYmFsW25hbWVzcGFjZV0gJiYgZ2xvYmFsW25hbWVzcGFjZV1bbWV0aG9kXTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgdW5jdXJyeVRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzJyk7XG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1hcnJheScpO1xudmFyIGlzQ2FsbGFibGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtY2FsbGFibGUnKTtcbnZhciBjbGFzc29mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NsYXNzb2YtcmF3Jyk7XG52YXIgdG9TdHJpbmcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tc3RyaW5nJyk7XG5cbnZhciBwdXNoID0gdW5jdXJyeVRoaXMoW10ucHVzaCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHJlcGxhY2VyKSB7XG4gIGlmIChpc0NhbGxhYmxlKHJlcGxhY2VyKSkgcmV0dXJuIHJlcGxhY2VyO1xuICBpZiAoIWlzQXJyYXkocmVwbGFjZXIpKSByZXR1cm47XG4gIHZhciByYXdMZW5ndGggPSByZXBsYWNlci5sZW5ndGg7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmF3TGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWxlbWVudCA9IHJlcGxhY2VyW2ldO1xuICAgIGlmICh0eXBlb2YgZWxlbWVudCA9PSAnc3RyaW5nJykgcHVzaChrZXlzLCBlbGVtZW50KTtcbiAgICBlbHNlIGlmICh0eXBlb2YgZWxlbWVudCA9PSAnbnVtYmVyJyB8fCBjbGFzc29mKGVsZW1lbnQpID09PSAnTnVtYmVyJyB8fCBjbGFzc29mKGVsZW1lbnQpID09PSAnU3RyaW5nJykgcHVzaChrZXlzLCB0b1N0cmluZyhlbGVtZW50KSk7XG4gIH1cbiAgdmFyIGtleXNMZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgdmFyIHJvb3QgPSB0cnVlO1xuICByZXR1cm4gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICBpZiAocm9vdCkge1xuICAgICAgcm9vdCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBpZiAoaXNBcnJheSh0aGlzKSkgcmV0dXJuIHZhbHVlO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwga2V5c0xlbmd0aDsgaisrKSBpZiAoa2V5c1tqXSA9PT0ga2V5KSByZXR1cm4gdmFsdWU7XG4gIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGFDYWxsYWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hLWNhbGxhYmxlJyk7XG52YXIgaXNOdWxsT3JVbmRlZmluZWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtbnVsbC1vci11bmRlZmluZWQnKTtcblxuLy8gYEdldE1ldGhvZGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWdldG1ldGhvZFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoViwgUCkge1xuICB2YXIgZnVuYyA9IFZbUF07XG4gIHJldHVybiBpc051bGxPclVuZGVmaW5lZChmdW5jKSA/IHVuZGVmaW5lZCA6IGFDYWxsYWJsZShmdW5jKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgY2hlY2sgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0ICYmIGl0Lk1hdGggPT09IE1hdGggJiYgaXQ7XG59O1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODYjaXNzdWVjb21tZW50LTExNTc1OTAyOFxubW9kdWxlLmV4cG9ydHMgPVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tZ2xvYmFsLXRoaXMgLS0gc2FmZVxuICBjaGVjayh0eXBlb2YgZ2xvYmFsVGhpcyA9PSAnb2JqZWN0JyAmJiBnbG9iYWxUaGlzKSB8fFxuICBjaGVjayh0eXBlb2Ygd2luZG93ID09ICdvYmplY3QnICYmIHdpbmRvdykgfHxcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtZ2xvYmFscyAtLSBzYWZlXG4gIGNoZWNrKHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYpIHx8XG4gIGNoZWNrKHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsKSB8fFxuICBjaGVjayh0eXBlb2YgdGhpcyA9PSAnb2JqZWN0JyAmJiB0aGlzKSB8fFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmMgLS0gZmFsbGJhY2tcbiAgKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0pKCkgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciB1bmN1cnJ5VGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1vYmplY3QnKTtcblxudmFyIGhhc093blByb3BlcnR5ID0gdW5jdXJyeVRoaXMoe30uaGFzT3duUHJvcGVydHkpO1xuXG4vLyBgSGFzT3duUHJvcGVydHlgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1oYXNvd25wcm9wZXJ0eVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1oYXNvd24gLS0gc2FmZVxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuaGFzT3duIHx8IGZ1bmN0aW9uIGhhc093bihpdCwga2V5KSB7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eSh0b09iamVjdChpdCksIGtleSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSB7fTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBnZXRCdWlsdEluID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dldC1idWlsdC1pbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEJ1aWx0SW4oJ2RvY3VtZW50JywgJ2RvY3VtZW50RWxlbWVudCcpO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciBjcmVhdGVFbGVtZW50ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RvY3VtZW50LWNyZWF0ZS1lbGVtZW50Jyk7XG5cbi8vIFRoYW5rcyB0byBJRTggZm9yIGl0cyBmdW5ueSBkZWZpbmVQcm9wZXJ0eVxubW9kdWxlLmV4cG9ydHMgPSAhREVTQ1JJUFRPUlMgJiYgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGNyZWF0ZUVsZW1lbnQoJ2RpdicpLCAnYScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH1cbiAgfSkuYSAhPT0gNztcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHVuY3VycnlUaGlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcycpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jbGFzc29mLXJhdycpO1xuXG52YXIgJE9iamVjdCA9IE9iamVjdDtcbnZhciBzcGxpdCA9IHVuY3VycnlUaGlzKCcnLnNwbGl0KTtcblxuLy8gZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBhbmQgbm9uLWVudW1lcmFibGUgb2xkIFY4IHN0cmluZ3Ncbm1vZHVsZS5leHBvcnRzID0gZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyB0aHJvd3MgYW4gZXJyb3IgaW4gcmhpbm8sIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9yaGluby9pc3N1ZXMvMzQ2XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnMgLS0gc2FmZVxuICByZXR1cm4gISRPYmplY3QoJ3onKS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgwKTtcbn0pID8gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBjbGFzc29mKGl0KSA9PT0gJ1N0cmluZycgPyBzcGxpdChpdCwgJycpIDogJE9iamVjdChpdCk7XG59IDogJE9iamVjdDtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciB1bmN1cnJ5VGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMnKTtcbnZhciBpc0NhbGxhYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWNhbGxhYmxlJyk7XG52YXIgc3RvcmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2hhcmVkLXN0b3JlJyk7XG5cbnZhciBmdW5jdGlvblRvU3RyaW5nID0gdW5jdXJyeVRoaXMoRnVuY3Rpb24udG9TdHJpbmcpO1xuXG4vLyB0aGlzIGhlbHBlciBicm9rZW4gaW4gYGNvcmUtanNAMy40LjEtMy40LjRgLCBzbyB3ZSBjYW4ndCB1c2UgYHNoYXJlZGAgaGVscGVyXG5pZiAoIWlzQ2FsbGFibGUoc3RvcmUuaW5zcGVjdFNvdXJjZSkpIHtcbiAgc3RvcmUuaW5zcGVjdFNvdXJjZSA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiBmdW5jdGlvblRvU3RyaW5nKGl0KTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdG9yZS5pbnNwZWN0U291cmNlO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIE5BVElWRV9XRUFLX01BUCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWFrLW1hcC1iYXNpYy1kZXRlY3Rpb24nKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1ub24tZW51bWVyYWJsZS1wcm9wZXJ0eScpO1xudmFyIGhhc093biA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMtb3duLXByb3BlcnR5Jyk7XG52YXIgc2hhcmVkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NoYXJlZC1zdG9yZScpO1xudmFyIHNoYXJlZEtleSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zaGFyZWQta2V5Jyk7XG52YXIgaGlkZGVuS2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oaWRkZW4ta2V5cycpO1xuXG52YXIgT0JKRUNUX0FMUkVBRFlfSU5JVElBTElaRUQgPSAnT2JqZWN0IGFscmVhZHkgaW5pdGlhbGl6ZWQnO1xudmFyIFR5cGVFcnJvciA9IGdsb2JhbC5UeXBlRXJyb3I7XG52YXIgV2Vha01hcCA9IGdsb2JhbC5XZWFrTWFwO1xudmFyIHNldCwgZ2V0LCBoYXM7XG5cbnZhciBlbmZvcmNlID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBoYXMoaXQpID8gZ2V0KGl0KSA6IHNldChpdCwge30pO1xufTtcblxudmFyIGdldHRlckZvciA9IGZ1bmN0aW9uIChUWVBFKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoaXQpIHtcbiAgICB2YXIgc3RhdGU7XG4gICAgaWYgKCFpc09iamVjdChpdCkgfHwgKHN0YXRlID0gZ2V0KGl0KSkudHlwZSAhPT0gVFlQRSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW5jb21wYXRpYmxlIHJlY2VpdmVyLCAnICsgVFlQRSArICcgcmVxdWlyZWQnKTtcbiAgICB9IHJldHVybiBzdGF0ZTtcbiAgfTtcbn07XG5cbmlmIChOQVRJVkVfV0VBS19NQVAgfHwgc2hhcmVkLnN0YXRlKSB7XG4gIHZhciBzdG9yZSA9IHNoYXJlZC5zdGF0ZSB8fCAoc2hhcmVkLnN0YXRlID0gbmV3IFdlYWtNYXAoKSk7XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLXNlbGYtYXNzaWduIC0tIHByb3RvdHlwZSBtZXRob2RzIHByb3RlY3Rpb24gKi9cbiAgc3RvcmUuZ2V0ID0gc3RvcmUuZ2V0O1xuICBzdG9yZS5oYXMgPSBzdG9yZS5oYXM7XG4gIHN0b3JlLnNldCA9IHN0b3JlLnNldDtcbiAgLyogZXNsaW50LWVuYWJsZSBuby1zZWxmLWFzc2lnbiAtLSBwcm90b3R5cGUgbWV0aG9kcyBwcm90ZWN0aW9uICovXG4gIHNldCA9IGZ1bmN0aW9uIChpdCwgbWV0YWRhdGEpIHtcbiAgICBpZiAoc3RvcmUuaGFzKGl0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihPQkpFQ1RfQUxSRUFEWV9JTklUSUFMSVpFRCk7XG4gICAgbWV0YWRhdGEuZmFjYWRlID0gaXQ7XG4gICAgc3RvcmUuc2V0KGl0LCBtZXRhZGF0YSk7XG4gICAgcmV0dXJuIG1ldGFkYXRhO1xuICB9O1xuICBnZXQgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gc3RvcmUuZ2V0KGl0KSB8fCB7fTtcbiAgfTtcbiAgaGFzID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIHN0b3JlLmhhcyhpdCk7XG4gIH07XG59IGVsc2Uge1xuICB2YXIgU1RBVEUgPSBzaGFyZWRLZXkoJ3N0YXRlJyk7XG4gIGhpZGRlbktleXNbU1RBVEVdID0gdHJ1ZTtcbiAgc2V0ID0gZnVuY3Rpb24gKGl0LCBtZXRhZGF0YSkge1xuICAgIGlmIChoYXNPd24oaXQsIFNUQVRFKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihPQkpFQ1RfQUxSRUFEWV9JTklUSUFMSVpFRCk7XG4gICAgbWV0YWRhdGEuZmFjYWRlID0gaXQ7XG4gICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KGl0LCBTVEFURSwgbWV0YWRhdGEpO1xuICAgIHJldHVybiBtZXRhZGF0YTtcbiAgfTtcbiAgZ2V0ID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIGhhc093bihpdCwgU1RBVEUpID8gaXRbU1RBVEVdIDoge307XG4gIH07XG4gIGhhcyA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiBoYXNPd24oaXQsIFNUQVRFKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNldDogc2V0LFxuICBnZXQ6IGdldCxcbiAgaGFzOiBoYXMsXG4gIGVuZm9yY2U6IGVuZm9yY2UsXG4gIGdldHRlckZvcjogZ2V0dGVyRm9yXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY2xhc3NvZi1yYXcnKTtcblxuLy8gYElzQXJyYXlgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1pc2FycmF5XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tYXJyYXktaXNhcnJheSAtLSBzYWZlXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gaXNBcnJheShhcmd1bWVudCkge1xuICByZXR1cm4gY2xhc3NvZihhcmd1bWVudCkgPT09ICdBcnJheSc7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1Jc0hUTUxEREEtaW50ZXJuYWwtc2xvdFxudmFyIGRvY3VtZW50QWxsID0gdHlwZW9mIGRvY3VtZW50ID09ICdvYmplY3QnICYmIGRvY3VtZW50LmFsbDtcblxuLy8gYElzQ2FsbGFibGVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1pc2NhbGxhYmxlXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgdW5pY29ybi9uby10eXBlb2YtdW5kZWZpbmVkIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG5tb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiBkb2N1bWVudEFsbCA9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudEFsbCAhPT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHJldHVybiB0eXBlb2YgYXJndW1lbnQgPT0gJ2Z1bmN0aW9uJyB8fCBhcmd1bWVudCA9PT0gZG9jdW1lbnRBbGw7XG59IDogZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHJldHVybiB0eXBlb2YgYXJndW1lbnQgPT0gJ2Z1bmN0aW9uJztcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgdW5jdXJyeVRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciBpc0NhbGxhYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWNhbGxhYmxlJyk7XG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jbGFzc29mJyk7XG52YXIgZ2V0QnVpbHRJbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nZXQtYnVpbHQtaW4nKTtcbnZhciBpbnNwZWN0U291cmNlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2luc3BlY3Qtc291cmNlJyk7XG5cbnZhciBub29wID0gZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9O1xudmFyIGNvbnN0cnVjdCA9IGdldEJ1aWx0SW4oJ1JlZmxlY3QnLCAnY29uc3RydWN0Jyk7XG52YXIgY29uc3RydWN0b3JSZWdFeHAgPSAvXlxccyooPzpjbGFzc3xmdW5jdGlvbilcXGIvO1xudmFyIGV4ZWMgPSB1bmN1cnJ5VGhpcyhjb25zdHJ1Y3RvclJlZ0V4cC5leGVjKTtcbnZhciBJTkNPUlJFQ1RfVE9fU1RSSU5HID0gIWNvbnN0cnVjdG9yUmVnRXhwLnRlc3Qobm9vcCk7XG5cbnZhciBpc0NvbnN0cnVjdG9yTW9kZXJuID0gZnVuY3Rpb24gaXNDb25zdHJ1Y3Rvcihhcmd1bWVudCkge1xuICBpZiAoIWlzQ2FsbGFibGUoYXJndW1lbnQpKSByZXR1cm4gZmFsc2U7XG4gIHRyeSB7XG4gICAgY29uc3RydWN0KG5vb3AsIFtdLCBhcmd1bWVudCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG52YXIgaXNDb25zdHJ1Y3RvckxlZ2FjeSA9IGZ1bmN0aW9uIGlzQ29uc3RydWN0b3IoYXJndW1lbnQpIHtcbiAgaWYgKCFpc0NhbGxhYmxlKGFyZ3VtZW50KSkgcmV0dXJuIGZhbHNlO1xuICBzd2l0Y2ggKGNsYXNzb2YoYXJndW1lbnQpKSB7XG4gICAgY2FzZSAnQXN5bmNGdW5jdGlvbic6XG4gICAgY2FzZSAnR2VuZXJhdG9yRnVuY3Rpb24nOlxuICAgIGNhc2UgJ0FzeW5jR2VuZXJhdG9yRnVuY3Rpb24nOiByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdHJ5IHtcbiAgICAvLyB3ZSBjYW4ndCBjaGVjayAucHJvdG90eXBlIHNpbmNlIGNvbnN0cnVjdG9ycyBwcm9kdWNlZCBieSAuYmluZCBoYXZlbid0IGl0XG4gICAgLy8gYEZ1bmN0aW9uI3RvU3RyaW5nYCB0aHJvd3Mgb24gc29tZSBidWlsdC1pdCBmdW5jdGlvbiBpbiBzb21lIGxlZ2FjeSBlbmdpbmVzXG4gICAgLy8gKGZvciBleGFtcGxlLCBgRE9NUXVhZGAgYW5kIHNpbWlsYXIgaW4gRkY0MS0pXG4gICAgcmV0dXJuIElOQ09SUkVDVF9UT19TVFJJTkcgfHwgISFleGVjKGNvbnN0cnVjdG9yUmVnRXhwLCBpbnNwZWN0U291cmNlKGFyZ3VtZW50KSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cbmlzQ29uc3RydWN0b3JMZWdhY3kuc2hhbSA9IHRydWU7XG5cbi8vIGBJc0NvbnN0cnVjdG9yYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtaXNjb25zdHJ1Y3RvclxubW9kdWxlLmV4cG9ydHMgPSAhY29uc3RydWN0IHx8IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgdmFyIGNhbGxlZDtcbiAgcmV0dXJuIGlzQ29uc3RydWN0b3JNb2Rlcm4oaXNDb25zdHJ1Y3Rvck1vZGVybi5jYWxsKVxuICAgIHx8ICFpc0NvbnN0cnVjdG9yTW9kZXJuKE9iamVjdClcbiAgICB8fCAhaXNDb25zdHJ1Y3Rvck1vZGVybihmdW5jdGlvbiAoKSB7IGNhbGxlZCA9IHRydWU7IH0pXG4gICAgfHwgY2FsbGVkO1xufSkgPyBpc0NvbnN0cnVjdG9yTGVnYWN5IDogaXNDb25zdHJ1Y3Rvck1vZGVybjtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIGlzQ2FsbGFibGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtY2FsbGFibGUnKTtcblxudmFyIHJlcGxhY2VtZW50ID0gLyN8XFwucHJvdG90eXBlXFwuLztcblxudmFyIGlzRm9yY2VkID0gZnVuY3Rpb24gKGZlYXR1cmUsIGRldGVjdGlvbikge1xuICB2YXIgdmFsdWUgPSBkYXRhW25vcm1hbGl6ZShmZWF0dXJlKV07XG4gIHJldHVybiB2YWx1ZSA9PT0gUE9MWUZJTEwgPyB0cnVlXG4gICAgOiB2YWx1ZSA9PT0gTkFUSVZFID8gZmFsc2VcbiAgICA6IGlzQ2FsbGFibGUoZGV0ZWN0aW9uKSA/IGZhaWxzKGRldGVjdGlvbilcbiAgICA6ICEhZGV0ZWN0aW9uO1xufTtcblxudmFyIG5vcm1hbGl6ZSA9IGlzRm9yY2VkLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgcmV0dXJuIFN0cmluZyhzdHJpbmcpLnJlcGxhY2UocmVwbGFjZW1lbnQsICcuJykudG9Mb3dlckNhc2UoKTtcbn07XG5cbnZhciBkYXRhID0gaXNGb3JjZWQuZGF0YSA9IHt9O1xudmFyIE5BVElWRSA9IGlzRm9yY2VkLk5BVElWRSA9ICdOJztcbnZhciBQT0xZRklMTCA9IGlzRm9yY2VkLlBPTFlGSUxMID0gJ1AnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRm9yY2VkO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gd2UgY2FuJ3QgdXNlIGp1c3QgYGl0ID09IG51bGxgIHNpbmNlIG9mIGBkb2N1bWVudC5hbGxgIHNwZWNpYWwgY2FzZVxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1Jc0hUTUxEREEtaW50ZXJuYWwtc2xvdC1hZWNcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCA9PT0gbnVsbCB8fCBpdCA9PT0gdW5kZWZpbmVkO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBpc0NhbGxhYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWNhbGxhYmxlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IGlzQ2FsbGFibGUoaXQpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGFyZ3VtZW50KSB8fCBhcmd1bWVudCA9PT0gbnVsbDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZhbHNlO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xudmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY2xhc3NvZi1yYXcnKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcblxudmFyIE1BVENIID0gd2VsbEtub3duU3ltYm9sKCdtYXRjaCcpO1xuXG4vLyBgSXNSZWdFeHBgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1pc3JlZ2V4cFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIGlzUmVnRXhwO1xuICByZXR1cm4gaXNPYmplY3QoaXQpICYmICgoaXNSZWdFeHAgPSBpdFtNQVRDSF0pICE9PSB1bmRlZmluZWQgPyAhIWlzUmVnRXhwIDogY2xhc3NvZihpdCkgPT09ICdSZWdFeHAnKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZ2V0QnVpbHRJbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nZXQtYnVpbHQtaW4nKTtcbnZhciBpc0NhbGxhYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWNhbGxhYmxlJyk7XG52YXIgaXNQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtaXMtcHJvdG90eXBlLW9mJyk7XG52YXIgVVNFX1NZTUJPTF9BU19VSUQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdXNlLXN5bWJvbC1hcy11aWQnKTtcblxudmFyICRPYmplY3QgPSBPYmplY3Q7XG5cbm1vZHVsZS5leHBvcnRzID0gVVNFX1NZTUJPTF9BU19VSUQgPyBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJztcbn0gOiBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyICRTeW1ib2wgPSBnZXRCdWlsdEluKCdTeW1ib2wnKTtcbiAgcmV0dXJuIGlzQ2FsbGFibGUoJFN5bWJvbCkgJiYgaXNQcm90b3R5cGVPZigkU3ltYm9sLnByb3RvdHlwZSwgJE9iamVjdChpdCkpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBJdGVyYXRvclByb3RvdHlwZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pdGVyYXRvcnMtY29yZScpLkl0ZXJhdG9yUHJvdG90eXBlO1xudmFyIGNyZWF0ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtY3JlYXRlJyk7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eS1kZXNjcmlwdG9yJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2V0LXRvLXN0cmluZy10YWcnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXRlcmF0b3JzJyk7XG5cbnZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoSXRlcmF0b3JDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCwgRU5VTUVSQUJMRV9ORVhUKSB7XG4gIHZhciBUT19TVFJJTkdfVEFHID0gTkFNRSArICcgSXRlcmF0b3InO1xuICBJdGVyYXRvckNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IGNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSwgeyBuZXh0OiBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoKyFFTlVNRVJBQkxFX05FWFQsIG5leHQpIH0pO1xuICBzZXRUb1N0cmluZ1RhZyhJdGVyYXRvckNvbnN0cnVjdG9yLCBUT19TVFJJTkdfVEFHLCBmYWxzZSwgdHJ1ZSk7XG4gIEl0ZXJhdG9yc1tUT19TVFJJTkdfVEFHXSA9IHJldHVyblRoaXM7XG4gIHJldHVybiBJdGVyYXRvckNvbnN0cnVjdG9yO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIGlzQ2FsbGFibGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtY2FsbGFibGUnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcbnZhciBjcmVhdGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWNyZWF0ZScpO1xudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtcHJvdG90eXBlLW9mJyk7XG52YXIgZGVmaW5lQnVpbHRJbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZWZpbmUtYnVpbHQtaW4nKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcbnZhciBJU19QVVJFID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLXB1cmUnKTtcblxudmFyIElURVJBVE9SID0gd2VsbEtub3duU3ltYm9sKCdpdGVyYXRvcicpO1xudmFyIEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgPSBmYWxzZTtcblxuLy8gYCVJdGVyYXRvclByb3RvdHlwZSVgIG9iamVjdFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy0laXRlcmF0b3Jwcm90b3R5cGUlLW9iamVjdFxudmFyIEl0ZXJhdG9yUHJvdG90eXBlLCBQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGUsIGFycmF5SXRlcmF0b3I7XG5cbi8qIGVzbGludC1kaXNhYmxlIGVzL25vLWFycmF5LXByb3RvdHlwZS1rZXlzIC0tIHNhZmUgKi9cbmlmIChbXS5rZXlzKSB7XG4gIGFycmF5SXRlcmF0b3IgPSBbXS5rZXlzKCk7XG4gIC8vIFNhZmFyaSA4IGhhcyBidWdneSBpdGVyYXRvcnMgdy9vIGBuZXh0YFxuICBpZiAoISgnbmV4dCcgaW4gYXJyYXlJdGVyYXRvcikpIEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgPSB0cnVlO1xuICBlbHNlIHtcbiAgICBQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90b3R5cGVPZihnZXRQcm90b3R5cGVPZihhcnJheUl0ZXJhdG9yKSk7XG4gICAgaWYgKFByb3RvdHlwZU9mQXJyYXlJdGVyYXRvclByb3RvdHlwZSAhPT0gT2JqZWN0LnByb3RvdHlwZSkgSXRlcmF0b3JQcm90b3R5cGUgPSBQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGU7XG4gIH1cbn1cblxudmFyIE5FV19JVEVSQVRPUl9QUk9UT1RZUEUgPSAhaXNPYmplY3QoSXRlcmF0b3JQcm90b3R5cGUpIHx8IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRlc3QgPSB7fTtcbiAgLy8gRkY0NC0gbGVnYWN5IGl0ZXJhdG9ycyBjYXNlXG4gIHJldHVybiBJdGVyYXRvclByb3RvdHlwZVtJVEVSQVRPUl0uY2FsbCh0ZXN0KSAhPT0gdGVzdDtcbn0pO1xuXG5pZiAoTkVXX0lURVJBVE9SX1BST1RPVFlQRSkgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcbmVsc2UgaWYgKElTX1BVUkUpIEl0ZXJhdG9yUHJvdG90eXBlID0gY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlKTtcblxuLy8gYCVJdGVyYXRvclByb3RvdHlwZSVbQEBpdGVyYXRvcl0oKWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLSVpdGVyYXRvcnByb3RvdHlwZSUtQEBpdGVyYXRvclxuaWYgKCFpc0NhbGxhYmxlKEl0ZXJhdG9yUHJvdG90eXBlW0lURVJBVE9SXSkpIHtcbiAgZGVmaW5lQnVpbHRJbihJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBJdGVyYXRvclByb3RvdHlwZTogSXRlcmF0b3JQcm90b3R5cGUsXG4gIEJVR0dZX1NBRkFSSV9JVEVSQVRPUlM6IEJVR0dZX1NBRkFSSV9JVEVSQVRPUlNcbn07XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IHt9O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWxlbmd0aCcpO1xuXG4vLyBgTGVuZ3RoT2ZBcnJheUxpa2VgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1sZW5ndGhvZmFycmF5bGlrZVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiB0b0xlbmd0aChvYmoubGVuZ3RoKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgdW5jdXJyeVRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciBpc0NhbGxhYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWNhbGxhYmxlJyk7XG52YXIgaGFzT3duID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcy1vd24tcHJvcGVydHknKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIENPTkZJR1VSQUJMRV9GVU5DVElPTl9OQU1FID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLW5hbWUnKS5DT05GSUdVUkFCTEU7XG52YXIgaW5zcGVjdFNvdXJjZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pbnNwZWN0LXNvdXJjZScpO1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW50ZXJuYWwtc3RhdGUnKTtcblxudmFyIGVuZm9yY2VJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5lbmZvcmNlO1xudmFyIGdldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmdldDtcbnZhciAkU3RyaW5nID0gU3RyaW5nO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSBzYWZlXG52YXIgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgc3RyaW5nU2xpY2UgPSB1bmN1cnJ5VGhpcygnJy5zbGljZSk7XG52YXIgcmVwbGFjZSA9IHVuY3VycnlUaGlzKCcnLnJlcGxhY2UpO1xudmFyIGpvaW4gPSB1bmN1cnJ5VGhpcyhbXS5qb2luKTtcblxudmFyIENPTkZJR1VSQUJMRV9MRU5HVEggPSBERVNDUklQVE9SUyAmJiAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZGVmaW5lUHJvcGVydHkoZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9LCAnbGVuZ3RoJywgeyB2YWx1ZTogOCB9KS5sZW5ndGggIT09IDg7XG59KTtcblxudmFyIFRFTVBMQVRFID0gU3RyaW5nKFN0cmluZykuc3BsaXQoJ1N0cmluZycpO1xuXG52YXIgbWFrZUJ1aWx0SW4gPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSwgbmFtZSwgb3B0aW9ucykge1xuICBpZiAoc3RyaW5nU2xpY2UoJFN0cmluZyhuYW1lKSwgMCwgNykgPT09ICdTeW1ib2woJykge1xuICAgIG5hbWUgPSAnWycgKyByZXBsYWNlKCRTdHJpbmcobmFtZSksIC9eU3ltYm9sXFwoKFteKV0qKVxcKS4qJC8sICckMScpICsgJ10nO1xuICB9XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZ2V0dGVyKSBuYW1lID0gJ2dldCAnICsgbmFtZTtcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5zZXR0ZXIpIG5hbWUgPSAnc2V0ICcgKyBuYW1lO1xuICBpZiAoIWhhc093bih2YWx1ZSwgJ25hbWUnKSB8fCAoQ09ORklHVVJBQkxFX0ZVTkNUSU9OX05BTUUgJiYgdmFsdWUubmFtZSAhPT0gbmFtZSkpIHtcbiAgICBpZiAoREVTQ1JJUFRPUlMpIGRlZmluZVByb3BlcnR5KHZhbHVlLCAnbmFtZScsIHsgdmFsdWU6IG5hbWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9KTtcbiAgICBlbHNlIHZhbHVlLm5hbWUgPSBuYW1lO1xuICB9XG4gIGlmIChDT05GSUdVUkFCTEVfTEVOR1RIICYmIG9wdGlvbnMgJiYgaGFzT3duKG9wdGlvbnMsICdhcml0eScpICYmIHZhbHVlLmxlbmd0aCAhPT0gb3B0aW9ucy5hcml0eSkge1xuICAgIGRlZmluZVByb3BlcnR5KHZhbHVlLCAnbGVuZ3RoJywgeyB2YWx1ZTogb3B0aW9ucy5hcml0eSB9KTtcbiAgfVxuICB0cnkge1xuICAgIGlmIChvcHRpb25zICYmIGhhc093bihvcHRpb25zLCAnY29uc3RydWN0b3InKSAmJiBvcHRpb25zLmNvbnN0cnVjdG9yKSB7XG4gICAgICBpZiAoREVTQ1JJUFRPUlMpIGRlZmluZVByb3BlcnR5KHZhbHVlLCAncHJvdG90eXBlJywgeyB3cml0YWJsZTogZmFsc2UgfSk7XG4gICAgLy8gaW4gVjggfiBDaHJvbWUgNTMsIHByb3RvdHlwZXMgb2Ygc29tZSBtZXRob2RzLCBsaWtlIGBBcnJheS5wcm90b3R5cGUudmFsdWVzYCwgYXJlIG5vbi13cml0YWJsZVxuICAgIH0gZWxzZSBpZiAodmFsdWUucHJvdG90eXBlKSB2YWx1ZS5wcm90b3R5cGUgPSB1bmRlZmluZWQ7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgdmFyIHN0YXRlID0gZW5mb3JjZUludGVybmFsU3RhdGUodmFsdWUpO1xuICBpZiAoIWhhc093bihzdGF0ZSwgJ3NvdXJjZScpKSB7XG4gICAgc3RhdGUuc291cmNlID0gam9pbihURU1QTEFURSwgdHlwZW9mIG5hbWUgPT0gJ3N0cmluZycgPyBuYW1lIDogJycpO1xuICB9IHJldHVybiB2YWx1ZTtcbn07XG5cbi8vIGFkZCBmYWtlIEZ1bmN0aW9uI3RvU3RyaW5nIGZvciBjb3JyZWN0IHdvcmsgd3JhcHBlZCBtZXRob2RzIC8gY29uc3RydWN0b3JzIHdpdGggbWV0aG9kcyBsaWtlIExvRGFzaCBpc05hdGl2ZVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWV4dGVuZC1uYXRpdmUgLS0gcmVxdWlyZWRcbkZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IG1ha2VCdWlsdEluKGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICByZXR1cm4gaXNDYWxsYWJsZSh0aGlzKSAmJiBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpLnNvdXJjZSB8fCBpbnNwZWN0U291cmNlKHRoaXMpO1xufSwgJ3RvU3RyaW5nJyk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgY2VpbCA9IE1hdGguY2VpbDtcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG5cbi8vIGBNYXRoLnRydW5jYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtbWF0aC50cnVuY1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW1hdGgtdHJ1bmMgLS0gc2FmZVxubW9kdWxlLmV4cG9ydHMgPSBNYXRoLnRydW5jIHx8IGZ1bmN0aW9uIHRydW5jKHgpIHtcbiAgdmFyIG4gPSAreDtcbiAgcmV0dXJuIChuID4gMCA/IGZsb29yIDogY2VpbCkobik7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLyogZ2xvYmFsIEFjdGl2ZVhPYmplY3QgLS0gb2xkIElFLCBXU0ggKi9cbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcbnZhciBkZWZpbmVQcm9wZXJ0aWVzTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydGllcycpO1xudmFyIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2VudW0tYnVnLWtleXMnKTtcbnZhciBoaWRkZW5LZXlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hpZGRlbi1rZXlzJyk7XG52YXIgaHRtbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9odG1sJyk7XG52YXIgZG9jdW1lbnRDcmVhdGVFbGVtZW50ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RvY3VtZW50LWNyZWF0ZS1lbGVtZW50Jyk7XG52YXIgc2hhcmVkS2V5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NoYXJlZC1rZXknKTtcblxudmFyIEdUID0gJz4nO1xudmFyIExUID0gJzwnO1xudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xudmFyIFNDUklQVCA9ICdzY3JpcHQnO1xudmFyIElFX1BST1RPID0gc2hhcmVkS2V5KCdJRV9QUk9UTycpO1xuXG52YXIgRW1wdHlDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcblxudmFyIHNjcmlwdFRhZyA9IGZ1bmN0aW9uIChjb250ZW50KSB7XG4gIHJldHVybiBMVCArIFNDUklQVCArIEdUICsgY29udGVudCArIExUICsgJy8nICsgU0NSSVBUICsgR1Q7XG59O1xuXG4vLyBDcmVhdGUgb2JqZWN0IHdpdGggZmFrZSBgbnVsbGAgcHJvdG90eXBlOiB1c2UgQWN0aXZlWCBPYmplY3Qgd2l0aCBjbGVhcmVkIHByb3RvdHlwZVxudmFyIE51bGxQcm90b09iamVjdFZpYUFjdGl2ZVggPSBmdW5jdGlvbiAoYWN0aXZlWERvY3VtZW50KSB7XG4gIGFjdGl2ZVhEb2N1bWVudC53cml0ZShzY3JpcHRUYWcoJycpKTtcbiAgYWN0aXZlWERvY3VtZW50LmNsb3NlKCk7XG4gIHZhciB0ZW1wID0gYWN0aXZlWERvY3VtZW50LnBhcmVudFdpbmRvdy5PYmplY3Q7XG4gIGFjdGl2ZVhEb2N1bWVudCA9IG51bGw7IC8vIGF2b2lkIG1lbW9yeSBsZWFrXG4gIHJldHVybiB0ZW1wO1xufTtcblxuLy8gQ3JlYXRlIG9iamVjdCB3aXRoIGZha2UgYG51bGxgIHByb3RvdHlwZTogdXNlIGlmcmFtZSBPYmplY3Qgd2l0aCBjbGVhcmVkIHByb3RvdHlwZVxudmFyIE51bGxQcm90b09iamVjdFZpYUlGcmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gVGhyYXNoLCB3YXN0ZSBhbmQgc29kb215OiBJRSBHQyBidWdcbiAgdmFyIGlmcmFtZSA9IGRvY3VtZW50Q3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gIHZhciBKUyA9ICdqYXZhJyArIFNDUklQVCArICc6JztcbiAgdmFyIGlmcmFtZURvY3VtZW50O1xuICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgaHRtbC5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvNDc1XG4gIGlmcmFtZS5zcmMgPSBTdHJpbmcoSlMpO1xuICBpZnJhbWVEb2N1bWVudCA9IGlmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50O1xuICBpZnJhbWVEb2N1bWVudC5vcGVuKCk7XG4gIGlmcmFtZURvY3VtZW50LndyaXRlKHNjcmlwdFRhZygnZG9jdW1lbnQuRj1PYmplY3QnKSk7XG4gIGlmcmFtZURvY3VtZW50LmNsb3NlKCk7XG4gIHJldHVybiBpZnJhbWVEb2N1bWVudC5GO1xufTtcblxuLy8gQ2hlY2sgZm9yIGRvY3VtZW50LmRvbWFpbiBhbmQgYWN0aXZlIHggc3VwcG9ydFxuLy8gTm8gbmVlZCB0byB1c2UgYWN0aXZlIHggYXBwcm9hY2ggd2hlbiBkb2N1bWVudC5kb21haW4gaXMgbm90IHNldFxuLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lcy1zaGltcy9lczUtc2hpbS9pc3N1ZXMvMTUwXG4vLyB2YXJpYXRpb24gb2YgaHR0cHM6Ly9naXRodWIuY29tL2tpdGNhbWJyaWRnZS9lczUtc2hpbS9jb21taXQvNGY3MzhhYzA2NjM0NlxuLy8gYXZvaWQgSUUgR0MgYnVnXG52YXIgYWN0aXZlWERvY3VtZW50O1xudmFyIE51bGxQcm90b09iamVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICBhY3RpdmVYRG9jdW1lbnQgPSBuZXcgQWN0aXZlWE9iamVjdCgnaHRtbGZpbGUnKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogaWdub3JlICovIH1cbiAgTnVsbFByb3RvT2JqZWN0ID0gdHlwZW9mIGRvY3VtZW50ICE9ICd1bmRlZmluZWQnXG4gICAgPyBkb2N1bWVudC5kb21haW4gJiYgYWN0aXZlWERvY3VtZW50XG4gICAgICA/IE51bGxQcm90b09iamVjdFZpYUFjdGl2ZVgoYWN0aXZlWERvY3VtZW50KSAvLyBvbGQgSUVcbiAgICAgIDogTnVsbFByb3RvT2JqZWN0VmlhSUZyYW1lKClcbiAgICA6IE51bGxQcm90b09iamVjdFZpYUFjdGl2ZVgoYWN0aXZlWERvY3VtZW50KTsgLy8gV1NIXG4gIHZhciBsZW5ndGggPSBlbnVtQnVnS2V5cy5sZW5ndGg7XG4gIHdoaWxlIChsZW5ndGgtLSkgZGVsZXRlIE51bGxQcm90b09iamVjdFtQUk9UT1RZUEVdW2VudW1CdWdLZXlzW2xlbmd0aF1dO1xuICByZXR1cm4gTnVsbFByb3RvT2JqZWN0KCk7XG59O1xuXG5oaWRkZW5LZXlzW0lFX1BST1RPXSA9IHRydWU7XG5cbi8vIGBPYmplY3QuY3JlYXRlYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmNyZWF0ZVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1jcmVhdGUgLS0gc2FmZVxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuY3JlYXRlIHx8IGZ1bmN0aW9uIGNyZWF0ZShPLCBQcm9wZXJ0aWVzKSB7XG4gIHZhciByZXN1bHQ7XG4gIGlmIChPICE9PSBudWxsKSB7XG4gICAgRW1wdHlDb25zdHJ1Y3RvcltQUk9UT1RZUEVdID0gYW5PYmplY3QoTyk7XG4gICAgcmVzdWx0ID0gbmV3IEVtcHR5Q29uc3RydWN0b3IoKTtcbiAgICBFbXB0eUNvbnN0cnVjdG9yW1BST1RPVFlQRV0gPSBudWxsO1xuICAgIC8vIGFkZCBcIl9fcHJvdG9fX1wiIGZvciBPYmplY3QuZ2V0UHJvdG90eXBlT2YgcG9seWZpbGxcbiAgICByZXN1bHRbSUVfUFJPVE9dID0gTztcbiAgfSBlbHNlIHJlc3VsdCA9IE51bGxQcm90b09iamVjdCgpO1xuICByZXR1cm4gUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogZGVmaW5lUHJvcGVydGllc01vZHVsZS5mKHJlc3VsdCwgUHJvcGVydGllcyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgVjhfUFJPVE9UWVBFX0RFRklORV9CVUcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdjgtcHJvdG90eXBlLWRlZmluZS1idWcnKTtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5Jyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4tb2JqZWN0Jyk7XG52YXIgdG9JbmRleGVkT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0Jyk7XG52YXIgb2JqZWN0S2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3Qta2V5cycpO1xuXG4vLyBgT2JqZWN0LmRlZmluZVByb3BlcnRpZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZGVmaW5lcHJvcGVydGllc1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0aWVzIC0tIHNhZmVcbmV4cG9ydHMuZiA9IERFU0NSSVBUT1JTICYmICFWOF9QUk9UT1RZUEVfREVGSU5FX0JVRyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzIDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICB2YXIgcHJvcHMgPSB0b0luZGV4ZWRPYmplY3QoUHJvcGVydGllcyk7XG4gIHZhciBrZXlzID0gb2JqZWN0S2V5cyhQcm9wZXJ0aWVzKTtcbiAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIga2V5O1xuICB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIGRlZmluZVByb3BlcnR5TW9kdWxlLmYoTywga2V5ID0ga2V5c1tpbmRleCsrXSwgcHJvcHNba2V5XSk7XG4gIHJldHVybiBPO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIElFOF9ET01fREVGSU5FID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2llOC1kb20tZGVmaW5lJyk7XG52YXIgVjhfUFJPVE9UWVBFX0RFRklORV9CVUcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdjgtcHJvdG90eXBlLWRlZmluZS1idWcnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcbnZhciB0b1Byb3BlcnR5S2V5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLXByb3BlcnR5LWtleScpO1xuXG52YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gc2FmZVxudmFyICRkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yIC0tIHNhZmVcbnZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBFTlVNRVJBQkxFID0gJ2VudW1lcmFibGUnO1xudmFyIENPTkZJR1VSQUJMRSA9ICdjb25maWd1cmFibGUnO1xudmFyIFdSSVRBQkxFID0gJ3dyaXRhYmxlJztcblxuLy8gYE9iamVjdC5kZWZpbmVQcm9wZXJ0eWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5kZWZpbmVwcm9wZXJ0eVxuZXhwb3J0cy5mID0gREVTQ1JJUFRPUlMgPyBWOF9QUk9UT1RZUEVfREVGSU5FX0JVRyA/IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpIHtcbiAgYW5PYmplY3QoTyk7XG4gIFAgPSB0b1Byb3BlcnR5S2V5KFApO1xuICBhbk9iamVjdChBdHRyaWJ1dGVzKTtcbiAgaWYgKHR5cGVvZiBPID09PSAnZnVuY3Rpb24nICYmIFAgPT09ICdwcm90b3R5cGUnICYmICd2YWx1ZScgaW4gQXR0cmlidXRlcyAmJiBXUklUQUJMRSBpbiBBdHRyaWJ1dGVzICYmICFBdHRyaWJ1dGVzW1dSSVRBQkxFXSkge1xuICAgIHZhciBjdXJyZW50ID0gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKTtcbiAgICBpZiAoY3VycmVudCAmJiBjdXJyZW50W1dSSVRBQkxFXSkge1xuICAgICAgT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XG4gICAgICBBdHRyaWJ1dGVzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IENPTkZJR1VSQUJMRSBpbiBBdHRyaWJ1dGVzID8gQXR0cmlidXRlc1tDT05GSUdVUkFCTEVdIDogY3VycmVudFtDT05GSUdVUkFCTEVdLFxuICAgICAgICBlbnVtZXJhYmxlOiBFTlVNRVJBQkxFIGluIEF0dHJpYnV0ZXMgPyBBdHRyaWJ1dGVzW0VOVU1FUkFCTEVdIDogY3VycmVudFtFTlVNRVJBQkxFXSxcbiAgICAgICAgd3JpdGFibGU6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgfSByZXR1cm4gJGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpO1xufSA6ICRkZWZpbmVQcm9wZXJ0eSA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpIHtcbiAgYW5PYmplY3QoTyk7XG4gIFAgPSB0b1Byb3BlcnR5S2V5KFApO1xuICBhbk9iamVjdChBdHRyaWJ1dGVzKTtcbiAgaWYgKElFOF9ET01fREVGSU5FKSB0cnkge1xuICAgIHJldHVybiAkZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKCdnZXQnIGluIEF0dHJpYnV0ZXMgfHwgJ3NldCcgaW4gQXR0cmlidXRlcykgdGhyb3cgbmV3ICRUeXBlRXJyb3IoJ0FjY2Vzc29ycyBub3Qgc3VwcG9ydGVkJyk7XG4gIGlmICgndmFsdWUnIGluIEF0dHJpYnV0ZXMpIE9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICByZXR1cm4gTztcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcbnZhciBjYWxsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWNhbGwnKTtcbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtcHJvcGVydHktaXMtZW51bWVyYWJsZScpO1xudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHktZGVzY3JpcHRvcicpO1xudmFyIHRvSW5kZXhlZE9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdCcpO1xudmFyIHRvUHJvcGVydHlLZXkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tcHJvcGVydHkta2V5Jyk7XG52YXIgaGFzT3duID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcy1vd24tcHJvcGVydHknKTtcbnZhciBJRThfRE9NX0RFRklORSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pZTgtZG9tLWRlZmluZScpO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvciAtLSBzYWZlXG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbi8vIGBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmdldG93bnByb3BlcnR5ZGVzY3JpcHRvclxuZXhwb3J0cy5mID0gREVTQ1JJUFRPUlMgPyAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIDogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApIHtcbiAgTyA9IHRvSW5kZXhlZE9iamVjdChPKTtcbiAgUCA9IHRvUHJvcGVydHlLZXkoUCk7XG4gIGlmIChJRThfRE9NX0RFRklORSkgdHJ5IHtcbiAgICByZXR1cm4gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICBpZiAoaGFzT3duKE8sIFApKSByZXR1cm4gY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKCFjYWxsKHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlLmYsIE8sIFApLCBPW1BdKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgaW50ZXJuYWxPYmplY3RLZXlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1rZXlzLWludGVybmFsJyk7XG52YXIgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZW51bS1idWcta2V5cycpO1xuXG52YXIgaGlkZGVuS2V5cyA9IGVudW1CdWdLZXlzLmNvbmNhdCgnbGVuZ3RoJywgJ3Byb3RvdHlwZScpO1xuXG4vLyBgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0b3ducHJvcGVydHluYW1lc1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eW5hbWVzIC0tIHNhZmVcbmV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoTykge1xuICByZXR1cm4gaW50ZXJuYWxPYmplY3RLZXlzKE8sIGhpZGRlbktleXMpO1xufTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlzeW1ib2xzIC0tIHNhZmVcbmV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgaGFzT3duID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcy1vd24tcHJvcGVydHknKTtcbnZhciBpc0NhbGxhYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWNhbGxhYmxlJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tb2JqZWN0Jyk7XG52YXIgc2hhcmVkS2V5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NoYXJlZC1rZXknKTtcbnZhciBDT1JSRUNUX1BST1RPVFlQRV9HRVRURVIgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY29ycmVjdC1wcm90b3R5cGUtZ2V0dGVyJyk7XG5cbnZhciBJRV9QUk9UTyA9IHNoYXJlZEtleSgnSUVfUFJPVE8nKTtcbnZhciAkT2JqZWN0ID0gT2JqZWN0O1xudmFyIE9iamVjdFByb3RvdHlwZSA9ICRPYmplY3QucHJvdG90eXBlO1xuXG4vLyBgT2JqZWN0LmdldFByb3RvdHlwZU9mYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmdldHByb3RvdHlwZW9mXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldHByb3RvdHlwZW9mIC0tIHNhZmVcbm1vZHVsZS5leHBvcnRzID0gQ09SUkVDVF9QUk9UT1RZUEVfR0VUVEVSID8gJE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIChPKSB7XG4gIHZhciBvYmplY3QgPSB0b09iamVjdChPKTtcbiAgaWYgKGhhc093bihvYmplY3QsIElFX1BST1RPKSkgcmV0dXJuIG9iamVjdFtJRV9QUk9UT107XG4gIHZhciBjb25zdHJ1Y3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcjtcbiAgaWYgKGlzQ2FsbGFibGUoY29uc3RydWN0b3IpICYmIG9iamVjdCBpbnN0YW5jZW9mIGNvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIGNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgfSByZXR1cm4gb2JqZWN0IGluc3RhbmNlb2YgJE9iamVjdCA/IE9iamVjdFByb3RvdHlwZSA6IG51bGw7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHVuY3VycnlUaGlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHVuY3VycnlUaGlzKHt9LmlzUHJvdG90eXBlT2YpO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHVuY3VycnlUaGlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcycpO1xudmFyIGhhc093biA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMtb3duLXByb3BlcnR5Jyk7XG52YXIgdG9JbmRleGVkT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0Jyk7XG52YXIgaW5kZXhPZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1pbmNsdWRlcycpLmluZGV4T2Y7XG52YXIgaGlkZGVuS2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oaWRkZW4ta2V5cycpO1xuXG52YXIgcHVzaCA9IHVuY3VycnlUaGlzKFtdLnB1c2gpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWVzKSB7XG4gIHZhciBPID0gdG9JbmRleGVkT2JqZWN0KG9iamVjdCk7XG4gIHZhciBpID0gMDtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIga2V5O1xuICBmb3IgKGtleSBpbiBPKSAhaGFzT3duKGhpZGRlbktleXMsIGtleSkgJiYgaGFzT3duKE8sIGtleSkgJiYgcHVzaChyZXN1bHQsIGtleSk7XG4gIC8vIERvbid0IGVudW0gYnVnICYgaGlkZGVuIGtleXNcbiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIGlmIChoYXNPd24oTywga2V5ID0gbmFtZXNbaSsrXSkpIHtcbiAgICB+aW5kZXhPZihyZXN1bHQsIGtleSkgfHwgcHVzaChyZXN1bHQsIGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgaW50ZXJuYWxPYmplY3RLZXlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1rZXlzLWludGVybmFsJyk7XG52YXIgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZW51bS1idWcta2V5cycpO1xuXG4vLyBgT2JqZWN0LmtleXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3Qua2V5c1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1rZXlzIC0tIHNhZmVcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ga2V5cyhPKSB7XG4gIHJldHVybiBpbnRlcm5hbE9iamVjdEtleXMoTywgZW51bUJ1Z0tleXMpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkcHJvcGVydHlJc0VudW1lcmFibGUgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yIC0tIHNhZmVcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG4vLyBOYXNob3JuIH4gSkRLOCBidWdcbnZhciBOQVNIT1JOX0JVRyA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvciAmJiAhJHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoeyAxOiAyIH0sIDEpO1xuXG4vLyBgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZWAgbWV0aG9kIGltcGxlbWVudGF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5wcm90b3R5cGUucHJvcGVydHlpc2VudW1lcmFibGVcbmV4cG9ydHMuZiA9IE5BU0hPUk5fQlVHID8gZnVuY3Rpb24gcHJvcGVydHlJc0VudW1lcmFibGUoVikge1xuICB2YXIgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0aGlzLCBWKTtcbiAgcmV0dXJuICEhZGVzY3JpcHRvciAmJiBkZXNjcmlwdG9yLmVudW1lcmFibGU7XG59IDogJHByb3BlcnR5SXNFbnVtZXJhYmxlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gLS0gc2FmZSAqL1xudmFyIHVuY3VycnlUaGlzQWNjZXNzb3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzLWFjY2Vzc29yJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4tb2JqZWN0Jyk7XG52YXIgYVBvc3NpYmxlUHJvdG90eXBlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2EtcG9zc2libGUtcHJvdG90eXBlJyk7XG5cbi8vIGBPYmplY3Quc2V0UHJvdG90eXBlT2ZgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3Quc2V0cHJvdG90eXBlb2Zcbi8vIFdvcmtzIHdpdGggX19wcm90b19fIG9ubHkuIE9sZCB2OCBjYW4ndCB3b3JrIHdpdGggbnVsbCBwcm90byBvYmplY3RzLlxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1zZXRwcm90b3R5cGVvZiAtLSBzYWZlXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCAoJ19fcHJvdG9fXycgaW4ge30gPyBmdW5jdGlvbiAoKSB7XG4gIHZhciBDT1JSRUNUX1NFVFRFUiA9IGZhbHNlO1xuICB2YXIgdGVzdCA9IHt9O1xuICB2YXIgc2V0dGVyO1xuICB0cnkge1xuICAgIHNldHRlciA9IHVuY3VycnlUaGlzQWNjZXNzb3IoT2JqZWN0LnByb3RvdHlwZSwgJ19fcHJvdG9fXycsICdzZXQnKTtcbiAgICBzZXR0ZXIodGVzdCwgW10pO1xuICAgIENPUlJFQ1RfU0VUVEVSID0gdGVzdCBpbnN0YW5jZW9mIEFycmF5O1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gIHJldHVybiBmdW5jdGlvbiBzZXRQcm90b3R5cGVPZihPLCBwcm90bykge1xuICAgIGFuT2JqZWN0KE8pO1xuICAgIGFQb3NzaWJsZVByb3RvdHlwZShwcm90byk7XG4gICAgaWYgKENPUlJFQ1RfU0VUVEVSKSBzZXR0ZXIoTywgcHJvdG8pO1xuICAgIGVsc2UgTy5fX3Byb3RvX18gPSBwcm90bztcbiAgICByZXR1cm4gTztcbiAgfTtcbn0oKSA6IHVuZGVmaW5lZCk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgY2FsbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi1jYWxsJyk7XG52YXIgaXNDYWxsYWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1jYWxsYWJsZScpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xuXG52YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcblxuLy8gYE9yZGluYXJ5VG9QcmltaXRpdmVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vcmRpbmFyeXRvcHJpbWl0aXZlXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpbnB1dCwgcHJlZikge1xuICB2YXIgZm4sIHZhbDtcbiAgaWYgKHByZWYgPT09ICdzdHJpbmcnICYmIGlzQ2FsbGFibGUoZm4gPSBpbnB1dC50b1N0cmluZykgJiYgIWlzT2JqZWN0KHZhbCA9IGNhbGwoZm4sIGlucHV0KSkpIHJldHVybiB2YWw7XG4gIGlmIChpc0NhbGxhYmxlKGZuID0gaW5wdXQudmFsdWVPZikgJiYgIWlzT2JqZWN0KHZhbCA9IGNhbGwoZm4sIGlucHV0KSkpIHJldHVybiB2YWw7XG4gIGlmIChwcmVmICE9PSAnc3RyaW5nJyAmJiBpc0NhbGxhYmxlKGZuID0gaW5wdXQudG9TdHJpbmcpICYmICFpc09iamVjdCh2YWwgPSBjYWxsKGZuLCBpbnB1dCkpKSByZXR1cm4gdmFsO1xuICB0aHJvdyBuZXcgJFR5cGVFcnJvcihcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZ2V0QnVpbHRJbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nZXQtYnVpbHQtaW4nKTtcbnZhciB1bmN1cnJ5VGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMnKTtcbnZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LW5hbWVzJyk7XG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LXN5bWJvbHMnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcblxudmFyIGNvbmNhdCA9IHVuY3VycnlUaGlzKFtdLmNvbmNhdCk7XG5cbi8vIGFsbCBvYmplY3Qga2V5cywgaW5jbHVkZXMgbm9uLWVudW1lcmFibGUgYW5kIHN5bWJvbHNcbm1vZHVsZS5leHBvcnRzID0gZ2V0QnVpbHRJbignUmVmbGVjdCcsICdvd25LZXlzJykgfHwgZnVuY3Rpb24gb3duS2V5cyhpdCkge1xuICB2YXIga2V5cyA9IGdldE93blByb3BlcnR5TmFtZXNNb2R1bGUuZihhbk9iamVjdChpdCkpO1xuICB2YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlLmY7XG4gIHJldHVybiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPyBjb25jYXQoa2V5cywgZ2V0T3duUHJvcGVydHlTeW1ib2xzKGl0KSkgOiBrZXlzO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBjYWxsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWNhbGwnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcbnZhciBpc0NhbGxhYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWNhbGxhYmxlJyk7XG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jbGFzc29mLXJhdycpO1xudmFyIHJlZ2V4cEV4ZWMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVnZXhwLWV4ZWMnKTtcblxudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG5cbi8vIGBSZWdFeHBFeGVjYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcmVnZXhwZXhlY1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoUiwgUykge1xuICB2YXIgZXhlYyA9IFIuZXhlYztcbiAgaWYgKGlzQ2FsbGFibGUoZXhlYykpIHtcbiAgICB2YXIgcmVzdWx0ID0gY2FsbChleGVjLCBSLCBTKTtcbiAgICBpZiAocmVzdWx0ICE9PSBudWxsKSBhbk9iamVjdChyZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgaWYgKGNsYXNzb2YoUikgPT09ICdSZWdFeHAnKSByZXR1cm4gY2FsbChyZWdleHBFeGVjLCBSLCBTKTtcbiAgdGhyb3cgbmV3ICRUeXBlRXJyb3IoJ1JlZ0V4cCNleGVjIGNhbGxlZCBvbiBpbmNvbXBhdGlibGUgcmVjZWl2ZXInKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG4vKiBlc2xpbnQtZGlzYWJsZSByZWdleHAvbm8tZW1wdHktY2FwdHVyaW5nLWdyb3VwLCByZWdleHAvbm8tZW1wdHktZ3JvdXAsIHJlZ2V4cC9uby1sYXp5LWVuZHMgLS0gdGVzdGluZyAqL1xuLyogZXNsaW50LWRpc2FibGUgcmVnZXhwL25vLXVzZWxlc3MtcXVhbnRpZmllciAtLSB0ZXN0aW5nICovXG52YXIgY2FsbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi1jYWxsJyk7XG52YXIgdW5jdXJyeVRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzJyk7XG52YXIgdG9TdHJpbmcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tc3RyaW5nJyk7XG52YXIgcmVnZXhwRmxhZ3MgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVnZXhwLWZsYWdzJyk7XG52YXIgc3RpY2t5SGVscGVycyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZWdleHAtc3RpY2t5LWhlbHBlcnMnKTtcbnZhciBzaGFyZWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2hhcmVkJyk7XG52YXIgY3JlYXRlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1jcmVhdGUnKTtcbnZhciBnZXRJbnRlcm5hbFN0YXRlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ludGVybmFsLXN0YXRlJykuZ2V0O1xudmFyIFVOU1VQUE9SVEVEX0RPVF9BTEwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVnZXhwLXVuc3VwcG9ydGVkLWRvdC1hbGwnKTtcbnZhciBVTlNVUFBPUlRFRF9OQ0cgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVnZXhwLXVuc3VwcG9ydGVkLW5jZycpO1xuXG52YXIgbmF0aXZlUmVwbGFjZSA9IHNoYXJlZCgnbmF0aXZlLXN0cmluZy1yZXBsYWNlJywgU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlKTtcbnZhciBuYXRpdmVFeGVjID0gUmVnRXhwLnByb3RvdHlwZS5leGVjO1xudmFyIHBhdGNoZWRFeGVjID0gbmF0aXZlRXhlYztcbnZhciBjaGFyQXQgPSB1bmN1cnJ5VGhpcygnJy5jaGFyQXQpO1xudmFyIGluZGV4T2YgPSB1bmN1cnJ5VGhpcygnJy5pbmRleE9mKTtcbnZhciByZXBsYWNlID0gdW5jdXJyeVRoaXMoJycucmVwbGFjZSk7XG52YXIgc3RyaW5nU2xpY2UgPSB1bmN1cnJ5VGhpcygnJy5zbGljZSk7XG5cbnZhciBVUERBVEVTX0xBU1RfSU5ERVhfV1JPTkcgPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgcmUxID0gL2EvO1xuICB2YXIgcmUyID0gL2IqL2c7XG4gIGNhbGwobmF0aXZlRXhlYywgcmUxLCAnYScpO1xuICBjYWxsKG5hdGl2ZUV4ZWMsIHJlMiwgJ2EnKTtcbiAgcmV0dXJuIHJlMS5sYXN0SW5kZXggIT09IDAgfHwgcmUyLmxhc3RJbmRleCAhPT0gMDtcbn0pKCk7XG5cbnZhciBVTlNVUFBPUlRFRF9ZID0gc3RpY2t5SGVscGVycy5CUk9LRU5fQ0FSRVQ7XG5cbi8vIG5vbnBhcnRpY2lwYXRpbmcgY2FwdHVyaW5nIGdyb3VwLCBjb3BpZWQgZnJvbSBlczUtc2hpbSdzIFN0cmluZyNzcGxpdCBwYXRjaC5cbnZhciBOUENHX0lOQ0xVREVEID0gLygpPz8vLmV4ZWMoJycpWzFdICE9PSB1bmRlZmluZWQ7XG5cbnZhciBQQVRDSCA9IFVQREFURVNfTEFTVF9JTkRFWF9XUk9ORyB8fCBOUENHX0lOQ0xVREVEIHx8IFVOU1VQUE9SVEVEX1kgfHwgVU5TVVBQT1JURURfRE9UX0FMTCB8fCBVTlNVUFBPUlRFRF9OQ0c7XG5cbmlmIChQQVRDSCkge1xuICBwYXRjaGVkRXhlYyA9IGZ1bmN0aW9uIGV4ZWMoc3RyaW5nKSB7XG4gICAgdmFyIHJlID0gdGhpcztcbiAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKHJlKTtcbiAgICB2YXIgc3RyID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICB2YXIgcmF3ID0gc3RhdGUucmF3O1xuICAgIHZhciByZXN1bHQsIHJlQ29weSwgbGFzdEluZGV4LCBtYXRjaCwgaSwgb2JqZWN0LCBncm91cDtcblxuICAgIGlmIChyYXcpIHtcbiAgICAgIHJhdy5sYXN0SW5kZXggPSByZS5sYXN0SW5kZXg7XG4gICAgICByZXN1bHQgPSBjYWxsKHBhdGNoZWRFeGVjLCByYXcsIHN0cik7XG4gICAgICByZS5sYXN0SW5kZXggPSByYXcubGFzdEluZGV4O1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICB2YXIgZ3JvdXBzID0gc3RhdGUuZ3JvdXBzO1xuICAgIHZhciBzdGlja3kgPSBVTlNVUFBPUlRFRF9ZICYmIHJlLnN0aWNreTtcbiAgICB2YXIgZmxhZ3MgPSBjYWxsKHJlZ2V4cEZsYWdzLCByZSk7XG4gICAgdmFyIHNvdXJjZSA9IHJlLnNvdXJjZTtcbiAgICB2YXIgY2hhcnNBZGRlZCA9IDA7XG4gICAgdmFyIHN0ckNvcHkgPSBzdHI7XG5cbiAgICBpZiAoc3RpY2t5KSB7XG4gICAgICBmbGFncyA9IHJlcGxhY2UoZmxhZ3MsICd5JywgJycpO1xuICAgICAgaWYgKGluZGV4T2YoZmxhZ3MsICdnJykgPT09IC0xKSB7XG4gICAgICAgIGZsYWdzICs9ICdnJztcbiAgICAgIH1cblxuICAgICAgc3RyQ29weSA9IHN0cmluZ1NsaWNlKHN0ciwgcmUubGFzdEluZGV4KTtcbiAgICAgIC8vIFN1cHBvcnQgYW5jaG9yZWQgc3RpY2t5IGJlaGF2aW9yLlxuICAgICAgaWYgKHJlLmxhc3RJbmRleCA+IDAgJiYgKCFyZS5tdWx0aWxpbmUgfHwgcmUubXVsdGlsaW5lICYmIGNoYXJBdChzdHIsIHJlLmxhc3RJbmRleCAtIDEpICE9PSAnXFxuJykpIHtcbiAgICAgICAgc291cmNlID0gJyg/OiAnICsgc291cmNlICsgJyknO1xuICAgICAgICBzdHJDb3B5ID0gJyAnICsgc3RyQ29weTtcbiAgICAgICAgY2hhcnNBZGRlZCsrO1xuICAgICAgfVxuICAgICAgLy8gXig/ICsgcnggKyApIGlzIG5lZWRlZCwgaW4gY29tYmluYXRpb24gd2l0aCBzb21lIHN0ciBzbGljaW5nLCB0b1xuICAgICAgLy8gc2ltdWxhdGUgdGhlICd5JyBmbGFnLlxuICAgICAgcmVDb3B5ID0gbmV3IFJlZ0V4cCgnXig/OicgKyBzb3VyY2UgKyAnKScsIGZsYWdzKTtcbiAgICB9XG5cbiAgICBpZiAoTlBDR19JTkNMVURFRCkge1xuICAgICAgcmVDb3B5ID0gbmV3IFJlZ0V4cCgnXicgKyBzb3VyY2UgKyAnJCg/IVxcXFxzKScsIGZsYWdzKTtcbiAgICB9XG4gICAgaWYgKFVQREFURVNfTEFTVF9JTkRFWF9XUk9ORykgbGFzdEluZGV4ID0gcmUubGFzdEluZGV4O1xuXG4gICAgbWF0Y2ggPSBjYWxsKG5hdGl2ZUV4ZWMsIHN0aWNreSA/IHJlQ29weSA6IHJlLCBzdHJDb3B5KTtcblxuICAgIGlmIChzdGlja3kpIHtcbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICBtYXRjaC5pbnB1dCA9IHN0cmluZ1NsaWNlKG1hdGNoLmlucHV0LCBjaGFyc0FkZGVkKTtcbiAgICAgICAgbWF0Y2hbMF0gPSBzdHJpbmdTbGljZShtYXRjaFswXSwgY2hhcnNBZGRlZCk7XG4gICAgICAgIG1hdGNoLmluZGV4ID0gcmUubGFzdEluZGV4O1xuICAgICAgICByZS5sYXN0SW5kZXggKz0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgfSBlbHNlIHJlLmxhc3RJbmRleCA9IDA7XG4gICAgfSBlbHNlIGlmIChVUERBVEVTX0xBU1RfSU5ERVhfV1JPTkcgJiYgbWF0Y2gpIHtcbiAgICAgIHJlLmxhc3RJbmRleCA9IHJlLmdsb2JhbCA/IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoIDogbGFzdEluZGV4O1xuICAgIH1cbiAgICBpZiAoTlBDR19JTkNMVURFRCAmJiBtYXRjaCAmJiBtYXRjaC5sZW5ndGggPiAxKSB7XG4gICAgICAvLyBGaXggYnJvd3NlcnMgd2hvc2UgYGV4ZWNgIG1ldGhvZHMgZG9uJ3QgY29uc2lzdGVudGx5IHJldHVybiBgdW5kZWZpbmVkYFxuICAgICAgLy8gZm9yIE5QQ0csIGxpa2UgSUU4LiBOT1RFOiBUaGlzIGRvZXNuJ3Qgd29yayBmb3IgLyguPyk/L1xuICAgICAgY2FsbChuYXRpdmVSZXBsYWNlLCBtYXRjaFswXSwgcmVDb3B5LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoIC0gMjsgaSsrKSB7XG4gICAgICAgICAgaWYgKGFyZ3VtZW50c1tpXSA9PT0gdW5kZWZpbmVkKSBtYXRjaFtpXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKG1hdGNoICYmIGdyb3Vwcykge1xuICAgICAgbWF0Y2guZ3JvdXBzID0gb2JqZWN0ID0gY3JlYXRlKG51bGwpO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGdyb3Vwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBncm91cCA9IGdyb3Vwc1tpXTtcbiAgICAgICAgb2JqZWN0W2dyb3VwWzBdXSA9IG1hdGNoW2dyb3VwWzFdXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWF0Y2g7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGF0Y2hlZEV4ZWM7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4tb2JqZWN0Jyk7XG5cbi8vIGBSZWdFeHAucHJvdG90eXBlLmZsYWdzYCBnZXR0ZXIgaW1wbGVtZW50YXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtZ2V0LXJlZ2V4cC5wcm90b3R5cGUuZmxhZ3Ncbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdGhhdCA9IGFuT2JqZWN0KHRoaXMpO1xuICB2YXIgcmVzdWx0ID0gJyc7XG4gIGlmICh0aGF0Lmhhc0luZGljZXMpIHJlc3VsdCArPSAnZCc7XG4gIGlmICh0aGF0Lmdsb2JhbCkgcmVzdWx0ICs9ICdnJztcbiAgaWYgKHRoYXQuaWdub3JlQ2FzZSkgcmVzdWx0ICs9ICdpJztcbiAgaWYgKHRoYXQubXVsdGlsaW5lKSByZXN1bHQgKz0gJ20nO1xuICBpZiAodGhhdC5kb3RBbGwpIHJlc3VsdCArPSAncyc7XG4gIGlmICh0aGF0LnVuaWNvZGUpIHJlc3VsdCArPSAndSc7XG4gIGlmICh0aGF0LnVuaWNvZGVTZXRzKSByZXN1bHQgKz0gJ3YnO1xuICBpZiAodGhhdC5zdGlja3kpIHJlc3VsdCArPSAneSc7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGNhbGwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tY2FsbCcpO1xudmFyIGhhc093biA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMtb3duLXByb3BlcnR5Jyk7XG52YXIgaXNQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtaXMtcHJvdG90eXBlLW9mJyk7XG52YXIgcmVnRXhwRmxhZ3MgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVnZXhwLWZsYWdzJyk7XG5cbnZhciBSZWdFeHBQcm90b3R5cGUgPSBSZWdFeHAucHJvdG90eXBlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChSKSB7XG4gIHZhciBmbGFncyA9IFIuZmxhZ3M7XG4gIHJldHVybiBmbGFncyA9PT0gdW5kZWZpbmVkICYmICEoJ2ZsYWdzJyBpbiBSZWdFeHBQcm90b3R5cGUpICYmICFoYXNPd24oUiwgJ2ZsYWdzJykgJiYgaXNQcm90b3R5cGVPZihSZWdFeHBQcm90b3R5cGUsIFIpXG4gICAgPyBjYWxsKHJlZ0V4cEZsYWdzLCBSKSA6IGZsYWdzO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcblxuLy8gYmFiZWwtbWluaWZ5IGFuZCBDbG9zdXJlIENvbXBpbGVyIHRyYW5zcGlsZXMgUmVnRXhwKCdhJywgJ3knKSAtPiAvYS95IGFuZCBpdCBjYXVzZXMgU3ludGF4RXJyb3JcbnZhciAkUmVnRXhwID0gZ2xvYmFsLlJlZ0V4cDtcblxudmFyIFVOU1VQUE9SVEVEX1kgPSBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHZhciByZSA9ICRSZWdFeHAoJ2EnLCAneScpO1xuICByZS5sYXN0SW5kZXggPSAyO1xuICByZXR1cm4gcmUuZXhlYygnYWJjZCcpICE9PSBudWxsO1xufSk7XG5cbi8vIFVDIEJyb3dzZXIgYnVnXG4vLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMTAwOFxudmFyIE1JU1NFRF9TVElDS1kgPSBVTlNVUFBPUlRFRF9ZIHx8IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICEkUmVnRXhwKCdhJywgJ3knKS5zdGlja3k7XG59KTtcblxudmFyIEJST0tFTl9DQVJFVCA9IFVOU1VQUE9SVEVEX1kgfHwgZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD03NzM2ODdcbiAgdmFyIHJlID0gJFJlZ0V4cCgnXnInLCAnZ3knKTtcbiAgcmUubGFzdEluZGV4ID0gMjtcbiAgcmV0dXJuIHJlLmV4ZWMoJ3N0cicpICE9PSBudWxsO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBCUk9LRU5fQ0FSRVQ6IEJST0tFTl9DQVJFVCxcbiAgTUlTU0VEX1NUSUNLWTogTUlTU0VEX1NUSUNLWSxcbiAgVU5TVVBQT1JURURfWTogVU5TVVBQT1JURURfWVxufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcblxuLy8gYmFiZWwtbWluaWZ5IGFuZCBDbG9zdXJlIENvbXBpbGVyIHRyYW5zcGlsZXMgUmVnRXhwKCcuJywgJ3MnKSAtPiAvLi9zIGFuZCBpdCBjYXVzZXMgU3ludGF4RXJyb3JcbnZhciAkUmVnRXhwID0gZ2xvYmFsLlJlZ0V4cDtcblxubW9kdWxlLmV4cG9ydHMgPSBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHZhciByZSA9ICRSZWdFeHAoJy4nLCAncycpO1xuICByZXR1cm4gIShyZS5kb3RBbGwgJiYgcmUudGVzdCgnXFxuJykgJiYgcmUuZmxhZ3MgPT09ICdzJyk7XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcblxuLy8gYmFiZWwtbWluaWZ5IGFuZCBDbG9zdXJlIENvbXBpbGVyIHRyYW5zcGlsZXMgUmVnRXhwKCcoPzxhPmIpJywgJ2cnKSAtPiAvKD88YT5iKS9nIGFuZCBpdCBjYXVzZXMgU3ludGF4RXJyb3JcbnZhciAkUmVnRXhwID0gZ2xvYmFsLlJlZ0V4cDtcblxubW9kdWxlLmV4cG9ydHMgPSBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHZhciByZSA9ICRSZWdFeHAoJyg/PGE+YiknLCAnZycpO1xuICByZXR1cm4gcmUuZXhlYygnYicpLmdyb3Vwcy5hICE9PSAnYicgfHxcbiAgICAnYicucmVwbGFjZShyZSwgJyQ8YT5jJykgIT09ICdiYyc7XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBpc051bGxPclVuZGVmaW5lZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1udWxsLW9yLXVuZGVmaW5lZCcpO1xuXG52YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcblxuLy8gYFJlcXVpcmVPYmplY3RDb2VyY2libGVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1yZXF1aXJlb2JqZWN0Y29lcmNpYmxlXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXNOdWxsT3JVbmRlZmluZWQoaXQpKSB0aHJvdyBuZXcgJFR5cGVFcnJvcihcIkNhbid0IGNhbGwgbWV0aG9kIG9uIFwiICsgaXQpO1xuICByZXR1cm4gaXQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHknKS5mO1xudmFyIGhhc093biA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMtb3duLXByb3BlcnR5Jyk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG5cbnZhciBUT19TVFJJTkdfVEFHID0gd2VsbEtub3duU3ltYm9sKCd0b1N0cmluZ1RhZycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0YXJnZXQsIFRBRywgU1RBVElDKSB7XG4gIGlmICh0YXJnZXQgJiYgIVNUQVRJQykgdGFyZ2V0ID0gdGFyZ2V0LnByb3RvdHlwZTtcbiAgaWYgKHRhcmdldCAmJiAhaGFzT3duKHRhcmdldCwgVE9fU1RSSU5HX1RBRykpIHtcbiAgICBkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIFRPX1NUUklOR19UQUcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCB2YWx1ZTogVEFHIH0pO1xuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zaGFyZWQnKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdWlkJyk7XG5cbnZhciBrZXlzID0gc2hhcmVkKCdrZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4ga2V5c1trZXldIHx8IChrZXlzW2tleV0gPSB1aWQoa2V5KSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBkZWZpbmVHbG9iYWxQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZWZpbmUtZ2xvYmFsLXByb3BlcnR5Jyk7XG5cbnZhciBTSEFSRUQgPSAnX19jb3JlLWpzX3NoYXJlZF9fJztcbnZhciBzdG9yZSA9IGdsb2JhbFtTSEFSRURdIHx8IGRlZmluZUdsb2JhbFByb3BlcnR5KFNIQVJFRCwge30pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHN0b3JlO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIElTX1BVUkUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtcHVyZScpO1xudmFyIHN0b3JlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NoYXJlZC1zdG9yZScpO1xuXG4obW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICByZXR1cm4gc3RvcmVba2V5XSB8fCAoc3RvcmVba2V5XSA9IHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IHt9KTtcbn0pKCd2ZXJzaW9ucycsIFtdKS5wdXNoKHtcbiAgdmVyc2lvbjogJzMuMzUuMScsXG4gIG1vZGU6IElTX1BVUkUgPyAncHVyZScgOiAnZ2xvYmFsJyxcbiAgY29weXJpZ2h0OiAnwqkgMjAxNC0yMDI0IERlbmlzIFB1c2hrYXJldiAoemxvaXJvY2sucnUpJyxcbiAgbGljZW5zZTogJ2h0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2Jsb2IvdjMuMzUuMS9MSUNFTlNFJyxcbiAgc291cmNlOiAnaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMnXG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcbnZhciBhQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYS1jb25zdHJ1Y3RvcicpO1xudmFyIGlzTnVsbE9yVW5kZWZpbmVkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW51bGwtb3ItdW5kZWZpbmVkJyk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG5cbnZhciBTUEVDSUVTID0gd2VsbEtub3duU3ltYm9sKCdzcGVjaWVzJyk7XG5cbi8vIGBTcGVjaWVzQ29uc3RydWN0b3JgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zcGVjaWVzY29uc3RydWN0b3Jcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE8sIGRlZmF1bHRDb25zdHJ1Y3Rvcikge1xuICB2YXIgQyA9IGFuT2JqZWN0KE8pLmNvbnN0cnVjdG9yO1xuICB2YXIgUztcbiAgcmV0dXJuIEMgPT09IHVuZGVmaW5lZCB8fCBpc051bGxPclVuZGVmaW5lZChTID0gYW5PYmplY3QoQylbU1BFQ0lFU10pID8gZGVmYXVsdENvbnN0cnVjdG9yIDogYUNvbnN0cnVjdG9yKFMpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciB1bmN1cnJ5VGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMnKTtcbnZhciB0b0ludGVnZXJPckluZmluaXR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWludGVnZXItb3ItaW5maW5pdHknKTtcbnZhciB0b1N0cmluZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1zdHJpbmcnKTtcbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZScpO1xuXG52YXIgY2hhckF0ID0gdW5jdXJyeVRoaXMoJycuY2hhckF0KTtcbnZhciBjaGFyQ29kZUF0ID0gdW5jdXJyeVRoaXMoJycuY2hhckNvZGVBdCk7XG52YXIgc3RyaW5nU2xpY2UgPSB1bmN1cnJ5VGhpcygnJy5zbGljZSk7XG5cbnZhciBjcmVhdGVNZXRob2QgPSBmdW5jdGlvbiAoQ09OVkVSVF9UT19TVFJJTkcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgcG9zKSB7XG4gICAgdmFyIFMgPSB0b1N0cmluZyhyZXF1aXJlT2JqZWN0Q29lcmNpYmxlKCR0aGlzKSk7XG4gICAgdmFyIHBvc2l0aW9uID0gdG9JbnRlZ2VyT3JJbmZpbml0eShwb3MpO1xuICAgIHZhciBzaXplID0gUy5sZW5ndGg7XG4gICAgdmFyIGZpcnN0LCBzZWNvbmQ7XG4gICAgaWYgKHBvc2l0aW9uIDwgMCB8fCBwb3NpdGlvbiA+PSBzaXplKSByZXR1cm4gQ09OVkVSVF9UT19TVFJJTkcgPyAnJyA6IHVuZGVmaW5lZDtcbiAgICBmaXJzdCA9IGNoYXJDb2RlQXQoUywgcG9zaXRpb24pO1xuICAgIHJldHVybiBmaXJzdCA8IDB4RDgwMCB8fCBmaXJzdCA+IDB4REJGRiB8fCBwb3NpdGlvbiArIDEgPT09IHNpemVcbiAgICAgIHx8IChzZWNvbmQgPSBjaGFyQ29kZUF0KFMsIHBvc2l0aW9uICsgMSkpIDwgMHhEQzAwIHx8IHNlY29uZCA+IDB4REZGRlxuICAgICAgICA/IENPTlZFUlRfVE9fU1RSSU5HXG4gICAgICAgICAgPyBjaGFyQXQoUywgcG9zaXRpb24pXG4gICAgICAgICAgOiBmaXJzdFxuICAgICAgICA6IENPTlZFUlRfVE9fU1RSSU5HXG4gICAgICAgICAgPyBzdHJpbmdTbGljZShTLCBwb3NpdGlvbiwgcG9zaXRpb24gKyAyKVxuICAgICAgICAgIDogKGZpcnN0IC0gMHhEODAwIDw8IDEwKSArIChzZWNvbmQgLSAweERDMDApICsgMHgxMDAwMDtcbiAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvLyBgU3RyaW5nLnByb3RvdHlwZS5jb2RlUG9pbnRBdGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS5jb2RlcG9pbnRhdFxuICBjb2RlQXQ6IGNyZWF0ZU1ldGhvZChmYWxzZSksXG4gIC8vIGBTdHJpbmcucHJvdG90eXBlLmF0YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21hdGhpYXNieW5lbnMvU3RyaW5nLnByb3RvdHlwZS5hdFxuICBjaGFyQXQ6IGNyZWF0ZU1ldGhvZCh0cnVlKVxufTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8qIGVzbGludC1kaXNhYmxlIGVzL25vLXN5bWJvbCAtLSByZXF1aXJlZCBmb3IgdGVzdGluZyAqL1xudmFyIFY4X1ZFUlNJT04gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZW5naW5lLXY4LXZlcnNpb24nKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcblxudmFyICRTdHJpbmcgPSBnbG9iYWwuU3RyaW5nO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5c3ltYm9scyAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xubW9kdWxlLmV4cG9ydHMgPSAhIU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgJiYgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN5bWJvbCA9IFN5bWJvbCgnc3ltYm9sIGRldGVjdGlvbicpO1xuICAvLyBDaHJvbWUgMzggU3ltYm9sIGhhcyBpbmNvcnJlY3QgdG9TdHJpbmcgY29udmVyc2lvblxuICAvLyBgZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzYCBwb2x5ZmlsbCBzeW1ib2xzIGNvbnZlcnRlZCB0byBvYmplY3QgYXJlIG5vdCBTeW1ib2wgaW5zdGFuY2VzXG4gIC8vIG5iOiBEbyBub3QgY2FsbCBgU3RyaW5nYCBkaXJlY3RseSB0byBhdm9pZCB0aGlzIGJlaW5nIG9wdGltaXplZCBvdXQgdG8gYHN5bWJvbCsnJ2Agd2hpY2ggd2lsbCxcbiAgLy8gb2YgY291cnNlLCBmYWlsLlxuICByZXR1cm4gISRTdHJpbmcoc3ltYm9sKSB8fCAhKE9iamVjdChzeW1ib2wpIGluc3RhbmNlb2YgU3ltYm9sKSB8fFxuICAgIC8vIENocm9tZSAzOC00MCBzeW1ib2xzIGFyZSBub3QgaW5oZXJpdGVkIGZyb20gRE9NIGNvbGxlY3Rpb25zIHByb3RvdHlwZXMgdG8gaW5zdGFuY2VzXG4gICAgIVN5bWJvbC5zaGFtICYmIFY4X1ZFUlNJT04gJiYgVjhfVkVSU0lPTiA8IDQxO1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgdG9JbnRlZ2VyT3JJbmZpbml0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbnRlZ2VyLW9yLWluZmluaXR5Jyk7XG5cbnZhciBtYXggPSBNYXRoLm1heDtcbnZhciBtaW4gPSBNYXRoLm1pbjtcblxuLy8gSGVscGVyIGZvciBhIHBvcHVsYXIgcmVwZWF0aW5nIGNhc2Ugb2YgdGhlIHNwZWM6XG4vLyBMZXQgaW50ZWdlciBiZSA/IFRvSW50ZWdlcihpbmRleCkuXG4vLyBJZiBpbnRlZ2VyIDwgMCwgbGV0IHJlc3VsdCBiZSBtYXgoKGxlbmd0aCArIGludGVnZXIpLCAwKTsgZWxzZSBsZXQgcmVzdWx0IGJlIG1pbihpbnRlZ2VyLCBsZW5ndGgpLlxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5kZXgsIGxlbmd0aCkge1xuICB2YXIgaW50ZWdlciA9IHRvSW50ZWdlck9ySW5maW5pdHkoaW5kZXgpO1xuICByZXR1cm4gaW50ZWdlciA8IDAgPyBtYXgoaW50ZWdlciArIGxlbmd0aCwgMCkgOiBtaW4oaW50ZWdlciwgbGVuZ3RoKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG4vLyB0b09iamVjdCB3aXRoIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgc3RyaW5nc1xudmFyIEluZGV4ZWRPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW5kZXhlZC1vYmplY3QnKTtcbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gSW5kZXhlZE9iamVjdChyZXF1aXJlT2JqZWN0Q29lcmNpYmxlKGl0KSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHRydW5jID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL21hdGgtdHJ1bmMnKTtcblxuLy8gYFRvSW50ZWdlck9ySW5maW5pdHlgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b2ludGVnZXJvcmluZmluaXR5XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICB2YXIgbnVtYmVyID0gK2FyZ3VtZW50O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlIC0tIE5hTiBjaGVja1xuICByZXR1cm4gbnVtYmVyICE9PSBudW1iZXIgfHwgbnVtYmVyID09PSAwID8gMCA6IHRydW5jKG51bWJlcik7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHRvSW50ZWdlck9ySW5maW5pdHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW50ZWdlci1vci1pbmZpbml0eScpO1xuXG52YXIgbWluID0gTWF0aC5taW47XG5cbi8vIGBUb0xlbmd0aGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvbGVuZ3RoXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICB2YXIgbGVuID0gdG9JbnRlZ2VyT3JJbmZpbml0eShhcmd1bWVudCk7XG4gIHJldHVybiBsZW4gPiAwID8gbWluKGxlbiwgMHgxRkZGRkZGRkZGRkZGRikgOiAwOyAvLyAyICoqIDUzIC0gMSA9PSA5MDA3MTk5MjU0NzQwOTkxXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVxdWlyZS1vYmplY3QtY29lcmNpYmxlJyk7XG5cbnZhciAkT2JqZWN0ID0gT2JqZWN0O1xuXG4vLyBgVG9PYmplY3RgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b29iamVjdFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuICRPYmplY3QocmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudCkpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciB0b1Bvc2l0aXZlSW50ZWdlciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1wb3NpdGl2ZS1pbnRlZ2VyJyk7XG5cbnZhciAkUmFuZ2VFcnJvciA9IFJhbmdlRXJyb3I7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBCWVRFUykge1xuICB2YXIgb2Zmc2V0ID0gdG9Qb3NpdGl2ZUludGVnZXIoaXQpO1xuICBpZiAob2Zmc2V0ICUgQllURVMpIHRocm93IG5ldyAkUmFuZ2VFcnJvcignV3Jvbmcgb2Zmc2V0Jyk7XG4gIHJldHVybiBvZmZzZXQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHRvSW50ZWdlck9ySW5maW5pdHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW50ZWdlci1vci1pbmZpbml0eScpO1xuXG52YXIgJFJhbmdlRXJyb3IgPSBSYW5nZUVycm9yO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgcmVzdWx0ID0gdG9JbnRlZ2VyT3JJbmZpbml0eShpdCk7XG4gIGlmIChyZXN1bHQgPCAwKSB0aHJvdyBuZXcgJFJhbmdlRXJyb3IoXCJUaGUgYXJndW1lbnQgY2FuJ3QgYmUgbGVzcyB0aGFuIDBcIik7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGNhbGwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tY2FsbCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xudmFyIGlzU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLXN5bWJvbCcpO1xudmFyIGdldE1ldGhvZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nZXQtbWV0aG9kJyk7XG52YXIgb3JkaW5hcnlUb1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vcmRpbmFyeS10by1wcmltaXRpdmUnKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcblxudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG52YXIgVE9fUFJJTUlUSVZFID0gd2VsbEtub3duU3ltYm9sKCd0b1ByaW1pdGl2ZScpO1xuXG4vLyBgVG9QcmltaXRpdmVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b3ByaW1pdGl2ZVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5wdXQsIHByZWYpIHtcbiAgaWYgKCFpc09iamVjdChpbnB1dCkgfHwgaXNTeW1ib2woaW5wdXQpKSByZXR1cm4gaW5wdXQ7XG4gIHZhciBleG90aWNUb1ByaW0gPSBnZXRNZXRob2QoaW5wdXQsIFRPX1BSSU1JVElWRSk7XG4gIHZhciByZXN1bHQ7XG4gIGlmIChleG90aWNUb1ByaW0pIHtcbiAgICBpZiAocHJlZiA9PT0gdW5kZWZpbmVkKSBwcmVmID0gJ2RlZmF1bHQnO1xuICAgIHJlc3VsdCA9IGNhbGwoZXhvdGljVG9QcmltLCBpbnB1dCwgcHJlZik7XG4gICAgaWYgKCFpc09iamVjdChyZXN1bHQpIHx8IGlzU3ltYm9sKHJlc3VsdCkpIHJldHVybiByZXN1bHQ7XG4gICAgdGhyb3cgbmV3ICRUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG4gIH1cbiAgaWYgKHByZWYgPT09IHVuZGVmaW5lZCkgcHJlZiA9ICdudW1iZXInO1xuICByZXR1cm4gb3JkaW5hcnlUb1ByaW1pdGl2ZShpbnB1dCwgcHJlZik7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLXByaW1pdGl2ZScpO1xudmFyIGlzU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLXN5bWJvbCcpO1xuXG4vLyBgVG9Qcm9wZXJ0eUtleWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvcHJvcGVydHlrZXlcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHZhciBrZXkgPSB0b1ByaW1pdGl2ZShhcmd1bWVudCwgJ3N0cmluZycpO1xuICByZXR1cm4gaXNTeW1ib2woa2V5KSA/IGtleSA6IGtleSArICcnO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcblxudmFyIFRPX1NUUklOR19UQUcgPSB3ZWxsS25vd25TeW1ib2woJ3RvU3RyaW5nVGFnJyk7XG52YXIgdGVzdCA9IHt9O1xuXG50ZXN0W1RPX1NUUklOR19UQUddID0gJ3onO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN0cmluZyh0ZXN0KSA9PT0gJ1tvYmplY3Qgel0nO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY2xhc3NvZicpO1xuXG52YXIgJFN0cmluZyA9IFN0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgaWYgKGNsYXNzb2YoYXJndW1lbnQpID09PSAnU3ltYm9sJykgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgYSBTeW1ib2wgdmFsdWUgdG8gYSBzdHJpbmcnKTtcbiAgcmV0dXJuICRTdHJpbmcoYXJndW1lbnQpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkU3RyaW5nID0gU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICB0cnkge1xuICAgIHJldHVybiAkU3RyaW5nKGFyZ3VtZW50KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gJ09iamVjdCc7XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgdW5jdXJyeVRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzJyk7XG5cbnZhciBpZCA9IDA7XG52YXIgcG9zdGZpeCA9IE1hdGgucmFuZG9tKCk7XG52YXIgdG9TdHJpbmcgPSB1bmN1cnJ5VGhpcygxLjAudG9TdHJpbmcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuICdTeW1ib2woJyArIChrZXkgPT09IHVuZGVmaW5lZCA/ICcnIDoga2V5KSArICcpXycgKyB0b1N0cmluZygrK2lkICsgcG9zdGZpeCwgMzYpO1xufTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8qIGVzbGludC1kaXNhYmxlIGVzL25vLXN5bWJvbCAtLSByZXF1aXJlZCBmb3IgdGVzdGluZyAqL1xudmFyIE5BVElWRV9TWU1CT0wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc3ltYm9sLWNvbnN0cnVjdG9yLWRldGVjdGlvbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE5BVElWRV9TWU1CT0xcbiAgJiYgIVN5bWJvbC5zaGFtXG4gICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT0gJ3N5bWJvbCc7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xuXG4vLyBWOCB+IENocm9tZSAzNi1cbi8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMzMzRcbm1vZHVsZS5leHBvcnRzID0gREVTQ1JJUFRPUlMgJiYgZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9LCAncHJvdG90eXBlJywge1xuICAgIHZhbHVlOiA0MixcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSkucHJvdG90eXBlICE9PSA0Mjtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBpc0NhbGxhYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWNhbGxhYmxlJyk7XG5cbnZhciBXZWFrTWFwID0gZ2xvYmFsLldlYWtNYXA7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNDYWxsYWJsZShXZWFrTWFwKSAmJiAvbmF0aXZlIGNvZGUvLnRlc3QoU3RyaW5nKFdlYWtNYXApKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgc2hhcmVkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NoYXJlZCcpO1xudmFyIGhhc093biA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMtb3duLXByb3BlcnR5Jyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3VpZCcpO1xudmFyIE5BVElWRV9TWU1CT0wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc3ltYm9sLWNvbnN0cnVjdG9yLWRldGVjdGlvbicpO1xudmFyIFVTRV9TWU1CT0xfQVNfVUlEID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3VzZS1zeW1ib2wtYXMtdWlkJyk7XG5cbnZhciBTeW1ib2wgPSBnbG9iYWwuU3ltYm9sO1xudmFyIFdlbGxLbm93blN5bWJvbHNTdG9yZSA9IHNoYXJlZCgnd2tzJyk7XG52YXIgY3JlYXRlV2VsbEtub3duU3ltYm9sID0gVVNFX1NZTUJPTF9BU19VSUQgPyBTeW1ib2xbJ2ZvciddIHx8IFN5bWJvbCA6IFN5bWJvbCAmJiBTeW1ib2wud2l0aG91dFNldHRlciB8fCB1aWQ7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgaWYgKCFoYXNPd24oV2VsbEtub3duU3ltYm9sc1N0b3JlLCBuYW1lKSkge1xuICAgIFdlbGxLbm93blN5bWJvbHNTdG9yZVtuYW1lXSA9IE5BVElWRV9TWU1CT0wgJiYgaGFzT3duKFN5bWJvbCwgbmFtZSlcbiAgICAgID8gU3ltYm9sW25hbWVdXG4gICAgICA6IGNyZWF0ZVdlbGxLbm93blN5bWJvbCgnU3ltYm9sLicgKyBuYW1lKTtcbiAgfSByZXR1cm4gV2VsbEtub3duU3ltYm9sc1N0b3JlW25hbWVdO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyICRyZWR1Y2UgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktcmVkdWNlJykubGVmdDtcbnZhciBhcnJheU1ldGhvZElzU3RyaWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LW1ldGhvZC1pcy1zdHJpY3QnKTtcbnZhciBDSFJPTUVfVkVSU0lPTiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9lbmdpbmUtdjgtdmVyc2lvbicpO1xudmFyIElTX05PREUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZW5naW5lLWlzLW5vZGUnKTtcblxuLy8gQ2hyb21lIDgwLTgyIGhhcyBhIGNyaXRpY2FsIGJ1Z1xuLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MTA0OTk4MlxudmFyIENIUk9NRV9CVUcgPSAhSVNfTk9ERSAmJiBDSFJPTUVfVkVSU0lPTiA+IDc5ICYmIENIUk9NRV9WRVJTSU9OIDwgODM7XG52YXIgRk9SQ0VEID0gQ0hST01FX0JVRyB8fCAhYXJyYXlNZXRob2RJc1N0cmljdCgncmVkdWNlJyk7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUucmVkdWNlYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnJlZHVjZVxuJCh7IHRhcmdldDogJ0FycmF5JywgcHJvdG86IHRydWUsIGZvcmNlZDogRk9SQ0VEIH0sIHtcbiAgcmVkdWNlOiBmdW5jdGlvbiByZWR1Y2UoY2FsbGJhY2tmbiAvKiAsIGluaXRpYWxWYWx1ZSAqLykge1xuICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHJldHVybiAkcmVkdWNlKHRoaXMsIGNhbGxiYWNrZm4sIGxlbmd0aCwgbGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gdGhpcyBtZXRob2Qgd2FzIGFkZGVkIHRvIHVuc2NvcGFibGVzIGFmdGVyIGltcGxlbWVudGF0aW9uXG4vLyBpbiBwb3B1bGFyIGVuZ2luZXMsIHNvIGl0J3MgbW92ZWQgdG8gYSBzZXBhcmF0ZSBtb2R1bGVcbnZhciBhZGRUb1Vuc2NvcGFibGVzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FkZC10by11bnNjb3BhYmxlcycpO1xuXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS1AQHVuc2NvcGFibGVzXG5hZGRUb1Vuc2NvcGFibGVzKCdmbGF0Jyk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBnZXRCdWlsdEluID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dldC1idWlsdC1pbicpO1xudmFyIGFwcGx5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWFwcGx5Jyk7XG52YXIgY2FsbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi1jYWxsJyk7XG52YXIgdW5jdXJyeVRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciBpc0NhbGxhYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWNhbGxhYmxlJyk7XG52YXIgaXNTeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtc3ltYm9sJyk7XG52YXIgYXJyYXlTbGljZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1zbGljZScpO1xudmFyIGdldFJlcGxhY2VyRnVuY3Rpb24gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2V0LWpzb24tcmVwbGFjZXItZnVuY3Rpb24nKTtcbnZhciBOQVRJVkVfU1lNQk9MID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3N5bWJvbC1jb25zdHJ1Y3Rvci1kZXRlY3Rpb24nKTtcblxudmFyICRTdHJpbmcgPSBTdHJpbmc7XG52YXIgJHN0cmluZ2lmeSA9IGdldEJ1aWx0SW4oJ0pTT04nLCAnc3RyaW5naWZ5Jyk7XG52YXIgZXhlYyA9IHVuY3VycnlUaGlzKC8uLy5leGVjKTtcbnZhciBjaGFyQXQgPSB1bmN1cnJ5VGhpcygnJy5jaGFyQXQpO1xudmFyIGNoYXJDb2RlQXQgPSB1bmN1cnJ5VGhpcygnJy5jaGFyQ29kZUF0KTtcbnZhciByZXBsYWNlID0gdW5jdXJyeVRoaXMoJycucmVwbGFjZSk7XG52YXIgbnVtYmVyVG9TdHJpbmcgPSB1bmN1cnJ5VGhpcygxLjAudG9TdHJpbmcpO1xuXG52YXIgdGVzdGVyID0gL1tcXHVEODAwLVxcdURGRkZdL2c7XG52YXIgbG93ID0gL15bXFx1RDgwMC1cXHVEQkZGXSQvO1xudmFyIGhpID0gL15bXFx1REMwMC1cXHVERkZGXSQvO1xuXG52YXIgV1JPTkdfU1lNQk9MU19DT05WRVJTSU9OID0gIU5BVElWRV9TWU1CT0wgfHwgZmFpbHMoZnVuY3Rpb24gKCkge1xuICB2YXIgc3ltYm9sID0gZ2V0QnVpbHRJbignU3ltYm9sJykoJ3N0cmluZ2lmeSBkZXRlY3Rpb24nKTtcbiAgLy8gTVMgRWRnZSBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMge31cbiAgcmV0dXJuICRzdHJpbmdpZnkoW3N5bWJvbF0pICE9PSAnW251bGxdJ1xuICAgIC8vIFdlYktpdCBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMgbnVsbFxuICAgIHx8ICRzdHJpbmdpZnkoeyBhOiBzeW1ib2wgfSkgIT09ICd7fSdcbiAgICAvLyBWOCB0aHJvd3Mgb24gYm94ZWQgc3ltYm9sc1xuICAgIHx8ICRzdHJpbmdpZnkoT2JqZWN0KHN5bWJvbCkpICE9PSAne30nO1xufSk7XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXdlbGwtZm9ybWVkLXN0cmluZ2lmeVxudmFyIElMTF9GT1JNRURfVU5JQ09ERSA9IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICRzdHJpbmdpZnkoJ1xcdURGMDZcXHVEODM0JykgIT09ICdcIlxcXFx1ZGYwNlxcXFx1ZDgzNFwiJ1xuICAgIHx8ICRzdHJpbmdpZnkoJ1xcdURFQUQnKSAhPT0gJ1wiXFxcXHVkZWFkXCInO1xufSk7XG5cbnZhciBzdHJpbmdpZnlXaXRoU3ltYm9sc0ZpeCA9IGZ1bmN0aW9uIChpdCwgcmVwbGFjZXIpIHtcbiAgdmFyIGFyZ3MgPSBhcnJheVNsaWNlKGFyZ3VtZW50cyk7XG4gIHZhciAkcmVwbGFjZXIgPSBnZXRSZXBsYWNlckZ1bmN0aW9uKHJlcGxhY2VyKTtcbiAgaWYgKCFpc0NhbGxhYmxlKCRyZXBsYWNlcikgJiYgKGl0ID09PSB1bmRlZmluZWQgfHwgaXNTeW1ib2woaXQpKSkgcmV0dXJuOyAvLyBJRTggcmV0dXJucyBzdHJpbmcgb24gdW5kZWZpbmVkXG4gIGFyZ3NbMV0gPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIC8vIHNvbWUgb2xkIGltcGxlbWVudGF0aW9ucyAobGlrZSBXZWJLaXQpIGNvdWxkIHBhc3MgbnVtYmVycyBhcyBrZXlzXG4gICAgaWYgKGlzQ2FsbGFibGUoJHJlcGxhY2VyKSkgdmFsdWUgPSBjYWxsKCRyZXBsYWNlciwgdGhpcywgJFN0cmluZyhrZXkpLCB2YWx1ZSk7XG4gICAgaWYgKCFpc1N5bWJvbCh2YWx1ZSkpIHJldHVybiB2YWx1ZTtcbiAgfTtcbiAgcmV0dXJuIGFwcGx5KCRzdHJpbmdpZnksIG51bGwsIGFyZ3MpO1xufTtcblxudmFyIGZpeElsbEZvcm1lZCA9IGZ1bmN0aW9uIChtYXRjaCwgb2Zmc2V0LCBzdHJpbmcpIHtcbiAgdmFyIHByZXYgPSBjaGFyQXQoc3RyaW5nLCBvZmZzZXQgLSAxKTtcbiAgdmFyIG5leHQgPSBjaGFyQXQoc3RyaW5nLCBvZmZzZXQgKyAxKTtcbiAgaWYgKChleGVjKGxvdywgbWF0Y2gpICYmICFleGVjKGhpLCBuZXh0KSkgfHwgKGV4ZWMoaGksIG1hdGNoKSAmJiAhZXhlYyhsb3csIHByZXYpKSkge1xuICAgIHJldHVybiAnXFxcXHUnICsgbnVtYmVyVG9TdHJpbmcoY2hhckNvZGVBdChtYXRjaCwgMCksIDE2KTtcbiAgfSByZXR1cm4gbWF0Y2g7XG59O1xuXG5pZiAoJHN0cmluZ2lmeSkge1xuICAvLyBgSlNPTi5zdHJpbmdpZnlgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWpzb24uc3RyaW5naWZ5XG4gICQoeyB0YXJnZXQ6ICdKU09OJywgc3RhdDogdHJ1ZSwgYXJpdHk6IDMsIGZvcmNlZDogV1JPTkdfU1lNQk9MU19DT05WRVJTSU9OIHx8IElMTF9GT1JNRURfVU5JQ09ERSB9LCB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzIC0tIHJlcXVpcmVkIGZvciBgLmxlbmd0aGBcbiAgICBzdHJpbmdpZnk6IGZ1bmN0aW9uIHN0cmluZ2lmeShpdCwgcmVwbGFjZXIsIHNwYWNlKSB7XG4gICAgICB2YXIgYXJncyA9IGFycmF5U2xpY2UoYXJndW1lbnRzKTtcbiAgICAgIHZhciByZXN1bHQgPSBhcHBseShXUk9OR19TWU1CT0xTX0NPTlZFUlNJT04gPyBzdHJpbmdpZnlXaXRoU3ltYm9sc0ZpeCA6ICRzdHJpbmdpZnksIG51bGwsIGFyZ3MpO1xuICAgICAgcmV0dXJuIElMTF9GT1JNRURfVU5JQ09ERSAmJiB0eXBlb2YgcmVzdWx0ID09ICdzdHJpbmcnID8gcmVwbGFjZShyZXN1bHQsIHRlc3RlciwgZml4SWxsRm9ybWVkKSA6IHJlc3VsdDtcbiAgICB9XG4gIH0pO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuLyogZXNsaW50LWRpc2FibGUgZXMvbm8tc3RyaW5nLXByb3RvdHlwZS1tYXRjaGFsbCAtLSBzYWZlICovXG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBjYWxsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWNhbGwnKTtcbnZhciB1bmN1cnJ5VGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMtY2xhdXNlJyk7XG52YXIgY3JlYXRlSXRlcmF0b3JDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pdGVyYXRvci1jcmVhdGUtY29uc3RydWN0b3InKTtcbnZhciBjcmVhdGVJdGVyUmVzdWx0T2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1pdGVyLXJlc3VsdC1vYmplY3QnKTtcbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZScpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWxlbmd0aCcpO1xudmFyIHRvU3RyaW5nID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLXN0cmluZycpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xudmFyIGlzTnVsbE9yVW5kZWZpbmVkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW51bGwtb3ItdW5kZWZpbmVkJyk7XG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jbGFzc29mLXJhdycpO1xudmFyIGlzUmVnRXhwID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLXJlZ2V4cCcpO1xudmFyIGdldFJlZ0V4cEZsYWdzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlZ2V4cC1nZXQtZmxhZ3MnKTtcbnZhciBnZXRNZXRob2QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2V0LW1ldGhvZCcpO1xudmFyIGRlZmluZUJ1aWx0SW4gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVmaW5lLWJ1aWx0LWluJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcbnZhciBzcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc3BlY2llcy1jb25zdHJ1Y3RvcicpO1xudmFyIGFkdmFuY2VTdHJpbmdJbmRleCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hZHZhbmNlLXN0cmluZy1pbmRleCcpO1xudmFyIHJlZ0V4cEV4ZWMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVnZXhwLWV4ZWMtYWJzdHJhY3QnKTtcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ludGVybmFsLXN0YXRlJyk7XG52YXIgSVNfUFVSRSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1wdXJlJyk7XG5cbnZhciBNQVRDSF9BTEwgPSB3ZWxsS25vd25TeW1ib2woJ21hdGNoQWxsJyk7XG52YXIgUkVHRVhQX1NUUklORyA9ICdSZWdFeHAgU3RyaW5nJztcbnZhciBSRUdFWFBfU1RSSU5HX0lURVJBVE9SID0gUkVHRVhQX1NUUklORyArICcgSXRlcmF0b3InO1xudmFyIHNldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLnNldDtcbnZhciBnZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5nZXR0ZXJGb3IoUkVHRVhQX1NUUklOR19JVEVSQVRPUik7XG52YXIgUmVnRXhwUHJvdG90eXBlID0gUmVnRXhwLnByb3RvdHlwZTtcbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xudmFyIHN0cmluZ0luZGV4T2YgPSB1bmN1cnJ5VGhpcygnJy5pbmRleE9mKTtcbnZhciBuYXRpdmVNYXRjaEFsbCA9IHVuY3VycnlUaGlzKCcnLm1hdGNoQWxsKTtcblxudmFyIFdPUktTX1dJVEhfTk9OX0dMT0JBTF9SRUdFWCA9ICEhbmF0aXZlTWF0Y2hBbGwgJiYgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgbmF0aXZlTWF0Y2hBbGwoJ2EnLCAvLi8pO1xufSk7XG5cbnZhciAkUmVnRXhwU3RyaW5nSXRlcmF0b3IgPSBjcmVhdGVJdGVyYXRvckNvbnN0cnVjdG9yKGZ1bmN0aW9uIFJlZ0V4cFN0cmluZ0l0ZXJhdG9yKHJlZ2V4cCwgc3RyaW5nLCAkZ2xvYmFsLCBmdWxsVW5pY29kZSkge1xuICBzZXRJbnRlcm5hbFN0YXRlKHRoaXMsIHtcbiAgICB0eXBlOiBSRUdFWFBfU1RSSU5HX0lURVJBVE9SLFxuICAgIHJlZ2V4cDogcmVnZXhwLFxuICAgIHN0cmluZzogc3RyaW5nLFxuICAgIGdsb2JhbDogJGdsb2JhbCxcbiAgICB1bmljb2RlOiBmdWxsVW5pY29kZSxcbiAgICBkb25lOiBmYWxzZVxuICB9KTtcbn0sIFJFR0VYUF9TVFJJTkcsIGZ1bmN0aW9uIG5leHQoKSB7XG4gIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUodGhpcyk7XG4gIGlmIChzdGF0ZS5kb25lKSByZXR1cm4gY3JlYXRlSXRlclJlc3VsdE9iamVjdCh1bmRlZmluZWQsIHRydWUpO1xuICB2YXIgUiA9IHN0YXRlLnJlZ2V4cDtcbiAgdmFyIFMgPSBzdGF0ZS5zdHJpbmc7XG4gIHZhciBtYXRjaCA9IHJlZ0V4cEV4ZWMoUiwgUyk7XG4gIGlmIChtYXRjaCA9PT0gbnVsbCkge1xuICAgIHN0YXRlLmRvbmUgPSB0cnVlO1xuICAgIHJldHVybiBjcmVhdGVJdGVyUmVzdWx0T2JqZWN0KHVuZGVmaW5lZCwgdHJ1ZSk7XG4gIH1cbiAgaWYgKHN0YXRlLmdsb2JhbCkge1xuICAgIGlmICh0b1N0cmluZyhtYXRjaFswXSkgPT09ICcnKSBSLmxhc3RJbmRleCA9IGFkdmFuY2VTdHJpbmdJbmRleChTLCB0b0xlbmd0aChSLmxhc3RJbmRleCksIHN0YXRlLnVuaWNvZGUpO1xuICAgIHJldHVybiBjcmVhdGVJdGVyUmVzdWx0T2JqZWN0KG1hdGNoLCBmYWxzZSk7XG4gIH1cbiAgc3RhdGUuZG9uZSA9IHRydWU7XG4gIHJldHVybiBjcmVhdGVJdGVyUmVzdWx0T2JqZWN0KG1hdGNoLCBmYWxzZSk7XG59KTtcblxudmFyICRtYXRjaEFsbCA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgdmFyIFIgPSBhbk9iamVjdCh0aGlzKTtcbiAgdmFyIFMgPSB0b1N0cmluZyhzdHJpbmcpO1xuICB2YXIgQyA9IHNwZWNpZXNDb25zdHJ1Y3RvcihSLCBSZWdFeHApO1xuICB2YXIgZmxhZ3MgPSB0b1N0cmluZyhnZXRSZWdFeHBGbGFncyhSKSk7XG4gIHZhciBtYXRjaGVyLCAkZ2xvYmFsLCBmdWxsVW5pY29kZTtcbiAgbWF0Y2hlciA9IG5ldyBDKEMgPT09IFJlZ0V4cCA/IFIuc291cmNlIDogUiwgZmxhZ3MpO1xuICAkZ2xvYmFsID0gISF+c3RyaW5nSW5kZXhPZihmbGFncywgJ2cnKTtcbiAgZnVsbFVuaWNvZGUgPSAhIX5zdHJpbmdJbmRleE9mKGZsYWdzLCAndScpO1xuICBtYXRjaGVyLmxhc3RJbmRleCA9IHRvTGVuZ3RoKFIubGFzdEluZGV4KTtcbiAgcmV0dXJuIG5ldyAkUmVnRXhwU3RyaW5nSXRlcmF0b3IobWF0Y2hlciwgUywgJGdsb2JhbCwgZnVsbFVuaWNvZGUpO1xufTtcblxuLy8gYFN0cmluZy5wcm90b3R5cGUubWF0Y2hBbGxgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLm1hdGNoYWxsXG4kKHsgdGFyZ2V0OiAnU3RyaW5nJywgcHJvdG86IHRydWUsIGZvcmNlZDogV09SS1NfV0lUSF9OT05fR0xPQkFMX1JFR0VYIH0sIHtcbiAgbWF0Y2hBbGw6IGZ1bmN0aW9uIG1hdGNoQWxsKHJlZ2V4cCkge1xuICAgIHZhciBPID0gcmVxdWlyZU9iamVjdENvZXJjaWJsZSh0aGlzKTtcbiAgICB2YXIgZmxhZ3MsIFMsIG1hdGNoZXIsIHJ4O1xuICAgIGlmICghaXNOdWxsT3JVbmRlZmluZWQocmVnZXhwKSkge1xuICAgICAgaWYgKGlzUmVnRXhwKHJlZ2V4cCkpIHtcbiAgICAgICAgZmxhZ3MgPSB0b1N0cmluZyhyZXF1aXJlT2JqZWN0Q29lcmNpYmxlKGdldFJlZ0V4cEZsYWdzKHJlZ2V4cCkpKTtcbiAgICAgICAgaWYgKCF+c3RyaW5nSW5kZXhPZihmbGFncywgJ2cnKSkgdGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2AubWF0Y2hBbGxgIGRvZXMgbm90IGFsbG93IG5vbi1nbG9iYWwgcmVnZXhlcycpO1xuICAgICAgfVxuICAgICAgaWYgKFdPUktTX1dJVEhfTk9OX0dMT0JBTF9SRUdFWCkgcmV0dXJuIG5hdGl2ZU1hdGNoQWxsKE8sIHJlZ2V4cCk7XG4gICAgICBtYXRjaGVyID0gZ2V0TWV0aG9kKHJlZ2V4cCwgTUFUQ0hfQUxMKTtcbiAgICAgIGlmIChtYXRjaGVyID09PSB1bmRlZmluZWQgJiYgSVNfUFVSRSAmJiBjbGFzc29mKHJlZ2V4cCkgPT09ICdSZWdFeHAnKSBtYXRjaGVyID0gJG1hdGNoQWxsO1xuICAgICAgaWYgKG1hdGNoZXIpIHJldHVybiBjYWxsKG1hdGNoZXIsIHJlZ2V4cCwgTyk7XG4gICAgfSBlbHNlIGlmIChXT1JLU19XSVRIX05PTl9HTE9CQUxfUkVHRVgpIHJldHVybiBuYXRpdmVNYXRjaEFsbChPLCByZWdleHApO1xuICAgIFMgPSB0b1N0cmluZyhPKTtcbiAgICByeCA9IG5ldyBSZWdFeHAocmVnZXhwLCAnZycpO1xuICAgIHJldHVybiBJU19QVVJFID8gY2FsbCgkbWF0Y2hBbGwsIHJ4LCBTKSA6IHJ4W01BVENIX0FMTF0oUyk7XG4gIH1cbn0pO1xuXG5JU19QVVJFIHx8IE1BVENIX0FMTCBpbiBSZWdFeHBQcm90b3R5cGUgfHwgZGVmaW5lQnVpbHRJbihSZWdFeHBQcm90b3R5cGUsIE1BVENIX0FMTCwgJG1hdGNoQWxsKTtcbiIsIi8vIGBTeW1ib2wucHJvdG90eXBlLmRlc2NyaXB0aW9uYCBnZXR0ZXJcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3ltYm9sLnByb3RvdHlwZS5kZXNjcmlwdGlvblxuJ3VzZSBzdHJpY3QnO1xudmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgdW5jdXJyeVRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzJyk7XG52YXIgaGFzT3duID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcy1vd24tcHJvcGVydHknKTtcbnZhciBpc0NhbGxhYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWNhbGxhYmxlJyk7XG52YXIgaXNQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtaXMtcHJvdG90eXBlLW9mJyk7XG52YXIgdG9TdHJpbmcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tc3RyaW5nJyk7XG52YXIgZGVmaW5lQnVpbHRJbkFjY2Vzc29yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RlZmluZS1idWlsdC1pbi1hY2Nlc3NvcicpO1xudmFyIGNvcHlDb25zdHJ1Y3RvclByb3BlcnRpZXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY29weS1jb25zdHJ1Y3Rvci1wcm9wZXJ0aWVzJyk7XG5cbnZhciBOYXRpdmVTeW1ib2wgPSBnbG9iYWwuU3ltYm9sO1xudmFyIFN5bWJvbFByb3RvdHlwZSA9IE5hdGl2ZVN5bWJvbCAmJiBOYXRpdmVTeW1ib2wucHJvdG90eXBlO1xuXG5pZiAoREVTQ1JJUFRPUlMgJiYgaXNDYWxsYWJsZShOYXRpdmVTeW1ib2wpICYmICghKCdkZXNjcmlwdGlvbicgaW4gU3ltYm9sUHJvdG90eXBlKSB8fFxuICAvLyBTYWZhcmkgMTIgYnVnXG4gIE5hdGl2ZVN5bWJvbCgpLmRlc2NyaXB0aW9uICE9PSB1bmRlZmluZWRcbikpIHtcbiAgdmFyIEVtcHR5U3RyaW5nRGVzY3JpcHRpb25TdG9yZSA9IHt9O1xuICAvLyB3cmFwIFN5bWJvbCBjb25zdHJ1Y3RvciBmb3IgY29ycmVjdCB3b3JrIHdpdGggdW5kZWZpbmVkIGRlc2NyaXB0aW9uXG4gIHZhciBTeW1ib2xXcmFwcGVyID0gZnVuY3Rpb24gU3ltYm9sKCkge1xuICAgIHZhciBkZXNjcmlwdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPCAxIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogdG9TdHJpbmcoYXJndW1lbnRzWzBdKTtcbiAgICB2YXIgcmVzdWx0ID0gaXNQcm90b3R5cGVPZihTeW1ib2xQcm90b3R5cGUsIHRoaXMpXG4gICAgICA/IG5ldyBOYXRpdmVTeW1ib2woZGVzY3JpcHRpb24pXG4gICAgICAvLyBpbiBFZGdlIDEzLCBTdHJpbmcoU3ltYm9sKHVuZGVmaW5lZCkpID09PSAnU3ltYm9sKHVuZGVmaW5lZCknXG4gICAgICA6IGRlc2NyaXB0aW9uID09PSB1bmRlZmluZWQgPyBOYXRpdmVTeW1ib2woKSA6IE5hdGl2ZVN5bWJvbChkZXNjcmlwdGlvbik7XG4gICAgaWYgKGRlc2NyaXB0aW9uID09PSAnJykgRW1wdHlTdHJpbmdEZXNjcmlwdGlvblN0b3JlW3Jlc3VsdF0gPSB0cnVlO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgY29weUNvbnN0cnVjdG9yUHJvcGVydGllcyhTeW1ib2xXcmFwcGVyLCBOYXRpdmVTeW1ib2wpO1xuICBTeW1ib2xXcmFwcGVyLnByb3RvdHlwZSA9IFN5bWJvbFByb3RvdHlwZTtcbiAgU3ltYm9sUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3ltYm9sV3JhcHBlcjtcblxuICB2YXIgTkFUSVZFX1NZTUJPTCA9IFN0cmluZyhOYXRpdmVTeW1ib2woJ2Rlc2NyaXB0aW9uIGRldGVjdGlvbicpKSA9PT0gJ1N5bWJvbChkZXNjcmlwdGlvbiBkZXRlY3Rpb24pJztcbiAgdmFyIHRoaXNTeW1ib2xWYWx1ZSA9IHVuY3VycnlUaGlzKFN5bWJvbFByb3RvdHlwZS52YWx1ZU9mKTtcbiAgdmFyIHN5bWJvbERlc2NyaXB0aXZlU3RyaW5nID0gdW5jdXJyeVRoaXMoU3ltYm9sUHJvdG90eXBlLnRvU3RyaW5nKTtcbiAgdmFyIHJlZ2V4cCA9IC9eU3ltYm9sXFwoKC4qKVxcKVteKV0rJC87XG4gIHZhciByZXBsYWNlID0gdW5jdXJyeVRoaXMoJycucmVwbGFjZSk7XG4gIHZhciBzdHJpbmdTbGljZSA9IHVuY3VycnlUaGlzKCcnLnNsaWNlKTtcblxuICBkZWZpbmVCdWlsdEluQWNjZXNzb3IoU3ltYm9sUHJvdG90eXBlLCAnZGVzY3JpcHRpb24nLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gZGVzY3JpcHRpb24oKSB7XG4gICAgICB2YXIgc3ltYm9sID0gdGhpc1N5bWJvbFZhbHVlKHRoaXMpO1xuICAgICAgaWYgKGhhc093bihFbXB0eVN0cmluZ0Rlc2NyaXB0aW9uU3RvcmUsIHN5bWJvbCkpIHJldHVybiAnJztcbiAgICAgIHZhciBzdHJpbmcgPSBzeW1ib2xEZXNjcmlwdGl2ZVN0cmluZyhzeW1ib2wpO1xuICAgICAgdmFyIGRlc2MgPSBOQVRJVkVfU1lNQk9MID8gc3RyaW5nU2xpY2Uoc3RyaW5nLCA3LCAtMSkgOiByZXBsYWNlKHN0cmluZywgcmVnZXhwLCAnJDEnKTtcbiAgICAgIHJldHVybiBkZXNjID09PSAnJyA/IHVuZGVmaW5lZCA6IGRlc2M7XG4gICAgfVxuICB9KTtcblxuICAkKHsgZ2xvYmFsOiB0cnVlLCBjb25zdHJ1Y3RvcjogdHJ1ZSwgZm9yY2VkOiB0cnVlIH0sIHtcbiAgICBTeW1ib2w6IFN5bWJvbFdyYXBwZXJcbiAgfSk7XG59XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIGNhbGwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tY2FsbCcpO1xudmFyIEFycmF5QnVmZmVyVmlld0NvcmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktYnVmZmVyLXZpZXctY29yZScpO1xudmFyIGxlbmd0aE9mQXJyYXlMaWtlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2xlbmd0aC1vZi1hcnJheS1saWtlJyk7XG52YXIgdG9PZmZzZXQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tb2Zmc2V0Jyk7XG52YXIgdG9JbmRleGVkT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLW9iamVjdCcpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG5cbnZhciBSYW5nZUVycm9yID0gZ2xvYmFsLlJhbmdlRXJyb3I7XG52YXIgSW50OEFycmF5ID0gZ2xvYmFsLkludDhBcnJheTtcbnZhciBJbnQ4QXJyYXlQcm90b3R5cGUgPSBJbnQ4QXJyYXkgJiYgSW50OEFycmF5LnByb3RvdHlwZTtcbnZhciAkc2V0ID0gSW50OEFycmF5UHJvdG90eXBlICYmIEludDhBcnJheVByb3RvdHlwZS5zZXQ7XG52YXIgYVR5cGVkQXJyYXkgPSBBcnJheUJ1ZmZlclZpZXdDb3JlLmFUeXBlZEFycmF5O1xudmFyIGV4cG9ydFR5cGVkQXJyYXlNZXRob2QgPSBBcnJheUJ1ZmZlclZpZXdDb3JlLmV4cG9ydFR5cGVkQXJyYXlNZXRob2Q7XG5cbnZhciBXT1JLU19XSVRIX09CSkVDVFNfQU5EX0dFTkVSSUNfT05fVFlQRURfQVJSQVlTID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLXR5cGVkLWFycmF5cyAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICB2YXIgYXJyYXkgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkoMik7XG4gIGNhbGwoJHNldCwgYXJyYXksIHsgbGVuZ3RoOiAxLCAwOiAzIH0sIDEpO1xuICByZXR1cm4gYXJyYXlbMV0gIT09IDM7XG59KTtcblxuLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MTEyOTQgYW5kIG90aGVyXG52YXIgVE9fT0JKRUNUX0JVRyA9IFdPUktTX1dJVEhfT0JKRUNUU19BTkRfR0VORVJJQ19PTl9UWVBFRF9BUlJBWVMgJiYgQXJyYXlCdWZmZXJWaWV3Q29yZS5OQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTICYmIGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgdmFyIGFycmF5ID0gbmV3IEludDhBcnJheSgyKTtcbiAgYXJyYXkuc2V0KDEpO1xuICBhcnJheS5zZXQoJzInLCAxKTtcbiAgcmV0dXJuIGFycmF5WzBdICE9PSAwIHx8IGFycmF5WzFdICE9PSAyO1xufSk7XG5cbi8vIGAlVHlwZWRBcnJheSUucHJvdG90eXBlLnNldGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLSV0eXBlZGFycmF5JS5wcm90b3R5cGUuc2V0XG5leHBvcnRUeXBlZEFycmF5TWV0aG9kKCdzZXQnLCBmdW5jdGlvbiBzZXQoYXJyYXlMaWtlIC8qICwgb2Zmc2V0ICovKSB7XG4gIGFUeXBlZEFycmF5KHRoaXMpO1xuICB2YXIgb2Zmc2V0ID0gdG9PZmZzZXQoYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIDEpO1xuICB2YXIgc3JjID0gdG9JbmRleGVkT2JqZWN0KGFycmF5TGlrZSk7XG4gIGlmIChXT1JLU19XSVRIX09CSkVDVFNfQU5EX0dFTkVSSUNfT05fVFlQRURfQVJSQVlTKSByZXR1cm4gY2FsbCgkc2V0LCB0aGlzLCBzcmMsIG9mZnNldCk7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgdmFyIGxlbiA9IGxlbmd0aE9mQXJyYXlMaWtlKHNyYyk7XG4gIHZhciBpbmRleCA9IDA7XG4gIGlmIChsZW4gKyBvZmZzZXQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdXcm9uZyBsZW5ndGgnKTtcbiAgd2hpbGUgKGluZGV4IDwgbGVuKSB0aGlzW29mZnNldCArIGluZGV4XSA9IHNyY1tpbmRleCsrXTtcbn0sICFXT1JLU19XSVRIX09CSkVDVFNfQU5EX0dFTkVSSUNfT05fVFlQRURfQVJSQVlTIHx8IFRPX09CSkVDVF9CVUcpO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciB1bmN1cnJ5VGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMtY2xhdXNlJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciBhQ2FsbGFibGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYS1jYWxsYWJsZScpO1xudmFyIGludGVybmFsU29ydCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1zb3J0Jyk7XG52YXIgQXJyYXlCdWZmZXJWaWV3Q29yZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1idWZmZXItdmlldy1jb3JlJyk7XG52YXIgRkYgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZW5naW5lLWZmLXZlcnNpb24nKTtcbnZhciBJRV9PUl9FREdFID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2VuZ2luZS1pcy1pZS1vci1lZGdlJyk7XG52YXIgVjggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZW5naW5lLXY4LXZlcnNpb24nKTtcbnZhciBXRUJLSVQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZW5naW5lLXdlYmtpdC12ZXJzaW9uJyk7XG5cbnZhciBhVHlwZWRBcnJheSA9IEFycmF5QnVmZmVyVmlld0NvcmUuYVR5cGVkQXJyYXk7XG52YXIgZXhwb3J0VHlwZWRBcnJheU1ldGhvZCA9IEFycmF5QnVmZmVyVmlld0NvcmUuZXhwb3J0VHlwZWRBcnJheU1ldGhvZDtcbnZhciBVaW50MTZBcnJheSA9IGdsb2JhbC5VaW50MTZBcnJheTtcbnZhciBuYXRpdmVTb3J0ID0gVWludDE2QXJyYXkgJiYgdW5jdXJyeVRoaXMoVWludDE2QXJyYXkucHJvdG90eXBlLnNvcnQpO1xuXG4vLyBXZWJLaXRcbnZhciBBQ0NFUFRfSU5DT1JSRUNUX0FSR1VNRU5UUyA9ICEhbmF0aXZlU29ydCAmJiAhKGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgbmF0aXZlU29ydChuZXcgVWludDE2QXJyYXkoMiksIG51bGwpO1xufSkgJiYgZmFpbHMoZnVuY3Rpb24gKCkge1xuICBuYXRpdmVTb3J0KG5ldyBVaW50MTZBcnJheSgyKSwge30pO1xufSkpO1xuXG52YXIgU1RBQkxFX1NPUlQgPSAhIW5hdGl2ZVNvcnQgJiYgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gZmVhdHVyZSBkZXRlY3Rpb24gY2FuIGJlIHRvbyBzbG93LCBzbyBjaGVjayBlbmdpbmVzIHZlcnNpb25zXG4gIGlmIChWOCkgcmV0dXJuIFY4IDwgNzQ7XG4gIGlmIChGRikgcmV0dXJuIEZGIDwgNjc7XG4gIGlmIChJRV9PUl9FREdFKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKFdFQktJVCkgcmV0dXJuIFdFQktJVCA8IDYwMjtcblxuICB2YXIgYXJyYXkgPSBuZXcgVWludDE2QXJyYXkoNTE2KTtcbiAgdmFyIGV4cGVjdGVkID0gQXJyYXkoNTE2KTtcbiAgdmFyIGluZGV4LCBtb2Q7XG5cbiAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgNTE2OyBpbmRleCsrKSB7XG4gICAgbW9kID0gaW5kZXggJSA0O1xuICAgIGFycmF5W2luZGV4XSA9IDUxNSAtIGluZGV4O1xuICAgIGV4cGVjdGVkW2luZGV4XSA9IGluZGV4IC0gMiAqIG1vZCArIDM7XG4gIH1cblxuICBuYXRpdmVTb3J0KGFycmF5LCBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiAoYSAvIDQgfCAwKSAtIChiIC8gNCB8IDApO1xuICB9KTtcblxuICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCA1MTY7IGluZGV4KyspIHtcbiAgICBpZiAoYXJyYXlbaW5kZXhdICE9PSBleHBlY3RlZFtpbmRleF0pIHJldHVybiB0cnVlO1xuICB9XG59KTtcblxudmFyIGdldFNvcnRDb21wYXJlID0gZnVuY3Rpb24gKGNvbXBhcmVmbikge1xuICByZXR1cm4gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICBpZiAoY29tcGFyZWZuICE9PSB1bmRlZmluZWQpIHJldHVybiArY29tcGFyZWZuKHgsIHkpIHx8IDA7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZSAtLSBOYU4gY2hlY2tcbiAgICBpZiAoeSAhPT0geSkgcmV0dXJuIC0xO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmUgLS0gTmFOIGNoZWNrXG4gICAgaWYgKHggIT09IHgpIHJldHVybiAxO1xuICAgIGlmICh4ID09PSAwICYmIHkgPT09IDApIHJldHVybiAxIC8geCA+IDAgJiYgMSAvIHkgPCAwID8gMSA6IC0xO1xuICAgIHJldHVybiB4ID4geTtcbiAgfTtcbn07XG5cbi8vIGAlVHlwZWRBcnJheSUucHJvdG90eXBlLnNvcnRgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy0ldHlwZWRhcnJheSUucHJvdG90eXBlLnNvcnRcbmV4cG9ydFR5cGVkQXJyYXlNZXRob2QoJ3NvcnQnLCBmdW5jdGlvbiBzb3J0KGNvbXBhcmVmbikge1xuICBpZiAoY29tcGFyZWZuICE9PSB1bmRlZmluZWQpIGFDYWxsYWJsZShjb21wYXJlZm4pO1xuICBpZiAoU1RBQkxFX1NPUlQpIHJldHVybiBuYXRpdmVTb3J0KHRoaXMsIGNvbXBhcmVmbik7XG5cbiAgcmV0dXJuIGludGVybmFsU29ydChhVHlwZWRBcnJheSh0aGlzKSwgZ2V0U29ydENvbXBhcmUoY29tcGFyZWZuKSk7XG59LCAhU1RBQkxFX1NPUlQgfHwgQUNDRVBUX0lOQ09SUkVDVF9BUkdVTUVOVFMpO1xuIiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG5cdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbiIsIi8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSAobW9kdWxlKSA9PiB7XG5cdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuXHRcdCgpID0+IChtb2R1bGVbJ2RlZmF1bHQnXSkgOlxuXHRcdCgpID0+IChtb2R1bGUpO1xuXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCB7IGE6IGdldHRlciB9KTtcblx0cmV0dXJuIGdldHRlcjtcbn07IiwiLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcblx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuXHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcblx0XHR9XG5cdH1cbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5nID0gKGZ1bmN0aW9uKCkge1xuXHRpZiAodHlwZW9mIGdsb2JhbFRoaXMgPT09ICdvYmplY3QnKSByZXR1cm4gZ2xvYmFsVGhpcztcblx0dHJ5IHtcblx0XHRyZXR1cm4gdGhpcyB8fCBuZXcgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JykgcmV0dXJuIHdpbmRvdztcblx0fVxufSkoKTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIiwiY29uc3QgX0VYVEVOU0lPTl9JRCA9IEVYVEVOU0lPTl9JRDtcbmV4cG9ydCB7IF9FWFRFTlNJT05fSUQgYXMgRVhURU5TSU9OX0lEIH07XG5jb25zdCBfQVBQX0lEID0gQVBQX0lEO1xuZXhwb3J0IHsgX0FQUF9JRCBhcyBBUFBfSUQgfTtcbmNvbnN0IF9TRUxGX0lEID0gU0VMRl9JRDtcbmV4cG9ydCB7IF9TRUxGX0lEIGFzIFNFTEZfSUQgfTtcbmNvbnN0IF9WRVJTSU9OID0gVkVSU0lPTjtcbmV4cG9ydCB7IF9WRVJTSU9OIGFzIFZFUlNJT04gfTtcbihmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFFWFRFTlNJT05fSUQgfHwgIUFQUF9JRCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFeHRlbnNpb24vQXBwIElEIGlzIG5vdCBkZWZpbmVkIGluIHRoaXMgYnVpbGQgb2YgdGhlIGFwcC9leHRlbnNpb24nKTtcbiAgICB9XG59KSgpO1xuZXhwb3J0IGZ1bmN0aW9uIGlzRXh0ZW5zaW9uKCkge1xuICAgIHJldHVybiBTRUxGX0lEID09PSBFWFRFTlNJT05fSUQ7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNBcHAoKSB7XG4gICAgcmV0dXJuIFNFTEZfSUQgPT09IEFQUF9JRDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBHZXRDbGllbnRWZXJzaW9uSUQoKSB7XG4gICAgaWYgKGlzQXBwKCkpIHtcbiAgICAgICAgcmV0dXJuICdDaHJvbWVBcHAtJyArIFZFUlNJT047XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gJ0Nocm9tZUFwcEV4dC0nICsgVkVSU0lPTjtcbiAgICB9XG59XG4iLCJleHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0UmVzcG9uc2VCb2R5KHJlc3ApIHtcbiAgICBpZiAocmVzcC5vaykge1xuICAgICAgICByZXR1cm4gcmVzcC5qc29uKCkudGhlbihyZXNwQm9keSA9PiByZXNwQm9keSk7XG4gICAgfVxuICAgIHRocm93IEVycm9yKGByZXF1ZXN0ICR7cmVzcC51cmx9IGZhaWxlZCB3aXRoIEhUVFAgJHtyZXNwLnN0YXR1c30gJHtyZXNwLnN0YXR1c1RleHR9YCk7XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gaXNvODYwMURhdGVUaW1lWm9uZShkKSB7XG4gICAgY29uc3Qgb2Zmc2V0ID0gLWQuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgICBjb25zdCBzaWduID0gb2Zmc2V0ID49IDAgPyAnKycgOiAnLSc7XG4gICAgcmV0dXJuIGQuZ2V0RnVsbFllYXIoKSArXG4gICAgICAgICctJyArIHBhZChkLmdldE1vbnRoKCkgKyAxKSArXG4gICAgICAgICctJyArIHBhZChkLmdldERhdGUoKSkgK1xuICAgICAgICAnVCcgKyBwYWQoZC5nZXRIb3VycygpKSArXG4gICAgICAgICc6JyArIHBhZChkLmdldE1pbnV0ZXMoKSkgK1xuICAgICAgICAnOicgKyBwYWQoZC5nZXRTZWNvbmRzKCkpICtcbiAgICAgICAgc2lnbiArIHBhZChvZmZzZXQgLyA2MCkgK1xuICAgICAgICAnOicgKyBwYWQob2Zmc2V0ICUgNjApO1xufVxuZnVuY3Rpb24gcGFkKG4pIHtcbiAgICBjb25zdCBhYnMgPSBNYXRoLmZsb29yKE1hdGguYWJzKG4pKTtcbiAgICByZXR1cm4gKGFicyA8IDEwID8gJzAnIDogJycpICsgYWJzO1xufVxuIiwiaW1wb3J0IHsgaXNvODYwMURhdGVUaW1lWm9uZSB9IGZyb20gJy4uL3RpbWUnO1xubGV0IHJlbW90ZUxvZ2dpbmcgPSB1bmRlZmluZWQ7XG5pZiAoc2VsZi5jaHJvbWUgJiYgY2hyb21lLnN0b3JhZ2UgJiYgY2hyb21lLnN0b3JhZ2UubG9jYWwgIT09IHVuZGVmaW5lZCkge1xuICAgIGNocm9tZS5zdG9yYWdlLmxvY2FsLmdldCgncmVtb3RlTG9nZ2luZ1VSTCcsIChkKSA9PiB7XG4gICAgICAgIGlmIChkICYmIGQucmVtb3RlTG9nZ2luZ1VSTCAmJiBkLnJlbW90ZUxvZ2dpbmdVUkwuc3RhcnRzV2l0aCgnaHR0cCcpKSB7XG4gICAgICAgICAgICBsb2coYFJlbW90ZSBsb2dnaW5nIGluaXRpYWxpc2VkOiAke0pTT04uc3RyaW5naWZ5KGQpfWApO1xuICAgICAgICAgICAgcmVtb3RlTG9nZ2luZyA9IGQ7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHJlbW90ZUxvZyhyZXF1ZXN0KSB7XG4gICAgaWYgKCFyZW1vdGVMb2dnaW5nIHx8ICFyZW1vdGVMb2dnaW5nLnJlbW90ZUxvZ2dpbmdVUkwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjaHJvbWUudGFicy5xdWVyeSh7IGFjdGl2ZTogdHJ1ZSwgY3VycmVudFdpbmRvdzogdHJ1ZSB9LCBmdW5jdGlvbiAodGFicykge1xuICAgICAgICBpZiAodGFicy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXF1ZXN0LmJvZHkgPSBgdGFiOiR7dGFic1swXS5pZH0gLSAke3JlcXVlc3QuYm9keX1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVxdWVzdC5ib2R5ID0gYD8/PyAtICR7cmVxdWVzdC5ib2R5fWA7XG4gICAgICAgIH1cbiAgICAgICAgZmV0Y2goYCR7cmVtb3RlTG9nZ2luZy5yZW1vdGVMb2dnaW5nVVJMfWAsIHJlcXVlc3QpLmNhdGNoKGUgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignZmFpbGVkIHRvIHJlbW90ZSBsb2cnLCBlKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBpc1JlbW90ZUxvZ2dpbmcoKSB7XG4gICAgcmV0dXJuIHJlbW90ZUxvZ2dpbmcgIT09IHVuZGVmaW5lZDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBsb2coLi4uYXJncykge1xuICAgIGlmIChvZmZzY3JlZW5Db250ZXh0KCkpIHtcbiAgICAgICAgc2VuZFRvU2VydmljZVdvcmtlcignbG9nJywgYXJncyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBbaXNvODYwMURhdGVUaW1lWm9uZShuZXcgRGF0ZSgpKSwgLi4uYXJnc10pO1xuICAgIH1cbiAgICBpZiAoaXNSZW1vdGVMb2dnaW5nKCkpIHtcbiAgICAgICAgcmVtb3RlTG9nKHtcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoWydJTkZPJywgLi4uYXJnc10pLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gZXJyb3IoLi4uYXJncykge1xuICAgIGlmIChvZmZzY3JlZW5Db250ZXh0KCkpIHtcbiAgICAgICAgc2VuZFRvU2VydmljZVdvcmtlcignZXJyb3InLCBhcmdzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IuYXBwbHkoY29uc29sZSwgW2lzbzg2MDFEYXRlVGltZVpvbmUobmV3IERhdGUoKSksIC4uLmFyZ3NdKTtcbiAgICB9XG4gICAgaWYgKGlzUmVtb3RlTG9nZ2luZygpKSB7XG4gICAgICAgIHJlbW90ZUxvZyh7XG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KFsnRVJST1InLCAuLi5hcmdzXSksXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiB3YXJuKC4uLmFyZ3MpIHtcbiAgICBpZiAob2Zmc2NyZWVuQ29udGV4dCgpKSB7XG4gICAgICAgIHNlbmRUb1NlcnZpY2VXb3JrZXIoJ3dhcm4nLCBhcmdzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2Fybi5hcHBseShjb25zb2xlLCBbaXNvODYwMURhdGVUaW1lWm9uZShuZXcgRGF0ZSgpKSwgLi4uYXJnc10pO1xuICAgIH1cbiAgICBpZiAoaXNSZW1vdGVMb2dnaW5nKCkpIHtcbiAgICAgICAgcmVtb3RlTG9nKHtcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoWydXQVJOJywgLi4uYXJnc10pLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBvZmZzY3JlZW5Db250ZXh0KCkge1xuICAgIHRyeSB7XG4gICAgICAgIGNocm9tZS5ydW50aW1lLmdldE1hbmlmZXN0KCk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBzZW5kVG9TZXJ2aWNlV29ya2VyKHR5cGUsIGRhdGEpIHtcbiAgICBjaHJvbWUucnVudGltZS5zZW5kTWVzc2FnZSh7XG4gICAgICAgIHR5cGUsXG4gICAgICAgIHRhcmdldDogJ2JhY2tncm91bmQnLFxuICAgICAgICBkYXRhLFxuICAgIH0pO1xufVxuIiwiZXhwb3J0ICogZnJvbSAnLi9sb2cnO1xuIiwiY29uc3QgUkFORE9NX1NUUklOR19DSEFSU0VUID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5JztcbmV4cG9ydCBmdW5jdGlvbiBjcnlwdG9SYW5kb21TdHJpbmcobGVuZ3RoKSB7XG4gICAgbGV0IHJlc3VsdCA9ICcnO1xuICAgIGZvciAoY29uc3QgdiBvZiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50MzJBcnJheShsZW5ndGgpKSkge1xuICAgICAgICByZXN1bHQgKz0gUkFORE9NX1NUUklOR19DSEFSU0VUW3YgJSBSQU5ET01fU1RSSU5HX0NIQVJTRVQubGVuZ3RoXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbiIsImV4cG9ydCAqIGZyb20gJy4vc3RyaW5nJztcbiIsImltcG9ydCB7IGNyeXB0b1JhbmRvbVN0cmluZyB9IGZyb20gJy4uL3JhbmRvbSc7XG5pbXBvcnQgeyBnZXRMb2NhbFN0b3JhZ2VEYXRhLCBzZXRMb2NhbFN0b3JhZ2VEYXRhIH0gZnJvbSAnLi4vc3RvcmFnZSc7XG5jb25zdCBDTElFTlRfSURfTEVOR1RIID0gMjI7XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q2xpZW50SWQoKSB7XG4gICAgY29uc3QgY2xpZW50SWQgPSBhd2FpdCBnZXRMb2NhbFN0b3JhZ2VEYXRhKCdjbGllbnRJZCcpO1xuICAgIGlmIChjbGllbnRJZCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNsaWVudElkKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBzZXRMb2NhbFN0b3JhZ2VEYXRhKCdjbGllbnRJZCcsIGNyeXB0b1JhbmRvbVN0cmluZyhDTElFTlRfSURfTEVOR1RIKSk7XG4gICAgfVxufVxuIiwiZXhwb3J0ICogZnJvbSAnLi9jbGllbnRJZCc7XG4iLCJleHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlU2Vzc2lvbihiYXNlVXJsLCByZXEpIHtcbiAgICBjb25zdCBpbml0ID0gcHJlcGFyZVJlcXVlc3RJbml0KHJlcS5jbGllbnRUb2tlbiwgcmVxLmNsaWVudElkKTtcbiAgICBpbml0Lm1ldGhvZCA9IFwiUE9TVFwiO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7c2Vzc2lvblBhdGgoYmFzZVVybCl9YCwgaW5pdCk7XG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICAgIHRocm93IGBlcnJvciBjcmVhdGluZyBjbGllbnQgc2Vzc2lvbiBbJHtyZXNwb25zZS5zdGF0dXN9XWA7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCByZXNwb25zZS5qc29uKCk7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlT2ZmZXIoYmFzZVVybCwgcmVxKSB7XG4gICAgY29uc3QgaW5pdCA9IHByZXBhcmVSZXF1ZXN0SW5pdChyZXEuY2xpZW50VG9rZW4sIHJlcS5jbGllbnRJZCk7XG4gICAgaW5pdC5tZXRob2QgPSBcIlBVVFwiO1xuICAgIGluaXQuYm9keSA9IEpTT04uc3RyaW5naWZ5KHsgaWNlT2ZmZXI6IHJlcS5pY2VPZmZlciB9KTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke3Nlc3Npb25QYXRoKGJhc2VVcmwpfS8ke3JlcS5zZXNzaW9uSWR9L29mZmVyYCwgaW5pdCk7XG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PSA0MDApIHtcbiAgICAgICAgdGhyb3cgYGVycm9yIHNlbmRpbmcgb2ZmZXI6IGV4cGlyZWQgc2Vzc2lvbmA7XG4gICAgfVxuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgIT0gMjAwKSB7XG4gICAgICAgIHRocm93IGBlcnJvciBzZW5kaW5nIG9mZmVyOiBbJHtyZXNwb25zZS5zdGF0dXN9XWA7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCByZXNwb25zZS5qc29uKCk7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbm90aWZ5Q2xpZW50Q2FuZGlkYXRlcyhiYXNlVXJsLCByZXEpIHtcbiAgICBjb25zdCBpbml0ID0gcHJlcGFyZVJlcXVlc3RJbml0KHJlcS5jbGllbnRUb2tlbiwgcmVxLmNsaWVudElkKTtcbiAgICBpbml0Lm1ldGhvZCA9IFwiUE9TVFwiO1xuICAgIGluaXQuYm9keSA9IEpTT04uc3RyaW5naWZ5KHsgaWNlQ2FuZGlkYXRlczogcmVxLmljZUNhbmRpZGF0ZXMgfSk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtzZXNzaW9uUGF0aChiYXNlVXJsKX0vJHtyZXEuc2Vzc2lvbklkfS9jYW5kaWRhdGVgLCBpbml0KTtcbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09IDQwMCkge1xuICAgICAgICB0aHJvdyBgZXJyb3Igbm90aWZ5aW5nIG5ldyBjYW5kaWRhdGVzOiBleHBpcmVkIHNlc3Npb25gO1xuICAgIH1cbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzICE9IDIwMCkge1xuICAgICAgICB0aHJvdyBgZXJyb3Igbm90aWZ5aW5nIG5ldyBjYW5kaWRhdGVzOiBbJHtyZXNwb25zZS5zdGF0dXN9XWA7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCByZXNwb25zZS5qc29uKCk7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0QW5zd2VyKGJhc2VVcmwsIHJlcSkge1xuICAgIGNvbnN0IGluaXQgPSBwcmVwYXJlUmVxdWVzdEluaXQocmVxLmNsaWVudFRva2VuLCByZXEuY2xpZW50SWQpO1xuICAgIGluaXQubWV0aG9kID0gXCJHRVRcIjtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke3Nlc3Npb25QYXRoKGJhc2VVcmwpfS8ke3JlcS5zZXNzaW9uSWR9L2Fuc3dlcmAsIGluaXQpO1xuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT0gNDA0KSB7XG4gICAgICAgIHJldHVybiBcInBlbmRpbmdcIjtcbiAgICB9XG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PSA0MDApIHtcbiAgICAgICAgdGhyb3cgXCJlcnJvciByZXRyaWV2aW5nIGFuc3dlcjogZXhwaXJlZCBzZXNzaW9uXCI7XG4gICAgfVxuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgIT0gMjAwKSB7XG4gICAgICAgIHRocm93IGBlcnJvciByZXRyaWV2aW5nIGFuc3dlcjogWyR7cmVzcG9uc2Uuc3RhdHVzfV1gO1xuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFNlcnZlckNhbmRpZGF0ZXMoYmFzZVVybCwgcmVxKSB7XG4gICAgY29uc3QgZGF0ZSA9IHJlcS5zaW5jZTtcbiAgICBjb25zdCBpbml0ID0gcHJlcGFyZVJlcXVlc3RJbml0KHJlcS5jbGllbnRUb2tlbiwgcmVxLmNsaWVudElkKTtcbiAgICBpbml0Lm1ldGhvZCA9IFwiR0VUXCI7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtzZXNzaW9uUGF0aChiYXNlVXJsKX0vJHtyZXEuc2Vzc2lvbklkfS9zZXJ2ZXJjYW5kaWRhdGVzP3NpbmNlPSR7cmVxLnNpbmNlfWAsIGluaXQpO1xuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT0gNDAwKSB7XG4gICAgICAgIHRocm93IGBlcnJvciByZWNlaXZpbmcgbmV3IGNhbmRpZGF0ZXM6IGV4cGlyZWQgc2Vzc2lvbmA7XG4gICAgfVxuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgIT0gMjAwKSB7XG4gICAgICAgIHRocm93IGBlcnJvciByZWNlaXZpbmcgbmV3IGNhbmRpZGF0ZXM6IFske3Jlc3BvbnNlLnN0YXR1c31dYDtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkZWxldGVTZXNzaW9uKGJhc2VVcmwsIHJlcSkge1xuICAgIGNvbnN0IGluaXQgPSBwcmVwYXJlUmVxdWVzdEluaXQocmVxLmNsaWVudFRva2VuLCByZXEuY2xpZW50SWQpO1xuICAgIGluaXQubWV0aG9kID0gXCJERUxFVEVcIjtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke3Nlc3Npb25QYXRoKGJhc2VVcmwpfS8ke3JlcS5zZXNzaW9uSWR9YCwgaW5pdCk7XG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyAhPSAyMDApIHtcbiAgICAgICAgdGhyb3cgYGVycm9yIGRlbGV0aW5nIHNlc3Npb246IFske3Jlc3BvbnNlLnN0YXR1c31dYDtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbn1cbmZ1bmN0aW9uIHByZXBhcmVSZXF1ZXN0SW5pdChjbGllbnRUb2tlbiwgY2xpZW50SWQpIHtcbiAgICBjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKTtcbiAgICBoZWFkZXJzLmFwcGVuZChcIkF1dGhvcml6YXRpb25cIiwgYEJlYXJlciAke2NsaWVudFRva2VufWApO1xuICAgIGhlYWRlcnMuYXBwZW5kKFwiWC1QYXBlckN1dC1DbGllbnQtSWRcIiwgY2xpZW50SWQpO1xuICAgIGhlYWRlcnMuYXBwZW5kKFwiVXNlci1BZ2VudFwiLCBcIlBhcGVyQ3V0TW9iaWxpdHlQcmludENsb3VkQ2xpZW50RVMvMS4wLjBcIik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaGVhZGVyczogaGVhZGVycyxcbiAgICB9O1xufVxuZnVuY3Rpb24gc2Vzc2lvblBhdGgoYmFzZVVybCkge1xuICAgIHJldHVybiBgJHtiYXNlVXJsfS9jbGllbnQvdjEvc2Vzc2lvbmA7XG59XG4iLCJleHBvcnQgKiBmcm9tICcuL3Nlc3Npb24nO1xuIiwiY29uc3QgREVGQVVMVF9DSFVOS19TSVpFID0gMTYzODQ7XG5jb25zdCBNSU5fQ0hVTktfU0laRSA9IDE7XG5leHBvcnQgZnVuY3Rpb24gY2h1bmtCbG9iKGJsb2IsIGNodW5rU2l6ZSkge1xuICAgIGlmIChjaHVua1NpemUgPCBNSU5fQ0hVTktfU0laRSkge1xuICAgICAgICBjaHVua1NpemUgPSBERUZBVUxUX0NIVU5LX1NJWkU7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgICpbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgICAgIGxldCBvZmZzZXQgPSAwO1xuICAgICAgICAgICAgbGV0IGVuZCA9IE1hdGgubWluKG9mZnNldCArIGNodW5rU2l6ZSwgYmxvYi5zaXplKTtcbiAgICAgICAgICAgIHdoaWxlIChvZmZzZXQgPCBibG9iLnNpemUpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCBibG9iLnNsaWNlKG9mZnNldCwgZW5kKTtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBlbmQ7XG4gICAgICAgICAgICAgICAgZW5kID0gTWF0aC5taW4ob2Zmc2V0ICsgY2h1bmtTaXplLCBibG9iLnNpemUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9LFxuICAgIH07XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYmxvYlRvQXJyYXlCdWZmZXIoYmxvYikge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICAgIHJlYWRlci5vbmxvYWRlbmQgPSAoKSA9PiByZXNvbHZlKHJlYWRlci5yZXN1bHQpO1xuICAgICAgICByZWFkZXIub25lcnJvciA9ICgpID0+IHJlamVjdChyZWFkZXIuZXJyb3IpO1xuICAgICAgICByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoYmxvYik7XG4gICAgfSk7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYmxvYlRvU3RyaW5nKGJsb2IpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICByZWFkZXIub25sb2FkZW5kID0gKCkgPT4gcmVzb2x2ZShyZWFkZXIucmVzdWx0KTtcbiAgICAgICAgcmVhZGVyLm9uZXJyb3IgPSAoKSA9PiByZWplY3QocmVhZGVyLmVycm9yKTtcbiAgICAgICAgcmVhZGVyLnJlYWRBc0JpbmFyeVN0cmluZyhibG9iKTtcbiAgICB9KTtcbn1cbiIsImltcG9ydCB7IGxvZywgZXJyb3IgfSBmcm9tICcuLi9sb2cnO1xuaW1wb3J0IHsgYmxvYlRvQXJyYXlCdWZmZXIsIGNodW5rQmxvYiB9IGZyb20gJy4vYmxvYic7XG5pbXBvcnQgeyBNZXNzYWdlIH0gZnJvbSAnLi9tZXNzYWdlJztcbmV4cG9ydCBjbGFzcyBEYXRhQ2hhbm5lbCB7XG4gICAgY29uc3RydWN0b3Ioc2VydmVySWQsIGRhdGFDaGFubmVsLCBnZXRDaHVua1NpemUpIHtcbiAgICAgICAgdGhpcy5kYXRhQ2hhbm5lbCA9IGRhdGFDaGFubmVsO1xuICAgICAgICB0aGlzLmdldENodW5rU2l6ZSA9IGdldENodW5rU2l6ZTtcbiAgICAgICAgdGhpcy5sYWJlbCA9IGAke3NlcnZlcklkfS4ke2RhdGFDaGFubmVsLmxhYmVsfWA7XG4gICAgfVxuICAgIGFzeW5jIHNlbmRCbG9iKGIpIHtcbiAgICAgICAgY29uc3QgY2h1bmtTaXplID0gdGhpcy5nZXRDaHVua1NpemUoKTtcbiAgICAgICAgY29uc3QgdGhyZXNob2xkTG93ID0gY2h1bmtTaXplO1xuICAgICAgICBjb25zdCB0aHJlc2hvbGRIaWdoID0gTWF0aC5tYXgoY2h1bmtTaXplICogOCwgMTAyNCAqIDEwMjQpO1xuICAgICAgICBjb25zdCBjaHVua2VkID0gY2h1bmtCbG9iKGIsIGNodW5rU2l6ZSlbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgICAgICBjb25zdCBudW1DaHVua3MgPSBNYXRoLmNlaWwoYi5zaXplIC8gY2h1bmtTaXplKTtcbiAgICAgICAgY29uc3QgbG9nRXZlcnlOQ2h1bmtzID0gTWF0aC5mbG9vcigoMTAyNCAqIDEwMjQpIC8gY2h1bmtTaXplKTtcbiAgICAgICAgbG9nKGBbJHt0aGlzLmxhYmVsfV0gc2VuZEJsb2I6IHNpemU9JHtiLnNpemV9IGJ5dGVzLCBudW1DaHVua3M9JHtudW1DaHVua3N9YCk7XG4gICAgICAgIHRoaXMuZGF0YUNoYW5uZWwuYnVmZmVyZWRBbW91bnRMb3dUaHJlc2hvbGQgPSB0aHJlc2hvbGRMb3c7XG4gICAgICAgIGNvbnN0IGRlZmVycmVkID0ge1xuICAgICAgICAgICAgcmVzb2x2ZWQ6IGZhbHNlLFxuICAgICAgICB9O1xuICAgICAgICBkZWZlcnJlZC5wcm9taXNlID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgbGV0IGNodW5rSWR4ID0gMDtcbiAgICAgICAgbGV0IGZpbGxJblByb2dyZXNzID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGZpbGxUb0NhcGFjaXR5ID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgZmlsbEluUHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kYXRhQ2hhbm5lbC5idWZmZXJlZEFtb3VudCA+PSB0aHJlc2hvbGRIaWdoKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGxJblByb2dyZXNzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gY2h1bmtlZC5uZXh0KCk7XG4gICAgICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjaHVua0lkeCA+IDAgJiYgY2h1bmtJZHggJSBsb2dFdmVyeU5DaHVua3MgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nKGBUcmFuc2ZlcnJlZCAke2NodW5rSWR4ICsgMX0gb3V0IG9mICR7bnVtQ2h1bmtzfSBjaHVua3MuIFtgLCAnbGFiZWw9JywgdGhpcy5sYWJlbCwgJ10nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgYnVmID0gYXdhaXQgYmxvYlRvQXJyYXlCdWZmZXIodmFsdWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YUNoYW5uZWwuc2VuZChidWYpO1xuICAgICAgICAgICAgICAgIGNodW5rSWR4Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZGF0YUNoYW5uZWwub25idWZmZXJlZGFtb3VudGxvdyA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGlmIChkZWZlcnJlZC5yZXNvbHZlZCB8fCBmaWxsSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IGZpbGxUb0NhcGFjaXR5KCk7XG4gICAgICAgIH07XG4gICAgICAgIGxvZyhgWyR7dGhpcy5sYWJlbH1dIGAgKyAnU3RhcnRpbmcgZGF0YSBjaGFubmVsIHRyYW5zZmVyLiBbJywgJ3NpemU9JywgYi5zaXplLCAnY2h1bmtTaXplPScsIGNodW5rU2l6ZSwgJ2NodW5rcz0nLCBudW1DaHVua3MsICdidWZmZXJIaWdoPScsIHRocmVzaG9sZEhpZ2gsICddJyk7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgYXdhaXQgZmlsbFRvQ2FwYWNpdHkoKTtcbiAgICAgICAgYXdhaXQgZGVmZXJyZWQucHJvbWlzZTtcbiAgICAgICAgdGhpcy5kYXRhQ2hhbm5lbC5vbmJ1ZmZlcmVkYW1vdW50bG93ID0gdW5kZWZpbmVkO1xuICAgICAgICBsb2coJ0RhdGEgY2hhbm5lbCB0cmFuc2ZlciBjb21wbGV0ZS4gWycsICdsYWJlbD0nLCB0aGlzLmxhYmVsLCAnZHVyYXRpb249JywgYCR7RGF0ZS5ub3coKSAtIHN0YXJ0fW1zYCwgJ10nKTtcbiAgICB9XG4gICAgc2VuZFN0cmluZyhzKSB7XG4gICAgICAgIGxvZyhgWyR7dGhpcy5sYWJlbH1dIHNlbmRTdHJpbmc6IHNpemU9JHtzLmxlbmd0aH0gYnl0ZXNgKTtcbiAgICAgICAgaWYgKHRoaXMuaXNDbG9zZWQoKSkge1xuICAgICAgICAgICAgZXJyb3IoYENhbm5vdCBzZW5kIG1lc3NhZ2Ugb24gY2xvc2VkIGNoYW5uZWwgJyR7dGhpcy5sYWJlbH1gKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRhdGFDaGFubmVsLnNlbmQocyk7XG4gICAgfVxuICAgIGlzQ2xvc2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhQ2hhbm5lbC5yZWFkeVN0YXRlID09PSAnY2xvc2VkJztcbiAgICB9XG4gICAgY2xvc2UoKSB7XG4gICAgICAgIHRoaXMuZGF0YUNoYW5uZWwuY2xvc2UoKTtcbiAgICB9XG4gICAgb25PcGVuKGYpIHtcbiAgICAgICAgdGhpcy5kYXRhQ2hhbm5lbC5vbm9wZW4gPSAoZXYpID0+IHtcbiAgICAgICAgICAgIGYodGhpcywgZXYpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBvbk1lc3NhZ2UoZikge1xuICAgICAgICB0aGlzLmRhdGFDaGFubmVsLm9ubWVzc2FnZSA9IChldikgPT4ge1xuICAgICAgICAgICAgY29uc3QgbXNnID0gbmV3IE1lc3NhZ2UoZXYpO1xuICAgICAgICAgICAgZih0aGlzLCBtc2cpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBjbGVhck9uTWVzc2FnZSgpIHtcbiAgICAgICAgdGhpcy5kYXRhQ2hhbm5lbC5vbm1lc3NhZ2UgPSBudWxsO1xuICAgIH1cbiAgICBvbkNsb3NlKGYpIHtcbiAgICAgICAgdGhpcy5kYXRhQ2hhbm5lbC5vbmNsb3NlID0gKGV2KSA9PiB7XG4gICAgICAgICAgICBmKHRoaXMsIGV2KTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgb25FcnJvcihmKSB7XG4gICAgICAgIHRoaXMuZGF0YUNoYW5uZWwub25lcnJvciA9IChldikgPT4ge1xuICAgICAgICAgICAgZih0aGlzLCBldik7XG4gICAgICAgIH07XG4gICAgfVxufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIGRlY29kZVNlc3Npb25EZXNjcmlwdGlvbihvZmZlcikge1xuICAgIHJldHVybiBKU09OLnBhcnNlKGF0b2Iob2ZmZXIpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVTZXNzaW9uRGVzY3JpcHRpb24oc2QpIHtcbiAgICByZXR1cm4gYnRvYShKU09OLnN0cmluZ2lmeShzZCkpO1xufVxuIiwiaW1wb3J0IHsgbG9nIH0gZnJvbSAnLi4vbG9nJztcbmltcG9ydCB7IERhdGFDaGFubmVsIH0gZnJvbSAnLi9kYXRhY2hhbm5lbCc7XG5pbXBvcnQgeyBkZWNvZGVTZXNzaW9uRGVzY3JpcHRpb24sIGVuY29kZVNlc3Npb25EZXNjcmlwdGlvbiB9IGZyb20gJy4vc2lnbmFsJztcbmNvbnN0IE1JTl9DSFVOS19TSVpFID0gMTYgKiAxMDI0O1xuY29uc3QgTUFYX0NIVU5LX1NJWkUgPSAyNTYgKiAxMDI0O1xuZXhwb3J0IGNsYXNzIFBlZXIge1xuICAgIGNvbnN0cnVjdG9yKHNlcnZlcklkLCBpY2VDb25maWcpIHtcbiAgICAgICAgdGhpcy5kYXRhQ2hhbm5lbHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvblN0YXRlQ2hhbmdlQ2FsbGJhY2tzID0gW107XG4gICAgICAgIHRoaXMuc2VydmVySWQgPSBzZXJ2ZXJJZDtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uID0gbmV3IFJUQ1BlZXJDb25uZWN0aW9uKGNyZWF0ZVJUQ0NvbmZpZyhpY2VDb25maWcpKTtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uLm9uY29ubmVjdGlvbnN0YXRlY2hhbmdlID0gKGV2KSA9PiB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGYgb2YgdGhpcy5jb25uZWN0aW9uU3RhdGVDaGFuZ2VDYWxsYmFja3MpIHtcbiAgICAgICAgICAgICAgICBmKHRoaXMsIGV2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0U2VydmVySWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlcnZlcklkO1xuICAgIH1cbiAgICBjcmVhdGVEYXRhQ2hhbm5lbChsYWJlbCkge1xuICAgICAgICBjb25zdCBkYyA9IHRoaXMuY29ubmVjdGlvbi5jcmVhdGVEYXRhQ2hhbm5lbChsYWJlbCk7XG4gICAgICAgIGNvbnN0IGNoYW5uZWwgPSBuZXcgRGF0YUNoYW5uZWwodGhpcy5zZXJ2ZXJJZCwgZGMsIHRoaXMuZ2V0Q2h1bmtTaXplLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmRhdGFDaGFubmVscy5zZXQobGFiZWwsIGNoYW5uZWwpO1xuICAgICAgICByZXR1cm4gY2hhbm5lbDtcbiAgICB9XG4gICAgZ2V0Q2h1bmtTaXplKCkge1xuICAgICAgICBpZiAodGhpcy5jb25uZWN0aW9uLnNjdHApIHtcbiAgICAgICAgICAgIGxvZyhgWyR7dGhpcy5nZXRTZXJ2ZXJJZCgpfV1gLCBgVXNpbmcgU0NUUCBzcGVjaWZpZWQgY2h1bmsgc2l6ZSB2YWx1ZTogJHt0aGlzLmNvbm5lY3Rpb24uc2N0cC5tYXhNZXNzYWdlU2l6ZX0gYnl0ZXNgKTtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1pbih0aGlzLmNvbm5lY3Rpb24uc2N0cC5tYXhNZXNzYWdlU2l6ZSAtIDEsIE1BWF9DSFVOS19TSVpFKTtcbiAgICAgICAgfVxuICAgICAgICBsb2coYFske3RoaXMuZ2V0U2VydmVySWQoKX1dIFVzaW5nIGZhbGwtYmFjayBjaHVuayBzaXplIHZhbHVlOiAke01JTl9DSFVOS19TSVpFfSBieXRlc2ApO1xuICAgICAgICByZXR1cm4gTUlOX0NIVU5LX1NJWkU7XG4gICAgfVxuICAgIG9uRGF0YUNoYW5uZWwoZikge1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb24ub25kYXRhY2hhbm5lbCA9IChldikgPT4ge1xuICAgICAgICAgICAgY29uc3QgZGMgPSBuZXcgRGF0YUNoYW5uZWwodGhpcy5zZXJ2ZXJJZCwgZXYuY2hhbm5lbCwgdGhpcy5nZXRDaHVua1NpemUuYmluZCh0aGlzKSk7XG4gICAgICAgICAgICB0aGlzLmRhdGFDaGFubmVscy5zZXQoZGMubGFiZWwsIGRjKTtcbiAgICAgICAgICAgIGYodGhpcywgZGMpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBvbk5lZ290aWF0aW9uTmVlZGVkKGYpIHtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uLm9ubmVnb3RpYXRpb25uZWVkZWQgPSAoZXYpID0+IHtcbiAgICAgICAgICAgIGYodGhpcywgZXYpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBvbklDRUNhbmRpZGF0ZShmKSB7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbi5vbmljZWNhbmRpZGF0ZSA9IChldikgPT4ge1xuICAgICAgICAgICAgZih0aGlzLCBldik7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGlzUGVlckNvbm5lY3RlZCgpIHtcbiAgICAgICAgbG9nKGBbJHt0aGlzLnNlcnZlcklkfV0gY2hlY2tpbmcgcGVlciBjb25uZWN0aW9uIHN0YXRlOmAsIHRoaXMuY29ubmVjdGlvbi5pY2VDb25uZWN0aW9uU3RhdGUpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uLmNvbm5lY3Rpb25TdGF0ZSA9PT0gJ2Nvbm5lY3RlZCc7XG4gICAgfVxuICAgIGNsb3NlKCkge1xuICAgICAgICBsb2coYFske3RoaXMuc2VydmVySWR9XSBjbG9zaW5nIHBlZXIgY29ubmVjdGlvbi4uLmApO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb24uY2xvc2UoKTtcbiAgICB9XG4gICAgYXN5bmMgY3JlYXRlQW5zd2VyKG9mZmVyKSB7XG4gICAgICAgIGNvbnN0IG9mZmVyU2Vzc2lvbkRlc2NyaXB0aW9uID0gZGVjb2RlU2Vzc2lvbkRlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5jb25uZWN0aW9uLnNldFJlbW90ZURlc2NyaXB0aW9uKG9mZmVyU2Vzc2lvbkRlc2NyaXB0aW9uKTtcbiAgICAgICAgY29uc3QgYW5zd2VyID0gYXdhaXQgdGhpcy5jb25uZWN0aW9uLmNyZWF0ZUFuc3dlcigpO1xuICAgICAgICBhd2FpdCB0aGlzLmNvbm5lY3Rpb24uc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICByZXR1cm4gZW5jb2RlU2Vzc2lvbkRlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgfVxuICAgIG9uQ29ubmVjdGlvblN0YXRlQ2hhbmdlKGYpIHtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uU3RhdGVDaGFuZ2VDYWxsYmFja3MucHVzaChmKTtcbiAgICB9XG4gICAgYXN5bmMgb25JQ0VDb25uZWN0aW9uU3RhdGVDaGFuZ2UoZikge1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb24ub25pY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2UgPSAoZXYpID0+IHtcbiAgICAgICAgICAgIGYodGhpcywgZXYpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXRDb25uZWN0aW9uU3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb24uY29ubmVjdGlvblN0YXRlO1xuICAgIH1cbiAgICBnZXRJQ0VDb25uZWN0aW9uU3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb24uaWNlQ29ubmVjdGlvblN0YXRlO1xuICAgIH1cbiAgICBhc3luYyBjcmVhdGVPZmZlcigpIHtcbiAgICAgICAgY29uc3Qgb2ZmZXIgPSBhd2FpdCB0aGlzLmNvbm5lY3Rpb24uY3JlYXRlT2ZmZXIoKTtcbiAgICAgICAgYXdhaXQgdGhpcy5jb25uZWN0aW9uLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmNvbm5lY3Rpb24ubG9jYWxEZXNjcmlwdGlvbjtcbiAgICAgICAgcmV0dXJuIGVuY29kZVNlc3Npb25EZXNjcmlwdGlvbihyZXN1bHQpO1xuICAgIH1cbiAgICBhc3luYyByZWdpc3RlckFuc3dlcihhbnN3ZXIpIHtcbiAgICAgICAgY29uc3QgYW5zd2VyU2Vzc2lvbkRlc2NyaXB0aW9uID0gZGVjb2RlU2Vzc2lvbkRlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuY29ubmVjdGlvbi5zZXRSZW1vdGVEZXNjcmlwdGlvbihhbnN3ZXJTZXNzaW9uRGVzY3JpcHRpb24pO1xuICAgIH1cbiAgICBhZGRJY2VDYW5kaWRhdGUoY2FuZGlkYXRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb24uYWRkSWNlQ2FuZGlkYXRlKGNhbmRpZGF0ZSk7XG4gICAgfVxuICAgIGdldERhdGFDaGFubmVsKGxhYmVsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFDaGFubmVscy5nZXQobGFiZWwpO1xuICAgIH1cbiAgICBnZXRTZWxlY3RlZENhbmRpZGF0ZVBhaXIoKSB7XG4gICAgICAgIGNvbnN0IGljZVRyYW5zcG9ydCA9IHRoaXMuZ2V0SUNFVHJhbnNwb3J0KCk7XG4gICAgICAgIGlmICghaWNlVHJhbnNwb3J0KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaWNlVHJhbnNwb3J0LmdldFNlbGVjdGVkQ2FuZGlkYXRlUGFpcigpO1xuICAgIH1cbiAgICBnZXRJQ0VUcmFuc3BvcnQoKSB7XG4gICAgICAgIGNvbnN0IHNjdHAgPSB0aGlzLmNvbm5lY3Rpb24uc2N0cDtcbiAgICAgICAgaWYgKCFzY3RwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2N0cC50cmFuc3BvcnQuaWNlVHJhbnNwb3J0O1xuICAgIH1cbiAgICB3YWl0Rm9yTGl2ZUNvbm5lY3Rpb24od2FpdEZvcikge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiByZWooYHRpbWVvdXQgd2FpdGluZyBmb3IgcGVlciBjb25uZWN0aW9uICR7dGhpcy5zZXJ2ZXJJZH0sIHN0YXRlOmAgKyB0aGlzLmdldENvbm5lY3Rpb25TdGF0ZSgpKSwgd2FpdEZvcik7XG4gICAgICAgICAgICB0aGlzLm9uQ29ubmVjdGlvblN0YXRlQ2hhbmdlKChjdHgsIF8pID0+IHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGN0eC5nZXRDb25uZWN0aW9uU3RhdGUoKSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdjbG9zZWQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Nvbm5lY3RlZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdjb25uZWN0aW5nJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdkaXNjb25uZWN0ZWQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2ZhaWxlZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWooJ2ZhaWxlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ25ldyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlUlRDQ29uZmlnKGljZUNvbmZpZykge1xuICAgIHJldHVybiB7XG4gICAgICAgIGljZVNlcnZlcnM6IGljZUNvbmZpZy5zZXJ2ZXJzLFxuICAgICAgICBpY2VUcmFuc3BvcnRQb2xpY3k6ICdhbGwnLFxuICAgIH07XG59XG4iLCJleHBvcnQgKiBmcm9tICcuL2Jsb2InO1xuZXhwb3J0ICogZnJvbSAnLi9kYXRhY2hhbm5lbCc7XG5leHBvcnQgKiBmcm9tICcuL21lc3NhZ2UnO1xuZXhwb3J0ICogZnJvbSAnLi9wZWVyJztcbmV4cG9ydCAqIGZyb20gJy4vc2lnbmFsJztcbiIsImltcG9ydCB7IGVycm9yLCBsb2cgfSBmcm9tICcuLi9sb2cnO1xuaW1wb3J0IHsgQ0FQQUJJTElUSUVTX0NIQU5ORUxfTEFCRUwsIEpPQl9DSEFOTkVMX0xBQkVMLCBKT0JfREVUQUlMU19MQUJFTCwgUFJJTlRFUl9DSEFOTkVMX0xBQkVMLCBTRVJWRVJfSU5GT19MQUJFTCwgVE9LRU5fQ0hBTk5FTF9MQUJFTCwgfSBmcm9tICcuL2NsaWVudGJ1aWxkZXInO1xuZXhwb3J0IGNsYXNzIE1vYlJUQ0NsaWVudCB7XG4gICAgY29uc3RydWN0b3IoaWQsIHBlZXIsIHRpbWVvdXQsIGNodW5rU2l6ZSwgdmVyc2lvbikge1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMucGVlciA9IHBlZXI7XG4gICAgICAgIHRoaXMudGltZW91dCA9IHRpbWVvdXQ7XG4gICAgICAgIHRoaXMuY2h1bmtTaXplID0gY2h1bmtTaXplO1xuICAgICAgICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgICAgICB0aGlzLnNob3J0VGltZW91dCA9IHRpbWVvdXQgLyA0O1xuICAgICAgICB0aGlzLnNlcnZlcklkID0gcGVlci5nZXRTZXJ2ZXJJZCgpO1xuICAgIH1cbiAgICBnZXRJRCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaWQ7XG4gICAgfVxuICAgIGFzeW5jIGdldFNlcnZlckluZm8oKSB7XG4gICAgICAgIGxvZyhgWyR7KHRoaXMuc2VydmVySWQpfV0gRmV0Y2hpbmcgc2VydmVyIGluZm8uLi5gKTtcbiAgICAgICAgY29uc3QgZGMgPSB0aGlzLmdldFNlcnZlckluZm9DaGFubmVsKCk7XG4gICAgICAgIGRjLnNlbmRTdHJpbmcoJyAnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZEpzb25SZXNwb25zZUZyb21DaGFubmVsKGRjLCB0aGlzLnNob3J0VGltZW91dCk7XG4gICAgfVxuICAgIGFzeW5jIHNlbmRQcmludEpvYkRldGFpbHMocHJpbnRUb2tlbiwgcHJpbnRlclVybCwgcGFyYW1zLCBmaWxlU2l6ZSkge1xuICAgICAgICBsb2coYFskeyh0aGlzLnNlcnZlcklkKX1dYCwgYFN1Ym1pdHRpbmcgcHJpbnQgam9iIGRldGFpbHM6IHByaW50ZXJVcmw9JHtwcmludGVyVXJsfSwgZmlsZVNpemU9JHtmaWxlU2l6ZX0gYnl0ZXMuYCk7XG4gICAgICAgIGNvbnN0IG1zZyA9IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIGNsaWVudFZlcnNpb246IHRoaXMudmVyc2lvbixcbiAgICAgICAgICAgIHByaW50VG9rZW4sXG4gICAgICAgICAgICBwcmludGVyVXJsLFxuICAgICAgICAgICAgcGFyYW1zLFxuICAgICAgICAgICAgZmlsZVNpemUsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBkYyA9IHRoaXMuZ2V0Sm9iRGV0YWlsc0NoYW5uZWwoKTtcbiAgICAgICAgZGMuc2VuZFN0cmluZyhtc2cpO1xuICAgICAgICBsZXQgYnVmO1xuICAgICAgICBsZXQgZGF0YTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGJ1ZiA9IGF3YWl0IHRoaXMucmVhZENodW5rZWRSZXNwb25zZShkYyk7XG4gICAgICAgICAgICBkYXRhID0gYnl0ZUFycmF5VG9TdHJpbmcoYnVmKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgZXJyb3IoYFskeyh0aGlzLnNlcnZlcklkKX1dIGVycm9yIHBhcnNpbmcgcHJpbnQgam9iIGRldGFpbHMgcmVzcG9uc2UuYCwgZSk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChNb2JSVENDbGllbnQuaXNFcnJvcihkYXRhKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBhc3luYyBzZW5kUHJpbnRKb2IoZmlsZSkge1xuICAgICAgICBpZiAoZmlsZS5zaXplID09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBmaWxlIHNpemU6IFske2ZpbGUuc2l6ZX1dYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Sm9iQ2hhbm5lbCgpLnNlbmRCbG9iKGZpbGUpO1xuICAgIH1cbiAgICBpc1JlYWR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wZWVyICYmIHRoaXMucGVlci5pc1BlZXJDb25uZWN0ZWQoKTtcbiAgICB9XG4gICAgY2xvc2UoKSB7XG4gICAgICAgIHRoaXMucGVlci5jbG9zZSgpO1xuICAgIH1cbiAgICBhc3luYyBnZXRQcmludFRva2VuKHNoYXJlVG9rZW4pIHtcbiAgICAgICAgbG9nKGBbJHsodGhpcy5zZXJ2ZXJJZCl9XSBFeGNoYW5naW5nIHNoYXJlIHRva2VuIGZvciBwcmludCB0b2tlbi5gKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRjID0gdGhpcy5nZXRUb2tlbkNoYW5uZWwoKTtcbiAgICAgICAgICAgIGRjLnNlbmRTdHJpbmcoc2hhcmVUb2tlbik7XG4gICAgICAgICAgICBsZXQgYnVmO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBidWYgPSBhd2FpdCB0aGlzLnJlYWRDaHVua2VkUmVzcG9uc2UoZGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHByaW50VG9rZW47XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHByaW50VG9rZW4gPSBieXRlQXJyYXlUb1N0cmluZyhidWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBlcnJvcihgWyR7KHRoaXMuc2VydmVySWQpfV0gZXJyb3IgcGFyc2luZyBhdXRoLXRva2VuIHJlc3BvbnNlLmAsIGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoTW9iUlRDQ2xpZW50LmlzRXJyb3IocHJpbnRUb2tlbikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGBmYWlsZWQgdG8gZXhjaGFuZ2Ugc2hhcmVUb2tlbiBmb3IgcHJpbnRUb2tlbjogJHtwcmludFRva2VufWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUocHJpbnRUb2tlbik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZWFkQ2h1bmtlZFJlc3BvbnNlKGRjLCBjaHVua1RpbWVvdXQgPSB0aGlzLnRpbWVvdXQpIHtcbiAgICAgICAgbG9nKGBbJHtkYy5sYWJlbH1dIHJlYWRDaHVua2VkUmVzcG9uc2UsICBjaHVua1RpbWVvdXQ9JHtjaHVua1RpbWVvdXR9bXNgKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGxldCBjaHVua0lkeCA9IDA7XG4gICAgICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZiA9IFtdO1xuICAgICAgICAgICAgbGV0IG9uVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGRjLmNsZWFyT25NZXNzYWdlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChgJHtjaHVua1RpbWVvdXR9bXMgdGltZW91dCByZWFjaGVkIHdhaXRpbmcgZm9yIHRoZSBmaXJzdCByZXNwb25zZS5gKTtcbiAgICAgICAgICAgIH0sIGNodW5rVGltZW91dCk7XG4gICAgICAgICAgICBsZXQgbG9nRXZlcnlOQ2h1bmtzID0gMDtcbiAgICAgICAgICAgIGRjLm9uTWVzc2FnZSgoY3R4LCBtc2cpID0+IHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQob25UaW1lb3V0KTtcbiAgICAgICAgICAgICAgICBvblRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmNsZWFyT25NZXNzYWdlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoYCR7dGhpcy50aW1lb3V0fW1zIHRpbWVvdXQgcmVhY2hlZCB3YWl0aW5nIGZvciBkYXRhIGNodW5rOiBbJHtjaHVua0lkeH1dYCk7XG4gICAgICAgICAgICAgICAgfSwgdGhpcy50aW1lb3V0KTtcbiAgICAgICAgICAgICAgICBjaHVua0lkeCsrO1xuICAgICAgICAgICAgICAgIGlmIChtc2cuc3RyaW5nRGF0YSgpID09PSAnRklOSVNIJykge1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQob25UaW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmNsZWFyT25NZXNzYWdlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChidWYubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKG5ldyBVaW50OEFycmF5KCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGJ1Zi5yZWR1Y2UoKHByZXYsIG5leHQpID0+IGNvbmNhdEJ5dGVBcnJheXMocHJldiwgbmV4dCkpO1xuICAgICAgICAgICAgICAgICAgICBsb2coYFske2RjLmxhYmVsfV1gLCBgRmluaXNoZWQgcmVjZWl2aW5nICR7KHJlc3VsdC5sZW5ndGggLyAxMDI0KS50b0ZpeGVkKDIpfUtpQixgLCBgY2h1bmtzIHJlY2VpdmVkOiBbJHtjaHVua0lkeH1dYCwgYHRvb2s6ICR7KHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnRUaW1lKS50b0ZpeGVkKDIpfSBtc2ApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjaHVuayA9IG1zZy5kYXRhKCk7XG4gICAgICAgICAgICAgICAgYnVmLnB1c2gobmV3IFVpbnQ4QXJyYXkoY2h1bmspKTtcbiAgICAgICAgICAgICAgICBpZiAobG9nRXZlcnlOQ2h1bmtzID09PSAwICYmIGNodW5rLmJ5dGVMZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ0V2ZXJ5TkNodW5rcyA9IE1hdGguZmxvb3IoKDEwMjQgKiAxMDI0KSAvIGNodW5rLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChsb2dFdmVyeU5DaHVua3MgPiAwICYmIGNodW5rSWR4ID4gMCAmJiBjaHVua0lkeCAlIGxvZ0V2ZXJ5TkNodW5rcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBsb2coYFske2RjLmxhYmVsfV06IGAsIGBSZWNlaXZlZCAke2NodW5rSWR4fSBjaHVua3MsYCwgYCR7KGNodW5rLmJ5dGVMZW5ndGggKiBjaHVua0lkeCAvIDEwMjQpLnRvRml4ZWQoMil9S2lCIC5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIGdldFByaW50ZXJzKHByaW50VG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRjID0gdGhpcy5nZXRQcmludGVyQ2hhbm5lbCgpO1xuICAgICAgICAgICAgZGMuc2VuZFN0cmluZyhwcmludFRva2VuKTtcbiAgICAgICAgICAgIGxldCBwcmludGVycztcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcHJpbnRlcnMgPSBhd2FpdCB0aGlzLnJlYWRKc29uUmVzcG9uc2VGcm9tQ2hhbm5lbChkYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGVycm9yKGBbJHsodGhpcy5zZXJ2ZXJJZCl9XSBlcnJvciByZWFkaW5nIHByaW50ZXIgaW5mbyByZXNwb25zZS5gLCBlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJpbnRlcnMuZm9yRWFjaChwID0+IHtcbiAgICAgICAgICAgICAgICBwLmlkID0gYGh0dHA6Ly9sb2NhbGhvc3Q6OTE2My9wcmludGVycy8ke2VuY29kZVVSSUNvbXBvbmVudChwLm5hbWUpfWA7XG4gICAgICAgICAgICAgICAgcC5uYW1lID0gYCR7cC5uYW1lfSAtIFske3AuZGVzY3JpcHRpb259XWA7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHByaW50ZXJzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIGdldENhcGFiaWxpdGllcyhwcmludGVySWQpIHtcbiAgICAgICAgY29uc3QgZGMgPSB0aGlzLmdldENhcGFiaWxpdGllc0NoYW5uZWwoKTtcbiAgICAgICAgZGMuc2VuZFN0cmluZyhwcmludGVySWQpO1xuICAgICAgICByZXR1cm4gdGhpcy5yZWFkSnNvblJlc3BvbnNlRnJvbUNoYW5uZWwoZGMpO1xuICAgIH1cbiAgICBhc3luYyByZWFkSnNvblJlc3BvbnNlRnJvbUNoYW5uZWwoZGMsIHRpbWVvdXQgPSB0aGlzLnRpbWVvdXQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IGAke3RoaXMuc2VydmVySWR9LiR7ZGMubGFiZWx9YDtcbiAgICAgICAgICAgIGxldCBidWY7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGJ1ZiA9IGF3YWl0IHRoaXMucmVhZENodW5rZWRSZXNwb25zZShkYywgdGltZW91dCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IGJ5dGVBcnJheVRvU3RyaW5nKGJ1Zik7XG4gICAgICAgICAgICAgICAgaWYgKE1vYlJUQ0NsaWVudC5pc0Vycm9yKGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yKGBbJHt0YWd9XTogU2VydmVyIHJlc3BvbmRlZCB3aXRoIGVycm9yOiAke2RhdGF9YCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoYFNlcnZlciByZXNwb25kZWQgd2l0aCBlcnJvciBvbjogJHtkYy5sYWJlbH1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShKU09OLnBhcnNlKGRhdGEpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IoYFske3RhZ31dOiBlcnJvciBwYXJzaW5nIEpTT04gcmVzcG9uc2U6IGAsIGUsIGJ1Zik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBlcnJvcihgWyR7dGFnfV06IGVycm9yIHJlYWRpbmcgcmVzcG9uc2U6IGAsIGUsIGJ1Zik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldFNlcnZlckluZm9DaGFubmVsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wZWVyLmdldERhdGFDaGFubmVsKFNFUlZFUl9JTkZPX0xBQkVMKTtcbiAgICB9XG4gICAgZ2V0UHJpbnRlckNoYW5uZWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBlZXIuZ2V0RGF0YUNoYW5uZWwoUFJJTlRFUl9DSEFOTkVMX0xBQkVMKTtcbiAgICB9XG4gICAgZ2V0Sm9iQ2hhbm5lbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGVlci5nZXREYXRhQ2hhbm5lbChKT0JfQ0hBTk5FTF9MQUJFTCk7XG4gICAgfVxuICAgIGdldFRva2VuQ2hhbm5lbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGVlci5nZXREYXRhQ2hhbm5lbChUT0tFTl9DSEFOTkVMX0xBQkVMKTtcbiAgICB9XG4gICAgZ2V0Q2FwYWJpbGl0aWVzQ2hhbm5lbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGVlci5nZXREYXRhQ2hhbm5lbChDQVBBQklMSVRJRVNfQ0hBTk5FTF9MQUJFTCk7XG4gICAgfVxuICAgIGdldEpvYkRldGFpbHNDaGFubmVsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wZWVyLmdldERhdGFDaGFubmVsKEpPQl9ERVRBSUxTX0xBQkVMKTtcbiAgICB9XG4gICAgc3RhdGljIGlzRXJyb3IoZGF0YSkge1xuICAgICAgICByZXR1cm4gZGF0YS5zdGFydHNXaXRoKCdFUlJPUjonKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gYnl0ZUFycmF5VG9TdHJpbmcoYnVmKSB7XG4gICAgY29uc3QgdXRmOGRlY29kZSA9IG5ldyBUZXh0RGVjb2RlcigpO1xuICAgIHJldHVybiB1dGY4ZGVjb2RlLmRlY29kZShidWYpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNvbmNhdEJ5dGVBcnJheXMoaGVhZCwgdGFpbCkge1xuICAgIGNvbnN0IGNvbmNhdFJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGhlYWQubGVuZ3RoICsgdGFpbC5sZW5ndGgpO1xuICAgIGNvbmNhdFJlc3VsdC5zZXQoaGVhZCk7XG4gICAgY29uY2F0UmVzdWx0LnNldCh0YWlsLCBoZWFkLmxlbmd0aCk7XG4gICAgcmV0dXJuIGNvbmNhdFJlc3VsdDtcbn1cbiIsImltcG9ydCB7IGNyZWF0ZU9mZmVyLCBjcmVhdGVTZXNzaW9uLCBkZWxldGVTZXNzaW9uLCBnZXRBbnN3ZXIsIGdldFNlcnZlckNhbmRpZGF0ZXMsIG5vdGlmeUNsaWVudENhbmRpZGF0ZXMsIH0gZnJvbSAncGMtbW9iaWxpdHktY2xvdWQnO1xuaW1wb3J0IHsgR2V0Q2xpZW50VmVyc2lvbklEIH0gZnJvbSAnLi4vZ2xvYmFscyc7XG5pbXBvcnQgeyBsb2cgfSBmcm9tICcuLi9sb2cnO1xuaW1wb3J0IHsgUGVlciB9IGZyb20gJy4uL3BlZXInO1xuaW1wb3J0IHsgTW9iUlRDQ2xpZW50IH0gZnJvbSAnLi9jbGllbnQnO1xuZXhwb3J0IGNvbnN0IFNFUlZFUl9JTkZPX0xBQkVMID0gJ1NFUlZFUklORk8nO1xuZXhwb3J0IGNvbnN0IEpPQl9DSEFOTkVMX0xBQkVMID0gJ0pPQic7XG5leHBvcnQgY29uc3QgSk9CX0RFVEFJTFNfTEFCRUwgPSAnSk9CREVUQUlMUyc7XG5leHBvcnQgY29uc3QgUFJJTlRFUl9DSEFOTkVMX0xBQkVMID0gJ1BSSU5URVInO1xuZXhwb3J0IGNvbnN0IFRPS0VOX0NIQU5ORUxfTEFCRUwgPSAnVE9LRU4nO1xuZXhwb3J0IGNvbnN0IENBUEFCSUxJVElFU19DSEFOTkVMX0xBQkVMID0gJ0NBUEFCSUxJVElFUyc7XG5leHBvcnQgY29uc3QgQ0xJRU5UX0FQSV9CQVNFX1VSTF9QUk9EID0gJ2h0dHBzOi8vbXAuY2xvdWQucGFwZXJjdXQuY29tJztcbmV4cG9ydCBjb25zdCBDTElFTlRfQVBJX0JBU0VfVVJMX1RFU1QgPSAnaHR0cHM6Ly9tcC5jbG91ZC5wYXBlcmN1dC5zb2Z0d2FyZSc7XG5leHBvcnQgY2xhc3MgTW9iUlRDQ2xpZW50QnVpbGRlciB7XG4gICAgY29uc3RydWN0b3Ioc2VydmVySWQpIHtcbiAgICAgICAgdGhpcy5jbGllbnRJZCA9ICcnO1xuICAgICAgICB0aGlzLnRpbWVvdXQgPSAyMDAwMDtcbiAgICAgICAgdGhpcy5zaGFyZVRva2VuID0gJyc7XG4gICAgICAgIHRoaXMucHJpbnRUb2tlbiA9ICcnO1xuICAgICAgICB0aGlzLmJhc2VVcmwgPSBDTElFTlRfQVBJX0JBU0VfVVJMX1BST0Q7XG4gICAgICAgIHRoaXMuc2VydmVySWQgPSBzZXJ2ZXJJZDtcbiAgICB9XG4gICAgc2V0Q2xpZW50SWQoY2xpZW50SWQpIHtcbiAgICAgICAgdGhpcy5jbGllbnRJZCA9IGNsaWVudElkO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc2V0VGltZW91dCh0aW1lb3V0KSB7XG4gICAgICAgIHRoaXMudGltZW91dCA9IHRpbWVvdXQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzZXRTaGFyZVRva2VuKHNoYXJlVG9rZW4pIHtcbiAgICAgICAgdGhpcy5zaGFyZVRva2VuID0gc2hhcmVUb2tlbjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHNldFByaW50VG9rZW4ocHJpbnRUb2tlbikge1xuICAgICAgICB0aGlzLnByaW50VG9rZW4gPSBwcmludFRva2VuO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc2V0QmFzZVVybChiYXNlVXJsKSB7XG4gICAgICAgIHRoaXMuYmFzZVVybCA9IGJhc2VVcmw7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBhc3luYyBidWlsZCgpIHtcbiAgICAgICAgbGV0IHJlY2VpdmVkQW5zd2VyID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGNsaWVudENhbmRpZGF0ZXMgPSBbXTtcbiAgICAgICAgY29uc3QgY2xpZW50VG9rZW4gPSB0aGlzLnByaW50VG9rZW4gfHwgdGhpcy5zaGFyZVRva2VuO1xuICAgICAgICBsb2coYFtNT0IgUlRDIEJ1aWxkZXIuJHt0aGlzLnNlcnZlcklkfV0gQ2xpZW50ICcke3RoaXMuY2xpZW50SWR9JyBjcmVhdGluZyBzZXNzaW9uIHZpYSAke3RoaXMuYmFzZVVybH0gLi4uYCk7XG4gICAgICAgIGNvbnN0IHsgaWQsIGljZUNvbmZpZyB9ID0gYXdhaXQgY3JlYXRlU2Vzc2lvbih0aGlzLmJhc2VVcmwsIHtcbiAgICAgICAgICAgIGNsaWVudFRva2VuLFxuICAgICAgICAgICAgY2xpZW50SWQ6IHRoaXMuY2xpZW50SWQsXG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgc2Vzc2lvbkRlbGV0ZWQgPSBmYWxzZTtcbiAgICAgICAgbG9nKGBbTU9CIFJUQyBCdWlsZGVyLiR7dGhpcy5zZXJ2ZXJJZH1dIElDRSBzZXJ2ZXJzYCwgaWNlQ29uZmlnLnNlcnZlcnMpO1xuICAgICAgICBjb25zdCBzZXNzaW9uUGFyYW1zID0ge1xuICAgICAgICAgICAgY2xpZW50VG9rZW4sXG4gICAgICAgICAgICBzZXNzaW9uSWQ6IGlkLFxuICAgICAgICAgICAgY2xpZW50SWQ6IHRoaXMuY2xpZW50SWQsXG4gICAgICAgIH07XG4gICAgICAgIGxvZyhgW01PQiBSVEMgQnVpbGRlci4ke3RoaXMuc2VydmVySWR9XSBzdGFydGluZyBwZWVyIGNvbm5lY3Rpb246IGAgK1xuICAgICAgICAgICAgYHNlcnZlcklkPSR7dGhpcy5zZXJ2ZXJJZH0sIHNlc3Npb25JZD0ke2lkfSwgY2xpZW50SWQ9JHt0aGlzLmNsaWVudElkfWApO1xuICAgICAgICBjb25zdCBwZWVyID0gbmV3IFBlZXIodGhpcy5zZXJ2ZXJJZCwgaWNlQ29uZmlnKTtcbiAgICAgICAgcGVlci5vbkNvbm5lY3Rpb25TdGF0ZUNoYW5nZSgoY3R4LCBfKSA9PiB7XG4gICAgICAgICAgICBpZiAoc2Vzc2lvbkRlbGV0ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzd2l0Y2ggKGN0eC5nZXRDb25uZWN0aW9uU3RhdGUoKSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2Nsb3NlZCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnZmFpbGVkJzpcbiAgICAgICAgICAgICAgICAgICAgbG9nKGBbTU9CIFJUQyBCdWlsZGVyLiR7dGhpcy5zZXJ2ZXJJZH1dIFJUQyBjb25uZWN0aW9uIGNsb3NlZCwgZGVsZXRpbmcgc2Vzc2lvbi5gLCAnc2Vzc2lvbklkJywgaWQpO1xuICAgICAgICAgICAgICAgICAgICBzZXNzaW9uRGVsZXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZVNlc3Npb24odGhpcy5iYXNlVXJsLCB7IC4uLnNlc3Npb25QYXJhbXMgfSkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2coYFtNT0IgUlRDIEJ1aWxkZXIuJHt0aGlzLnNlcnZlcklkfV0gQ2xvdWQgc2Vzc2lvbiBkZWxldGVkLmAsICdzZXNzaW9uSWQnLCBpZCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsb2coYFtNT0IgUlRDIEJ1aWxkZXIuJHt0aGlzLnNlcnZlcklkfV0gUlRDIGNvbm5lY3Rpb24gc3RhdGUgY2hhbmdlZDogJHtjdHguZ2V0Q29ubmVjdGlvblN0YXRlKCl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBwZWVyLm9uSUNFQ2FuZGlkYXRlKGFzeW5jIChjdHgsIGV2KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXYuY2FuZGlkYXRlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBsb2coYFtNT0IgUlRDIEJ1aWxkZXIuJHt0aGlzLnNlcnZlcklkfV0gY2FuZGlkYXRlcyBleGhhdXN0ZWRgLCBpZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFyZWNlaXZlZEFuc3dlcikge1xuICAgICAgICAgICAgICAgIGNsaWVudENhbmRpZGF0ZXMucHVzaChKU09OLnN0cmluZ2lmeShldi5jYW5kaWRhdGUpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGxvZyhgW01PQiBSVEMgQnVpbGRlci4ke3RoaXMuc2VydmVySWR9XSBmb3VuZCBjYW5kaWRhdGUsIHNlbmRpbmcgdG8gcmVtb3RlIHBlZXJgLCAnY2FuZGlkYXRlJywgZXYuY2FuZGlkYXRlLCAnc2Vzc2lvbklkJywgaWQpO1xuICAgICAgICAgICAgICAgIGF3YWl0IG5vdGlmeUNsaWVudENhbmRpZGF0ZXModGhpcy5iYXNlVXJsLCB7XG4gICAgICAgICAgICAgICAgICAgIC4uLnNlc3Npb25QYXJhbXMsXG4gICAgICAgICAgICAgICAgICAgIGljZUNhbmRpZGF0ZXM6IFtKU09OLnN0cmluZ2lmeShldi5jYW5kaWRhdGUpXSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY3R4LmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgYXdhaXQgZGVsZXRlU2Vzc2lvbih0aGlzLmJhc2VVcmwsIHsgLi4uc2Vzc2lvblBhcmFtcyB9KTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBEYXRlLm5vdygpO1xuICAgICAgICBjb25zdCBwZWVyQ29ubmVjdGlvbkxpdmUgPSBwZWVyLndhaXRGb3JMaXZlQ29ubmVjdGlvbih0aGlzLnRpbWVvdXQpO1xuICAgICAgICBsb2coYFtNT0IgUlRDIEJ1aWxkZXIuJHt0aGlzLnNlcnZlcklkfV0gcmVnaXN0ZXJpbmcgaWNlIGNhbmRpZGF0ZSBzZW5kIGhhbmRsZXJgKTtcbiAgICAgICAgY29uc3Qgb2ZmZXIgPSBuZXcgUHJvbWlzZSgocmVzKSA9PiB7XG4gICAgICAgICAgICBwZWVyLm9uTmVnb3RpYXRpb25OZWVkZWQoYXN5bmMgKGN0eCwgXykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9mZmVyID0gYXdhaXQgY3R4LmNyZWF0ZU9mZmVyKCk7XG4gICAgICAgICAgICAgICAgcmVzKG9mZmVyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZGF0YUNoYW5uZWxzID0gdGhpcy5zZXREYXRhQ2hhbm5lbEhhbmRsZXJzKHBlZXIpO1xuICAgICAgICBsb2coYFtNT0IgUlRDIEJ1aWxkZXIuJHt0aGlzLnNlcnZlcklkfV0gc2VuZGluZyBvZmZlciB0byByZW1vdGUgcGVlcmApO1xuICAgICAgICBhd2FpdCBjcmVhdGVPZmZlcih0aGlzLmJhc2VVcmwsIHsgLi4uc2Vzc2lvblBhcmFtcywgaWNlT2ZmZXI6IGF3YWl0IG9mZmVyIH0pO1xuICAgICAgICBsb2coYFtNT0IgUlRDIEJ1aWxkZXIuJHt0aGlzLnNlcnZlcklkfV0gYXdhaXRpbmcgYW5zd2VyYCk7XG4gICAgICAgIGNvbnN0IGFuc3dlciA9IGF3YWl0IHBvbGxHZXRBbnN3ZXIodGhpcy5iYXNlVXJsLCB7IC4uLnNlc3Npb25QYXJhbXMgfSwgeyBpbnRlcnZhbDogNTAwLCB0aW1lb3V0OiAxNTAwMCB9KTtcbiAgICAgICAgaWYgKGFuc3dlciA9PSAndGltZW91dCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IHJldHJpZXZlIHJlbW90ZSBhbnN3ZXInKTtcbiAgICAgICAgfVxuICAgICAgICBsb2coYFtNT0IgUlRDIEJ1aWxkZXIuJHt0aGlzLnNlcnZlcklkfV0gcmVnaXN0ZXJpbmcgcmVtb3RlIGFuc3dlciBsb2NhbGx5YCk7XG4gICAgICAgIGF3YWl0IHBlZXIucmVnaXN0ZXJBbnN3ZXIoYW5zd2VyLmljZUFuc3dlcik7XG4gICAgICAgIHJlY2VpdmVkQW5zd2VyID0gdHJ1ZTtcbiAgICAgICAgaWYgKGNsaWVudENhbmRpZGF0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbG9nKGBbTU9CIFJUQyBCdWlsZGVyLiR7dGhpcy5zZXJ2ZXJJZH1dIHNlbmRpbmcgYnVmZmVyZWQgY2FuZGlkYXRlIHRvIHBlZXJgKTtcbiAgICAgICAgICAgIGF3YWl0IG5vdGlmeUNsaWVudENhbmRpZGF0ZXModGhpcy5iYXNlVXJsLCB7XG4gICAgICAgICAgICAgICAgLi4uc2Vzc2lvblBhcmFtcyxcbiAgICAgICAgICAgICAgICBpY2VDYW5kaWRhdGVzOiBjbGllbnRDYW5kaWRhdGVzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wb2xsRm9yQ2FuZGlkYXRlcyhwZWVyLCBzZXNzaW9uUGFyYW1zKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHBlZXJDb25uZWN0aW9uTGl2ZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbG9nKGBbTU9CIFJUQyBCdWlsZGVyLiR7dGhpcy5zZXJ2ZXJJZH1dIFBlZXIgY29ubmVjdGlvbiBmYWlsZWQuLi5gKTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VsID0gcGVlci5nZXRTZWxlY3RlZENhbmRpZGF0ZVBhaXIoKTtcbiAgICAgICAgbG9nKGBTZWxlY3RlZCBwZWVyIGNhbmRpZGF0ZXMsIGxvY2FsOiAke0pTT04uc3RyaW5naWZ5KHNlbC5sb2NhbCl9LCByZW1vdGU6ICR7SlNPTi5zdHJpbmdpZnkoc2VsLnJlbW90ZSl9YCk7XG4gICAgICAgIGxvZyhgW01PQiBSVEMgQnVpbGRlci4ke3RoaXMuc2VydmVySWR9XSBQZWVyIGNvbm5lY3Rpb24gaXMgbGl2ZS4gYCwgYFRpbWUgdG8gZXN0YWJsaXNoOiAkeyhEYXRlLm5vdygpIC0gc3RhcnQpIC8gMTAwMH1zLmApO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgICAgICAgICBkYXRhQ2hhbm5lbHMsXG4gICAgICAgICAgICAgICAgbmV3IFByb21pc2UocmVzID0+IHNldFRpbWVvdXQocmVzLCB0aGlzLnRpbWVvdXQpKSxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIGxvZyhgW01PQiBSVEMgQnVpbGRlci4ke3RoaXMuc2VydmVySWR9XSBDcmVhdGluZyBNb2JpbGl0eSBDbG91ZCBjbGllbnQ6IFxuXHRcdFx0dmVyc2lvbj0ke0dldENsaWVudFZlcnNpb25JRCgpfSxcblx0XHRcdHNlc3Npb25JZD0ke3Nlc3Npb25QYXJhbXMuc2Vzc2lvbklkfVxuXHRcdFx0Y2xpZW50SWQ9JHtzZXNzaW9uUGFyYW1zLmNsaWVudElkfVxuXHRcdFx0dGltZW91dD0ke3RoaXMudGltZW91dH1tcywgXG5cdFx0XHRtYXhDaHVua1NpemU9JHtpY2VDb25maWcubWF4Q2h1bmtTaXplfWApO1xuICAgICAgICByZXR1cm4gbmV3IE1vYlJUQ0NsaWVudChzZXNzaW9uUGFyYW1zLnNlc3Npb25JZCwgcGVlciwgdGhpcy50aW1lb3V0LCBpY2VDb25maWcubWF4Q2h1bmtTaXplLCBHZXRDbGllbnRWZXJzaW9uSUQoKSk7XG4gICAgfVxuICAgIHBvbGxGb3JDYW5kaWRhdGVzKHBlZXIsIHNlc3Npb25QYXJhbXMsIHRpbWVvdXRNcyA9IDIwMDAwKSB7XG4gICAgICAgIGxvZyhgW01PQiBSVEMgQnVpbGRlci4ke3RoaXMuc2VydmVySWR9XWAsIGBzZXNzaW9uICcke3Nlc3Npb25QYXJhbXMuc2Vzc2lvbklkfScgc3RhcnRpbmcgcG9sbGluZyBmb3Igc2VydmVyIGNhbmRpZGF0ZXMuLi5gKTtcbiAgICAgICAgbmV3IFByb21pc2UoYXN5bmMgKHJlcykgPT4ge1xuICAgICAgICAgICAgbGV0IHRpbWUgPSAwO1xuICAgICAgICAgICAgbGV0IHNob3VsZEJyZWFrID0gZmFsc2U7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBzaG91bGRCcmVhayA9IHRydWU7XG4gICAgICAgICAgICB9LCB0aW1lb3V0TXMpO1xuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGljZUNhbmRpZGF0ZXMsIHVwZGF0ZWQgfSA9IGF3YWl0IGdldFNlcnZlckNhbmRpZGF0ZXModGhpcy5iYXNlVXJsLCB7XG4gICAgICAgICAgICAgICAgICAgIC4uLnNlc3Npb25QYXJhbXMsXG4gICAgICAgICAgICAgICAgICAgIHNpbmNlOiB0aW1lLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRpbWUgPSB1cGRhdGVkO1xuICAgICAgICAgICAgICAgIGljZUNhbmRpZGF0ZXMuZm9yRWFjaCgoYykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsb2coYFtNT0IgUlRDIEJ1aWxkZXIuJHt0aGlzLnNlcnZlcklkfV0gc2Vzc2lvbiAnJHtzZXNzaW9uUGFyYW1zLnNlc3Npb25JZH0nIGdvdCBjYW5kaWRhdGVgLCBjKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gSlNPTi5wYXJzZShjKTtcbiAgICAgICAgICAgICAgICAgICAgcGVlci5hZGRJY2VDYW5kaWRhdGUoY2FuZGlkYXRlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBhd2FpdCBkZWxheSg1MDApO1xuICAgICAgICAgICAgICAgIGlmIChzaG91bGRCcmVhaykge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXMoKTtcbiAgICAgICAgfSkudGhlbihfID0+IHtcbiAgICAgICAgICAgIGxvZyhgW01PQiBSVEMgQnVpbGRlci4ke3RoaXMuc2VydmVySWR9XWAsIGBzZXNzaW9uICcke3Nlc3Npb25QYXJhbXMuc2Vzc2lvbklkfScgc3RvcHBlZCB3YWl0aW5nIGZvciBtb3JlIHNlcnZlciBjYW5kaWRhdGVzYCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzZXREYXRhQ2hhbm5lbEhhbmRsZXIocGVlciwgbGFiZWwpIHtcbiAgICAgICAgY29uc3QgY2hhbm5lbCA9IHBlZXIuY3JlYXRlRGF0YUNoYW5uZWwobGFiZWwpO1xuICAgICAgICBjaGFubmVsLm9uQ2xvc2UoKGN0eCwgXykgPT4ge1xuICAgICAgICAgICAgbG9nKGBbTU9CIFJUQyBDbGllbnRdIFske2N0eC5sYWJlbH1dIGRhdGFjaGFubmVsIGNsb3NlZGApO1xuICAgICAgICB9KTtcbiAgICAgICAgY2hhbm5lbC5vbkVycm9yKChjdHgsIGV2KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXYuZXJyb3IubWVzc2FnZSA9PSAnVHJhbnNwb3J0IGNoYW5uZWwgY2xvc2VkJykge1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9nKGBbTU9CIFJUQyBDbGllbnRdIFske2N0eC5sYWJlbH1dIGRhdGFjaGFubmVsIGVycm9yYCwgZXYuZXJyb3IuZXJyb3JEZXRhaWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgICAgY2hhbm5lbC5vbk9wZW4oKGN0eCwgXykgPT4ge1xuICAgICAgICAgICAgICAgIGxvZyhgW01PQiBSVEMgQ2xpZW50XSBbJHtjdHgubGFiZWx9XSBkYXRhY2hhbm5lbCBvcGVuIGFuZCByZWFkeWApO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2V0RGF0YUNoYW5uZWxIYW5kbGVycyhwZWVyKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICB0aGlzLnNldERhdGFDaGFubmVsSGFuZGxlcihwZWVyLCBTRVJWRVJfSU5GT19MQUJFTCksXG4gICAgICAgICAgICB0aGlzLnNldERhdGFDaGFubmVsSGFuZGxlcihwZWVyLCBDQVBBQklMSVRJRVNfQ0hBTk5FTF9MQUJFTCksXG4gICAgICAgICAgICB0aGlzLnNldERhdGFDaGFubmVsSGFuZGxlcihwZWVyLCBUT0tFTl9DSEFOTkVMX0xBQkVMKSxcbiAgICAgICAgICAgIHRoaXMuc2V0RGF0YUNoYW5uZWxIYW5kbGVyKHBlZXIsIFBSSU5URVJfQ0hBTk5FTF9MQUJFTCksXG4gICAgICAgICAgICB0aGlzLnNldERhdGFDaGFubmVsSGFuZGxlcihwZWVyLCBKT0JfQ0hBTk5FTF9MQUJFTCksXG4gICAgICAgICAgICB0aGlzLnNldERhdGFDaGFubmVsSGFuZGxlcihwZWVyLCBKT0JfREVUQUlMU19MQUJFTCksXG4gICAgICAgIF0pO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGRlbGF5KG1zKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXMpID0+IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBjaHJvbWUucnVudGltZS5zZW5kTWVzc2FnZSh7IG1zZzogJ2tlZXAgYWN0aXZlJyB9KTtcbiAgICAgICAgcmVzKCk7XG4gICAgfSwgbXMpKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHBvbGxHZXRBbnN3ZXIoYmFzZVVybCwgcmVxLCBwb2xsT3B0aW9ucykge1xuICAgIGxldCBzaG91bGRCcmVhayA9IGZhbHNlO1xuICAgIGNvbnN0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgc2hvdWxkQnJlYWsgPSB0cnVlO1xuICAgIH0sIHBvbGxPcHRpb25zLnRpbWVvdXQpO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGlmIChzaG91bGRCcmVhaykge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBnZXRBbnN3ZXIoYmFzZVVybCwgcmVxKTtcbiAgICAgICAgaWYgKHJlc3BvbnNlICE9PSAncGVuZGluZycpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBkZWxheShwb2xsT3B0aW9ucy5pbnRlcnZhbCk7XG4gICAgfVxuICAgIHJldHVybiAndGltZW91dCc7XG59XG4iLCJleHBvcnQgKiBmcm9tICcuL2NsaWVudGJ1aWxkZXInO1xuZXhwb3J0ICogZnJvbSAnLi9jbGllbnQnO1xuZXhwb3J0ICogZnJvbSAnLi9saW5rJztcbiIsImNvbnN0IGRlZmF1bHRDb2xvck9wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICB0eXBlOiAnU1RBTkRBUkRfQ09MT1InLFxuICAgICAgICBpc19kZWZhdWx0OiB0cnVlLFxuICAgIH0sXG4gICAge1xuICAgICAgICB0eXBlOiAnU1RBTkRBUkRfTU9OT0NIUk9NRScsXG4gICAgfSxcbl07XG5jb25zdCBkZWZhdWx0RHVwbGV4T3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIHR5cGU6ICdOT19EVVBMRVgnLFxuICAgICAgICBpc19kZWZhdWx0OiB0cnVlLFxuICAgIH0sXG4gICAge1xuICAgICAgICB0eXBlOiAnTE9OR19FREdFJyxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgdHlwZTogJ1NIT1JUX0VER0UnLFxuICAgIH0sXG5dO1xuY29uc3QgZGVmYXVsdFBhcGVyU2l6ZSA9ICdBNCc7XG5jb25zdCBkZWZhdWx0TWVkaWFTaXplcyA9IFtcbiAgICB7XG4gICAgICAgIG5hbWU6ICdJU09fQTAnLFxuICAgICAgICB3aWR0aF9taWNyb25zOiA4NDEwMDAsXG4gICAgICAgIGhlaWdodF9taWNyb25zOiAxMTg5MDAwLFxuICAgICAgICBpc19kZWZhdWx0OiBmYWxzZSxcbiAgICAgICAgY3VzdG9tX2Rpc3BsYXlfbmFtZTogJ0EwJyxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ0lTT19BMScsXG4gICAgICAgIHdpZHRoX21pY3JvbnM6IDU5NDAwMCxcbiAgICAgICAgaGVpZ2h0X21pY3JvbnM6IDg0MTAwMCxcbiAgICAgICAgaXNfZGVmYXVsdDogZmFsc2UsXG4gICAgICAgIGN1c3RvbV9kaXNwbGF5X25hbWU6ICdBMScsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICdJU09fQTInLFxuICAgICAgICB3aWR0aF9taWNyb25zOiA0MjAwMDAsXG4gICAgICAgIGhlaWdodF9taWNyb25zOiA1OTQwMDAsXG4gICAgICAgIGlzX2RlZmF1bHQ6IGZhbHNlLFxuICAgICAgICBjdXN0b21fZGlzcGxheV9uYW1lOiAnQTInLFxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAnSVNPX0EzJyxcbiAgICAgICAgd2lkdGhfbWljcm9uczogMjk3MDAwLFxuICAgICAgICBoZWlnaHRfbWljcm9uczogNDIwMDAwLFxuICAgICAgICBpc19kZWZhdWx0OiBmYWxzZSxcbiAgICAgICAgY3VzdG9tX2Rpc3BsYXlfbmFtZTogJ0EzJyxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ0lTT19BNCcsXG4gICAgICAgIHdpZHRoX21pY3JvbnM6IDIxMDAwMCxcbiAgICAgICAgaGVpZ2h0X21pY3JvbnM6IDI5NzAwMCxcbiAgICAgICAgaXNfZGVmYXVsdDogJ0E0JyA9PT0gZGVmYXVsdFBhcGVyU2l6ZS50b1VwcGVyQ2FzZSgpLFxuICAgICAgICBjdXN0b21fZGlzcGxheV9uYW1lOiAnQTQnLFxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAnSVNPX0E1JyxcbiAgICAgICAgd2lkdGhfbWljcm9uczogMTQ4MDAwLFxuICAgICAgICBoZWlnaHRfbWljcm9uczogMjEwMDAwLFxuICAgICAgICBpc19kZWZhdWx0OiBmYWxzZSxcbiAgICAgICAgY3VzdG9tX2Rpc3BsYXlfbmFtZTogJ0E1JyxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ0lTT19BNicsXG4gICAgICAgIHdpZHRoX21pY3JvbnM6IDEwNTAwMCxcbiAgICAgICAgaGVpZ2h0X21pY3JvbnM6IDE0ODAwMCxcbiAgICAgICAgaXNfZGVmYXVsdDogZmFsc2UsXG4gICAgICAgIGN1c3RvbV9kaXNwbGF5X25hbWU6ICdBNicsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICdJU09fQTcnLFxuICAgICAgICB3aWR0aF9taWNyb25zOiA3NDAwMCxcbiAgICAgICAgaGVpZ2h0X21pY3JvbnM6IDEwNTAwMCxcbiAgICAgICAgaXNfZGVmYXVsdDogZmFsc2UsXG4gICAgICAgIGN1c3RvbV9kaXNwbGF5X25hbWU6ICdBNycsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICdJU09fQTgnLFxuICAgICAgICB3aWR0aF9taWNyb25zOiA1MjAwMCxcbiAgICAgICAgaGVpZ2h0X21pY3JvbnM6IDc0MDAwLFxuICAgICAgICBpc19kZWZhdWx0OiBmYWxzZSxcbiAgICAgICAgY3VzdG9tX2Rpc3BsYXlfbmFtZTogJ0E4JyxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ0lTT19BOScsXG4gICAgICAgIHdpZHRoX21pY3JvbnM6IDM3MDAwLFxuICAgICAgICBoZWlnaHRfbWljcm9uczogNTIwMDAsXG4gICAgICAgIGlzX2RlZmF1bHQ6IGZhbHNlLFxuICAgICAgICBjdXN0b21fZGlzcGxheV9uYW1lOiAnQTknLFxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAnSVNPX0ExMCcsXG4gICAgICAgIHdpZHRoX21pY3JvbnM6IDI2MDAwLFxuICAgICAgICBoZWlnaHRfbWljcm9uczogMzcwMDAsXG4gICAgICAgIGlzX2RlZmF1bHQ6IGZhbHNlLFxuICAgICAgICBjdXN0b21fZGlzcGxheV9uYW1lOiAnQTEwJyxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ0pJU19CMCcsXG4gICAgICAgIHdpZHRoX21pY3JvbnM6IDEwMzAwMDAsXG4gICAgICAgIGhlaWdodF9taWNyb25zOiAxNDU2MDAwLFxuICAgICAgICBpc19kZWZhdWx0OiBmYWxzZSxcbiAgICAgICAgY3VzdG9tX2Rpc3BsYXlfbmFtZTogJ0pJUyBCMCcsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICdKSVNfQjEnLFxuICAgICAgICB3aWR0aF9taWNyb25zOiA3MjgwMDAsXG4gICAgICAgIGhlaWdodF9taWNyb25zOiAxMDMwMDAwLFxuICAgICAgICBpc19kZWZhdWx0OiBmYWxzZSxcbiAgICAgICAgY3VzdG9tX2Rpc3BsYXlfbmFtZTogJ0pJUyBCMScsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICdKSVNfQjInLFxuICAgICAgICB3aWR0aF9taWNyb25zOiA1MTUwMDAsXG4gICAgICAgIGhlaWdodF9taWNyb25zOiA3MjgwMDAsXG4gICAgICAgIGlzX2RlZmF1bHQ6IGZhbHNlLFxuICAgICAgICBjdXN0b21fZGlzcGxheV9uYW1lOiAnSklTIEIyJyxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ0pJU19CMycsXG4gICAgICAgIHdpZHRoX21pY3JvbnM6IDM2NDAwMCxcbiAgICAgICAgaGVpZ2h0X21pY3JvbnM6IDUxNTAwMCxcbiAgICAgICAgaXNfZGVmYXVsdDogZmFsc2UsXG4gICAgICAgIGN1c3RvbV9kaXNwbGF5X25hbWU6ICdKSVMgQjMnLFxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAnSklTX0I0JyxcbiAgICAgICAgd2lkdGhfbWljcm9uczogMjU3MDAwLFxuICAgICAgICBoZWlnaHRfbWljcm9uczogMzY0MDAwLFxuICAgICAgICBpc19kZWZhdWx0OiBmYWxzZSxcbiAgICAgICAgY3VzdG9tX2Rpc3BsYXlfbmFtZTogJ0pJUyBCNCcsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICdKSVNfQjUnLFxuICAgICAgICB3aWR0aF9taWNyb25zOiAxODIwMDAsXG4gICAgICAgIGhlaWdodF9taWNyb25zOiAyNTcwMDAsXG4gICAgICAgIGlzX2RlZmF1bHQ6IGZhbHNlLFxuICAgICAgICBjdXN0b21fZGlzcGxheV9uYW1lOiAnSklTIEI1JyxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ0pJU19CNicsXG4gICAgICAgIHdpZHRoX21pY3JvbnM6IDEyODAwMCxcbiAgICAgICAgaGVpZ2h0X21pY3JvbnM6IDE4MjAwMCxcbiAgICAgICAgaXNfZGVmYXVsdDogZmFsc2UsXG4gICAgICAgIGN1c3RvbV9kaXNwbGF5X25hbWU6ICdKSVMgQjYnLFxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAnSklTX0I3JyxcbiAgICAgICAgd2lkdGhfbWljcm9uczogOTEwMDAsXG4gICAgICAgIGhlaWdodF9taWNyb25zOiAxMjgwMDAsXG4gICAgICAgIGlzX2RlZmF1bHQ6IGZhbHNlLFxuICAgICAgICBjdXN0b21fZGlzcGxheV9uYW1lOiAnSklTIEI3JyxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ0pJU19COCcsXG4gICAgICAgIHdpZHRoX21pY3JvbnM6IDY0MDAwLFxuICAgICAgICBoZWlnaHRfbWljcm9uczogOTEwMDAsXG4gICAgICAgIGlzX2RlZmF1bHQ6IGZhbHNlLFxuICAgICAgICBjdXN0b21fZGlzcGxheV9uYW1lOiAnSklTIEI4JyxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ0pJU19COScsXG4gICAgICAgIHdpZHRoX21pY3JvbnM6IDQ1MDAwLFxuICAgICAgICBoZWlnaHRfbWljcm9uczogNjQwMDAsXG4gICAgICAgIGlzX2RlZmF1bHQ6IGZhbHNlLFxuICAgICAgICBjdXN0b21fZGlzcGxheV9uYW1lOiAnSklTIEI5JyxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ0pJU19CMTAnLFxuICAgICAgICB3aWR0aF9taWNyb25zOiAzMjAwMCxcbiAgICAgICAgaGVpZ2h0X21pY3JvbnM6IDQ1MDAwLFxuICAgICAgICBpc19kZWZhdWx0OiBmYWxzZSxcbiAgICAgICAgY3VzdG9tX2Rpc3BsYXlfbmFtZTogJ0pJUyBCMTAnLFxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAnSVNPX0IwJyxcbiAgICAgICAgd2lkdGhfbWljcm9uczogMTAwMDAwMCxcbiAgICAgICAgaGVpZ2h0X21pY3JvbnM6IDE0MTQwMDAsXG4gICAgICAgIGlzX2RlZmF1bHQ6IGZhbHNlLFxuICAgICAgICBjdXN0b21fZGlzcGxheV9uYW1lOiAnSVNPIEIwJyxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ0lTT19CMScsXG4gICAgICAgIHdpZHRoX21pY3JvbnM6IDcwNzAwMCxcbiAgICAgICAgaGVpZ2h0X21pY3JvbnM6IDEwMDAwMDAsXG4gICAgICAgIGlzX2RlZmF1bHQ6IGZhbHNlLFxuICAgICAgICBjdXN0b21fZGlzcGxheV9uYW1lOiAnSVNPIEIxJyxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ0lTT19CMicsXG4gICAgICAgIHdpZHRoX21pY3JvbnM6IDUwMDAwMCxcbiAgICAgICAgaGVpZ2h0X21pY3JvbnM6IDcwNzAwMCxcbiAgICAgICAgaXNfZGVmYXVsdDogZmFsc2UsXG4gICAgICAgIGN1c3RvbV9kaXNwbGF5X25hbWU6ICdJU08gQjInLFxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAnSVNPX0IzJyxcbiAgICAgICAgd2lkdGhfbWljcm9uczogMzUzMDAwLFxuICAgICAgICBoZWlnaHRfbWljcm9uczogNTAwMDAwLFxuICAgICAgICBpc19kZWZhdWx0OiBmYWxzZSxcbiAgICAgICAgY3VzdG9tX2Rpc3BsYXlfbmFtZTogJ0lTTyBCMycsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICdJU09fQjQnLFxuICAgICAgICB3aWR0aF9taWNyb25zOiAyNTAwMDAsXG4gICAgICAgIGhlaWdodF9taWNyb25zOiAzNTMwMDAsXG4gICAgICAgIGlzX2RlZmF1bHQ6IGZhbHNlLFxuICAgICAgICBjdXN0b21fZGlzcGxheV9uYW1lOiAnSVNPIEI0JyxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ0lTT19CNScsXG4gICAgICAgIHdpZHRoX21pY3JvbnM6IDE3NjAwMCxcbiAgICAgICAgaGVpZ2h0X21pY3JvbnM6IDI1MDAwMCxcbiAgICAgICAgaXNfZGVmYXVsdDogZmFsc2UsXG4gICAgICAgIGN1c3RvbV9kaXNwbGF5X25hbWU6ICdJU08gQjUnLFxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAnSVNPX0I2JyxcbiAgICAgICAgd2lkdGhfbWljcm9uczogMTI1MDAwLFxuICAgICAgICBoZWlnaHRfbWljcm9uczogMTc2MDAwLFxuICAgICAgICBpc19kZWZhdWx0OiBmYWxzZSxcbiAgICAgICAgY3VzdG9tX2Rpc3BsYXlfbmFtZTogJ0lTTyBCNicsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICdJU09fQjcnLFxuICAgICAgICB3aWR0aF9taWNyb25zOiA4ODAwMCxcbiAgICAgICAgaGVpZ2h0X21pY3JvbnM6IDEyNTAwMCxcbiAgICAgICAgaXNfZGVmYXVsdDogZmFsc2UsXG4gICAgICAgIGN1c3RvbV9kaXNwbGF5X25hbWU6ICdJU08gQjcnLFxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAnSVNPX0I4JyxcbiAgICAgICAgd2lkdGhfbWljcm9uczogNjIwMDAsXG4gICAgICAgIGhlaWdodF9taWNyb25zOiA4ODAwMCxcbiAgICAgICAgaXNfZGVmYXVsdDogZmFsc2UsXG4gICAgICAgIGN1c3RvbV9kaXNwbGF5X25hbWU6ICdJU08gQjgnLFxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAnSVNPX0I5JyxcbiAgICAgICAgd2lkdGhfbWljcm9uczogNDQwMDAsXG4gICAgICAgIGhlaWdodF9taWNyb25zOiA2MjAwMCxcbiAgICAgICAgaXNfZGVmYXVsdDogZmFsc2UsXG4gICAgICAgIGN1c3RvbV9kaXNwbGF5X25hbWU6ICdJU08gQjknLFxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAnSVNPX0IxMCcsXG4gICAgICAgIHdpZHRoX21pY3JvbnM6IDMxMDAwLFxuICAgICAgICBoZWlnaHRfbWljcm9uczogNDQwMDAsXG4gICAgICAgIGlzX2RlZmF1bHQ6IGZhbHNlLFxuICAgICAgICBjdXN0b21fZGlzcGxheV9uYW1lOiAnSVNPIEIxMCcsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICdOQV9MRVRURVInLFxuICAgICAgICB3aWR0aF9taWNyb25zOiAyMTU5MDAsXG4gICAgICAgIGhlaWdodF9taWNyb25zOiAyNzk0MDAsXG4gICAgICAgIGlzX2RlZmF1bHQ6IGZhbHNlLFxuICAgICAgICBjdXN0b21fZGlzcGxheV9uYW1lOiAnTGV0dGVyJyxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ05BX0xFR0FMJyxcbiAgICAgICAgd2lkdGhfbWljcm9uczogMjE1OTAwLFxuICAgICAgICBoZWlnaHRfbWljcm9uczogMzU1NjAwLFxuICAgICAgICBpc19kZWZhdWx0OiBmYWxzZSxcbiAgICAgICAgY3VzdG9tX2Rpc3BsYXlfbmFtZTogJ0xlZ2FsJyxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ05BXzVYNycsXG4gICAgICAgIHdpZHRoX21pY3JvbnM6IDEyNzAwMCxcbiAgICAgICAgaGVpZ2h0X21pY3JvbnM6IDE3NzgwMCxcbiAgICAgICAgaXNfZGVmYXVsdDogZmFsc2UsXG4gICAgICAgIGN1c3RvbV9kaXNwbGF5X25hbWU6ICc1WDcnLFxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAnTkFfRVhFQ1VUSVZFJyxcbiAgICAgICAgd2lkdGhfbWljcm9uczogMTg0MTUwLFxuICAgICAgICBoZWlnaHRfbWljcm9uczogMjY2NzAwLFxuICAgICAgICBpc19kZWZhdWx0OiBmYWxzZSxcbiAgICAgICAgY3VzdG9tX2Rpc3BsYXlfbmFtZTogJ0V4ZWN1dGl2ZScsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICdOQV9JTlZPSUNFJyxcbiAgICAgICAgd2lkdGhfbWljcm9uczogMTM5NzAwLFxuICAgICAgICBoZWlnaHRfbWljcm9uczogMjE1OTAwLFxuICAgICAgICBpc19kZWZhdWx0OiBmYWxzZSxcbiAgICAgICAgY3VzdG9tX2Rpc3BsYXlfbmFtZTogJ0ludm9pY2UnLFxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAnTkFfTEVER0VSJyxcbiAgICAgICAgd2lkdGhfbWljcm9uczogMjc5NDAwLFxuICAgICAgICBoZWlnaHRfbWljcm9uczogNDMxODAwLFxuICAgICAgICBpc19kZWZhdWx0OiBmYWxzZSxcbiAgICAgICAgY3VzdG9tX2Rpc3BsYXlfbmFtZTogJ0xlZGdlcicsXG4gICAgfSxcbl07XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUHJpbnRlckNhcGFiaWxpdGllcyhjb2xvck9wdGlvbnMgPSBkZWZhdWx0Q29sb3JPcHRpb25zLCBkdXBsZXhPcHRpb25zID0gZGVmYXVsdER1cGxleE9wdGlvbnMsIG1lZGlhU2l6ZXMgPSBkZWZhdWx0TWVkaWFTaXplcykge1xuICAgIHJldHVybiB7XG4gICAgICAgIHZlcnNpb246ICcxLjAnLFxuICAgICAgICBwcmludGVyOiB7XG4gICAgICAgICAgICBzdXBwb3J0ZWRfY29udGVudF90eXBlOiBbeyBjb250ZW50X3R5cGU6ICdhcHBsaWNhdGlvbi9wZGYnIH1dLFxuICAgICAgICAgICAgY29sb3I6IHtcbiAgICAgICAgICAgICAgICBvcHRpb246IGNvbG9yT3B0aW9ucyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkdXBsZXg6IHtcbiAgICAgICAgICAgICAgICBvcHRpb246IGR1cGxleE9wdGlvbnMsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGFnZV9vcmllbnRhdGlvbjoge1xuICAgICAgICAgICAgICAgIG9wdGlvbjogW1xuICAgICAgICAgICAgICAgICAgICB7IHR5cGU6ICdQT1JUUkFJVCcsIGlzX2RlZmF1bHQ6IHRydWUgfSxcbiAgICAgICAgICAgICAgICAgICAgeyB0eXBlOiAnTEFORFNDQVBFJywgaXNfZGVmYXVsdDogZmFsc2UgfSxcbiAgICAgICAgICAgICAgICAgICAgeyB0eXBlOiAnQVVUTycsIGlzX2RlZmF1bHQ6IGZhbHNlIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb3BpZXM6IHsgZGVmYXVsdDogMSwgbWF4OiAxMDAgfSxcbiAgICAgICAgICAgIG1lZGlhX3NpemU6IHsgb3B0aW9uOiBtZWRpYVNpemVzIH0sXG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZU1vYmlsaXR5UHJpbnRDYXBhYmlsaXRpZXMoY2FwYWJpbGl0aWVzKSB7XG4gICAgY29uc3QgbWVkaWFTaXplcyA9IGNhcGFiaWxpdGllcy5tZWRpYVNpemVzLm1hcCgobSkgPT4gKHtcbiAgICAgICAgbmFtZTogJ0NVU1RPTScsXG4gICAgICAgIHdpZHRoX21pY3JvbnM6IG0ud2lkdGhNaWNyb25zLFxuICAgICAgICBoZWlnaHRfbWljcm9uczogbS5oZWlnaHRNaWNyb25zLFxuICAgICAgICBpc19kZWZhdWx0OiBtLmlzRGVmYXVsdCxcbiAgICAgICAgY3VzdG9tX2Rpc3BsYXlfbmFtZTogbS5jdXN0b21EaXNwbGF5TmFtZSB8fCBtLm5hbWUsXG4gICAgfSkpO1xuICAgIGlmIChtZWRpYVNpemVzLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgbWVkaWFTaXplcy5ldmVyeShmdW5jdGlvbiAobSkge1xuICAgICAgICAgICAgcmV0dXJuICFtLmlzX2RlZmF1bHQ7XG4gICAgICAgIH0pKSB7XG4gICAgICAgIG1lZGlhU2l6ZXNbMF0uaXNfZGVmYXVsdCA9IHRydWU7XG4gICAgfVxuICAgIGNvbnN0IGNvbG9yT3B0aW9ucyA9IGNhcGFiaWxpdGllcy5jb2xvci5tYXAoZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogbiB9O1xuICAgIH0pO1xuICAgIGlmIChjb2xvck9wdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb2xvck9wdGlvbnNbMF1bJ2lzX2RlZmF1bHQnXSA9IHRydWU7XG4gICAgfVxuICAgIGNvbnN0IGR1cGxleE9wdGlvbnMgPSBjYXBhYmlsaXRpZXMuZHVwbGV4Lm1hcChmdW5jdGlvbiAobikge1xuICAgICAgICByZXR1cm4geyB0eXBlOiBuIH07XG4gICAgfSk7XG4gICAgaWYgKGR1cGxleE9wdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICBkdXBsZXhPcHRpb25zWzBdWydpc19kZWZhdWx0J10gPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlUHJpbnRlckNhcGFiaWxpdGllcyhjb2xvck9wdGlvbnMsIGR1cGxleE9wdGlvbnMsIG1lZGlhU2l6ZXMpO1xufVxuIiwiZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldE1hbmFnZWRTdG9yYWdlRGF0YShrZXkpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjaHJvbWUuc3RvcmFnZS5tYW5hZ2VkLmdldChrZXksIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICBpZiAoZGF0YSAmJiBkYXRhW2tleV0pIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKGRhdGFba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaHJvbWUucnVudGltZS5sYXN0RXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoY2hyb21lLnJ1bnRpbWUubGFzdEVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc29sdmUodW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0TG9jYWxTdG9yYWdlRGF0YShrZXkpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjaHJvbWUuc3RvcmFnZS5sb2NhbC5nZXQoa2V5LCAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICBpZiAocmVzdWx0ICYmIHJlc3VsdFtrZXldKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHRba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaHJvbWUucnVudGltZS5sYXN0RXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoY2hyb21lLnJ1bnRpbWUubGFzdEVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc29sdmUodW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVtb3ZlTG9jYWxTdG9yYWdlRGF0YShrZXlzKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY2hyb21lLnN0b3JhZ2UubG9jYWwucmVtb3ZlKGtleXMsICgpID0+IHtcbiAgICAgICAgICAgIGlmIChjaHJvbWUucnVudGltZS5sYXN0RXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoY2hyb21lLnJ1bnRpbWUubGFzdEVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2V0TG9jYWxTdG9yYWdlRGF0YShrZXksIGRhdGEpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjaHJvbWUuc3RvcmFnZS5sb2NhbC5zZXQoeyBba2V5XTogZGF0YSB9LCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoY2hyb21lLnJ1bnRpbWUubGFzdEVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGNocm9tZS5ydW50aW1lLmxhc3RFcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNhdmVNYXAoa2V5LCBtYXApIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjaHJvbWUuc3RvcmFnZS5sb2NhbC5zZXQoe1xuICAgICAgICAgICAgW2tleV06IEFycmF5LmZyb20obWFwLmVudHJpZXMoKSksXG4gICAgICAgIH0sICgpID0+IHtcbiAgICAgICAgICAgIGlmIChjaHJvbWUucnVudGltZS5sYXN0RXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoY2hyb21lLnJ1bnRpbWUubGFzdEVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBsb2FkTWFwKGtleSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNocm9tZS5zdG9yYWdlLmxvY2FsLmdldChrZXksIChkKSA9PiB7XG4gICAgICAgICAgICBpZiAoZCAmJiBkW2tleV0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBbaywgdl0gb2YgZFtrZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hcC5zZXQoaywgdik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc29sdmUobWFwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNocm9tZS5ydW50aW1lLmxhc3RFcnJvcikge1xuICAgICAgICAgICAgICAgIHJlamVjdChjaHJvbWUucnVudGltZS5sYXN0RXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuIiwiYXN5bmMgZnVuY3Rpb24gc2xlZXAobWlsbGlzKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHIgPT4gc2V0VGltZW91dChyLCBtaWxsaXMpKTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB3YWl0Rm9yQ29uZGl0aW9uKGNvbmRUZXN0RnVuYywgc2xlZXBNaWxsaXMgPSAxMDAwLCBzbGVlcE1heE1pbGxpcyA9IDYwMDAwKSB7XG4gICAgY29uc3Qgc3RhcnRlZCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIHdoaWxlICghY29uZFRlc3RGdW5jKCkpIHtcbiAgICAgICAgaWYgKHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnRlZCA+IHNsZWVwTWF4TWlsbGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgc2xlZXAoc2xlZXBNaWxsaXMpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB3b3JrZXJXYWl0VW50aWwocHJvbWlzZSkge1xuICAgIGNvbnN0IGtlZXBBbGl2ZSA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ0tlZXAtYWxpdmUnKTtcbiAgICAgICAgY2hyb21lLnJ1bnRpbWUuZ2V0UGxhdGZvcm1JbmZvKCk7XG4gICAgfSwgMjUgKiAxMDAwKTtcbiAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdXYWl0aW5nIHdpdGgga2VlcC1hbGl2ZS4uLicpO1xuICAgICAgICByZXR1cm4gYXdhaXQgcHJvbWlzZTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1dhaXQgY29tcGxldGVkIHdpdGggZXJyb3I6JywgZSk7XG4gICAgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICBjb25zb2xlLmxvZyhgRmluaXNoZWQgd2FpdGluZyB3aXRoIGtlZXAtYWxpdmUsIGVsYXBzZWQ6ICR7KERhdGUubm93KCkgLSBzdGFydFRpbWUpIC8gMTAwMH1zZWNvbmRzYCk7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwoa2VlcEFsaXZlKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBlcnJvciwgbG9nLCB3YXJuIH0gZnJvbSAnLi4vbG9nJztcbmltcG9ydCB7IHBhcnNlTW9iaWxpdHlQcmludENhcGFiaWxpdGllcyB9IGZyb20gJy4uL3ByaW50ZXIvY2FwYWJpbGl0aWVzJztcbmltcG9ydCB7IGdldExvY2FsU3RvcmFnZURhdGEsIGxvYWRNYXAsIHNhdmVNYXAgfSBmcm9tICcuLi9zdG9yYWdlJztcbmltcG9ydCB7IHdhaXRGb3JDb25kaXRpb24gfSBmcm9tICcuLi93YWl0JztcbmV4cG9ydCBjb25zdCBwcmludGVyQ2FwYWJpbGl0aWVzQ2FjaGUgPSBuZXcgTWFwKCk7XG5jb25zdCBzZXJ2ZXJJZFRvQ2xpZW50Q2FjaGUgPSBuZXcgTWFwKCk7XG5jb25zdCBzdG9yYWdlS2V5U2VydmVySWRUb0luZm9DYWNoZSA9ICdzZXJ2ZXJJZFRvSW5mb0NhY2hlJztcbmNvbnN0IHNlcnZlcklkVG9JbmZvQ2FjaGUgPSBuZXcgTWFwKCk7XG5jb25zdCBzdG9yYWdlS2V5UHJpbnRlclRpbWVVc2VkTWFwID0gJ3ByaW50ZXJUaW1lVXNlZE1hcCc7XG5jb25zdCBzdG9yYWdlS2V5UHJpbnRlckNhcGFiaWxpdGllc01hcCA9ICdwcmludGVyQ2FwYWJpbGl0aWVzTWFwJztcbmNvbnN0IHN0b3JhZ2VLZXlQcmludGVyU2VydmVyTWFwID0gJ3ByaW50ZXJTZXJ2ZXJNYXAnO1xuY29uc3Qgc3RvcmFnZUtleVByaW50VG9rZW5DYWNoZSA9ICdwcmludFRva2VuQ2FjaGUnO1xuY29uc3QgcHJpbnRlclRpbWVVc2VkTWFwID0gbmV3IE1hcCgpO1xuY29uc3QgcHJpbnRlck5hbWVUb1NlcnZlcklkQ2FjaGUgPSBuZXcgTWFwKCk7XG5jb25zdCBwcmludFRva2VuQ2FjaGUgPSBuZXcgTWFwKCk7XG5jb25zdCBzdG9yYWdlS2V5UmVjbGFpbVN0b3JhZ2VMaW1pdEtiID0gJ3JlY2xhaW1TdG9yYWdlTGltaXRLYic7XG5jb25zdCBzdG9yYWdlS2V5UHJpbnRlZE9sZGVyVGhhbkRheXMgPSAncHJpbnRlZE9sZGVyVGhhbkRheXMnO1xubGV0IHJlY2xhaW1TdG9yYWdlTGltaXRLYjtcbmxldCBwcmludGVkT2xkZXJUaGFuRGF5cztcbmxldCBjYWNoZUxvYWRlZCA9IGZhbHNlO1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGluaXRDYWNoZSgpIHtcbiAgICBjb25zdCBbc3RvcmFnZUxpbWl0LCBwcmludGVkQWdlXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgZ2V0TG9jYWxTdG9yYWdlRGF0YShzdG9yYWdlS2V5UmVjbGFpbVN0b3JhZ2VMaW1pdEtiKS50aGVuKHYgPT4gdiA/ICt2IDogNDA5NiksXG4gICAgICAgIGdldExvY2FsU3RvcmFnZURhdGEoc3RvcmFnZUtleVByaW50ZWRPbGRlclRoYW5EYXlzKS50aGVuKHYgPT4gdiA/ICt2IDogMzApLFxuICAgIF0pO1xuICAgIHJlY2xhaW1TdG9yYWdlTGltaXRLYiA9IHN0b3JhZ2VMaW1pdDtcbiAgICBwcmludGVkT2xkZXJUaGFuRGF5cyA9IHByaW50ZWRBZ2U7XG4gICAgbG9nKGBMb2NhbCBzdG9yYWdlIGNsZWFudXAgc2V0dGluZ3M6IHJlY2xhaW1TdG9yYWdlTGltaXRLYj0ke3JlY2xhaW1TdG9yYWdlTGltaXRLYn0gS2lCLCBgICtcbiAgICAgICAgYHByaW50ZWRPbGRlclRoYW5EYXlzPSR7cHJpbnRlZE9sZGVyVGhhbkRheXN9IGRheXNgKTtcbiAgICBwb3B1bGF0ZUNhY2hlKHJlY2xhaW1TdG9yYWdlTGltaXRLYiwgcHJpbnRlZE9sZGVyVGhhbkRheXMpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFNlcnZlcklkVG9DbGllbnRDYWNoZSgpIHtcbiAgICByZXR1cm4gc2VydmVySWRUb0NsaWVudENhY2hlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFNlcnZlcklkVG9TZXJ2ZXJJbmZvQ2FjaGUoKSB7XG4gICAgcmV0dXJuIHNlcnZlcklkVG9JbmZvQ2FjaGU7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0UHJpbnRlck5hbWVUb1NlcnZlcklkQ2FjaGUoKSB7XG4gICAgcmV0dXJuIHByaW50ZXJOYW1lVG9TZXJ2ZXJJZENhY2hlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFByaW50VG9rZW5DYWNoZSgpIHtcbiAgICByZXR1cm4gcHJpbnRUb2tlbkNhY2hlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZVByaW50VG9rZW4ocHJpbnRUb2tlbkNhY2hlSUQsIHByaW50VG9rZW4pIHtcbiAgICBpZiAoIXByaW50VG9rZW4pIHtcbiAgICAgICAgd2FybigndXBkYXRlUHJpbnRUb2tlbjogUHJpbnQgdG9rZW4gaXMgbm90IHByb3ZpZGVkJyk7XG4gICAgfVxuICAgIGxvZyhgIHVwZGF0ZVByaW50VG9rZW46IFNhdmluZyBwcmludCB0b2tlbiBmb3I6ICR7cHJpbnRUb2tlbkNhY2hlSUR9YCk7XG4gICAgZ2V0UHJpbnRUb2tlbkNhY2hlKCkuc2V0KHByaW50VG9rZW5DYWNoZUlELCBwcmludFRva2VuKTtcbiAgICBzYXZlTWFwVG9TdG9yYWdlKHN0b3JhZ2VLZXlQcmludFRva2VuQ2FjaGUsIHByaW50VG9rZW5DYWNoZSlcbiAgICAgICAgLnRoZW4oKCkgPT4gbG9nKGAgdXBkYXRlUHJpbnRUb2tlbjogVXBkYXRlZCBwcmludCB0b2tlbiBmb3I6ICR7cHJpbnRUb2tlbkNhY2hlSUR9YCkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZVNlcnZlckluZm8oc2VydmVySWQsIHNlcnZlckluZm8pIHtcbiAgICBjb25zdCBpZFRvU2VydmVySW5mb0NhY2hlID0gZ2V0U2VydmVySWRUb1NlcnZlckluZm9DYWNoZSgpO1xuICAgIGlkVG9TZXJ2ZXJJbmZvQ2FjaGUuc2V0KHNlcnZlcklkLCBzZXJ2ZXJJbmZvKTtcbiAgICBzYXZlTWFwVG9TdG9yYWdlKHN0b3JhZ2VLZXlTZXJ2ZXJJZFRvSW5mb0NhY2hlLCBpZFRvU2VydmVySW5mb0NhY2hlKVxuICAgICAgICAudGhlbigoKSA9PiBsb2coYFVwZGF0ZWQgaW5mbyBmb3Igc2VydmVyICcke3NlcnZlcklkfTogJHtKU09OLnN0cmluZ2lmeShzZXJ2ZXJJbmZvKX0uLi5gKSk7XG59XG5mdW5jdGlvbiBwb3B1bGF0ZUNhY2hlKHJlY2xhaW1TdG9yYWdlTGltaXRLYiwgcHJpbnRlZE9sZGVyVGhhbkRheXMpIHtcbiAgICBQcm9taXNlLmFsbChbXG4gICAgICAgIGxvYWRNYXBGcm9tU3RvcmFnZShzdG9yYWdlS2V5UHJpbnRlclRpbWVVc2VkTWFwLCBwcmludGVyVGltZVVzZWRNYXApLFxuICAgICAgICBsb2FkTWFwRnJvbVN0b3JhZ2Uoc3RvcmFnZUtleVByaW50ZXJDYXBhYmlsaXRpZXNNYXAsIHByaW50ZXJDYXBhYmlsaXRpZXNDYWNoZSksXG4gICAgICAgIGxvYWRNYXBGcm9tU3RvcmFnZShzdG9yYWdlS2V5UHJpbnRlclNlcnZlck1hcCwgcHJpbnRlck5hbWVUb1NlcnZlcklkQ2FjaGUpLFxuICAgICAgICBsb2FkTWFwRnJvbVN0b3JhZ2Uoc3RvcmFnZUtleVByaW50VG9rZW5DYWNoZSwgcHJpbnRUb2tlbkNhY2hlKSxcbiAgICAgICAgbG9hZE1hcEZyb21TdG9yYWdlKHN0b3JhZ2VLZXlTZXJ2ZXJJZFRvSW5mb0NhY2hlLCBzZXJ2ZXJJZFRvSW5mb0NhY2hlKSxcbiAgICBdKS50aGVuKCgpID0+IHtcbiAgICAgICAgY2hyb21lLnN0b3JhZ2UubG9jYWwuZ2V0Qnl0ZXNJblVzZShieXRlc0luVXNlID0+IHtcbiAgICAgICAgICAgIGxvZyhgW09mZk5ldHdvcmtDYWNoZTpwb3B1bGF0ZUNhY2hlXSB0b3RhbCBjYWNoZWQgc3RvcmFnZTogJHsoYnl0ZXNJblVzZSAvIDEwMjQpLnRvRml4ZWQoMil9S2lCYCk7XG4gICAgICAgICAgICBpZiAoYnl0ZXNJblVzZSAvIDEwMjQgPj0gcmVjbGFpbVN0b3JhZ2VMaW1pdEtiKSB7XG4gICAgICAgICAgICAgICAgd2FybihgRXhjZWVkZWQgc3RvcmFnZSBsaW1pdCB0aHJlc2hvbGQgb2YgJHtyZWNsYWltU3RvcmFnZUxpbWl0S2J9S2lCLCBcblx0XHRcdFx0XHRjbGVhbnVwIGNhcGFiaWxpdGllcyBmb3IgcHJpbnRlcnMgbm90IHVzZWQgaW4gJHtwcmludGVkT2xkZXJUaGFuRGF5c30gZGF5cy4uLmApO1xuICAgICAgICAgICAgICAgIGNsZWFudXBTdG9yYWdlKHByaW50ZWRPbGRlclRoYW5EYXlzKVxuICAgICAgICAgICAgICAgICAgICAudGhlbigoKSA9PiBsb2coYENvbXBsZXRlZCBjbGVhbnVwIG9mIHByaW50ZXJzIHVzZWQgPiAke3ByaW50ZWRPbGRlclRoYW5EYXlzfSBkYXlzYCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FjaGVMb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICAgbG9nKCdbT2ZmTmV0d29ya0NhY2hlOnBvcHVsYXRlQ2FjaGVdIGNvbXBsZXRlZC4nKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5hc3luYyBmdW5jdGlvbiBsb2FkTWFwRnJvbVN0b3JhZ2Uoa2V5LCB0b01hcCkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG1hcCA9IGF3YWl0IGxvYWRNYXAoa2V5KTtcbiAgICAgICAgaWYgKG1hcCkge1xuICAgICAgICAgICAgY29weVRvTWFwKG1hcCwgdG9NYXApO1xuICAgICAgICAgICAgbG9nKGBMb2FkZWQgJyR7a2V5fScgd2l0aCAke21hcC5zaXplfSBpdGVtcyBmcm9tIGxvY2FsIHN0b3JhZ2UuLi5gKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxvZyhgVW5hYmxlIHRvIGxvYWQgJyR7a2V5fSBmcm9tIGxvY2FsIHN0b3JhZ2UgLSBpdCBkb2VzIG5vdCBleGlzdGApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChyZWFzb24pIHtcbiAgICAgICAgcmV0dXJuIGVycm9yKGBVbmFibGUgdG8gbG9hZCAnJHtrZXl9JyBmcm9tIGxvY2FsIHN0b3JhZ2U6ICR7cmVhc29ufWApO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHNhdmVNYXBUb1N0b3JhZ2Uoa2V5LCBtYXApIHtcbiAgICB0cnkge1xuICAgICAgICBhd2FpdCBzYXZlTWFwKGtleSwgbWFwKTtcbiAgICAgICAgcmV0dXJuIGxvZyhgU2F2ZWQgJyR7a2V5fScgd2l0aCAke21hcC5zaXplfSBpdGVtcyB0byBsb2NhbCBzdG9yYWdlLi4uYCk7XG4gICAgfVxuICAgIGNhdGNoIChyZWFzb24pIHtcbiAgICAgICAgZXJyb3IoYEZhaWxlZCB0byBzYXZlIGRhdGEgdG8gbG9jYWwgc3RvcmFnZTogJHtyZWFzb259YCk7XG4gICAgICAgIGlmIChyZWFzb24gJiYgcmVhc29uLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ3F1b3RhJykpIHtcbiAgICAgICAgICAgIGNsZWFudXBTdG9yYWdlKHByaW50ZWRPbGRlclRoYW5EYXlzKVxuICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IGxvZyhgQ29tcGxldGVkIGNsZWFudXAgb2YgcHJpbnRlcnMgdXNlZCA+ICR7cHJpbnRlZE9sZGVyVGhhbkRheXN9IGRheXNgKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBjb3B5VG9NYXAoc3JjLCBkc3QpIHtcbiAgICBkc3QuY2xlYXIoKTtcbiAgICBzcmMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4gZHN0LnNldChrZXksIHZhbHVlKSk7XG59XG5mdW5jdGlvbiBkYXlzQWdvKHRpbWVzdGFtcE1pbGxpcykge1xuICAgIGNvbnN0IG1pbGxpc1BlckRheSA9IDEwMDAgKiA2MCAqIDYwICogMjQ7XG4gICAgaWYgKHRpbWVzdGFtcE1pbGxpcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiAoRGF0ZS5ub3coKSAtIHRpbWVzdGFtcE1pbGxpcykgLyBtaWxsaXNQZXJEYXk7XG59XG5hc3luYyBmdW5jdGlvbiBjbGVhbnVwU3RvcmFnZShwcmludGVkT2xkZXJUaGFuRGF5cykge1xuICAgIGxvZyhgW09mZk5ldHdvcmtDYWNoZTpjbGVhbnVwU3RvcmFnZV0gU3RvcmFnZSBjbGVhbnVwIHJlcXVlc3RlZCwgcHJpbnRpbmcgdGhyZXNob2xkPSR7cHJpbnRlZE9sZGVyVGhhbkRheXN9ZGF5c2ApO1xuICAgIGNocm9tZS5zdG9yYWdlLmxvY2FsLmdldEJ5dGVzSW5Vc2UodXNlZEJ5dGVzID0+IHtcbiAgICAgICAgbG9nKGBbT2ZmTmV0d29ya0NhY2hlOmNsZWFudXBTdG9yYWdlXSBTdG9yYWdlIGNsZWFudXAsICR7KHVzZWRCeXRlcyAvIDEwMjQpLnRvRml4ZWQoMil9S2lCIHVzZWRgKTtcbiAgICAgICAgbG9nKGBbT2ZmTmV0d29ya0NhY2hlOmNsZWFudXBTdG9yYWdlXSAke3ByaW50ZXJDYXBhYmlsaXRpZXNDYWNoZS5zaXplfSBwcmludGVyIGNhcGFiaWxpdGllcyBjYWNoZWRgKTtcbiAgICB9KTtcbiAgICBmb3IgKGNvbnN0IHByaW50ZXJJZCBvZiBwcmludGVyQ2FwYWJpbGl0aWVzQ2FjaGUua2V5cygpKSB7XG4gICAgICAgIGNvbnN0IHByaW50ZXJOYW1lID0gcHJpbnRlck5hbWVGcm9tVXJsKHByaW50ZXJJZCk7XG4gICAgICAgIGNvbnN0IHVudXNlZFByaW50ZXIgPSBwcmludGVyTmFtZSA9PSB1bmRlZmluZWQgfHwgYXdhaXQgZ2V0U2VydmVySWRGb3JQcmludGVyKHByaW50ZXJJZCkgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgcHJpbnRlZERheXMgPSBkYXlzQWdvKHByaW50ZXJUaW1lVXNlZE1hcC5nZXQocHJpbnRlcklkKSk7XG4gICAgICAgIGxldCBkaXNjYXJkID0gZmFsc2U7XG4gICAgICAgIGlmICh1bnVzZWRQcmludGVyKSB7XG4gICAgICAgICAgICBsb2coYFtPZmZOZXR3b3JrQ2FjaGU6Y2xlYW51cFN0b3JhZ2VdIERpc2NhcmRpbmcgdW51c2VkIHByaW50ZXIgY2FwYWJpbGl0eTogJHtwcmludGVyTmFtZX1gKTtcbiAgICAgICAgICAgIGRpc2NhcmQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByaW50ZWREYXlzID09PSB1bmRlZmluZWQgfHwgcHJpbnRlZERheXMgPiBwcmludGVkT2xkZXJUaGFuRGF5cykge1xuICAgICAgICAgICAgbG9nKGBbT2ZmTmV0d29ya0NhY2hlOmNsZWFudXBTdG9yYWdlXSBEaXNjYXJkaW5nIHByaW50ZXIgY2FwYWJpbGl0eSBvbGRlciB0aGFuICR7cHJpbnRlZE9sZGVyVGhhbkRheXN9IGRheXM6IFxuXHRcdFx0JHtwcmludGVyTmFtZX0sIGxhc3QgcHJpbnRlZDogJHtwcmludGVkRGF5cyA/IHByaW50ZWREYXlzLnRvRml4ZWQoMCkgKyAnIGRheXMgYWdvJyA6ICduZXZlcid9YCk7XG4gICAgICAgICAgICBkaXNjYXJkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlzY2FyZCkge1xuICAgICAgICAgICAgcHJpbnRlclRpbWVVc2VkTWFwLmRlbGV0ZShwcmludGVySWQpO1xuICAgICAgICAgICAgcHJpbnRlckNhcGFiaWxpdGllc0NhY2hlLmRlbGV0ZShwcmludGVySWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxvZyhgW09mZk5ldHdvcmtDYWNoZTpjbGVhbnVwU3RvcmFnZV0gJHtwcmludGVyQ2FwYWJpbGl0aWVzQ2FjaGUuc2l6ZX0gcHJpbnRlciBjYXBhYmlsaXRpZXMgYWZ0ZXIgY2xlYW4tdXBgKTtcbiAgICBQcm9taXNlLmFsbChbXG4gICAgICAgIHNhdmVNYXBUb1N0b3JhZ2Uoc3RvcmFnZUtleVByaW50ZXJUaW1lVXNlZE1hcCwgcHJpbnRlclRpbWVVc2VkTWFwKSxcbiAgICAgICAgc2F2ZU1hcFRvU3RvcmFnZShzdG9yYWdlS2V5UHJpbnRlckNhcGFiaWxpdGllc01hcCwgcHJpbnRlckNhcGFiaWxpdGllc0NhY2hlKSxcbiAgICBdKS50aGVuKCgpID0+IHtcbiAgICAgICAgY2hyb21lLnN0b3JhZ2UubG9jYWwuZ2V0Qnl0ZXNJblVzZShieXRlc0luVXNlID0+IHtcbiAgICAgICAgICAgIGxvZyhgW09mZk5ldHdvcmtDYWNoZTpjbGVhbnVwU3RvcmFnZV0gQ2xlYW51cCBjb21wbGV0ZSwgJHsoYnl0ZXNJblVzZSAvIDEwMjQpLnRvRml4ZWQoMil9S2lCIHVzZWRgKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdXBkYXRlUHJpbnRlckNhY2hlKHNlcnZlcklkLCBwcmludGVycykge1xuICAgIGZvciAoY29uc3QgcHJpbnRlciBvZiBwcmludGVycykge1xuICAgICAgICBwcmludGVyQ2FwYWJpbGl0aWVzQ2FjaGUuc2V0KHByaW50ZXIuaWQsIHByaW50ZXIuY2FwYWJpbGl0aWVzKTtcbiAgICAgICAgcHJpbnRlck5hbWVUb1NlcnZlcklkQ2FjaGUuc2V0KHByaW50ZXIubmFtZSwgc2VydmVySWQpO1xuICAgIH1cbiAgICBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgIHNhdmVNYXBUb1N0b3JhZ2Uoc3RvcmFnZUtleVByaW50ZXJUaW1lVXNlZE1hcCwgcHJpbnRlclRpbWVVc2VkTWFwKSxcbiAgICAgICAgc2F2ZU1hcFRvU3RvcmFnZShzdG9yYWdlS2V5UHJpbnRlckNhcGFiaWxpdGllc01hcCwgcHJpbnRlckNhcGFiaWxpdGllc0NhY2hlKSxcbiAgICAgICAgc2F2ZU1hcFRvU3RvcmFnZShzdG9yYWdlS2V5UHJpbnRlclNlcnZlck1hcCwgcHJpbnRlck5hbWVUb1NlcnZlcklkQ2FjaGUpLFxuICAgIF0pLmNhdGNoKGUgPT4ge1xuICAgICAgICBlcnJvcihgRmFpbGVkIHRvIHNhdmUgZGF0YSBjYWNoZXMgdG8gc3RvcmFnZTogJHtlLm5hbWV9IC0gJHtlLm1lc3NhZ2V9YCk7XG4gICAgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0UHJpbnRlckNhcGFiaWxpdGllcyhwcmludGVySWQpIHtcbiAgICBjb25zdCBjYXAgPSBwcmludGVyQ2FwYWJpbGl0aWVzQ2FjaGUuZ2V0KHByaW50ZXJJZCk7XG4gICAgaWYgKCFjYXApIHtcbiAgICAgICAgbG9nKGBDYWNoZWQgcHJpbnRlciBjYXBhYmlsaXR5IGZvciAnJHtwcmludGVySWR9JyBtaXNzaW5nIGZyb20gY2FjaGUhYCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBsb2coYEZvdW5kIGNhY2hlZCBwcmludGVyIGNhcGFiaWxpdGllcyBmb3I6ICR7cHJpbnRlcklkfSA9PiAke0pTT04uc3RyaW5naWZ5KGNhcCl9YCk7XG4gICAgcmV0dXJuIHBhcnNlTW9iaWxpdHlQcmludENhcGFiaWxpdGllcyhjYXApO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZUxhc3RQcmludGVkVGltZShwcmludGVyVXJsKSB7XG4gICAgcHJpbnRlclRpbWVVc2VkTWFwLnNldChwcmludGVyVXJsLCBEYXRlLm5vdygpKTtcbiAgICBzYXZlTWFwVG9TdG9yYWdlKHN0b3JhZ2VLZXlQcmludGVyVGltZVVzZWRNYXAsIHByaW50ZXJUaW1lVXNlZE1hcClcbiAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICBsb2coYFNhdmVkIGxhc3QgcHJpbnRlZCBkYXRlIGZvcjogJHtwcmludGVyVXJsfWApO1xuICAgIH0pO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFNlcnZlcklkRm9yUHJpbnRlcihwcmludGVyVXJsKSB7XG4gICAgY29uc3QgcHJpbnRlck5hbWUgPSBwcmludGVyTmFtZUZyb21VcmwocHJpbnRlclVybCk7XG4gICAgaWYgKCFwcmludGVyTmFtZSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCByZWFkeSA9IGF3YWl0IHdhaXRGb3JDb25kaXRpb24oKCkgPT4ge1xuICAgICAgICBsb2coJ1tPZmZOZXR3b3JrQ2FjaGU6Z2V0U2VydmVySWRGb3JQcmludGVyXSBXYWl0aW5nIGZvciBjYWNoZSB0byBiZSBsb2FkZWQgYW5kIHJlYWR5Li4uJyk7XG4gICAgICAgIHJldHVybiBjYWNoZUxvYWRlZDtcbiAgICB9KTtcbiAgICBpZiAoIXJlYWR5KSB7XG4gICAgICAgIGVycm9yKCdbT2ZmTmV0d29ya0NhY2hlOmdldFNlcnZlcklkRm9yUHJpbnRlcl0gR2l2aW5nIHVwIHdhaXRlZCBmb3IgY2FjaGUgdG8gYmUgcmVhZHkuLi4nKTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZm9yIChjb25zdCBbY2FjaGVkUHJpbnRlck5hbWUsIHNlcnZlcklkXSBvZiBwcmludGVyTmFtZVRvU2VydmVySWRDYWNoZSkge1xuICAgICAgICBpZiAoY2FjaGVkUHJpbnRlck5hbWUuc3RhcnRzV2l0aChwcmludGVyTmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBzZXJ2ZXJJZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gcHJpbnRlck5hbWVGcm9tVXJsKHByaW50ZXJVcmwpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCB1cmxQYXRoID0gbmV3IFVSTChwcmludGVyVXJsKS5wYXRobmFtZTtcbiAgICAgICAgY29uc3QgbGFzdFNsYXNoID0gdXJsUGF0aC5sYXN0SW5kZXhPZignLycpO1xuICAgICAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHVybFBhdGguc3Vic3RyaW5nKGxhc3RTbGFzaCArIDEpKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgZXJyb3IoYENhbm5vdCBmaW5kIHByaW50ZXIgbmFtZSAtIGludmFsaWQgVVJMOiAke3ByaW50ZXJVcmx9YCwgZSk7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgQ2xvdWRQcmludExpbmsgfSBmcm9tICcuLi9jbG91ZHByaW50JztcbmltcG9ydCB7IGdldENsaWVudElkIH0gZnJvbSAnLi4vaWRlbnRpdHknO1xuaW1wb3J0IHsgZXJyb3IsIGxvZyB9IGZyb20gJy4uL2xvZyc7XG5pbXBvcnQgeyBpbml0Q2FjaGUgfSBmcm9tICcuL29mZm5ldHdvcmtjYWNoZSc7XG5jb25zdCBMSU5LU19TVE9SQUdFX0tFWSA9ICdDbG91ZFByaW50SW52aXRlTGlua3MnO1xuY29uc3QgQ0xPVURfUFJJTlRfRVJSID0gJ0Nsb3VkIFByaW50IGVycm9yJztcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBpbml0Q2xvdWRQcmludCgpIHtcbiAgICBsb2coJ1tPZmZOZXR3b3JrXSBJbml0aWFsaXppbmcgQ2xvdWQgUHJpbnQnKTtcbiAgICBhd2FpdCBnZXRDbGllbnRJZCgpO1xuICAgIHJldHVybiBpbml0Q2FjaGUoKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0Nsb3VkUHJpbnRFcnJvcihlKSB7XG4gICAgaWYgKHR5cGVvZiBlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gZS5pbmNsdWRlcyhDTE9VRF9QUklOVF9FUlIpO1xuICAgIH1cbiAgICByZXR1cm4gZSAmJiBlLm1lc3NhZ2UgJiYgZS5tZXNzYWdlLmluY2x1ZGVzKENMT1VEX1BSSU5UX0VSUik7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2F2ZUJZT0RMaW5rKGxpbmspIHtcbiAgICBjb25zdCBsaW5rcyA9IGF3YWl0IGdldEFsbExpbmtzKCk7XG4gICAgaWYgKCFsaW5rcy5pbmNsdWRlcyhsaW5rKSkge1xuICAgICAgICBsb2coYG5vIGV4aXN0aW5nIGxpbmsgZm91bmQsIHNhdmluZyB0aGUgcmVjZWl2ZWQgbGluayBhcyBhIEJZT0QgbGluazogJHtsaW5rfWApO1xuICAgICAgICBjb25zdCBieW9kTGlua3MgPSBhd2FpdCBnZXRCWU9ETGlua3MoKTtcbiAgICAgICAgYnlvZExpbmtzLnB1c2gobGluayk7XG4gICAgICAgIGNocm9tZS5zdG9yYWdlLmxvY2FsLnNldCh7IENsb3VkUHJpbnRJbnZpdGVMaW5rczogYnlvZExpbmtzIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbG9nKCdmb3VuZCBleGlzdGluZyBsaW5rJyk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0QllPRExpbmtzKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXMgPT4ge1xuICAgICAgICBjaHJvbWUuc3RvcmFnZS5sb2NhbC5nZXQoTElOS1NfU1RPUkFHRV9LRVksIGRhdGEgPT4ge1xuICAgICAgICAgICAgaWYgKGRhdGEgJiYgZGF0YVtMSU5LU19TVE9SQUdFX0tFWV0pIHtcbiAgICAgICAgICAgICAgICBsb2coYGdldHRpbmcgJHtkYXRhW0xJTktTX1NUT1JBR0VfS0VZXS5sZW5ndGh9IEJZT0QgbGluayhzKS4uLmApO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXMoZGF0YVtMSU5LU19TVE9SQUdFX0tFWV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9nKCdubyBCWU9EIGxpbmtzIGZvdW5kJyk7XG4gICAgICAgICAgICAgICAgcmVzKFtdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBnZXRNYW5hZ2VkTGlua3MoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlcyA9PiB7XG4gICAgICAgIGNocm9tZS5zdG9yYWdlLm1hbmFnZWQuZ2V0KExJTktTX1NUT1JBR0VfS0VZLCBkYXRhID0+IHtcbiAgICAgICAgICAgIGlmIChkYXRhICYmIGRhdGFbTElOS1NfU1RPUkFHRV9LRVldKSB7XG4gICAgICAgICAgICAgICAgbG9nKGBnZXR0aW5nICR7ZGF0YVtMSU5LU19TVE9SQUdFX0tFWV0ubGVuZ3RofSBtYW5hZ2VkIGxpbmsocykuLi5gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzKGRhdGFbTElOS1NfU1RPUkFHRV9LRVldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvZygnbm8gbWFuYWdlZCBsaW5rcyBmb3VuZCcpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXMoW10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldEFsbExpbmtzKCkge1xuICAgIGNvbnN0IHN0b3JlZExpbmtzID0gYXdhaXQgZ2V0TWFuYWdlZExpbmtzKCk7XG4gICAgY29uc3QgYnlvZExpbmtzID0gYXdhaXQgZ2V0QllPRExpbmtzKCk7XG4gICAgcmV0dXJuIHN0b3JlZExpbmtzLmNvbmNhdChieW9kTGlua3MpO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldE9mZk5ldHdvcmtMaW5rcygpIHtcbiAgICBjb25zdCBhbGxMaW5rcyA9IGF3YWl0IGdldEFsbExpbmtzKCk7XG4gICAgY29uc3QgbGlua3MgPSBhbGxMaW5rcy5tYXAocyA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gQ2xvdWRQcmludExpbmsucGFyc2Uocyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGVycm9yKCdGYWlsZWQgdG8gcGFyc2UgQ2xvdWQgUHJpbnQgbGluay4nLCAnbGluaycsIHMsIGUpO1xuICAgICAgICB9XG4gICAgfSkuZmlsdGVyKChyZXMpID0+IHJlcyAhPSBudWxsKTtcbiAgICBsb2coJ1BhcnNlZCBDbG91ZCBQcmludCBsaW5rcy4nLCBsaW5rcy5tYXAobCA9PiBsLm9yZ0lkICsgJy8nICsgbC5zZXJ2ZXJJZCArICcgJyArIChsLmV4cGlyZXMoKSA/IGAoZXhwaXJ5OiAke2wuZXhwaXJ5LnRvSVNPU3RyaW5nKCl9KWAgOiAnKG5vIGV4cGlyeSknKSkpO1xuICAgIHJldHVybiBsaW5rcztcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRQcmludFRva2VuQ2FjaGVJRChzZXJ2ZXJJZCwgc2hhcmVUb2tlbikge1xuICAgIHJldHVybiBzZXJ2ZXJJZCArICc6JyArIHNoYXJlVG9rZW47XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0U2hhcmVUb2tlbihzZXJ2ZXJJZCkge1xuICAgIHJldHVybiAoYXdhaXQgZ2V0TGluayhzZXJ2ZXJJZCkpLnNoYXJlVG9rZW47XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0TGluayhzZXJ2ZXJJZCkge1xuICAgIGNvbnN0IGxpbmsgPSAoYXdhaXQgZ2V0T2ZmTmV0d29ya0xpbmtzKCkpLmZpbmQobGluayA9PiBsaW5rLnNlcnZlcklkID09IHNlcnZlcklkKTtcbiAgICBpZiAoIWxpbmspIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBubyBsaW5rIGZvciBzZXJ2ZXIgJHtzZXJ2ZXJJZH1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpbms7XG59XG4iLCJpbXBvcnQgeyBsb2cgfSBmcm9tICcuLi9sb2cnO1xuY29uc3QgT0ZGU0NSRUVOX0RPQ1VNRU5UX1BBVEggPSAnL29mZnNjcmVlbi5odG1sJztcbmxldCBvZmZTY3JlZW5Eb2N1bWVudENoZWNrID0gUHJvbWlzZS5yZXNvbHZlKCk7XG5hc3luYyBmdW5jdGlvbiBnZXRPZmZTY3JlZW5Eb2N1bWVudCgpIHtcbiAgICBvZmZTY3JlZW5Eb2N1bWVudENoZWNrID0gb2ZmU2NyZWVuRG9jdW1lbnRDaGVjay50aGVuKGFzeW5jICgpID0+IHtcbiAgICAgICAgaWYgKCEoYXdhaXQgaGFzRG9jdW1lbnQoKSkpIHtcbiAgICAgICAgICAgIGxvZygnW09mZnNjcmVlbl0gY3JlYXRpbmcgb2Zmc2NyZWVuIGRvY3VtZW50Li4uJyk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IGNocm9tZS5vZmZzY3JlZW4uY3JlYXRlRG9jdW1lbnQoe1xuICAgICAgICAgICAgICAgICAgICB1cmw6IE9GRlNDUkVFTl9ET0NVTUVOVF9QQVRILFxuICAgICAgICAgICAgICAgICAgICByZWFzb25zOiBbY2hyb21lLm9mZnNjcmVlbi5SZWFzb24uV0VCX1JUQ10sXG4gICAgICAgICAgICAgICAgICAgIGp1c3RpZmljYXRpb246ICdXZWJSVEMgZm9yIE1vYmlsaXR5IENsb3VkIFByaW50JyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmICghZXJyb3IubWVzc2FnZS5zdGFydHNXaXRoKCdPbmx5IGEgc2luZ2xlIG9mZnNjcmVlbiBkb2N1bWVudCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBvZmZTY3JlZW5Eb2N1bWVudENoZWNrO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIG1lc3NhZ2VPZmZTY3JlZW4oZGF0YSkge1xuICAgIGF3YWl0IGdldE9mZlNjcmVlbkRvY3VtZW50KCk7XG4gICAgY29uc3QgY2xpZW50VXJsID0gY2hyb21lLnJ1bnRpbWUuZ2V0VVJMKE9GRlNDUkVFTl9ET0NVTUVOVF9QQVRIKTtcbiAgICBjb25zdCBtZXNzYWdlQ2xpZW50ID0gKGF3YWl0IHNlbGYuY2xpZW50cy5tYXRjaEFsbCh7IGluY2x1ZGVVbmNvbnRyb2xsZWQ6IHRydWUgfSkpXG4gICAgICAgIC5maW5kKGMgPT4gYy51cmwgPT09IGNsaWVudFVybCk7XG4gICAgY29uc3QgbWVzc2FnZUNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICBtZXNzYWdlQ2xpZW50LnBvc3RNZXNzYWdlKGRhdGEsIFttZXNzYWdlQ2hhbm5lbC5wb3J0Ml0pO1xuICAgIGNvbnN0IHsgZGF0YTogb2Zmc2NyZWVuUmVzcG9uc2UgfSA9IGF3YWl0IG5ldyBQcm9taXNlKGNiID0+IChtZXNzYWdlQ2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBjYikpO1xuICAgIGxvZyhgW09mZnNjcmVlbi4ke2RhdGEuTXNnVHlwZX1dIGdvdCByZXNwb25zZWAsIG9mZnNjcmVlblJlc3BvbnNlKTtcbiAgICByZXR1cm4gb2Zmc2NyZWVuUmVzcG9uc2U7XG59XG5hc3luYyBmdW5jdGlvbiBoYXNEb2N1bWVudCgpIHtcbiAgICBjb25zdCBjbGllbnRXaW5kb3dzID0gYXdhaXQgc2VsZi5jbGllbnRzLm1hdGNoQWxsKCk7XG4gICAgbG9nKCdbT2Zmc2NyZWVuXSBjaGVja2luZyBmb3Igb2Zmc2NyZWVuIHdpbmRvdy4uLicsIGNsaWVudFdpbmRvd3MpO1xuICAgIGZvciAoY29uc3QgY2xpZW50V2luZG93IG9mIGNsaWVudFdpbmRvd3MpIHtcbiAgICAgICAgaWYgKGNsaWVudFdpbmRvdy51cmwuZW5kc1dpdGgoT0ZGU0NSRUVOX0RPQ1VNRU5UX1BBVEgpKSB7XG4gICAgICAgICAgICBsb2coJ1tPZmZzY3JlZW5dIGZvdW5kIGV4aXN0aW5nIG9mZnNjcmVlbiBkb2N1bWVudCcsIGNsaWVudFdpbmRvdyk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsb2coJ1tPZmZzY3JlZW5dIGNvdWxkIG5vdCBmaW5kIGV4aXN0aW5nIG9mZnNjcmVlbiBkb2N1bWVudCcpO1xuICAgIHJldHVybiBmYWxzZTtcbn1cbnRyeSB7XG4gICAgY2hyb21lLnJ1bnRpbWUub25TdXNwZW5kLmFkZExpc3RlbmVyKCgpID0+IHtcbiAgICAgICAgY2hyb21lLm9mZnNjcmVlbi5jbG9zZURvY3VtZW50KCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBsb2coJ1tPZmZzY3JlZW5dIGRvY3VtZW50IGNsb3NlZCBvbiBleHRlbnNpb24gdW5sb2FkJyk7XG4gICAgICAgIH0pLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgZXJyb3IoJ0ZhaWxlZCB0byBjbG9zZSBvZmZzY3JlZW4gZG9jdW1lbnQgb24gdW5sb2FkOicsIGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5jYXRjaCAoZSkge1xuICAgIGNvbnNvbGUubG9nKGBFcnJvcjogJHtlfWApO1xufVxuIiwiaW1wb3J0IHsgZ2V0Q2xpZW50SWQgfSBmcm9tICcuLi9pZGVudGl0eSc7XG5pbXBvcnQgeyBlcnJvciwgbG9nLCB3YXJuIH0gZnJvbSAnLi4vbG9nJztcbmltcG9ydCB7IGdldExpbmssIGdldE9mZk5ldHdvcmtMaW5rcywgZ2V0UHJpbnRUb2tlbkNhY2hlSUQsIGdldFNoYXJlVG9rZW4gfSBmcm9tICcuL29mZm5ldHdvcmstdXRpbHMnO1xuaW1wb3J0IHsgZ2V0UHJpbnRlck5hbWVUb1NlcnZlcklkQ2FjaGUsIGdldFByaW50VG9rZW5DYWNoZSwgZ2V0U2VydmVySWRGb3JQcmludGVyLCB1cGRhdGVMYXN0UHJpbnRlZFRpbWUsIHVwZGF0ZVByaW50ZXJDYWNoZSwgdXBkYXRlUHJpbnRUb2tlbiwgdXBkYXRlU2VydmVySW5mbywgfSBmcm9tICcuL29mZm5ldHdvcmtjYWNoZSc7XG5pbXBvcnQgeyBtZXNzYWdlT2ZmU2NyZWVuIH0gZnJvbSAnLi9vZmZzY3JlZW4tdXRpbHMnO1xudHJ5IHtcbiAgICBjaHJvbWUucnVudGltZS5vbk1lc3NhZ2UuYWRkTGlzdGVuZXIoaGFuZGxlTWVzc2FnZXMpO1xufVxuY2F0Y2ggKGUpIHtcbiAgICBjb25zb2xlLmxvZyhgRXJyb3I6ICR7ZX1gKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZU1lc3NhZ2VzKG1lc3NhZ2UpIHtcbiAgICBpZiAobWVzc2FnZS50YXJnZXQgIT09ICdiYWNrZ3JvdW5kJykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHN3aXRjaCAobWVzc2FnZS50eXBlKSB7XG4gICAgICAgIGNhc2UgJ2xvZyc6IHtcbiAgICAgICAgICAgIGxvZyhtZXNzYWdlLmRhdGEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnZXJyb3InOiB7XG4gICAgICAgICAgICBlcnJvcihtZXNzYWdlLmRhdGEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnd2Fybic6IHtcbiAgICAgICAgICAgIHdhcm4obWVzc2FnZS5kYXRhKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2NhY2hlLXNlcnZlci1pbmZvJzoge1xuICAgICAgICAgICAgbG9nKGBbb2Zmc2NyZWVuLiR7bWVzc2FnZS50eXBlfV0gY2FjaGUgc2VydmVyIGluZm86ICR7bWVzc2FnZS5kYXRhLlNlcnZlcklEfWApO1xuICAgICAgICAgICAgdXBkYXRlU2VydmVySW5mbyhtZXNzYWdlLmRhdGEuU2VydmVySUQsIG1lc3NhZ2UuZGF0YS5TZXJ2ZXJJbmZvKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3VwZGF0ZS1wcmludC10b2tlbi1jYWNoZSc6IHtcbiAgICAgICAgICAgIGxvZyhgW29mZnNjcmVlbi4ke21lc3NhZ2UudHlwZX1dIGNhY2hlIHByaW50IHRva2VuIGZvciBzZXJ2ZXI6ICR7bWVzc2FnZS5kYXRhLlNlcnZlcklEfWApO1xuICAgICAgICAgICAgdXBkYXRlUHJpbnRUb2tlbihnZXRQcmludFRva2VuQ2FjaGVJRChtZXNzYWdlLmRhdGEuU2VydmVySUQsIG1lc3NhZ2UuZGF0YS5TaGFyZVRva2VuKSwgbWVzc2FnZS5kYXRhLlByaW50VG9rZW4pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnZGVsZXRlLXByaW50LXRva2VuLWNhY2hlJzoge1xuICAgICAgICAgICAgbG9nKGBbb2Zmc2NyZWVuLiR7bWVzc2FnZS50eXBlfV0gcmVtb3ZlIHByaW50IHRva2VuIGZvciBzZXJ2ZXI6ICR7bWVzc2FnZS5kYXRhLlNlcnZlcklEfWApO1xuICAgICAgICAgICAgZ2V0UHJpbnRUb2tlbkNhY2hlKCkuZGVsZXRlKGdldFByaW50VG9rZW5DYWNoZUlEKG1lc3NhZ2UuZGF0YS5TZXJ2ZXJJRCwgbWVzc2FnZS5kYXRhLlNoYXJlVG9rZW4pKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3VwZGF0ZS1wcmludGVyLWNhY2hlJzoge1xuICAgICAgICAgICAgbG9nKGBbb2Zmc2NyZWVuLiR7bWVzc2FnZS50eXBlfV0gdXBkYXRlIGNhY2hlZCBwcmludGVycyBmb3Igc2VydmVyOiAke21lc3NhZ2UuZGF0YS5TZXJ2ZXJJRH1gKTtcbiAgICAgICAgICAgIGF3YWl0IHVwZGF0ZVByaW50ZXJDYWNoZShtZXNzYWdlLmRhdGEuU2VydmVySUQsIG1lc3NhZ2UuZGF0YS5QcmludGVyTGlzdCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY29uc29sZS53YXJuKGBVbmV4cGVjdGVkIG1lc3NhZ2UgcmVjZWl2ZWQgZm9yIGJhY2tncm91bmQgc2NyaXB0OiAnJHtKU09OLnN0cmluZ2lmeShtZXNzYWdlKX0nLmApO1xuICAgIH1cbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRQcmludGVyc0Zyb21BbGxTZXJ2ZXJzKCkge1xuICAgIGxldCBsaW5rcztcbiAgICB0cnkge1xuICAgICAgICBsaW5rcyA9IGF3YWl0IGdldE9mZk5ldHdvcmtMaW5rcygpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBlcnJvcignW09mZk5ldHdvcms6Z2V0UHJpbnRlcnNGcm9tQWxsU2VydmVyc10gZmFpbGVkIHRvIGdldCBsaW5rczogJywgZSk7XG4gICAgfVxuICAgIGlmIChsaW5rcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgbG9nKCdbT2ZmTmV0d29yazpnZXRQcmludGVyc0Zyb21BbGxTZXJ2ZXJzXSBObyBDbG91ZCBQcmludCBsaW5rcywgc2tpcHBpbmcgQ2xvdWQgUHJpbnQgZGlzY292ZXJ5LicpO1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGxvZygnW09mZk5ldHdvcms6Z2V0UHJpbnRlcnNGcm9tQWxsU2VydmVyc10gbGlua3MnLCBsaW5rcyk7XG4gICAgY29uc3Qgc2VydmVySWRzID0gbmV3IFNldChsaW5rcy5tYXAobGluayA9PiBsaW5rLnNlcnZlcklkKSk7XG4gICAgY29uc3QgcHJpbnRlck5hbWVUb1NlcnZlcklkQ2FjaGUgPSBnZXRQcmludGVyTmFtZVRvU2VydmVySWRDYWNoZSgpO1xuICAgIGZvciAoY29uc3QgW3ByaW50ZXJOYW1lLCBzZXJ2ZXJJZF0gb2YgcHJpbnRlck5hbWVUb1NlcnZlcklkQ2FjaGUuZW50cmllcygpKSB7XG4gICAgICAgIGlmICghc2VydmVySWRzLmhhcyhzZXJ2ZXJJZCkpIHtcbiAgICAgICAgICAgIHByaW50ZXJOYW1lVG9TZXJ2ZXJJZENhY2hlLmRlbGV0ZShwcmludGVyTmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcHJpbnRlclJlc3VsdHMgPSBbLi4uc2VydmVySWRzXS5tYXAoYXN5bmMgKHNlcnZlcklkKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBwcmludGVycyA9IGF3YWl0IGdldFByaW50ZXJzRnJvbVNlcnZlcihzZXJ2ZXJJZCk7XG4gICAgICAgICAgICBsb2coYFtPZmZOZXR3b3JrOmdldFByaW50ZXJzRnJvbUFsbFNlcnZlcnNdIGdvdCAke3ByaW50ZXJzLmxlbmd0aH0gcHJpbnRlcnMgZnJvbSAnJHtzZXJ2ZXJJZH0nYCwgcHJpbnRlcnMpO1xuICAgICAgICAgICAgcmV0dXJuIHByaW50ZXJzO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBlcnJvcihgW09mZk5ldHdvcms6Z2V0UHJpbnRlcnNGcm9tQWxsU2VydmVyc10gZmFpbGVkIGZvciAke3NlcnZlcklkfTogYCwgZSk7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCByZXN1bHQgPSAoYXdhaXQgUHJvbWlzZS5hbGwocHJpbnRlclJlc3VsdHMpKS5mbGF0KEluZmluaXR5KTtcbiAgICBsb2coYFtPZmZOZXR3b3JrOmdldFByaW50ZXJzRnJvbUFsbFNlcnZlcnNdIGNvbXBsZXRlZCB3aXRoICR7cmVzdWx0Lmxlbmd0aH0gQ2xvdWQgUHJpbnQgcHJpbnRlcnMuYCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRTZXJ2ZXJJbmZvUlRDKHNlcnZlcklkKSB7XG4gICAgbG9nKGBbT2ZmTmV0d29yazpnZXRTZXJ2ZXJJbmZvUlRDXSBSZXF1ZXN0aW5nIHNlcnZlciBpbmZvOiAke3NlcnZlcklkfWApO1xuICAgIGNvbnN0IHNoYXJlVG9rZW4gPSBhd2FpdCBnZXRTaGFyZVRva2VuKHNlcnZlcklkKTtcbiAgICBjb25zdCBwcmludFRva2VuQ2FjaGVJRCA9IGdldFByaW50VG9rZW5DYWNoZUlEKHNlcnZlcklkLCBzaGFyZVRva2VuKTtcbiAgICBjb25zdCBwcmludFRva2VuID0gZ2V0UHJpbnRUb2tlbkNhY2hlKCkuZ2V0KHByaW50VG9rZW5DYWNoZUlEKTtcbiAgICBjb25zdCBjbGllbnRJZCA9IGF3YWl0IGdldENsaWVudElkKCk7XG4gICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgU2VydmVySUQ6IHNlcnZlcklkLFxuICAgICAgICBDbGllbnRJRDogY2xpZW50SWQsXG4gICAgICAgIFRlc3RFbnY6IChhd2FpdCBnZXRMaW5rKHNlcnZlcklkKSkudGVzdEVudixcbiAgICAgICAgU2hhcmVUb2tlbjogc2hhcmVUb2tlbixcbiAgICAgICAgUHJpbnRUb2tlbjogcHJpbnRUb2tlbixcbiAgICAgICAgTXNnVHlwZTogJ2dldC1zZXJ2ZXItaW5mby1ydGMnLFxuICAgIH07XG4gICAgY29uc3Qgc2VydmVySW5mbyA9IGF3YWl0IG1lc3NhZ2VPZmZTY3JlZW4oZGF0YSk7XG4gICAgaWYgKCFzZXJ2ZXJJbmZvLlJlc3BTdGF0ZSkge1xuICAgICAgICBlcnJvcignW09mZk5ldHdvcms6Z2V0U2VydmVySW5mb1JUQ10gc2VydmVyIGluZm8gZmV0Y2ggZXJyb3IgJywgc2VydmVySW5mby5SZXNwRGF0YSk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihzZXJ2ZXJJbmZvLlJlc3BEYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlcnZlckluZm8uUmVzcERhdGE7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRQcmludGVyc0Zyb21TZXJ2ZXIoc2VydmVySWQpIHtcbiAgICBsb2coYFtPZmZOZXR3b3JrOmdldFByaW50ZXJzRnJvbVNlcnZlcl0gZmV0Y2hpbmcgcHJpbnRlcnMgZm9yIHNlcnZlciAnJHtzZXJ2ZXJJZH0nLi4uYCk7XG4gICAgY29uc3Qgc2hhcmVUb2tlbiA9IGF3YWl0IGdldFNoYXJlVG9rZW4oc2VydmVySWQpO1xuICAgIGNvbnN0IHByaW50VG9rZW5DYWNoZUlEID0gZ2V0UHJpbnRUb2tlbkNhY2hlSUQoc2VydmVySWQsIHNoYXJlVG9rZW4pO1xuICAgIGNvbnN0IHByaW50VG9rZW4gPSBnZXRQcmludFRva2VuQ2FjaGUoKS5nZXQocHJpbnRUb2tlbkNhY2hlSUQpO1xuICAgIGNvbnN0IGNsaWVudElkID0gYXdhaXQgZ2V0Q2xpZW50SWQoKTtcbiAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICBTZXJ2ZXJJRDogc2VydmVySWQsXG4gICAgICAgIENsaWVudElEOiBjbGllbnRJZCxcbiAgICAgICAgVGVzdEVudjogKGF3YWl0IGdldExpbmsoc2VydmVySWQpKS50ZXN0RW52LFxuICAgICAgICBTaGFyZVRva2VuOiBzaGFyZVRva2VuLFxuICAgICAgICBQcmludFRva2VuOiBwcmludFRva2VuLFxuICAgICAgICBNc2dUeXBlOiAnZ2V0LXByaW50ZXJzLWZyb20tc2VydmVyJyxcbiAgICB9O1xuICAgIGNvbnN0IHByaW50ZXJSZXN1bHQgPSBhd2FpdCBtZXNzYWdlT2ZmU2NyZWVuKGRhdGEpO1xuICAgIGlmICghcHJpbnRlclJlc3VsdC5SZXNwU3RhdGUpIHtcbiAgICAgICAgZXJyb3IoJ1tPZmZOZXR3b3JrOmdldFByaW50ZXJzRnJvbVNlcnZlcl0gY2xvdWQgcHJpbnQgam9iIHN1Ym1pdCBlcnJvciAocHJvbWlzZSByZWplY3QpOiAnLCBwcmludGVyUmVzdWx0LlJlc3BEYXRhKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByaW50ZXJSZXN1bHQuUmVzcERhdGEpO1xuICAgIH1cbiAgICBhd2FpdCB1cGRhdGVQcmludGVyQ2FjaGUoc2VydmVySWQsIHByaW50ZXJSZXN1bHQuUmVzcERhdGEpO1xuICAgIHJldHVybiBwcmludGVyUmVzdWx0LlJlc3BEYXRhO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFByaW50ZXJJbmZvUlRDKHByaW50ZXJJZCkge1xuICAgIGxvZyhgW09mZk5ldHdvcms6Z2V0UHJpbnRlckluZm9SVENdIFJlcXVlc3RpbmcgcHJpbnRlciBpbmZvOiAke3ByaW50ZXJJZH1gKTtcbiAgICBjb25zdCBzZXJ2ZXJJZCA9IGF3YWl0IGdldFNlcnZlcklkRm9yUHJpbnRlcihwcmludGVySWQpO1xuICAgIGlmICghc2VydmVySWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmtub3duIHNlcnZlciBpZCBmb3IgcHJpbnRlcjogJHtwcmludGVySWR9YCk7XG4gICAgfVxuICAgIGNvbnN0IHNoYXJlVG9rZW4gPSBhd2FpdCBnZXRTaGFyZVRva2VuKHNlcnZlcklkKTtcbiAgICBjb25zdCBwcmludFRva2VuQ2FjaGVJRCA9IGdldFByaW50VG9rZW5DYWNoZUlEKHNlcnZlcklkLCBzaGFyZVRva2VuKTtcbiAgICBjb25zdCBwcmludFRva2VuID0gZ2V0UHJpbnRUb2tlbkNhY2hlKCkuZ2V0KHByaW50VG9rZW5DYWNoZUlEKTtcbiAgICBjb25zdCBjbGllbnRJZCA9IGF3YWl0IGdldENsaWVudElkKCk7XG4gICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgUHJpbnRlcklEOiBwcmludGVySWQsXG4gICAgICAgIFNlcnZlcklEOiBzZXJ2ZXJJZCxcbiAgICAgICAgQ2xpZW50SUQ6IGNsaWVudElkLFxuICAgICAgICBUZXN0RW52OiAoYXdhaXQgZ2V0TGluayhzZXJ2ZXJJZCkpLnRlc3RFbnYsXG4gICAgICAgIFNoYXJlVG9rZW46IHNoYXJlVG9rZW4sXG4gICAgICAgIFByaW50VG9rZW46IHByaW50VG9rZW4sXG4gICAgICAgIE1zZ1R5cGU6ICdnZXQtcHJpbnRlci1pbmZvLXJ0YycsXG4gICAgfTtcbiAgICBjb25zdCBjYXBhYmlsaXRpZXMgPSBhd2FpdCBtZXNzYWdlT2ZmU2NyZWVuKGRhdGEpO1xuICAgIGlmICghY2FwYWJpbGl0aWVzLlJlc3BTdGF0ZSkge1xuICAgICAgICBlcnJvcignW09mZk5ldHdvcms6Z2V0Q2FwYWJpbGl0aWVzT2ZmTmV0d29ya10gY2xvdWQgcHJpbnRlciBjYXBhYmlsaXRpZXMgZmV0Y2ggZXJyb3IgJywgY2FwYWJpbGl0aWVzLlJlc3BEYXRhKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciBmZXRjaGluZyBjYXBhYmlsaXRpZXMgdmlhIGNsb3VkIGNsaWVudCcpO1xuICAgIH1cbiAgICBsb2coJ1tnZXRQcmludGVySW5mb1JUQ10gUmVjZWl2ZWQgcHJpbnRlciBjYXBhYmlsaXRpZXMuJywgY2FwYWJpbGl0aWVzLlJlc3BEYXRhKTtcbiAgICByZXR1cm4gY2FwYWJpbGl0aWVzLlJlc3BEYXRhO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHN1Ym1pdFByaW50Sm9iUlRDKGZpbGUsIHByaW50ZXJVcmwsIHBhcmFtcykge1xuICAgIGNvbnN0IHNlcnZlcklkID0gYXdhaXQgZ2V0U2VydmVySWRGb3JQcmludGVyKHByaW50ZXJVcmwpO1xuICAgIGlmICghc2VydmVySWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmtub3duIHNlcnZlciBpZCBmb3IgcHJpbnRlciAke3ByaW50ZXJVcmx9YCk7XG4gICAgfVxuICAgIGxvZygnW09mZk5ldHdvcms6c3VibWl0UHJpbnRKb2JSVENdJywgJ3NlcnZlcklkJywgc2VydmVySWQsICdwYXJhbXMnLCB7XG4gICAgICAgIC4uLnBhcmFtcyxcbiAgICAgICAgY3JlZGVudGlhbHM6ICdbUkVEQUNURURdJyxcbiAgICB9KTtcbiAgICBjb25zdCBzaGFyZVRva2VuID0gYXdhaXQgZ2V0U2hhcmVUb2tlbihzZXJ2ZXJJZCk7XG4gICAgY29uc3QgcHJpbnRUb2tlbkNhY2hlSUQgPSBnZXRQcmludFRva2VuQ2FjaGVJRChzZXJ2ZXJJZCwgc2hhcmVUb2tlbik7XG4gICAgY29uc3QgcHJpbnRUb2tlbiA9IGdldFByaW50VG9rZW5DYWNoZSgpLmdldChwcmludFRva2VuQ2FjaGVJRCk7XG4gICAgY29uc3QgY2xpZW50SWQgPSBhd2FpdCBnZXRDbGllbnRJZCgpO1xuICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgIEZpbGVEYXRhOiBmaWxlLFxuICAgICAgICBQcmludGVyVVJMOiBwcmludGVyVXJsLFxuICAgICAgICBQYXJhbXM6IHBhcmFtcyxcbiAgICAgICAgU2VydmVySUQ6IHNlcnZlcklkLFxuICAgICAgICBDbGllbnRJRDogY2xpZW50SWQsXG4gICAgICAgIFRlc3RFbnY6IChhd2FpdCBnZXRMaW5rKHNlcnZlcklkKSkudGVzdEVudixcbiAgICAgICAgU2hhcmVUb2tlbjogc2hhcmVUb2tlbixcbiAgICAgICAgUHJpbnRUb2tlbjogcHJpbnRUb2tlbixcbiAgICAgICAgTXNnVHlwZTogJ3N1Ym1pdC1wcmludC1qb2ItcnRjJyxcbiAgICB9O1xuICAgIGNvbnN0IGpvYkRldGFpbHMgPSBhd2FpdCBtZXNzYWdlT2ZmU2NyZWVuKGRhdGEpO1xuICAgIGlmICgham9iRGV0YWlscy5SZXNwU3RhdGUpIHtcbiAgICAgICAgZXJyb3IoJ1tPZmZOZXR3b3JrOnN1Ym1pdFByaW50Sm9iUlRDXSBjbG91ZCBwcmludCBqb2Igc3VibWl0IGVycm9yIChwcm9taXNlIHJlamVjdCk6ICcsIGpvYkRldGFpbHMuUmVzcERhdGEpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3Ioam9iRGV0YWlscy5SZXNwRGF0YSk7XG4gICAgfVxuICAgIGxvZygnW3N1Ym1pdFByaW50Sm9iUlRDXSByZWNlaXZlZCBqb2Igc3VibWl0IHJlc3VsdCAoam9iRGV0YWlscykgZnJvbSBvZmZzY3JlZW4gZG9jOiAnLCBqb2JEZXRhaWxzLlJlc3BEYXRhKTtcbiAgICB1cGRhdGVMYXN0UHJpbnRlZFRpbWUocHJpbnRlclVybCk7XG4gICAgcmV0dXJuIGpvYkRldGFpbHMuUmVzcERhdGE7XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gZ2V0VXJsQmFzZU9mUHJpbnRlclVybChwcmludGVyVXJsKSB7XG4gICAgcmV0dXJuIHByaW50ZXJVcmwucmVwbGFjZSgvXFwvcHJpbnRlcnNcXC8uKi9pLCAnJyk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0UHJpbnRlck5hbWUocHJpbnRlclVybCkge1xuICAgIHJldHVybiBwcmludGVyVXJsLnNsaWNlKHByaW50ZXJVcmwubGFzdEluZGV4T2YoJy9wcmludGVycy8nKSArICcvcHJpbnRlcnMvJy5sZW5ndGgpO1xufVxuIiwidmFyIEJJX1JNID0gXCIwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpcIjtcbmV4cG9ydCBmdW5jdGlvbiBpbnQyY2hhcihuKSB7XG4gICAgcmV0dXJuIEJJX1JNLmNoYXJBdChuKTtcbn1cbi8vI3JlZ2lvbiBCSVRfT1BFUkFUSU9OU1xuLy8gKHB1YmxpYykgdGhpcyAmIGFcbmV4cG9ydCBmdW5jdGlvbiBvcF9hbmQoeCwgeSkge1xuICAgIHJldHVybiB4ICYgeTtcbn1cbi8vIChwdWJsaWMpIHRoaXMgfCBhXG5leHBvcnQgZnVuY3Rpb24gb3Bfb3IoeCwgeSkge1xuICAgIHJldHVybiB4IHwgeTtcbn1cbi8vIChwdWJsaWMpIHRoaXMgXiBhXG5leHBvcnQgZnVuY3Rpb24gb3BfeG9yKHgsIHkpIHtcbiAgICByZXR1cm4geCBeIHk7XG59XG4vLyAocHVibGljKSB0aGlzICYgfmFcbmV4cG9ydCBmdW5jdGlvbiBvcF9hbmRub3QoeCwgeSkge1xuICAgIHJldHVybiB4ICYgfnk7XG59XG4vLyByZXR1cm4gaW5kZXggb2YgbG93ZXN0IDEtYml0IGluIHgsIHggPCAyXjMxXG5leHBvcnQgZnVuY3Rpb24gbGJpdCh4KSB7XG4gICAgaWYgKHggPT0gMCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIHZhciByID0gMDtcbiAgICBpZiAoKHggJiAweGZmZmYpID09IDApIHtcbiAgICAgICAgeCA+Pj0gMTY7XG4gICAgICAgIHIgKz0gMTY7XG4gICAgfVxuICAgIGlmICgoeCAmIDB4ZmYpID09IDApIHtcbiAgICAgICAgeCA+Pj0gODtcbiAgICAgICAgciArPSA4O1xuICAgIH1cbiAgICBpZiAoKHggJiAweGYpID09IDApIHtcbiAgICAgICAgeCA+Pj0gNDtcbiAgICAgICAgciArPSA0O1xuICAgIH1cbiAgICBpZiAoKHggJiAzKSA9PSAwKSB7XG4gICAgICAgIHggPj49IDI7XG4gICAgICAgIHIgKz0gMjtcbiAgICB9XG4gICAgaWYgKCh4ICYgMSkgPT0gMCkge1xuICAgICAgICArK3I7XG4gICAgfVxuICAgIHJldHVybiByO1xufVxuLy8gcmV0dXJuIG51bWJlciBvZiAxIGJpdHMgaW4geFxuZXhwb3J0IGZ1bmN0aW9uIGNiaXQoeCkge1xuICAgIHZhciByID0gMDtcbiAgICB3aGlsZSAoeCAhPSAwKSB7XG4gICAgICAgIHggJj0geCAtIDE7XG4gICAgICAgICsrcjtcbiAgICB9XG4gICAgcmV0dXJuIHI7XG59XG4vLyNlbmRyZWdpb24gQklUX09QRVJBVElPTlNcbiIsImltcG9ydCB7IGludDJjaGFyIH0gZnJvbSBcIi4vdXRpbFwiO1xudmFyIGI2NG1hcCA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL1wiO1xudmFyIGI2NHBhZCA9IFwiPVwiO1xuZXhwb3J0IGZ1bmN0aW9uIGhleDJiNjQoaCkge1xuICAgIHZhciBpO1xuICAgIHZhciBjO1xuICAgIHZhciByZXQgPSBcIlwiO1xuICAgIGZvciAoaSA9IDA7IGkgKyAzIDw9IGgubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgYyA9IHBhcnNlSW50KGguc3Vic3RyaW5nKGksIGkgKyAzKSwgMTYpO1xuICAgICAgICByZXQgKz0gYjY0bWFwLmNoYXJBdChjID4+IDYpICsgYjY0bWFwLmNoYXJBdChjICYgNjMpO1xuICAgIH1cbiAgICBpZiAoaSArIDEgPT0gaC5sZW5ndGgpIHtcbiAgICAgICAgYyA9IHBhcnNlSW50KGguc3Vic3RyaW5nKGksIGkgKyAxKSwgMTYpO1xuICAgICAgICByZXQgKz0gYjY0bWFwLmNoYXJBdChjIDw8IDIpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpICsgMiA9PSBoLmxlbmd0aCkge1xuICAgICAgICBjID0gcGFyc2VJbnQoaC5zdWJzdHJpbmcoaSwgaSArIDIpLCAxNik7XG4gICAgICAgIHJldCArPSBiNjRtYXAuY2hhckF0KGMgPj4gMikgKyBiNjRtYXAuY2hhckF0KChjICYgMykgPDwgNCk7XG4gICAgfVxuICAgIHdoaWxlICgocmV0Lmxlbmd0aCAmIDMpID4gMCkge1xuICAgICAgICByZXQgKz0gYjY0cGFkO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuLy8gY29udmVydCBhIGJhc2U2NCBzdHJpbmcgdG8gaGV4XG5leHBvcnQgZnVuY3Rpb24gYjY0dG9oZXgocykge1xuICAgIHZhciByZXQgPSBcIlwiO1xuICAgIHZhciBpO1xuICAgIHZhciBrID0gMDsgLy8gYjY0IHN0YXRlLCAwLTNcbiAgICB2YXIgc2xvcCA9IDA7XG4gICAgZm9yIChpID0gMDsgaSA8IHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKHMuY2hhckF0KGkpID09IGI2NHBhZCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHYgPSBiNjRtYXAuaW5kZXhPZihzLmNoYXJBdChpKSk7XG4gICAgICAgIGlmICh2IDwgMCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGsgPT0gMCkge1xuICAgICAgICAgICAgcmV0ICs9IGludDJjaGFyKHYgPj4gMik7XG4gICAgICAgICAgICBzbG9wID0gdiAmIDM7XG4gICAgICAgICAgICBrID0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrID09IDEpIHtcbiAgICAgICAgICAgIHJldCArPSBpbnQyY2hhcigoc2xvcCA8PCAyKSB8ICh2ID4+IDQpKTtcbiAgICAgICAgICAgIHNsb3AgPSB2ICYgMHhmO1xuICAgICAgICAgICAgayA9IDI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoayA9PSAyKSB7XG4gICAgICAgICAgICByZXQgKz0gaW50MmNoYXIoc2xvcCk7XG4gICAgICAgICAgICByZXQgKz0gaW50MmNoYXIodiA+PiAyKTtcbiAgICAgICAgICAgIHNsb3AgPSB2ICYgMztcbiAgICAgICAgICAgIGsgPSAzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0ICs9IGludDJjaGFyKChzbG9wIDw8IDIpIHwgKHYgPj4gNCkpO1xuICAgICAgICAgICAgcmV0ICs9IGludDJjaGFyKHYgJiAweGYpO1xuICAgICAgICAgICAgayA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGsgPT0gMSkge1xuICAgICAgICByZXQgKz0gaW50MmNoYXIoc2xvcCA8PCAyKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cbi8vIGNvbnZlcnQgYSBiYXNlNjQgc3RyaW5nIHRvIGEgYnl0ZS9udW1iZXIgYXJyYXlcbmV4cG9ydCBmdW5jdGlvbiBiNjR0b0JBKHMpIHtcbiAgICAvLyBwaWdneWJhY2sgb24gYjY0dG9oZXggZm9yIG5vdywgb3B0aW1pemUgbGF0ZXJcbiAgICB2YXIgaCA9IGI2NHRvaGV4KHMpO1xuICAgIHZhciBpO1xuICAgIHZhciBhID0gW107XG4gICAgZm9yIChpID0gMDsgMiAqIGkgPCBoLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGFbaV0gPSBwYXJzZUludChoLnN1YnN0cmluZygyICogaSwgMiAqIGkgKyAyKSwgMTYpO1xuICAgIH1cbiAgICByZXR1cm4gYTtcbn1cbiIsIi8vIEhleCBKYXZhU2NyaXB0IGRlY29kZXJcbi8vIENvcHlyaWdodCAoYykgMjAwOC0yMDEzIExhcG8gTHVjaGluaSA8bGFwb0BsYXBvLml0PlxuLy8gUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XG4vLyBwdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQsIHByb3ZpZGVkIHRoYXQgdGhlIGFib3ZlXG4vLyBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIGFwcGVhciBpbiBhbGwgY29waWVzLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTXG4vLyBXSVRIIFJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUlxuLy8gQU5ZIFNQRUNJQUwsIERJUkVDVCwgSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFU1xuLy8gV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTSBMT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOXG4vLyBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1IgT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRlxuLy8gT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1IgUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cbi8qanNoaW50IGJyb3dzZXI6IHRydWUsIHN0cmljdDogdHJ1ZSwgaW1tZWQ6IHRydWUsIGxhdGVkZWY6IHRydWUsIHVuZGVmOiB0cnVlLCByZWdleGRhc2g6IGZhbHNlICovXG52YXIgZGVjb2RlcjtcbmV4cG9ydCB2YXIgSGV4ID0ge1xuICAgIGRlY29kZTogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIGlmIChkZWNvZGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhciBoZXggPSBcIjAxMjM0NTY3ODlBQkNERUZcIjtcbiAgICAgICAgICAgIHZhciBpZ25vcmUgPSBcIiBcXGZcXG5cXHJcXHRcXHUwMEEwXFx1MjAyOFxcdTIwMjlcIjtcbiAgICAgICAgICAgIGRlY29kZXIgPSB7fTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgICAgICAgICAgICAgZGVjb2RlcltoZXguY2hhckF0KGkpXSA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoZXggPSBoZXgudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGZvciAoaSA9IDEwOyBpIDwgMTY7ICsraSkge1xuICAgICAgICAgICAgICAgIGRlY29kZXJbaGV4LmNoYXJBdChpKV0gPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGlnbm9yZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGRlY29kZXJbaWdub3JlLmNoYXJBdChpKV0gPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgb3V0ID0gW107XG4gICAgICAgIHZhciBiaXRzID0gMDtcbiAgICAgICAgdmFyIGNoYXJfY291bnQgPSAwO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIGMgPSBhLmNoYXJBdChpKTtcbiAgICAgICAgICAgIGlmIChjID09IFwiPVwiKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjID0gZGVjb2RlcltjXTtcbiAgICAgICAgICAgIGlmIChjID09IC0xKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSWxsZWdhbCBjaGFyYWN0ZXIgYXQgb2Zmc2V0IFwiICsgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiaXRzIHw9IGM7XG4gICAgICAgICAgICBpZiAoKytjaGFyX2NvdW50ID49IDIpIHtcbiAgICAgICAgICAgICAgICBvdXRbb3V0Lmxlbmd0aF0gPSBiaXRzO1xuICAgICAgICAgICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAgICAgICAgIGNoYXJfY291bnQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYml0cyA8PD0gNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhcl9jb3VudCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSGV4IGVuY29kaW5nIGluY29tcGxldGU6IDQgYml0cyBtaXNzaW5nXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxufTtcbiIsIi8vIEJhc2U2NCBKYXZhU2NyaXB0IGRlY29kZXJcbi8vIENvcHlyaWdodCAoYykgMjAwOC0yMDEzIExhcG8gTHVjaGluaSA8bGFwb0BsYXBvLml0PlxuLy8gUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XG4vLyBwdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQsIHByb3ZpZGVkIHRoYXQgdGhlIGFib3ZlXG4vLyBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIGFwcGVhciBpbiBhbGwgY29waWVzLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTXG4vLyBXSVRIIFJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUlxuLy8gQU5ZIFNQRUNJQUwsIERJUkVDVCwgSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFU1xuLy8gV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTSBMT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOXG4vLyBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1IgT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRlxuLy8gT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1IgUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cbi8qanNoaW50IGJyb3dzZXI6IHRydWUsIHN0cmljdDogdHJ1ZSwgaW1tZWQ6IHRydWUsIGxhdGVkZWY6IHRydWUsIHVuZGVmOiB0cnVlLCByZWdleGRhc2g6IGZhbHNlICovXG52YXIgZGVjb2RlcjtcbmV4cG9ydCB2YXIgQmFzZTY0ID0ge1xuICAgIGRlY29kZTogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIGlmIChkZWNvZGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhciBiNjQgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9cIjtcbiAgICAgICAgICAgIHZhciBpZ25vcmUgPSBcIj0gXFxmXFxuXFxyXFx0XFx1MDBBMFxcdTIwMjhcXHUyMDI5XCI7XG4gICAgICAgICAgICBkZWNvZGVyID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCA2NDsgKytpKSB7XG4gICAgICAgICAgICAgICAgZGVjb2RlcltiNjQuY2hhckF0KGkpXSA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWNvZGVyWyctJ10gPSA2MjsgLy8rXG4gICAgICAgICAgICBkZWNvZGVyWydfJ10gPSA2MzsgLy8tXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaWdub3JlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgZGVjb2RlcltpZ25vcmUuY2hhckF0KGkpXSA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBvdXQgPSBbXTtcbiAgICAgICAgdmFyIGJpdHMgPSAwO1xuICAgICAgICB2YXIgY2hhcl9jb3VudCA9IDA7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgYyA9IGEuY2hhckF0KGkpO1xuICAgICAgICAgICAgaWYgKGMgPT0gXCI9XCIpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGMgPSBkZWNvZGVyW2NdO1xuICAgICAgICAgICAgaWYgKGMgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbGxlZ2FsIGNoYXJhY3RlciBhdCBvZmZzZXQgXCIgKyBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJpdHMgfD0gYztcbiAgICAgICAgICAgIGlmICgrK2NoYXJfY291bnQgPj0gNCkge1xuICAgICAgICAgICAgICAgIG91dFtvdXQubGVuZ3RoXSA9IChiaXRzID4+IDE2KTtcbiAgICAgICAgICAgICAgICBvdXRbb3V0Lmxlbmd0aF0gPSAoYml0cyA+PiA4KSAmIDB4RkY7XG4gICAgICAgICAgICAgICAgb3V0W291dC5sZW5ndGhdID0gYml0cyAmIDB4RkY7XG4gICAgICAgICAgICAgICAgYml0cyA9IDA7XG4gICAgICAgICAgICAgICAgY2hhcl9jb3VudCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBiaXRzIDw8PSA2O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoY2hhcl9jb3VudCkge1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJhc2U2NCBlbmNvZGluZyBpbmNvbXBsZXRlOiBhdCBsZWFzdCAyIGJpdHMgbWlzc2luZ1wiKTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBvdXRbb3V0Lmxlbmd0aF0gPSAoYml0cyA+PiAxMCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgb3V0W291dC5sZW5ndGhdID0gKGJpdHMgPj4gMTYpO1xuICAgICAgICAgICAgICAgIG91dFtvdXQubGVuZ3RoXSA9IChiaXRzID4+IDgpICYgMHhGRjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH0sXG4gICAgcmU6IC8tLS0tLUJFR0lOIFteLV0rLS0tLS0oW0EtWmEtejAtOStcXC89XFxzXSspLS0tLS1FTkQgW14tXSstLS0tLXxiZWdpbi1iYXNlNjRbXlxcbl0rXFxuKFtBLVphLXowLTkrXFwvPVxcc10rKT09PT0vLFxuICAgIHVuYXJtb3I6IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHZhciBtID0gQmFzZTY0LnJlLmV4ZWMoYSk7XG4gICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgICBpZiAobVsxXSkge1xuICAgICAgICAgICAgICAgIGEgPSBtWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobVsyXSkge1xuICAgICAgICAgICAgICAgIGEgPSBtWzJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVnRXhwIG91dCBvZiBzeW5jXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBCYXNlNjQuZGVjb2RlKGEpO1xuICAgIH1cbn07XG4iLCIvLyBCaWcgaW50ZWdlciBiYXNlLTEwIHByaW50aW5nIGxpYnJhcnlcbi8vIENvcHlyaWdodCAoYykgMjAxNCBMYXBvIEx1Y2hpbmkgPGxhcG9AbGFwby5pdD5cbi8vIFBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxuLy8gcHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLCBwcm92aWRlZCB0aGF0IHRoZSBhYm92ZVxuLy8gY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBhcHBlYXIgaW4gYWxsIGNvcGllcy5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFU1xuLy8gV0lUSCBSRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1Jcbi8vIEFOWSBTUEVDSUFMLCBESVJFQ1QsIElORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVNcbi8vIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST00gTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTlxuLy8gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SIE9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0Zcbi8vIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SIFBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXG4vKmpzaGludCBicm93c2VyOiB0cnVlLCBzdHJpY3Q6IHRydWUsIGltbWVkOiB0cnVlLCBsYXRlZGVmOiB0cnVlLCB1bmRlZjogdHJ1ZSwgcmVnZXhkYXNoOiBmYWxzZSAqL1xudmFyIG1heCA9IDEwMDAwMDAwMDAwMDAwOyAvLyBiaWdnZXN0IGludGVnZXIgdGhhdCBjYW4gc3RpbGwgZml0IDJeNTMgd2hlbiBtdWx0aXBsaWVkIGJ5IDI1NlxudmFyIEludDEwID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEludDEwKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuYnVmID0gWyt2YWx1ZSB8fCAwXTtcbiAgICB9XG4gICAgSW50MTAucHJvdG90eXBlLm11bEFkZCA9IGZ1bmN0aW9uIChtLCBjKSB7XG4gICAgICAgIC8vIGFzc2VydChtIDw9IDI1NilcbiAgICAgICAgdmFyIGIgPSB0aGlzLmJ1ZjtcbiAgICAgICAgdmFyIGwgPSBiLmxlbmd0aDtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciB0O1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICB0ID0gYltpXSAqIG0gKyBjO1xuICAgICAgICAgICAgaWYgKHQgPCBtYXgpIHtcbiAgICAgICAgICAgICAgICBjID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGMgPSAwIHwgKHQgLyBtYXgpO1xuICAgICAgICAgICAgICAgIHQgLT0gYyAqIG1heDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJbaV0gPSB0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChjID4gMCkge1xuICAgICAgICAgICAgYltpXSA9IGM7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEludDEwLnByb3RvdHlwZS5zdWIgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICAvLyBhc3NlcnQobSA8PSAyNTYpXG4gICAgICAgIHZhciBiID0gdGhpcy5idWY7XG4gICAgICAgIHZhciBsID0gYi5sZW5ndGg7XG4gICAgICAgIHZhciBpO1xuICAgICAgICB2YXIgdDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgdCA9IGJbaV0gLSBjO1xuICAgICAgICAgICAgaWYgKHQgPCAwKSB7XG4gICAgICAgICAgICAgICAgdCArPSBtYXg7XG4gICAgICAgICAgICAgICAgYyA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJbaV0gPSB0O1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChiW2IubGVuZ3RoIC0gMV0gPT09IDApIHtcbiAgICAgICAgICAgIGIucG9wKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEludDEwLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIChiYXNlKSB7XG4gICAgICAgIGlmICgoYmFzZSB8fCAxMCkgIT0gMTApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm9ubHkgYmFzZSAxMCBpcyBzdXBwb3J0ZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGIgPSB0aGlzLmJ1ZjtcbiAgICAgICAgdmFyIHMgPSBiW2IubGVuZ3RoIC0gMV0udG9TdHJpbmcoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IGIubGVuZ3RoIC0gMjsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgIHMgKz0gKG1heCArIGJbaV0pLnRvU3RyaW5nKCkuc3Vic3RyaW5nKDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzO1xuICAgIH07XG4gICAgSW50MTAucHJvdG90eXBlLnZhbHVlT2YgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBiID0gdGhpcy5idWY7XG4gICAgICAgIHZhciB2ID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IGIubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgIHYgPSB2ICogbWF4ICsgYltpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdjtcbiAgICB9O1xuICAgIEludDEwLnByb3RvdHlwZS5zaW1wbGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGIgPSB0aGlzLmJ1ZjtcbiAgICAgICAgcmV0dXJuIChiLmxlbmd0aCA9PSAxKSA/IGJbMF0gOiB0aGlzO1xuICAgIH07XG4gICAgcmV0dXJuIEludDEwO1xufSgpKTtcbmV4cG9ydCB7IEludDEwIH07XG4iLCIvLyBBU04uMSBKYXZhU2NyaXB0IGRlY29kZXJcbi8vIENvcHlyaWdodCAoYykgMjAwOC0yMDE0IExhcG8gTHVjaGluaSA8bGFwb0BsYXBvLml0PlxuLy8gUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XG4vLyBwdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQsIHByb3ZpZGVkIHRoYXQgdGhlIGFib3ZlXG4vLyBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIGFwcGVhciBpbiBhbGwgY29waWVzLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTXG4vLyBXSVRIIFJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUlxuLy8gQU5ZIFNQRUNJQUwsIERJUkVDVCwgSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFU1xuLy8gV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTSBMT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOXG4vLyBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1IgT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRlxuLy8gT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1IgUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cbi8qanNoaW50IGJyb3dzZXI6IHRydWUsIHN0cmljdDogdHJ1ZSwgaW1tZWQ6IHRydWUsIGxhdGVkZWY6IHRydWUsIHVuZGVmOiB0cnVlLCByZWdleGRhc2g6IGZhbHNlICovXG4vKmdsb2JhbCBvaWRzICovXG5pbXBvcnQgeyBJbnQxMCB9IGZyb20gXCIuL2ludDEwXCI7XG52YXIgZWxsaXBzaXMgPSBcIlxcdTIwMjZcIjtcbnZhciByZVRpbWVTID0gL14oXFxkXFxkKSgwWzEtOV18MVswLTJdKSgwWzEtOV18WzEyXVxcZHwzWzAxXSkoWzAxXVxcZHwyWzAtM10pKD86KFswLTVdXFxkKSg/OihbMC01XVxcZCkoPzpbLixdKFxcZHsxLDN9KSk/KT8pPyhafFstK10oPzpbMF1cXGR8MVswLTJdKShbMC01XVxcZCk/KT8kLztcbnZhciByZVRpbWVMID0gL14oXFxkXFxkXFxkXFxkKSgwWzEtOV18MVswLTJdKSgwWzEtOV18WzEyXVxcZHwzWzAxXSkoWzAxXVxcZHwyWzAtM10pKD86KFswLTVdXFxkKSg/OihbMC01XVxcZCkoPzpbLixdKFxcZHsxLDN9KSk/KT8pPyhafFstK10oPzpbMF1cXGR8MVswLTJdKShbMC01XVxcZCk/KT8kLztcbmZ1bmN0aW9uIHN0cmluZ0N1dChzdHIsIGxlbikge1xuICAgIGlmIChzdHIubGVuZ3RoID4gbGVuKSB7XG4gICAgICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoMCwgbGVuKSArIGVsbGlwc2lzO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xufVxudmFyIFN0cmVhbSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdHJlYW0oZW5jLCBwb3MpIHtcbiAgICAgICAgdGhpcy5oZXhEaWdpdHMgPSBcIjAxMjM0NTY3ODlBQkNERUZcIjtcbiAgICAgICAgaWYgKGVuYyBpbnN0YW5jZW9mIFN0cmVhbSkge1xuICAgICAgICAgICAgdGhpcy5lbmMgPSBlbmMuZW5jO1xuICAgICAgICAgICAgdGhpcy5wb3MgPSBlbmMucG9zO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gZW5jIHNob3VsZCBiZSBhbiBhcnJheSBvciBhIGJpbmFyeSBzdHJpbmdcbiAgICAgICAgICAgIHRoaXMuZW5jID0gZW5jO1xuICAgICAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgICAgIH1cbiAgICB9XG4gICAgU3RyZWFtLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAocG9zKSB7XG4gICAgICAgIGlmIChwb3MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcG9zID0gdGhpcy5wb3MrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zID49IHRoaXMuZW5jLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVxdWVzdGluZyBieXRlIG9mZnNldCBcIi5jb25jYXQocG9zLCBcIiBvbiBhIHN0cmVhbSBvZiBsZW5ndGggXCIpLmNvbmNhdCh0aGlzLmVuYy5sZW5ndGgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKFwic3RyaW5nXCIgPT09IHR5cGVvZiB0aGlzLmVuYykgPyB0aGlzLmVuYy5jaGFyQ29kZUF0KHBvcykgOiB0aGlzLmVuY1twb3NdO1xuICAgIH07XG4gICAgU3RyZWFtLnByb3RvdHlwZS5oZXhCeXRlID0gZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGV4RGlnaXRzLmNoYXJBdCgoYiA+PiA0KSAmIDB4RikgKyB0aGlzLmhleERpZ2l0cy5jaGFyQXQoYiAmIDB4Rik7XG4gICAgfTtcbiAgICBTdHJlYW0ucHJvdG90eXBlLmhleER1bXAgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgcmF3KSB7XG4gICAgICAgIHZhciBzID0gXCJcIjtcbiAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgICAgICAgIHMgKz0gdGhpcy5oZXhCeXRlKHRoaXMuZ2V0KGkpKTtcbiAgICAgICAgICAgIGlmIChyYXcgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGkgJiAweEYpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAweDc6XG4gICAgICAgICAgICAgICAgICAgICAgICBzICs9IFwiICBcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDB4RjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHMgKz0gXCJcXG5cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcyArPSBcIiBcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfTtcbiAgICBTdHJlYW0ucHJvdG90eXBlLmlzQVNDSUkgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICAgICAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgICAgICAgdmFyIGMgPSB0aGlzLmdldChpKTtcbiAgICAgICAgICAgIGlmIChjIDwgMzIgfHwgYyA+IDE3Nikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIFN0cmVhbS5wcm90b3R5cGUucGFyc2VTdHJpbmdJU08gPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICAgICAgICB2YXIgcyA9IFwiXCI7XG4gICAgICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICAgICAgICBzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodGhpcy5nZXQoaSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzO1xuICAgIH07XG4gICAgU3RyZWFtLnByb3RvdHlwZS5wYXJzZVN0cmluZ1VURiA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gICAgICAgIHZhciBzID0gXCJcIjtcbiAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOykge1xuICAgICAgICAgICAgdmFyIGMgPSB0aGlzLmdldChpKyspO1xuICAgICAgICAgICAgaWYgKGMgPCAxMjgpIHtcbiAgICAgICAgICAgICAgICBzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgoYyA+IDE5MSkgJiYgKGMgPCAyMjQpKSB7XG4gICAgICAgICAgICAgICAgcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoYyAmIDB4MUYpIDw8IDYpIHwgKHRoaXMuZ2V0KGkrKykgJiAweDNGKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKChjICYgMHgwRikgPDwgMTIpIHwgKCh0aGlzLmdldChpKyspICYgMHgzRikgPDwgNikgfCAodGhpcy5nZXQoaSsrKSAmIDB4M0YpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcztcbiAgICB9O1xuICAgIFN0cmVhbS5wcm90b3R5cGUucGFyc2VTdHJpbmdCTVAgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICAgICAgICB2YXIgc3RyID0gXCJcIjtcbiAgICAgICAgdmFyIGhpO1xuICAgICAgICB2YXIgbG87XG4gICAgICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDspIHtcbiAgICAgICAgICAgIGhpID0gdGhpcy5nZXQoaSsrKTtcbiAgICAgICAgICAgIGxvID0gdGhpcy5nZXQoaSsrKTtcbiAgICAgICAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChoaSA8PCA4KSB8IGxvKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH07XG4gICAgU3RyZWFtLnByb3RvdHlwZS5wYXJzZVRpbWUgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgc2hvcnRZZWFyKSB7XG4gICAgICAgIHZhciBzID0gdGhpcy5wYXJzZVN0cmluZ0lTTyhzdGFydCwgZW5kKTtcbiAgICAgICAgdmFyIG0gPSAoc2hvcnRZZWFyID8gcmVUaW1lUyA6IHJlVGltZUwpLmV4ZWMocyk7XG4gICAgICAgIGlmICghbSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiVW5yZWNvZ25pemVkIHRpbWU6IFwiICsgcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvcnRZZWFyKSB7XG4gICAgICAgICAgICAvLyB0byBhdm9pZCBxdWVyeWluZyB0aGUgdGltZXIsIHVzZSB0aGUgZml4ZWQgcmFuZ2UgWzE5NzAsIDIwNjldXG4gICAgICAgICAgICAvLyBpdCB3aWxsIGNvbmZvcm0gd2l0aCBJVFUgWC40MDAgWy0xMCwgKzQwXSBzbGlkaW5nIHdpbmRvdyB1bnRpbCAyMDMwXG4gICAgICAgICAgICBtWzFdID0gK21bMV07XG4gICAgICAgICAgICBtWzFdICs9ICgrbVsxXSA8IDcwKSA/IDIwMDAgOiAxOTAwO1xuICAgICAgICB9XG4gICAgICAgIHMgPSBtWzFdICsgXCItXCIgKyBtWzJdICsgXCItXCIgKyBtWzNdICsgXCIgXCIgKyBtWzRdO1xuICAgICAgICBpZiAobVs1XSkge1xuICAgICAgICAgICAgcyArPSBcIjpcIiArIG1bNV07XG4gICAgICAgICAgICBpZiAobVs2XSkge1xuICAgICAgICAgICAgICAgIHMgKz0gXCI6XCIgKyBtWzZdO1xuICAgICAgICAgICAgICAgIGlmIChtWzddKSB7XG4gICAgICAgICAgICAgICAgICAgIHMgKz0gXCIuXCIgKyBtWzddO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobVs4XSkge1xuICAgICAgICAgICAgcyArPSBcIiBVVENcIjtcbiAgICAgICAgICAgIGlmIChtWzhdICE9IFwiWlwiKSB7XG4gICAgICAgICAgICAgICAgcyArPSBtWzhdO1xuICAgICAgICAgICAgICAgIGlmIChtWzldKSB7XG4gICAgICAgICAgICAgICAgICAgIHMgKz0gXCI6XCIgKyBtWzldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcztcbiAgICB9O1xuICAgIFN0cmVhbS5wcm90b3R5cGUucGFyc2VJbnRlZ2VyID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgdmFyIHYgPSB0aGlzLmdldChzdGFydCk7XG4gICAgICAgIHZhciBuZWcgPSAodiA+IDEyNyk7XG4gICAgICAgIHZhciBwYWQgPSBuZWcgPyAyNTUgOiAwO1xuICAgICAgICB2YXIgbGVuO1xuICAgICAgICB2YXIgcyA9IFwiXCI7XG4gICAgICAgIC8vIHNraXAgdW51c2VmdWwgYml0cyAobm90IGFsbG93ZWQgaW4gREVSKVxuICAgICAgICB3aGlsZSAodiA9PSBwYWQgJiYgKytzdGFydCA8IGVuZCkge1xuICAgICAgICAgICAgdiA9IHRoaXMuZ2V0KHN0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgICBsZW4gPSBlbmQgLSBzdGFydDtcbiAgICAgICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG5lZyA/IC0xIDogMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBzaG93IGJpdCBsZW5ndGggb2YgaHVnZSBpbnRlZ2Vyc1xuICAgICAgICBpZiAobGVuID4gNCkge1xuICAgICAgICAgICAgcyA9IHY7XG4gICAgICAgICAgICBsZW4gPDw9IDM7XG4gICAgICAgICAgICB3aGlsZSAoKCgrcyBeIHBhZCkgJiAweDgwKSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgcyA9ICtzIDw8IDE7XG4gICAgICAgICAgICAgICAgLS1sZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzID0gXCIoXCIgKyBsZW4gKyBcIiBiaXQpXFxuXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGVjb2RlIHRoZSBpbnRlZ2VyXG4gICAgICAgIGlmIChuZWcpIHtcbiAgICAgICAgICAgIHYgPSB2IC0gMjU2O1xuICAgICAgICB9XG4gICAgICAgIHZhciBuID0gbmV3IEludDEwKHYpO1xuICAgICAgICBmb3IgKHZhciBpID0gc3RhcnQgKyAxOyBpIDwgZW5kOyArK2kpIHtcbiAgICAgICAgICAgIG4ubXVsQWRkKDI1NiwgdGhpcy5nZXQoaSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzICsgbi50b1N0cmluZygpO1xuICAgIH07XG4gICAgU3RyZWFtLnByb3RvdHlwZS5wYXJzZUJpdFN0cmluZyA9IGZ1bmN0aW9uIChzdGFydCwgZW5kLCBtYXhMZW5ndGgpIHtcbiAgICAgICAgdmFyIHVudXNlZEJpdCA9IHRoaXMuZ2V0KHN0YXJ0KTtcbiAgICAgICAgdmFyIGxlbkJpdCA9ICgoZW5kIC0gc3RhcnQgLSAxKSA8PCAzKSAtIHVudXNlZEJpdDtcbiAgICAgICAgdmFyIGludHJvID0gXCIoXCIgKyBsZW5CaXQgKyBcIiBiaXQpXFxuXCI7XG4gICAgICAgIHZhciBzID0gXCJcIjtcbiAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0ICsgMTsgaSA8IGVuZDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgYiA9IHRoaXMuZ2V0KGkpO1xuICAgICAgICAgICAgdmFyIHNraXAgPSAoaSA9PSBlbmQgLSAxKSA/IHVudXNlZEJpdCA6IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gNzsgaiA+PSBza2lwOyAtLWopIHtcbiAgICAgICAgICAgICAgICBzICs9IChiID4+IGopICYgMSA/IFwiMVwiIDogXCIwXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocy5sZW5ndGggPiBtYXhMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW50cm8gKyBzdHJpbmdDdXQocywgbWF4TGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW50cm8gKyBzO1xuICAgIH07XG4gICAgU3RyZWFtLnByb3RvdHlwZS5wYXJzZU9jdGV0U3RyaW5nID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIG1heExlbmd0aCkge1xuICAgICAgICBpZiAodGhpcy5pc0FTQ0lJKHN0YXJ0LCBlbmQpKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5nQ3V0KHRoaXMucGFyc2VTdHJpbmdJU08oc3RhcnQsIGVuZCksIG1heExlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0O1xuICAgICAgICB2YXIgcyA9IFwiKFwiICsgbGVuICsgXCIgYnl0ZSlcXG5cIjtcbiAgICAgICAgbWF4TGVuZ3RoIC89IDI7IC8vIHdlIHdvcmsgaW4gYnl0ZXNcbiAgICAgICAgaWYgKGxlbiA+IG1heExlbmd0aCkge1xuICAgICAgICAgICAgZW5kID0gc3RhcnQgKyBtYXhMZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgICAgICAgIHMgKz0gdGhpcy5oZXhCeXRlKHRoaXMuZ2V0KGkpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuID4gbWF4TGVuZ3RoKSB7XG4gICAgICAgICAgICBzICs9IGVsbGlwc2lzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzO1xuICAgIH07XG4gICAgU3RyZWFtLnByb3RvdHlwZS5wYXJzZU9JRCA9IGZ1bmN0aW9uIChzdGFydCwgZW5kLCBtYXhMZW5ndGgpIHtcbiAgICAgICAgdmFyIHMgPSBcIlwiO1xuICAgICAgICB2YXIgbiA9IG5ldyBJbnQxMCgpO1xuICAgICAgICB2YXIgYml0cyA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgdiA9IHRoaXMuZ2V0KGkpO1xuICAgICAgICAgICAgbi5tdWxBZGQoMTI4LCB2ICYgMHg3Rik7XG4gICAgICAgICAgICBiaXRzICs9IDc7XG4gICAgICAgICAgICBpZiAoISh2ICYgMHg4MCkpIHsgLy8gZmluaXNoZWRcbiAgICAgICAgICAgICAgICBpZiAocyA9PT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICBuID0gbi5zaW1wbGlmeSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobiBpbnN0YW5jZW9mIEludDEwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuLnN1Yig4MCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzID0gXCIyLlwiICsgbi50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG0gPSBuIDwgODAgPyBuIDwgNDAgPyAwIDogMSA6IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBzID0gbSArIFwiLlwiICsgKG4gLSBtICogNDApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzICs9IFwiLlwiICsgbi50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocy5sZW5ndGggPiBtYXhMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZ0N1dChzLCBtYXhMZW5ndGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuID0gbmV3IEludDEwKCk7XG4gICAgICAgICAgICAgICAgYml0cyA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJpdHMgPiAwKSB7XG4gICAgICAgICAgICBzICs9IFwiLmluY29tcGxldGVcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcztcbiAgICB9O1xuICAgIHJldHVybiBTdHJlYW07XG59KCkpO1xuZXhwb3J0IHsgU3RyZWFtIH07XG52YXIgQVNOMSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBU04xKHN0cmVhbSwgaGVhZGVyLCBsZW5ndGgsIHRhZywgc3ViKSB7XG4gICAgICAgIGlmICghKHRhZyBpbnN0YW5jZW9mIEFTTjFUYWcpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHRhZyB2YWx1ZS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdHJlYW0gPSBzdHJlYW07XG4gICAgICAgIHRoaXMuaGVhZGVyID0gaGVhZGVyO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdGhpcy50YWcgPSB0YWc7XG4gICAgICAgIHRoaXMuc3ViID0gc3ViO1xuICAgIH1cbiAgICBBU04xLnByb3RvdHlwZS50eXBlTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLnRhZy50YWdDbGFzcykge1xuICAgICAgICAgICAgY2FzZSAwOiAvLyB1bml2ZXJzYWxcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRoaXMudGFnLnRhZ051bWJlcikge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDB4MDA6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJFT0NcIjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAweDAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiQk9PTEVBTlwiO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDB4MDI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJJTlRFR0VSXCI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMHgwMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIkJJVF9TVFJJTkdcIjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAweDA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiT0NURVRfU1RSSU5HXCI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMHgwNTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIk5VTExcIjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAweDA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiT0JKRUNUX0lERU5USUZJRVJcIjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAweDA3OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiT2JqZWN0RGVzY3JpcHRvclwiO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDB4MDg6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJFWFRFUk5BTFwiO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDB4MDk6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJSRUFMXCI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMHgwQTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIkVOVU1FUkFURURcIjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAweDBCOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiRU1CRURERURfUERWXCI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMHgwQzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlVURjhTdHJpbmdcIjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAweDEwOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiU0VRVUVOQ0VcIjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAweDExOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiU0VUXCI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMHgxMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIk51bWVyaWNTdHJpbmdcIjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAweDEzOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiUHJpbnRhYmxlU3RyaW5nXCI7IC8vIEFTQ0lJIHN1YnNldFxuICAgICAgICAgICAgICAgICAgICBjYXNlIDB4MTQ6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJUZWxldGV4U3RyaW5nXCI7IC8vIGFrYSBUNjFTdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAweDE1OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiVmlkZW90ZXhTdHJpbmdcIjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAweDE2OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiSUE1U3RyaW5nXCI7IC8vIEFTQ0lJXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMHgxNzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlVUQ1RpbWVcIjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAweDE4OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiR2VuZXJhbGl6ZWRUaW1lXCI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMHgxOTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIkdyYXBoaWNTdHJpbmdcIjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAweDFBOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiVmlzaWJsZVN0cmluZ1wiOyAvLyBBU0NJSSBzdWJzZXRcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAweDFCOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiR2VuZXJhbFN0cmluZ1wiO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDB4MUM6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJVbml2ZXJzYWxTdHJpbmdcIjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAweDFFOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiQk1QU3RyaW5nXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBcIlVuaXZlcnNhbF9cIiArIHRoaXMudGFnLnRhZ051bWJlci50b1N0cmluZygpO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHJldHVybiBcIkFwcGxpY2F0aW9uX1wiICsgdGhpcy50YWcudGFnTnVtYmVyLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiW1wiICsgdGhpcy50YWcudGFnTnVtYmVyLnRvU3RyaW5nKCkgKyBcIl1cIjsgLy8gQ29udGV4dFxuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIHJldHVybiBcIlByaXZhdGVfXCIgKyB0aGlzLnRhZy50YWdOdW1iZXIudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQVNOMS5wcm90b3R5cGUuY29udGVudCA9IGZ1bmN0aW9uIChtYXhMZW5ndGgpIHtcbiAgICAgICAgaWYgKHRoaXMudGFnID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXhMZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbWF4TGVuZ3RoID0gSW5maW5pdHk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbnRlbnQgPSB0aGlzLnBvc0NvbnRlbnQoKTtcbiAgICAgICAgdmFyIGxlbiA9IE1hdGguYWJzKHRoaXMubGVuZ3RoKTtcbiAgICAgICAgaWYgKCF0aGlzLnRhZy5pc1VuaXZlcnNhbCgpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdWIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCIoXCIgKyB0aGlzLnN1Yi5sZW5ndGggKyBcIiBlbGVtKVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtLnBhcnNlT2N0ZXRTdHJpbmcoY29udGVudCwgY29udGVudCArIGxlbiwgbWF4TGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHRoaXMudGFnLnRhZ051bWJlcikge1xuICAgICAgICAgICAgY2FzZSAweDAxOiAvLyBCT09MRUFOXG4gICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLnN0cmVhbS5nZXQoY29udGVudCkgPT09IDApID8gXCJmYWxzZVwiIDogXCJ0cnVlXCI7XG4gICAgICAgICAgICBjYXNlIDB4MDI6IC8vIElOVEVHRVJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW0ucGFyc2VJbnRlZ2VyKGNvbnRlbnQsIGNvbnRlbnQgKyBsZW4pO1xuICAgICAgICAgICAgY2FzZSAweDAzOiAvLyBCSVRfU1RSSU5HXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3ViID8gXCIoXCIgKyB0aGlzLnN1Yi5sZW5ndGggKyBcIiBlbGVtKVwiIDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHJlYW0ucGFyc2VCaXRTdHJpbmcoY29udGVudCwgY29udGVudCArIGxlbiwgbWF4TGVuZ3RoKTtcbiAgICAgICAgICAgIGNhc2UgMHgwNDogLy8gT0NURVRfU1RSSU5HXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3ViID8gXCIoXCIgKyB0aGlzLnN1Yi5sZW5ndGggKyBcIiBlbGVtKVwiIDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHJlYW0ucGFyc2VPY3RldFN0cmluZyhjb250ZW50LCBjb250ZW50ICsgbGVuLCBtYXhMZW5ndGgpO1xuICAgICAgICAgICAgLy8gY2FzZSAweDA1OiAvLyBOVUxMXG4gICAgICAgICAgICBjYXNlIDB4MDY6IC8vIE9CSkVDVF9JREVOVElGSUVSXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtLnBhcnNlT0lEKGNvbnRlbnQsIGNvbnRlbnQgKyBsZW4sIG1heExlbmd0aCk7XG4gICAgICAgICAgICAvLyBjYXNlIDB4MDc6IC8vIE9iamVjdERlc2NyaXB0b3JcbiAgICAgICAgICAgIC8vIGNhc2UgMHgwODogLy8gRVhURVJOQUxcbiAgICAgICAgICAgIC8vIGNhc2UgMHgwOTogLy8gUkVBTFxuICAgICAgICAgICAgLy8gY2FzZSAweDBBOiAvLyBFTlVNRVJBVEVEXG4gICAgICAgICAgICAvLyBjYXNlIDB4MEI6IC8vIEVNQkVEREVEX1BEVlxuICAgICAgICAgICAgY2FzZSAweDEwOiAvLyBTRVFVRU5DRVxuICAgICAgICAgICAgY2FzZSAweDExOiAvLyBTRVRcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdWIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiKFwiICsgdGhpcy5zdWIubGVuZ3RoICsgXCIgZWxlbSlcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIihubyBlbGVtKVwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgMHgwQzogLy8gVVRGOFN0cmluZ1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmdDdXQodGhpcy5zdHJlYW0ucGFyc2VTdHJpbmdVVEYoY29udGVudCwgY29udGVudCArIGxlbiksIG1heExlbmd0aCk7XG4gICAgICAgICAgICBjYXNlIDB4MTI6IC8vIE51bWVyaWNTdHJpbmdcbiAgICAgICAgICAgIGNhc2UgMHgxMzogLy8gUHJpbnRhYmxlU3RyaW5nXG4gICAgICAgICAgICBjYXNlIDB4MTQ6IC8vIFRlbGV0ZXhTdHJpbmdcbiAgICAgICAgICAgIGNhc2UgMHgxNTogLy8gVmlkZW90ZXhTdHJpbmdcbiAgICAgICAgICAgIGNhc2UgMHgxNjogLy8gSUE1U3RyaW5nXG4gICAgICAgICAgICAvLyBjYXNlIDB4MTk6IC8vIEdyYXBoaWNTdHJpbmdcbiAgICAgICAgICAgIGNhc2UgMHgxQTogLy8gVmlzaWJsZVN0cmluZ1xuICAgICAgICAgICAgICAgIC8vIGNhc2UgMHgxQjogLy8gR2VuZXJhbFN0cmluZ1xuICAgICAgICAgICAgICAgIC8vIGNhc2UgMHgxQzogLy8gVW5pdmVyc2FsU3RyaW5nXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZ0N1dCh0aGlzLnN0cmVhbS5wYXJzZVN0cmluZ0lTTyhjb250ZW50LCBjb250ZW50ICsgbGVuKSwgbWF4TGVuZ3RoKTtcbiAgICAgICAgICAgIGNhc2UgMHgxRTogLy8gQk1QU3RyaW5nXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZ0N1dCh0aGlzLnN0cmVhbS5wYXJzZVN0cmluZ0JNUChjb250ZW50LCBjb250ZW50ICsgbGVuKSwgbWF4TGVuZ3RoKTtcbiAgICAgICAgICAgIGNhc2UgMHgxNzogLy8gVVRDVGltZVxuICAgICAgICAgICAgY2FzZSAweDE4OiAvLyBHZW5lcmFsaXplZFRpbWVcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW0ucGFyc2VUaW1lKGNvbnRlbnQsIGNvbnRlbnQgKyBsZW4sICh0aGlzLnRhZy50YWdOdW1iZXIgPT0gMHgxNykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgQVNOMS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGVOYW1lKCkgKyBcIkBcIiArIHRoaXMuc3RyZWFtLnBvcyArIFwiW2hlYWRlcjpcIiArIHRoaXMuaGVhZGVyICsgXCIsbGVuZ3RoOlwiICsgdGhpcy5sZW5ndGggKyBcIixzdWI6XCIgKyAoKHRoaXMuc3ViID09PSBudWxsKSA/IFwibnVsbFwiIDogdGhpcy5zdWIubGVuZ3RoKSArIFwiXVwiO1xuICAgIH07XG4gICAgQVNOMS5wcm90b3R5cGUudG9QcmV0dHlTdHJpbmcgPSBmdW5jdGlvbiAoaW5kZW50KSB7XG4gICAgICAgIGlmIChpbmRlbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaW5kZW50ID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcyA9IGluZGVudCArIHRoaXMudHlwZU5hbWUoKSArIFwiIEBcIiArIHRoaXMuc3RyZWFtLnBvcztcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoID49IDApIHtcbiAgICAgICAgICAgIHMgKz0gXCIrXCI7XG4gICAgICAgIH1cbiAgICAgICAgcyArPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgaWYgKHRoaXMudGFnLnRhZ0NvbnN0cnVjdGVkKSB7XG4gICAgICAgICAgICBzICs9IFwiIChjb25zdHJ1Y3RlZClcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgodGhpcy50YWcuaXNVbml2ZXJzYWwoKSAmJiAoKHRoaXMudGFnLnRhZ051bWJlciA9PSAweDAzKSB8fCAodGhpcy50YWcudGFnTnVtYmVyID09IDB4MDQpKSkgJiYgKHRoaXMuc3ViICE9PSBudWxsKSkge1xuICAgICAgICAgICAgcyArPSBcIiAoZW5jYXBzdWxhdGVzKVwiO1xuICAgICAgICB9XG4gICAgICAgIHMgKz0gXCJcXG5cIjtcbiAgICAgICAgaWYgKHRoaXMuc3ViICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpbmRlbnQgKz0gXCIgIFwiO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG1heCA9IHRoaXMuc3ViLmxlbmd0aDsgaSA8IG1heDsgKytpKSB7XG4gICAgICAgICAgICAgICAgcyArPSB0aGlzLnN1YltpXS50b1ByZXR0eVN0cmluZyhpbmRlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzO1xuICAgIH07XG4gICAgQVNOMS5wcm90b3R5cGUucG9zU3RhcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cmVhbS5wb3M7XG4gICAgfTtcbiAgICBBU04xLnByb3RvdHlwZS5wb3NDb250ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW0ucG9zICsgdGhpcy5oZWFkZXI7XG4gICAgfTtcbiAgICBBU04xLnByb3RvdHlwZS5wb3NFbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cmVhbS5wb3MgKyB0aGlzLmhlYWRlciArIE1hdGguYWJzKHRoaXMubGVuZ3RoKTtcbiAgICB9O1xuICAgIEFTTjEucHJvdG90eXBlLnRvSGV4U3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW0uaGV4RHVtcCh0aGlzLnBvc1N0YXJ0KCksIHRoaXMucG9zRW5kKCksIHRydWUpO1xuICAgIH07XG4gICAgQVNOMS5kZWNvZGVMZW5ndGggPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gICAgICAgIHZhciBidWYgPSBzdHJlYW0uZ2V0KCk7XG4gICAgICAgIHZhciBsZW4gPSBidWYgJiAweDdGO1xuICAgICAgICBpZiAobGVuID09IGJ1Zikge1xuICAgICAgICAgICAgcmV0dXJuIGxlbjtcbiAgICAgICAgfVxuICAgICAgICAvLyBubyByZWFzb24gdG8gdXNlIEludDEwLCBhcyBpdCB3b3VsZCBiZSBhIGh1Z2UgYnVmZmVyIGFueXdheXNcbiAgICAgICAgaWYgKGxlbiA+IDYpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkxlbmd0aCBvdmVyIDQ4IGJpdHMgbm90IHN1cHBvcnRlZCBhdCBwb3NpdGlvbiBcIiArIChzdHJlYW0ucG9zIC0gMSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9IC8vIHVuZGVmaW5lZFxuICAgICAgICBidWYgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICBidWYgPSAoYnVmICogMjU2KSArIHN0cmVhbS5nZXQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVmO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgdGhlIGhleGFkZWNpbWFsIHZhbHVlIChhcyBhIHN0cmluZykgb2YgdGhlIGN1cnJlbnQgQVNOLjEgZWxlbWVudFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIEFTTjEucHJvdG90eXBlLmdldEhleFN0cmluZ1ZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaGV4U3RyaW5nID0gdGhpcy50b0hleFN0cmluZygpO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5oZWFkZXIgKiAyO1xuICAgICAgICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGggKiAyO1xuICAgICAgICByZXR1cm4gaGV4U3RyaW5nLnN1YnN0cihvZmZzZXQsIGxlbmd0aCk7XG4gICAgfTtcbiAgICBBU04xLmRlY29kZSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgdmFyIHN0cmVhbTtcbiAgICAgICAgaWYgKCEoc3RyIGluc3RhbmNlb2YgU3RyZWFtKSkge1xuICAgICAgICAgICAgc3RyZWFtID0gbmV3IFN0cmVhbShzdHIsIDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RyZWFtID0gc3RyO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdHJlYW1TdGFydCA9IG5ldyBTdHJlYW0oc3RyZWFtKTtcbiAgICAgICAgdmFyIHRhZyA9IG5ldyBBU04xVGFnKHN0cmVhbSk7XG4gICAgICAgIHZhciBsZW4gPSBBU04xLmRlY29kZUxlbmd0aChzdHJlYW0pO1xuICAgICAgICB2YXIgc3RhcnQgPSBzdHJlYW0ucG9zO1xuICAgICAgICB2YXIgaGVhZGVyID0gc3RhcnQgLSBzdHJlYW1TdGFydC5wb3M7XG4gICAgICAgIHZhciBzdWIgPSBudWxsO1xuICAgICAgICB2YXIgZ2V0U3ViID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJldCA9IFtdO1xuICAgICAgICAgICAgaWYgKGxlbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIGRlZmluaXRlIGxlbmd0aFxuICAgICAgICAgICAgICAgIHZhciBlbmQgPSBzdGFydCArIGxlbjtcbiAgICAgICAgICAgICAgICB3aGlsZSAoc3RyZWFtLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgICAgICAgICByZXRbcmV0Lmxlbmd0aF0gPSBBU04xLmRlY29kZShzdHJlYW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3RyZWFtLnBvcyAhPSBlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29udGVudCBzaXplIGlzIG5vdCBjb3JyZWN0IGZvciBjb250YWluZXIgc3RhcnRpbmcgYXQgb2Zmc2V0IFwiICsgc3RhcnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHVuZGVmaW5lZCBsZW5ndGhcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IEFTTjEuZGVjb2RlKHN0cmVhbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocy50YWcuaXNFT0MoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0W3JldC5sZW5ndGhdID0gcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZW4gPSBzdGFydCAtIHN0cmVhbS5wb3M7IC8vIHVuZGVmaW5lZCBsZW5ndGhzIGFyZSByZXByZXNlbnRlZCBhcyBuZWdhdGl2ZSB2YWx1ZXNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhjZXB0aW9uIHdoaWxlIGRlY29kaW5nIHVuZGVmaW5lZCBsZW5ndGggY29udGVudDogXCIgKyBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9O1xuICAgICAgICBpZiAodGFnLnRhZ0NvbnN0cnVjdGVkKSB7XG4gICAgICAgICAgICAvLyBtdXN0IGhhdmUgdmFsaWQgY29udGVudFxuICAgICAgICAgICAgc3ViID0gZ2V0U3ViKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGFnLmlzVW5pdmVyc2FsKCkgJiYgKCh0YWcudGFnTnVtYmVyID09IDB4MDMpIHx8ICh0YWcudGFnTnVtYmVyID09IDB4MDQpKSkge1xuICAgICAgICAgICAgLy8gc29tZXRpbWVzIEJpdFN0cmluZyBhbmQgT2N0ZXRTdHJpbmcgYXJlIHVzZWQgdG8gZW5jYXBzdWxhdGUgQVNOLjFcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHRhZy50YWdOdW1iZXIgPT0gMHgwMykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RyZWFtLmdldCgpICE9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJJVCBTVFJJTkdzIHdpdGggdW51c2VkIGJpdHMgY2Fubm90IGVuY2Fwc3VsYXRlLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdWIgPSBnZXRTdWIoKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN1Yi5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3ViW2ldLnRhZy5pc0VPQygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFT0MgaXMgbm90IHN1cHBvc2VkIHRvIGJlIGFjdHVhbCBjb250ZW50LlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLy8gYnV0IHNpbGVudGx5IGlnbm9yZSB3aGVuIHRoZXkgZG9uJ3RcbiAgICAgICAgICAgICAgICBzdWIgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdWIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChsZW4gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXZSBjYW4ndCBza2lwIG92ZXIgYW4gaW52YWxpZCB0YWcgd2l0aCB1bmRlZmluZWQgbGVuZ3RoIGF0IG9mZnNldCBcIiArIHN0YXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0cmVhbS5wb3MgPSBzdGFydCArIE1hdGguYWJzKGxlbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBBU04xKHN0cmVhbVN0YXJ0LCBoZWFkZXIsIGxlbiwgdGFnLCBzdWIpO1xuICAgIH07XG4gICAgcmV0dXJuIEFTTjE7XG59KCkpO1xuZXhwb3J0IHsgQVNOMSB9O1xudmFyIEFTTjFUYWcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQVNOMVRhZyhzdHJlYW0pIHtcbiAgICAgICAgdmFyIGJ1ZiA9IHN0cmVhbS5nZXQoKTtcbiAgICAgICAgdGhpcy50YWdDbGFzcyA9IGJ1ZiA+PiA2O1xuICAgICAgICB0aGlzLnRhZ0NvbnN0cnVjdGVkID0gKChidWYgJiAweDIwKSAhPT0gMCk7XG4gICAgICAgIHRoaXMudGFnTnVtYmVyID0gYnVmICYgMHgxRjtcbiAgICAgICAgaWYgKHRoaXMudGFnTnVtYmVyID09IDB4MUYpIHsgLy8gbG9uZyB0YWdcbiAgICAgICAgICAgIHZhciBuID0gbmV3IEludDEwKCk7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgYnVmID0gc3RyZWFtLmdldCgpO1xuICAgICAgICAgICAgICAgIG4ubXVsQWRkKDEyOCwgYnVmICYgMHg3Rik7XG4gICAgICAgICAgICB9IHdoaWxlIChidWYgJiAweDgwKTtcbiAgICAgICAgICAgIHRoaXMudGFnTnVtYmVyID0gbi5zaW1wbGlmeSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIEFTTjFUYWcucHJvdG90eXBlLmlzVW5pdmVyc2FsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50YWdDbGFzcyA9PT0gMHgwMDtcbiAgICB9O1xuICAgIEFTTjFUYWcucHJvdG90eXBlLmlzRU9DID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50YWdDbGFzcyA9PT0gMHgwMCAmJiB0aGlzLnRhZ051bWJlciA9PT0gMHgwMDtcbiAgICB9O1xuICAgIHJldHVybiBBU04xVGFnO1xufSgpKTtcbmV4cG9ydCB7IEFTTjFUYWcgfTtcbiIsIi8vIENvcHlyaWdodCAoYykgMjAwNSAgVG9tIFd1XG4vLyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy8gU2VlIFwiTElDRU5TRVwiIGZvciBkZXRhaWxzLlxuLy8gQmFzaWMgSmF2YVNjcmlwdCBCTiBsaWJyYXJ5IC0gc3Vic2V0IHVzZWZ1bCBmb3IgUlNBIGVuY3J5cHRpb24uXG5pbXBvcnQgeyBjYml0LCBpbnQyY2hhciwgbGJpdCwgb3BfYW5kLCBvcF9hbmRub3QsIG9wX29yLCBvcF94b3IgfSBmcm9tIFwiLi91dGlsXCI7XG4vLyBCaXRzIHBlciBkaWdpdFxudmFyIGRiaXRzO1xuLy8gSmF2YVNjcmlwdCBlbmdpbmUgYW5hbHlzaXNcbnZhciBjYW5hcnkgPSAweGRlYWRiZWVmY2FmZTtcbnZhciBqX2xtID0gKChjYW5hcnkgJiAweGZmZmZmZikgPT0gMHhlZmNhZmUpO1xuLy8jcmVnaW9uXG52YXIgbG93cHJpbWVzID0gWzIsIDMsIDUsIDcsIDExLCAxMywgMTcsIDE5LCAyMywgMjksIDMxLCAzNywgNDEsIDQzLCA0NywgNTMsIDU5LCA2MSwgNjcsIDcxLCA3MywgNzksIDgzLCA4OSwgOTcsIDEwMSwgMTAzLCAxMDcsIDEwOSwgMTEzLCAxMjcsIDEzMSwgMTM3LCAxMzksIDE0OSwgMTUxLCAxNTcsIDE2MywgMTY3LCAxNzMsIDE3OSwgMTgxLCAxOTEsIDE5MywgMTk3LCAxOTksIDIxMSwgMjIzLCAyMjcsIDIyOSwgMjMzLCAyMzksIDI0MSwgMjUxLCAyNTcsIDI2MywgMjY5LCAyNzEsIDI3NywgMjgxLCAyODMsIDI5MywgMzA3LCAzMTEsIDMxMywgMzE3LCAzMzEsIDMzNywgMzQ3LCAzNDksIDM1MywgMzU5LCAzNjcsIDM3MywgMzc5LCAzODMsIDM4OSwgMzk3LCA0MDEsIDQwOSwgNDE5LCA0MjEsIDQzMSwgNDMzLCA0MzksIDQ0MywgNDQ5LCA0NTcsIDQ2MSwgNDYzLCA0NjcsIDQ3OSwgNDg3LCA0OTEsIDQ5OSwgNTAzLCA1MDksIDUyMSwgNTIzLCA1NDEsIDU0NywgNTU3LCA1NjMsIDU2OSwgNTcxLCA1NzcsIDU4NywgNTkzLCA1OTksIDYwMSwgNjA3LCA2MTMsIDYxNywgNjE5LCA2MzEsIDY0MSwgNjQzLCA2NDcsIDY1MywgNjU5LCA2NjEsIDY3MywgNjc3LCA2ODMsIDY5MSwgNzAxLCA3MDksIDcxOSwgNzI3LCA3MzMsIDczOSwgNzQzLCA3NTEsIDc1NywgNzYxLCA3NjksIDc3MywgNzg3LCA3OTcsIDgwOSwgODExLCA4MjEsIDgyMywgODI3LCA4MjksIDgzOSwgODUzLCA4NTcsIDg1OSwgODYzLCA4NzcsIDg4MSwgODgzLCA4ODcsIDkwNywgOTExLCA5MTksIDkyOSwgOTM3LCA5NDEsIDk0NywgOTUzLCA5NjcsIDk3MSwgOTc3LCA5ODMsIDk5MSwgOTk3XTtcbnZhciBscGxpbSA9ICgxIDw8IDI2KSAvIGxvd3ByaW1lc1tsb3dwcmltZXMubGVuZ3RoIC0gMV07XG4vLyNlbmRyZWdpb25cbi8vIChwdWJsaWMpIENvbnN0cnVjdG9yXG52YXIgQmlnSW50ZWdlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCaWdJbnRlZ2VyKGEsIGIsIGMpIHtcbiAgICAgICAgaWYgKGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKFwibnVtYmVyXCIgPT0gdHlwZW9mIGEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZyb21OdW1iZXIoYSwgYiwgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiID09IG51bGwgJiYgXCJzdHJpbmdcIiAhPSB0eXBlb2YgYSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZnJvbVN0cmluZyhhLCAyNTYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mcm9tU3RyaW5nKGEsIGIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vI3JlZ2lvbiBQVUJMSUNcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS50b1N0cmluZyA9IGJuVG9TdHJpbmc7XG4gICAgLy8gKHB1YmxpYykgcmV0dXJuIHN0cmluZyByZXByZXNlbnRhdGlvbiBpbiBnaXZlbiByYWRpeFxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgaWYgKHRoaXMucyA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBcIi1cIiArIHRoaXMubmVnYXRlKCkudG9TdHJpbmcoYik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGs7XG4gICAgICAgIGlmIChiID09IDE2KSB7XG4gICAgICAgICAgICBrID0gNDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChiID09IDgpIHtcbiAgICAgICAgICAgIGsgPSAzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGIgPT0gMikge1xuICAgICAgICAgICAgayA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYiA9PSAzMikge1xuICAgICAgICAgICAgayA9IDU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYiA9PSA0KSB7XG4gICAgICAgICAgICBrID0gMjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvUmFkaXgoYik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGttID0gKDEgPDwgaykgLSAxO1xuICAgICAgICB2YXIgZDtcbiAgICAgICAgdmFyIG0gPSBmYWxzZTtcbiAgICAgICAgdmFyIHIgPSBcIlwiO1xuICAgICAgICB2YXIgaSA9IHRoaXMudDtcbiAgICAgICAgdmFyIHAgPSB0aGlzLkRCIC0gKGkgKiB0aGlzLkRCKSAlIGs7XG4gICAgICAgIGlmIChpLS0gPiAwKSB7XG4gICAgICAgICAgICBpZiAocCA8IHRoaXMuREIgJiYgKGQgPSB0aGlzW2ldID4+IHApID4gMCkge1xuICAgICAgICAgICAgICAgIG0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHIgPSBpbnQyY2hhcihkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChpID49IDApIHtcbiAgICAgICAgICAgICAgICBpZiAocCA8IGspIHtcbiAgICAgICAgICAgICAgICAgICAgZCA9ICh0aGlzW2ldICYgKCgxIDw8IHApIC0gMSkpIDw8IChrIC0gcCk7XG4gICAgICAgICAgICAgICAgICAgIGQgfD0gdGhpc1stLWldID4+IChwICs9IHRoaXMuREIgLSBrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGQgPSAodGhpc1tpXSA+PiAocCAtPSBrKSkgJiBrbTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHAgPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcCArPSB0aGlzLkRCO1xuICAgICAgICAgICAgICAgICAgICAgICAgLS1pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBtID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG0pIHtcbiAgICAgICAgICAgICAgICAgICAgciArPSBpbnQyY2hhcihkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG0gPyByIDogXCIwXCI7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5uZWdhdGUgPSBibk5lZ2F0ZTtcbiAgICAvLyAocHVibGljKSAtdGhpc1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm5lZ2F0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHIgPSBuYmkoKTtcbiAgICAgICAgQmlnSW50ZWdlci5aRVJPLnN1YlRvKHRoaXMsIHIpO1xuICAgICAgICByZXR1cm4gcjtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLmFicyA9IGJuQWJzO1xuICAgIC8vIChwdWJsaWMpIHx0aGlzfFxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmFicyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnMgPCAwKSA/IHRoaXMubmVnYXRlKCkgOiB0aGlzO1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuY29tcGFyZVRvID0gYm5Db21wYXJlVG87XG4gICAgLy8gKHB1YmxpYykgcmV0dXJuICsgaWYgdGhpcyA+IGEsIC0gaWYgdGhpcyA8IGEsIDAgaWYgZXF1YWxcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5jb21wYXJlVG8gPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgciA9IHRoaXMucyAtIGEucztcbiAgICAgICAgaWYgKHIgIT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGkgPSB0aGlzLnQ7XG4gICAgICAgIHIgPSBpIC0gYS50O1xuICAgICAgICBpZiAociAhPSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMucyA8IDApID8gLXIgOiByO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlICgtLWkgPj0gMCkge1xuICAgICAgICAgICAgaWYgKChyID0gdGhpc1tpXSAtIGFbaV0pICE9IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLmJpdExlbmd0aCA9IGJuQml0TGVuZ3RoO1xuICAgIC8vIChwdWJsaWMpIHJldHVybiB0aGUgbnVtYmVyIG9mIGJpdHMgaW4gXCJ0aGlzXCJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5iaXRMZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnQgPD0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuREIgKiAodGhpcy50IC0gMSkgKyBuYml0cyh0aGlzW3RoaXMudCAtIDFdIF4gKHRoaXMucyAmIHRoaXMuRE0pKTtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLm1vZCA9IGJuTW9kO1xuICAgIC8vIChwdWJsaWMpIHRoaXMgbW9kIGFcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5tb2QgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgciA9IG5iaSgpO1xuICAgICAgICB0aGlzLmFicygpLmRpdlJlbVRvKGEsIG51bGwsIHIpO1xuICAgICAgICBpZiAodGhpcy5zIDwgMCAmJiByLmNvbXBhcmVUbyhCaWdJbnRlZ2VyLlpFUk8pID4gMCkge1xuICAgICAgICAgICAgYS5zdWJUbyhyLCByKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcjtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLm1vZFBvd0ludCA9IGJuTW9kUG93SW50O1xuICAgIC8vIChwdWJsaWMpIHRoaXNeZSAlIG0sIDAgPD0gZSA8IDJeMzJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5tb2RQb3dJbnQgPSBmdW5jdGlvbiAoZSwgbSkge1xuICAgICAgICB2YXIgejtcbiAgICAgICAgaWYgKGUgPCAyNTYgfHwgbS5pc0V2ZW4oKSkge1xuICAgICAgICAgICAgeiA9IG5ldyBDbGFzc2ljKG0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgeiA9IG5ldyBNb250Z29tZXJ5KG0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmV4cChlLCB6KTtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLmNsb25lID0gYm5DbG9uZTtcbiAgICAvLyAocHVibGljKVxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgciA9IG5iaSgpO1xuICAgICAgICB0aGlzLmNvcHlUbyhyKTtcbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5pbnRWYWx1ZSA9IGJuSW50VmFsdWU7XG4gICAgLy8gKHB1YmxpYykgcmV0dXJuIHZhbHVlIGFzIGludGVnZXJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5pbnRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMucyA8IDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnQgPT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzWzBdIC0gdGhpcy5EVjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMudCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMudCA9PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1swXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnQgPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYXNzdW1lcyAxNiA8IERCIDwgMzJcbiAgICAgICAgcmV0dXJuICgodGhpc1sxXSAmICgoMSA8PCAoMzIgLSB0aGlzLkRCKSkgLSAxKSkgPDwgdGhpcy5EQikgfCB0aGlzWzBdO1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuYnl0ZVZhbHVlID0gYm5CeXRlVmFsdWU7XG4gICAgLy8gKHB1YmxpYykgcmV0dXJuIHZhbHVlIGFzIGJ5dGVcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5ieXRlVmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy50ID09IDApID8gdGhpcy5zIDogKHRoaXNbMF0gPDwgMjQpID4+IDI0O1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuc2hvcnRWYWx1ZSA9IGJuU2hvcnRWYWx1ZTtcbiAgICAvLyAocHVibGljKSByZXR1cm4gdmFsdWUgYXMgc2hvcnQgKGFzc3VtZXMgREI+PTE2KVxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnNob3J0VmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy50ID09IDApID8gdGhpcy5zIDogKHRoaXNbMF0gPDwgMTYpID4+IDE2O1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuc2lnbnVtID0gYm5TaWdOdW07XG4gICAgLy8gKHB1YmxpYykgMCBpZiB0aGlzID09IDAsIDEgaWYgdGhpcyA+IDBcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5zaWdudW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnMgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy50IDw9IDAgfHwgKHRoaXMudCA9PSAxICYmIHRoaXNbMF0gPD0gMCkpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLnRvQnl0ZUFycmF5ID0gYm5Ub0J5dGVBcnJheTtcbiAgICAvLyAocHVibGljKSBjb252ZXJ0IHRvIGJpZ2VuZGlhbiBieXRlIGFycmF5XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUudG9CeXRlQXJyYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpID0gdGhpcy50O1xuICAgICAgICB2YXIgciA9IFtdO1xuICAgICAgICByWzBdID0gdGhpcy5zO1xuICAgICAgICB2YXIgcCA9IHRoaXMuREIgLSAoaSAqIHRoaXMuREIpICUgODtcbiAgICAgICAgdmFyIGQ7XG4gICAgICAgIHZhciBrID0gMDtcbiAgICAgICAgaWYgKGktLSA+IDApIHtcbiAgICAgICAgICAgIGlmIChwIDwgdGhpcy5EQiAmJiAoZCA9IHRoaXNbaV0gPj4gcCkgIT0gKHRoaXMucyAmIHRoaXMuRE0pID4+IHApIHtcbiAgICAgICAgICAgICAgICByW2srK10gPSBkIHwgKHRoaXMucyA8PCAodGhpcy5EQiAtIHApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChpID49IDApIHtcbiAgICAgICAgICAgICAgICBpZiAocCA8IDgpIHtcbiAgICAgICAgICAgICAgICAgICAgZCA9ICh0aGlzW2ldICYgKCgxIDw8IHApIC0gMSkpIDw8ICg4IC0gcCk7XG4gICAgICAgICAgICAgICAgICAgIGQgfD0gdGhpc1stLWldID4+IChwICs9IHRoaXMuREIgLSA4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGQgPSAodGhpc1tpXSA+PiAocCAtPSA4KSkgJiAweGZmO1xuICAgICAgICAgICAgICAgICAgICBpZiAocCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwICs9IHRoaXMuREI7XG4gICAgICAgICAgICAgICAgICAgICAgICAtLWk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKChkICYgMHg4MCkgIT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBkIHw9IC0yNTY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChrID09IDAgJiYgKHRoaXMucyAmIDB4ODApICE9IChkICYgMHg4MCkpIHtcbiAgICAgICAgICAgICAgICAgICAgKytrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoayA+IDAgfHwgZCAhPSB0aGlzLnMpIHtcbiAgICAgICAgICAgICAgICAgICAgcltrKytdID0gZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5lcXVhbHMgPSBibkVxdWFscztcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICByZXR1cm4gKHRoaXMuY29tcGFyZVRvKGEpID09IDApO1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUubWluID0gYm5NaW47XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUubWluID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmNvbXBhcmVUbyhhKSA8IDApID8gdGhpcyA6IGE7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5tYXggPSBibk1heDtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5tYXggPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICByZXR1cm4gKHRoaXMuY29tcGFyZVRvKGEpID4gMCkgPyB0aGlzIDogYTtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLmFuZCA9IGJuQW5kO1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmFuZCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHZhciByID0gbmJpKCk7XG4gICAgICAgIHRoaXMuYml0d2lzZVRvKGEsIG9wX2FuZCwgcik7XG4gICAgICAgIHJldHVybiByO1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUub3IgPSBibk9yO1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm9yID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIHIgPSBuYmkoKTtcbiAgICAgICAgdGhpcy5iaXR3aXNlVG8oYSwgb3Bfb3IsIHIpO1xuICAgICAgICByZXR1cm4gcjtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLnhvciA9IGJuWG9yO1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnhvciA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHZhciByID0gbmJpKCk7XG4gICAgICAgIHRoaXMuYml0d2lzZVRvKGEsIG9wX3hvciwgcik7XG4gICAgICAgIHJldHVybiByO1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuYW5kTm90ID0gYm5BbmROb3Q7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuYW5kTm90ID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIHIgPSBuYmkoKTtcbiAgICAgICAgdGhpcy5iaXR3aXNlVG8oYSwgb3BfYW5kbm90LCByKTtcbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5ub3QgPSBibk5vdDtcbiAgICAvLyAocHVibGljKSB+dGhpc1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm5vdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHIgPSBuYmkoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnQ7ICsraSkge1xuICAgICAgICAgICAgcltpXSA9IHRoaXMuRE0gJiB+dGhpc1tpXTtcbiAgICAgICAgfVxuICAgICAgICByLnQgPSB0aGlzLnQ7XG4gICAgICAgIHIucyA9IH50aGlzLnM7XG4gICAgICAgIHJldHVybiByO1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuc2hpZnRMZWZ0ID0gYm5TaGlmdExlZnQ7XG4gICAgLy8gKHB1YmxpYykgdGhpcyA8PCBuXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuc2hpZnRMZWZ0ID0gZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgdmFyIHIgPSBuYmkoKTtcbiAgICAgICAgaWYgKG4gPCAwKSB7XG4gICAgICAgICAgICB0aGlzLnJTaGlmdFRvKC1uLCByKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubFNoaWZ0VG8obiwgcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5zaGlmdFJpZ2h0ID0gYm5TaGlmdFJpZ2h0O1xuICAgIC8vIChwdWJsaWMpIHRoaXMgPj4gblxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnNoaWZ0UmlnaHQgPSBmdW5jdGlvbiAobikge1xuICAgICAgICB2YXIgciA9IG5iaSgpO1xuICAgICAgICBpZiAobiA8IDApIHtcbiAgICAgICAgICAgIHRoaXMubFNoaWZ0VG8oLW4sIHIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yU2hpZnRUbyhuLCByKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcjtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLmdldExvd2VzdFNldEJpdCA9IGJuR2V0TG93ZXN0U2V0Qml0O1xuICAgIC8vIChwdWJsaWMpIHJldHVybnMgaW5kZXggb2YgbG93ZXN0IDEtYml0IChvciAtMSBpZiBub25lKVxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmdldExvd2VzdFNldEJpdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnQ7ICsraSkge1xuICAgICAgICAgICAgaWYgKHRoaXNbaV0gIT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpICogdGhpcy5EQiArIGxiaXQodGhpc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucyA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnQgKiB0aGlzLkRCO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLmJpdENvdW50ID0gYm5CaXRDb3VudDtcbiAgICAvLyAocHVibGljKSByZXR1cm4gbnVtYmVyIG9mIHNldCBiaXRzXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuYml0Q291bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByID0gMDtcbiAgICAgICAgdmFyIHggPSB0aGlzLnMgJiB0aGlzLkRNO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudDsgKytpKSB7XG4gICAgICAgICAgICByICs9IGNiaXQodGhpc1tpXSBeIHgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByO1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUudGVzdEJpdCA9IGJuVGVzdEJpdDtcbiAgICAvLyAocHVibGljKSB0cnVlIGlmZiBudGggYml0IGlzIHNldFxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnRlc3RCaXQgPSBmdW5jdGlvbiAobikge1xuICAgICAgICB2YXIgaiA9IE1hdGguZmxvb3IobiAvIHRoaXMuREIpO1xuICAgICAgICBpZiAoaiA+PSB0aGlzLnQpIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5zICE9IDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoKHRoaXNbal0gJiAoMSA8PCAobiAlIHRoaXMuREIpKSkgIT0gMCk7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5zZXRCaXQgPSBiblNldEJpdDtcbiAgICAvLyAocHVibGljKSB0aGlzIHwgKDE8PG4pXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuc2V0Qml0ID0gZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbmdlQml0KG4sIG9wX29yKTtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLmNsZWFyQml0ID0gYm5DbGVhckJpdDtcbiAgICAvLyAocHVibGljKSB0aGlzICYgfigxPDxuKVxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmNsZWFyQml0ID0gZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbmdlQml0KG4sIG9wX2FuZG5vdCk7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5mbGlwQml0ID0gYm5GbGlwQml0O1xuICAgIC8vIChwdWJsaWMpIHRoaXMgXiAoMTw8bilcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5mbGlwQml0ID0gZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbmdlQml0KG4sIG9wX3hvcik7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5hZGQgPSBibkFkZDtcbiAgICAvLyAocHVibGljKSB0aGlzICsgYVxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHZhciByID0gbmJpKCk7XG4gICAgICAgIHRoaXMuYWRkVG8oYSwgcik7XG4gICAgICAgIHJldHVybiByO1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuc3VidHJhY3QgPSBiblN1YnRyYWN0O1xuICAgIC8vIChwdWJsaWMpIHRoaXMgLSBhXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuc3VidHJhY3QgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgciA9IG5iaSgpO1xuICAgICAgICB0aGlzLnN1YlRvKGEsIHIpO1xuICAgICAgICByZXR1cm4gcjtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLm11bHRpcGx5ID0gYm5NdWx0aXBseTtcbiAgICAvLyAocHVibGljKSB0aGlzICogYVxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm11bHRpcGx5ID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIHIgPSBuYmkoKTtcbiAgICAgICAgdGhpcy5tdWx0aXBseVRvKGEsIHIpO1xuICAgICAgICByZXR1cm4gcjtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLmRpdmlkZSA9IGJuRGl2aWRlO1xuICAgIC8vIChwdWJsaWMpIHRoaXMgLyBhXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuZGl2aWRlID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIHIgPSBuYmkoKTtcbiAgICAgICAgdGhpcy5kaXZSZW1UbyhhLCByLCBudWxsKTtcbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5yZW1haW5kZXIgPSBiblJlbWFpbmRlcjtcbiAgICAvLyAocHVibGljKSB0aGlzICUgYVxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnJlbWFpbmRlciA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHZhciByID0gbmJpKCk7XG4gICAgICAgIHRoaXMuZGl2UmVtVG8oYSwgbnVsbCwgcik7XG4gICAgICAgIHJldHVybiByO1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuZGl2aWRlQW5kUmVtYWluZGVyID0gYm5EaXZpZGVBbmRSZW1haW5kZXI7XG4gICAgLy8gKHB1YmxpYykgW3RoaXMvYSx0aGlzJWFdXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuZGl2aWRlQW5kUmVtYWluZGVyID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIHEgPSBuYmkoKTtcbiAgICAgICAgdmFyIHIgPSBuYmkoKTtcbiAgICAgICAgdGhpcy5kaXZSZW1UbyhhLCBxLCByKTtcbiAgICAgICAgcmV0dXJuIFtxLCByXTtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLm1vZFBvdyA9IGJuTW9kUG93O1xuICAgIC8vIChwdWJsaWMpIHRoaXNeZSAlIG0gKEhBQyAxNC44NSlcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5tb2RQb3cgPSBmdW5jdGlvbiAoZSwgbSkge1xuICAgICAgICB2YXIgaSA9IGUuYml0TGVuZ3RoKCk7XG4gICAgICAgIHZhciBrO1xuICAgICAgICB2YXIgciA9IG5idigxKTtcbiAgICAgICAgdmFyIHo7XG4gICAgICAgIGlmIChpIDw9IDApIHtcbiAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGkgPCAxOCkge1xuICAgICAgICAgICAgayA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaSA8IDQ4KSB7XG4gICAgICAgICAgICBrID0gMztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpIDwgMTQ0KSB7XG4gICAgICAgICAgICBrID0gNDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpIDwgNzY4KSB7XG4gICAgICAgICAgICBrID0gNTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGsgPSA2O1xuICAgICAgICB9XG4gICAgICAgIGlmIChpIDwgOCkge1xuICAgICAgICAgICAgeiA9IG5ldyBDbGFzc2ljKG0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG0uaXNFdmVuKCkpIHtcbiAgICAgICAgICAgIHogPSBuZXcgQmFycmV0dChtKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHogPSBuZXcgTW9udGdvbWVyeShtKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBwcmVjb21wdXRhdGlvblxuICAgICAgICB2YXIgZyA9IFtdO1xuICAgICAgICB2YXIgbiA9IDM7XG4gICAgICAgIHZhciBrMSA9IGsgLSAxO1xuICAgICAgICB2YXIga20gPSAoMSA8PCBrKSAtIDE7XG4gICAgICAgIGdbMV0gPSB6LmNvbnZlcnQodGhpcyk7XG4gICAgICAgIGlmIChrID4gMSkge1xuICAgICAgICAgICAgdmFyIGcyID0gbmJpKCk7XG4gICAgICAgICAgICB6LnNxclRvKGdbMV0sIGcyKTtcbiAgICAgICAgICAgIHdoaWxlIChuIDw9IGttKSB7XG4gICAgICAgICAgICAgICAgZ1tuXSA9IG5iaSgpO1xuICAgICAgICAgICAgICAgIHoubXVsVG8oZzIsIGdbbiAtIDJdLCBnW25dKTtcbiAgICAgICAgICAgICAgICBuICs9IDI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGogPSBlLnQgLSAxO1xuICAgICAgICB2YXIgdztcbiAgICAgICAgdmFyIGlzMSA9IHRydWU7XG4gICAgICAgIHZhciByMiA9IG5iaSgpO1xuICAgICAgICB2YXIgdDtcbiAgICAgICAgaSA9IG5iaXRzKGVbal0pIC0gMTtcbiAgICAgICAgd2hpbGUgKGogPj0gMCkge1xuICAgICAgICAgICAgaWYgKGkgPj0gazEpIHtcbiAgICAgICAgICAgICAgICB3ID0gKGVbal0gPj4gKGkgLSBrMSkpICYga207XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB3ID0gKGVbal0gJiAoKDEgPDwgKGkgKyAxKSkgLSAxKSkgPDwgKGsxIC0gaSk7XG4gICAgICAgICAgICAgICAgaWYgKGogPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHcgfD0gZVtqIC0gMV0gPj4gKHRoaXMuREIgKyBpIC0gazEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG4gPSBrO1xuICAgICAgICAgICAgd2hpbGUgKCh3ICYgMSkgPT0gMCkge1xuICAgICAgICAgICAgICAgIHcgPj49IDE7XG4gICAgICAgICAgICAgICAgLS1uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChpIC09IG4pIDwgMCkge1xuICAgICAgICAgICAgICAgIGkgKz0gdGhpcy5EQjtcbiAgICAgICAgICAgICAgICAtLWo7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXMxKSB7IC8vIHJldCA9PSAxLCBkb24ndCBib3RoZXIgc3F1YXJpbmcgb3IgbXVsdGlwbHlpbmcgaXRcbiAgICAgICAgICAgICAgICBnW3ddLmNvcHlUbyhyKTtcbiAgICAgICAgICAgICAgICBpczEgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHdoaWxlIChuID4gMSkge1xuICAgICAgICAgICAgICAgICAgICB6LnNxclRvKHIsIHIyKTtcbiAgICAgICAgICAgICAgICAgICAgei5zcXJUbyhyMiwgcik7XG4gICAgICAgICAgICAgICAgICAgIG4gLT0gMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG4gPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHouc3FyVG8ociwgcjIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdCA9IHI7XG4gICAgICAgICAgICAgICAgICAgIHIgPSByMjtcbiAgICAgICAgICAgICAgICAgICAgcjIgPSB0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB6Lm11bFRvKHIyLCBnW3ddLCByKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChqID49IDAgJiYgKGVbal0gJiAoMSA8PCBpKSkgPT0gMCkge1xuICAgICAgICAgICAgICAgIHouc3FyVG8ociwgcjIpO1xuICAgICAgICAgICAgICAgIHQgPSByO1xuICAgICAgICAgICAgICAgIHIgPSByMjtcbiAgICAgICAgICAgICAgICByMiA9IHQ7XG4gICAgICAgICAgICAgICAgaWYgKC0taSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaSA9IHRoaXMuREIgLSAxO1xuICAgICAgICAgICAgICAgICAgICAtLWo7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB6LnJldmVydChyKTtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLm1vZEludmVyc2UgPSBibk1vZEludmVyc2U7XG4gICAgLy8gKHB1YmxpYykgMS90aGlzICUgbSAoSEFDIDE0LjYxKVxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm1vZEludmVyc2UgPSBmdW5jdGlvbiAobSkge1xuICAgICAgICB2YXIgYWMgPSBtLmlzRXZlbigpO1xuICAgICAgICBpZiAoKHRoaXMuaXNFdmVuKCkgJiYgYWMpIHx8IG0uc2lnbnVtKCkgPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIEJpZ0ludGVnZXIuWkVSTztcbiAgICAgICAgfVxuICAgICAgICB2YXIgdSA9IG0uY2xvbmUoKTtcbiAgICAgICAgdmFyIHYgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIHZhciBhID0gbmJ2KDEpO1xuICAgICAgICB2YXIgYiA9IG5idigwKTtcbiAgICAgICAgdmFyIGMgPSBuYnYoMCk7XG4gICAgICAgIHZhciBkID0gbmJ2KDEpO1xuICAgICAgICB3aGlsZSAodS5zaWdudW0oKSAhPSAwKSB7XG4gICAgICAgICAgICB3aGlsZSAodS5pc0V2ZW4oKSkge1xuICAgICAgICAgICAgICAgIHUuclNoaWZ0VG8oMSwgdSk7XG4gICAgICAgICAgICAgICAgaWYgKGFjKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYS5pc0V2ZW4oKSB8fCAhYi5pc0V2ZW4oKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYS5hZGRUbyh0aGlzLCBhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGIuc3ViVG8obSwgYik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYS5yU2hpZnRUbygxLCBhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWIuaXNFdmVuKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYi5zdWJUbyhtLCBiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYi5yU2hpZnRUbygxLCBiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlICh2LmlzRXZlbigpKSB7XG4gICAgICAgICAgICAgICAgdi5yU2hpZnRUbygxLCB2KTtcbiAgICAgICAgICAgICAgICBpZiAoYWMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjLmlzRXZlbigpIHx8ICFkLmlzRXZlbigpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjLmFkZFRvKHRoaXMsIGMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZC5zdWJUbyhtLCBkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjLnJTaGlmdFRvKDEsIGMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghZC5pc0V2ZW4oKSkge1xuICAgICAgICAgICAgICAgICAgICBkLnN1YlRvKG0sIGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkLnJTaGlmdFRvKDEsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHUuY29tcGFyZVRvKHYpID49IDApIHtcbiAgICAgICAgICAgICAgICB1LnN1YlRvKHYsIHUpO1xuICAgICAgICAgICAgICAgIGlmIChhYykge1xuICAgICAgICAgICAgICAgICAgICBhLnN1YlRvKGMsIGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBiLnN1YlRvKGQsIGIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdi5zdWJUbyh1LCB2KTtcbiAgICAgICAgICAgICAgICBpZiAoYWMpIHtcbiAgICAgICAgICAgICAgICAgICAgYy5zdWJUbyhhLCBjKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZC5zdWJUbyhiLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodi5jb21wYXJlVG8oQmlnSW50ZWdlci5PTkUpICE9IDApIHtcbiAgICAgICAgICAgIHJldHVybiBCaWdJbnRlZ2VyLlpFUk87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGQuY29tcGFyZVRvKG0pID49IDApIHtcbiAgICAgICAgICAgIHJldHVybiBkLnN1YnRyYWN0KG0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkLnNpZ251bSgpIDwgMCkge1xuICAgICAgICAgICAgZC5hZGRUbyhtLCBkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkLnNpZ251bSgpIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIGQuYWRkKG0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLnBvdyA9IGJuUG93O1xuICAgIC8vIChwdWJsaWMpIHRoaXNeZVxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnBvdyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV4cChlLCBuZXcgTnVsbEV4cCgpKTtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLmdjZCA9IGJuR0NEO1xuICAgIC8vIChwdWJsaWMpIGdjZCh0aGlzLGEpIChIQUMgMTQuNTQpXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuZ2NkID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIHggPSAodGhpcy5zIDwgMCkgPyB0aGlzLm5lZ2F0ZSgpIDogdGhpcy5jbG9uZSgpO1xuICAgICAgICB2YXIgeSA9IChhLnMgPCAwKSA/IGEubmVnYXRlKCkgOiBhLmNsb25lKCk7XG4gICAgICAgIGlmICh4LmNvbXBhcmVUbyh5KSA8IDApIHtcbiAgICAgICAgICAgIHZhciB0ID0geDtcbiAgICAgICAgICAgIHggPSB5O1xuICAgICAgICAgICAgeSA9IHQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGkgPSB4LmdldExvd2VzdFNldEJpdCgpO1xuICAgICAgICB2YXIgZyA9IHkuZ2V0TG93ZXN0U2V0Qml0KCk7XG4gICAgICAgIGlmIChnIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPCBnKSB7XG4gICAgICAgICAgICBnID0gaTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZyA+IDApIHtcbiAgICAgICAgICAgIHguclNoaWZ0VG8oZywgeCk7XG4gICAgICAgICAgICB5LnJTaGlmdFRvKGcsIHkpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlICh4LnNpZ251bSgpID4gMCkge1xuICAgICAgICAgICAgaWYgKChpID0geC5nZXRMb3dlc3RTZXRCaXQoKSkgPiAwKSB7XG4gICAgICAgICAgICAgICAgeC5yU2hpZnRUbyhpLCB4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoaSA9IHkuZ2V0TG93ZXN0U2V0Qml0KCkpID4gMCkge1xuICAgICAgICAgICAgICAgIHkuclNoaWZ0VG8oaSwgeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeC5jb21wYXJlVG8oeSkgPj0gMCkge1xuICAgICAgICAgICAgICAgIHguc3ViVG8oeSwgeCk7XG4gICAgICAgICAgICAgICAgeC5yU2hpZnRUbygxLCB4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHkuc3ViVG8oeCwgeSk7XG4gICAgICAgICAgICAgICAgeS5yU2hpZnRUbygxLCB5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZyA+IDApIHtcbiAgICAgICAgICAgIHkubFNoaWZ0VG8oZywgeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHk7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5pc1Byb2JhYmxlUHJpbWUgPSBibklzUHJvYmFibGVQcmltZTtcbiAgICAvLyAocHVibGljKSB0ZXN0IHByaW1hbGl0eSB3aXRoIGNlcnRhaW50eSA+PSAxLS41XnRcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5pc1Byb2JhYmxlUHJpbWUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIHggPSB0aGlzLmFicygpO1xuICAgICAgICBpZiAoeC50ID09IDEgJiYgeFswXSA8PSBsb3dwcmltZXNbbG93cHJpbWVzLmxlbmd0aCAtIDFdKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbG93cHJpbWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHhbMF0gPT0gbG93cHJpbWVzW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeC5pc0V2ZW4oKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGkgPSAxO1xuICAgICAgICB3aGlsZSAoaSA8IGxvd3ByaW1lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBtID0gbG93cHJpbWVzW2ldO1xuICAgICAgICAgICAgdmFyIGogPSBpICsgMTtcbiAgICAgICAgICAgIHdoaWxlIChqIDwgbG93cHJpbWVzLmxlbmd0aCAmJiBtIDwgbHBsaW0pIHtcbiAgICAgICAgICAgICAgICBtICo9IGxvd3ByaW1lc1tqKytdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbSA9IHgubW9kSW50KG0pO1xuICAgICAgICAgICAgd2hpbGUgKGkgPCBqKSB7XG4gICAgICAgICAgICAgICAgaWYgKG0gJSBsb3dwcmltZXNbaSsrXSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHgubWlsbGVyUmFiaW4odCk7XG4gICAgfTtcbiAgICAvLyNlbmRyZWdpb24gUFVCTElDXG4gICAgLy8jcmVnaW9uIFBST1RFQ1RFRFxuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLmNvcHlUbyA9IGJucENvcHlUbztcbiAgICAvLyAocHJvdGVjdGVkKSBjb3B5IHRoaXMgdG8gclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmNvcHlUbyA9IGZ1bmN0aW9uIChyKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLnQgLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgcltpXSA9IHRoaXNbaV07XG4gICAgICAgIH1cbiAgICAgICAgci50ID0gdGhpcy50O1xuICAgICAgICByLnMgPSB0aGlzLnM7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5mcm9tSW50ID0gYm5wRnJvbUludDtcbiAgICAvLyAocHJvdGVjdGVkKSBzZXQgZnJvbSBpbnRlZ2VyIHZhbHVlIHgsIC1EViA8PSB4IDwgRFZcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5mcm9tSW50ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdGhpcy50ID0gMTtcbiAgICAgICAgdGhpcy5zID0gKHggPCAwKSA/IC0xIDogMDtcbiAgICAgICAgaWYgKHggPiAwKSB7XG4gICAgICAgICAgICB0aGlzWzBdID0geDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh4IDwgLTEpIHtcbiAgICAgICAgICAgIHRoaXNbMF0gPSB4ICsgdGhpcy5EVjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudCA9IDA7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLmZyb21TdHJpbmcgPSBibnBGcm9tU3RyaW5nO1xuICAgIC8vIChwcm90ZWN0ZWQpIHNldCBmcm9tIHN0cmluZyBhbmQgcmFkaXhcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5mcm9tU3RyaW5nID0gZnVuY3Rpb24gKHMsIGIpIHtcbiAgICAgICAgdmFyIGs7XG4gICAgICAgIGlmIChiID09IDE2KSB7XG4gICAgICAgICAgICBrID0gNDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChiID09IDgpIHtcbiAgICAgICAgICAgIGsgPSAzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGIgPT0gMjU2KSB7XG4gICAgICAgICAgICBrID0gODtcbiAgICAgICAgICAgIC8qIGJ5dGUgYXJyYXkgKi9cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChiID09IDIpIHtcbiAgICAgICAgICAgIGsgPSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGIgPT0gMzIpIHtcbiAgICAgICAgICAgIGsgPSA1O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGIgPT0gNCkge1xuICAgICAgICAgICAgayA9IDI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmZyb21SYWRpeChzLCBiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnQgPSAwO1xuICAgICAgICB0aGlzLnMgPSAwO1xuICAgICAgICB2YXIgaSA9IHMubGVuZ3RoO1xuICAgICAgICB2YXIgbWkgPSBmYWxzZTtcbiAgICAgICAgdmFyIHNoID0gMDtcbiAgICAgICAgd2hpbGUgKC0taSA+PSAwKSB7XG4gICAgICAgICAgICB2YXIgeCA9IChrID09IDgpID8gKCtzW2ldKSAmIDB4ZmYgOiBpbnRBdChzLCBpKTtcbiAgICAgICAgICAgIGlmICh4IDwgMCkge1xuICAgICAgICAgICAgICAgIGlmIChzLmNoYXJBdChpKSA9PSBcIi1cIikge1xuICAgICAgICAgICAgICAgICAgICBtaSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWkgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChzaCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpc1t0aGlzLnQrK10gPSB4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2ggKyBrID4gdGhpcy5EQikge1xuICAgICAgICAgICAgICAgIHRoaXNbdGhpcy50IC0gMV0gfD0gKHggJiAoKDEgPDwgKHRoaXMuREIgLSBzaCkpIC0gMSkpIDw8IHNoO1xuICAgICAgICAgICAgICAgIHRoaXNbdGhpcy50KytdID0gKHggPj4gKHRoaXMuREIgLSBzaCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpc1t0aGlzLnQgLSAxXSB8PSB4IDw8IHNoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2ggKz0gaztcbiAgICAgICAgICAgIGlmIChzaCA+PSB0aGlzLkRCKSB7XG4gICAgICAgICAgICAgICAgc2ggLT0gdGhpcy5EQjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoayA9PSA4ICYmICgoK3NbMF0pICYgMHg4MCkgIT0gMCkge1xuICAgICAgICAgICAgdGhpcy5zID0gLTE7XG4gICAgICAgICAgICBpZiAoc2ggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpc1t0aGlzLnQgLSAxXSB8PSAoKDEgPDwgKHRoaXMuREIgLSBzaCkpIC0gMSkgPDwgc2g7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbGFtcCgpO1xuICAgICAgICBpZiAobWkpIHtcbiAgICAgICAgICAgIEJpZ0ludGVnZXIuWkVSTy5zdWJUbyh0aGlzLCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuY2xhbXAgPSBibnBDbGFtcDtcbiAgICAvLyAocHJvdGVjdGVkKSBjbGFtcCBvZmYgZXhjZXNzIGhpZ2ggd29yZHNcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5jbGFtcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGMgPSB0aGlzLnMgJiB0aGlzLkRNO1xuICAgICAgICB3aGlsZSAodGhpcy50ID4gMCAmJiB0aGlzW3RoaXMudCAtIDFdID09IGMpIHtcbiAgICAgICAgICAgIC0tdGhpcy50O1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5kbFNoaWZ0VG8gPSBibnBETFNoaWZ0VG87XG4gICAgLy8gKHByb3RlY3RlZCkgciA9IHRoaXMgPDwgbipEQlxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmRsU2hpZnRUbyA9IGZ1bmN0aW9uIChuLCByKSB7XG4gICAgICAgIHZhciBpO1xuICAgICAgICBmb3IgKGkgPSB0aGlzLnQgLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgcltpICsgbl0gPSB0aGlzW2ldO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IG4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgcltpXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgci50ID0gdGhpcy50ICsgbjtcbiAgICAgICAgci5zID0gdGhpcy5zO1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuZHJTaGlmdFRvID0gYm5wRFJTaGlmdFRvO1xuICAgIC8vIChwcm90ZWN0ZWQpIHIgPSB0aGlzID4+IG4qREJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5kclNoaWZ0VG8gPSBmdW5jdGlvbiAobiwgcikge1xuICAgICAgICBmb3IgKHZhciBpID0gbjsgaSA8IHRoaXMudDsgKytpKSB7XG4gICAgICAgICAgICByW2kgLSBuXSA9IHRoaXNbaV07XG4gICAgICAgIH1cbiAgICAgICAgci50ID0gTWF0aC5tYXgodGhpcy50IC0gbiwgMCk7XG4gICAgICAgIHIucyA9IHRoaXMucztcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLmxTaGlmdFRvID0gYm5wTFNoaWZ0VG87XG4gICAgLy8gKHByb3RlY3RlZCkgciA9IHRoaXMgPDwgblxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmxTaGlmdFRvID0gZnVuY3Rpb24gKG4sIHIpIHtcbiAgICAgICAgdmFyIGJzID0gbiAlIHRoaXMuREI7XG4gICAgICAgIHZhciBjYnMgPSB0aGlzLkRCIC0gYnM7XG4gICAgICAgIHZhciBibSA9ICgxIDw8IGNicykgLSAxO1xuICAgICAgICB2YXIgZHMgPSBNYXRoLmZsb29yKG4gLyB0aGlzLkRCKTtcbiAgICAgICAgdmFyIGMgPSAodGhpcy5zIDw8IGJzKSAmIHRoaXMuRE07XG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLnQgLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgcltpICsgZHMgKyAxXSA9ICh0aGlzW2ldID4+IGNicykgfCBjO1xuICAgICAgICAgICAgYyA9ICh0aGlzW2ldICYgYm0pIDw8IGJzO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSBkcyAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICByW2ldID0gMDtcbiAgICAgICAgfVxuICAgICAgICByW2RzXSA9IGM7XG4gICAgICAgIHIudCA9IHRoaXMudCArIGRzICsgMTtcbiAgICAgICAgci5zID0gdGhpcy5zO1xuICAgICAgICByLmNsYW1wKCk7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5yU2hpZnRUbyA9IGJucFJTaGlmdFRvO1xuICAgIC8vIChwcm90ZWN0ZWQpIHIgPSB0aGlzID4+IG5cbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5yU2hpZnRUbyA9IGZ1bmN0aW9uIChuLCByKSB7XG4gICAgICAgIHIucyA9IHRoaXMucztcbiAgICAgICAgdmFyIGRzID0gTWF0aC5mbG9vcihuIC8gdGhpcy5EQik7XG4gICAgICAgIGlmIChkcyA+PSB0aGlzLnQpIHtcbiAgICAgICAgICAgIHIudCA9IDA7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJzID0gbiAlIHRoaXMuREI7XG4gICAgICAgIHZhciBjYnMgPSB0aGlzLkRCIC0gYnM7XG4gICAgICAgIHZhciBibSA9ICgxIDw8IGJzKSAtIDE7XG4gICAgICAgIHJbMF0gPSB0aGlzW2RzXSA+PiBicztcbiAgICAgICAgZm9yICh2YXIgaSA9IGRzICsgMTsgaSA8IHRoaXMudDsgKytpKSB7XG4gICAgICAgICAgICByW2kgLSBkcyAtIDFdIHw9ICh0aGlzW2ldICYgYm0pIDw8IGNicztcbiAgICAgICAgICAgIHJbaSAtIGRzXSA9IHRoaXNbaV0gPj4gYnM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJzID4gMCkge1xuICAgICAgICAgICAgclt0aGlzLnQgLSBkcyAtIDFdIHw9ICh0aGlzLnMgJiBibSkgPDwgY2JzO1xuICAgICAgICB9XG4gICAgICAgIHIudCA9IHRoaXMudCAtIGRzO1xuICAgICAgICByLmNsYW1wKCk7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5zdWJUbyA9IGJucFN1YlRvO1xuICAgIC8vIChwcm90ZWN0ZWQpIHIgPSB0aGlzIC0gYVxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnN1YlRvID0gZnVuY3Rpb24gKGEsIHIpIHtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgYyA9IDA7XG4gICAgICAgIHZhciBtID0gTWF0aC5taW4oYS50LCB0aGlzLnQpO1xuICAgICAgICB3aGlsZSAoaSA8IG0pIHtcbiAgICAgICAgICAgIGMgKz0gdGhpc1tpXSAtIGFbaV07XG4gICAgICAgICAgICByW2krK10gPSBjICYgdGhpcy5ETTtcbiAgICAgICAgICAgIGMgPj49IHRoaXMuREI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGEudCA8IHRoaXMudCkge1xuICAgICAgICAgICAgYyAtPSBhLnM7XG4gICAgICAgICAgICB3aGlsZSAoaSA8IHRoaXMudCkge1xuICAgICAgICAgICAgICAgIGMgKz0gdGhpc1tpXTtcbiAgICAgICAgICAgICAgICByW2krK10gPSBjICYgdGhpcy5ETTtcbiAgICAgICAgICAgICAgICBjID4+PSB0aGlzLkRCO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYyArPSB0aGlzLnM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjICs9IHRoaXMucztcbiAgICAgICAgICAgIHdoaWxlIChpIDwgYS50KSB7XG4gICAgICAgICAgICAgICAgYyAtPSBhW2ldO1xuICAgICAgICAgICAgICAgIHJbaSsrXSA9IGMgJiB0aGlzLkRNO1xuICAgICAgICAgICAgICAgIGMgPj49IHRoaXMuREI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjIC09IGEucztcbiAgICAgICAgfVxuICAgICAgICByLnMgPSAoYyA8IDApID8gLTEgOiAwO1xuICAgICAgICBpZiAoYyA8IC0xKSB7XG4gICAgICAgICAgICByW2krK10gPSB0aGlzLkRWICsgYztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjID4gMCkge1xuICAgICAgICAgICAgcltpKytdID0gYztcbiAgICAgICAgfVxuICAgICAgICByLnQgPSBpO1xuICAgICAgICByLmNsYW1wKCk7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5tdWx0aXBseVRvID0gYm5wTXVsdGlwbHlUbztcbiAgICAvLyAocHJvdGVjdGVkKSByID0gdGhpcyAqIGEsIHIgIT0gdGhpcyxhIChIQUMgMTQuMTIpXG4gICAgLy8gXCJ0aGlzXCIgc2hvdWxkIGJlIHRoZSBsYXJnZXIgb25lIGlmIGFwcHJvcHJpYXRlLlxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm11bHRpcGx5VG8gPSBmdW5jdGlvbiAoYSwgcikge1xuICAgICAgICB2YXIgeCA9IHRoaXMuYWJzKCk7XG4gICAgICAgIHZhciB5ID0gYS5hYnMoKTtcbiAgICAgICAgdmFyIGkgPSB4LnQ7XG4gICAgICAgIHIudCA9IGkgKyB5LnQ7XG4gICAgICAgIHdoaWxlICgtLWkgPj0gMCkge1xuICAgICAgICAgICAgcltpXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHkudDsgKytpKSB7XG4gICAgICAgICAgICByW2kgKyB4LnRdID0geC5hbSgwLCB5W2ldLCByLCBpLCAwLCB4LnQpO1xuICAgICAgICB9XG4gICAgICAgIHIucyA9IDA7XG4gICAgICAgIHIuY2xhbXAoKTtcbiAgICAgICAgaWYgKHRoaXMucyAhPSBhLnMpIHtcbiAgICAgICAgICAgIEJpZ0ludGVnZXIuWkVSTy5zdWJUbyhyLCByKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuc3F1YXJlVG8gPSBibnBTcXVhcmVUbztcbiAgICAvLyAocHJvdGVjdGVkKSByID0gdGhpc14yLCByICE9IHRoaXMgKEhBQyAxNC4xNilcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5zcXVhcmVUbyA9IGZ1bmN0aW9uIChyKSB7XG4gICAgICAgIHZhciB4ID0gdGhpcy5hYnMoKTtcbiAgICAgICAgdmFyIGkgPSByLnQgPSAyICogeC50O1xuICAgICAgICB3aGlsZSAoLS1pID49IDApIHtcbiAgICAgICAgICAgIHJbaV0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB4LnQgLSAxOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBjID0geC5hbShpLCB4W2ldLCByLCAyICogaSwgMCwgMSk7XG4gICAgICAgICAgICBpZiAoKHJbaSArIHgudF0gKz0geC5hbShpICsgMSwgMiAqIHhbaV0sIHIsIDIgKiBpICsgMSwgYywgeC50IC0gaSAtIDEpKSA+PSB4LkRWKSB7XG4gICAgICAgICAgICAgICAgcltpICsgeC50XSAtPSB4LkRWO1xuICAgICAgICAgICAgICAgIHJbaSArIHgudCArIDFdID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoci50ID4gMCkge1xuICAgICAgICAgICAgcltyLnQgLSAxXSArPSB4LmFtKGksIHhbaV0sIHIsIDIgKiBpLCAwLCAxKTtcbiAgICAgICAgfVxuICAgICAgICByLnMgPSAwO1xuICAgICAgICByLmNsYW1wKCk7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5kaXZSZW1UbyA9IGJucERpdlJlbVRvO1xuICAgIC8vIChwcm90ZWN0ZWQpIGRpdmlkZSB0aGlzIGJ5IG0sIHF1b3RpZW50IGFuZCByZW1haW5kZXIgdG8gcSwgciAoSEFDIDE0LjIwKVxuICAgIC8vIHIgIT0gcSwgdGhpcyAhPSBtLiAgcSBvciByIG1heSBiZSBudWxsLlxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmRpdlJlbVRvID0gZnVuY3Rpb24gKG0sIHEsIHIpIHtcbiAgICAgICAgdmFyIHBtID0gbS5hYnMoKTtcbiAgICAgICAgaWYgKHBtLnQgPD0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwdCA9IHRoaXMuYWJzKCk7XG4gICAgICAgIGlmIChwdC50IDwgcG0udCkge1xuICAgICAgICAgICAgaWYgKHEgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHEuZnJvbUludCgwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvcHlUbyhyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAociA9PSBudWxsKSB7XG4gICAgICAgICAgICByID0gbmJpKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHkgPSBuYmkoKTtcbiAgICAgICAgdmFyIHRzID0gdGhpcy5zO1xuICAgICAgICB2YXIgbXMgPSBtLnM7XG4gICAgICAgIHZhciBuc2ggPSB0aGlzLkRCIC0gbmJpdHMocG1bcG0udCAtIDFdKTsgLy8gbm9ybWFsaXplIG1vZHVsdXNcbiAgICAgICAgaWYgKG5zaCA+IDApIHtcbiAgICAgICAgICAgIHBtLmxTaGlmdFRvKG5zaCwgeSk7XG4gICAgICAgICAgICBwdC5sU2hpZnRUbyhuc2gsIHIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcG0uY29weVRvKHkpO1xuICAgICAgICAgICAgcHQuY29weVRvKHIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB5cyA9IHkudDtcbiAgICAgICAgdmFyIHkwID0geVt5cyAtIDFdO1xuICAgICAgICBpZiAoeTAgPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciB5dCA9IHkwICogKDEgPDwgdGhpcy5GMSkgKyAoKHlzID4gMSkgPyB5W3lzIC0gMl0gPj4gdGhpcy5GMiA6IDApO1xuICAgICAgICB2YXIgZDEgPSB0aGlzLkZWIC8geXQ7XG4gICAgICAgIHZhciBkMiA9ICgxIDw8IHRoaXMuRjEpIC8geXQ7XG4gICAgICAgIHZhciBlID0gMSA8PCB0aGlzLkYyO1xuICAgICAgICB2YXIgaSA9IHIudDtcbiAgICAgICAgdmFyIGogPSBpIC0geXM7XG4gICAgICAgIHZhciB0ID0gKHEgPT0gbnVsbCkgPyBuYmkoKSA6IHE7XG4gICAgICAgIHkuZGxTaGlmdFRvKGosIHQpO1xuICAgICAgICBpZiAoci5jb21wYXJlVG8odCkgPj0gMCkge1xuICAgICAgICAgICAgcltyLnQrK10gPSAxO1xuICAgICAgICAgICAgci5zdWJUbyh0LCByKTtcbiAgICAgICAgfVxuICAgICAgICBCaWdJbnRlZ2VyLk9ORS5kbFNoaWZ0VG8oeXMsIHQpO1xuICAgICAgICB0LnN1YlRvKHksIHkpOyAvLyBcIm5lZ2F0aXZlXCIgeSBzbyB3ZSBjYW4gcmVwbGFjZSBzdWIgd2l0aCBhbSBsYXRlclxuICAgICAgICB3aGlsZSAoeS50IDwgeXMpIHtcbiAgICAgICAgICAgIHlbeS50KytdID0gMDtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoLS1qID49IDApIHtcbiAgICAgICAgICAgIC8vIEVzdGltYXRlIHF1b3RpZW50IGRpZ2l0XG4gICAgICAgICAgICB2YXIgcWQgPSAoclstLWldID09IHkwKSA/IHRoaXMuRE0gOiBNYXRoLmZsb29yKHJbaV0gKiBkMSArIChyW2kgLSAxXSArIGUpICogZDIpO1xuICAgICAgICAgICAgaWYgKChyW2ldICs9IHkuYW0oMCwgcWQsIHIsIGosIDAsIHlzKSkgPCBxZCkgeyAvLyBUcnkgaXQgb3V0XG4gICAgICAgICAgICAgICAgeS5kbFNoaWZ0VG8oaiwgdCk7XG4gICAgICAgICAgICAgICAgci5zdWJUbyh0LCByKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAocltpXSA8IC0tcWQpIHtcbiAgICAgICAgICAgICAgICAgICAgci5zdWJUbyh0LCByKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHEgIT0gbnVsbCkge1xuICAgICAgICAgICAgci5kclNoaWZ0VG8oeXMsIHEpO1xuICAgICAgICAgICAgaWYgKHRzICE9IG1zKSB7XG4gICAgICAgICAgICAgICAgQmlnSW50ZWdlci5aRVJPLnN1YlRvKHEsIHEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHIudCA9IHlzO1xuICAgICAgICByLmNsYW1wKCk7XG4gICAgICAgIGlmIChuc2ggPiAwKSB7XG4gICAgICAgICAgICByLnJTaGlmdFRvKG5zaCwgcik7XG4gICAgICAgIH0gLy8gRGVub3JtYWxpemUgcmVtYWluZGVyXG4gICAgICAgIGlmICh0cyA8IDApIHtcbiAgICAgICAgICAgIEJpZ0ludGVnZXIuWkVSTy5zdWJUbyhyLCByKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuaW52RGlnaXQgPSBibnBJbnZEaWdpdDtcbiAgICAvLyAocHJvdGVjdGVkKSByZXR1cm4gXCItMS90aGlzICUgMl5EQlwiOyB1c2VmdWwgZm9yIE1vbnQuIHJlZHVjdGlvblxuICAgIC8vIGp1c3RpZmljYXRpb246XG4gICAgLy8gICAgICAgICB4eSA9PSAxIChtb2QgbSlcbiAgICAvLyAgICAgICAgIHh5ID0gIDEra21cbiAgICAvLyAgIHh5KDIteHkpID0gKDEra20pKDEta20pXG4gICAgLy8geFt5KDIteHkpXSA9IDEta14ybV4yXG4gICAgLy8geFt5KDIteHkpXSA9PSAxIChtb2QgbV4yKVxuICAgIC8vIGlmIHkgaXMgMS94IG1vZCBtLCB0aGVuIHkoMi14eSkgaXMgMS94IG1vZCBtXjJcbiAgICAvLyBzaG91bGQgcmVkdWNlIHggYW5kIHkoMi14eSkgYnkgbV4yIGF0IGVhY2ggc3RlcCB0byBrZWVwIHNpemUgYm91bmRlZC5cbiAgICAvLyBKUyBtdWx0aXBseSBcIm92ZXJmbG93c1wiIGRpZmZlcmVudGx5IGZyb20gQy9DKyssIHNvIGNhcmUgaXMgbmVlZGVkIGhlcmUuXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuaW52RGlnaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnQgPCAxKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgeCA9IHRoaXNbMF07XG4gICAgICAgIGlmICgoeCAmIDEpID09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciB5ID0geCAmIDM7IC8vIHkgPT0gMS94IG1vZCAyXjJcbiAgICAgICAgeSA9ICh5ICogKDIgLSAoeCAmIDB4ZikgKiB5KSkgJiAweGY7IC8vIHkgPT0gMS94IG1vZCAyXjRcbiAgICAgICAgeSA9ICh5ICogKDIgLSAoeCAmIDB4ZmYpICogeSkpICYgMHhmZjsgLy8geSA9PSAxL3ggbW9kIDJeOFxuICAgICAgICB5ID0gKHkgKiAoMiAtICgoKHggJiAweGZmZmYpICogeSkgJiAweGZmZmYpKSkgJiAweGZmZmY7IC8vIHkgPT0gMS94IG1vZCAyXjE2XG4gICAgICAgIC8vIGxhc3Qgc3RlcCAtIGNhbGN1bGF0ZSBpbnZlcnNlIG1vZCBEViBkaXJlY3RseTtcbiAgICAgICAgLy8gYXNzdW1lcyAxNiA8IERCIDw9IDMyIGFuZCBhc3N1bWVzIGFiaWxpdHkgdG8gaGFuZGxlIDQ4LWJpdCBpbnRzXG4gICAgICAgIHkgPSAoeSAqICgyIC0geCAqIHkgJSB0aGlzLkRWKSkgJSB0aGlzLkRWOyAvLyB5ID09IDEveCBtb2QgMl5kYml0c1xuICAgICAgICAvLyB3ZSByZWFsbHkgd2FudCB0aGUgbmVnYXRpdmUgaW52ZXJzZSwgYW5kIC1EViA8IHkgPCBEVlxuICAgICAgICByZXR1cm4gKHkgPiAwKSA/IHRoaXMuRFYgLSB5IDogLXk7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5pc0V2ZW4gPSBibnBJc0V2ZW47XG4gICAgLy8gKHByb3RlY3RlZCkgdHJ1ZSBpZmYgdGhpcyBpcyBldmVuXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuaXNFdmVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKCh0aGlzLnQgPiAwKSA/ICh0aGlzWzBdICYgMSkgOiB0aGlzLnMpID09IDA7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5leHAgPSBibnBFeHA7XG4gICAgLy8gKHByb3RlY3RlZCkgdGhpc15lLCBlIDwgMl4zMiwgZG9pbmcgc3FyIGFuZCBtdWwgd2l0aCBcInJcIiAoSEFDIDE0Ljc5KVxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmV4cCA9IGZ1bmN0aW9uIChlLCB6KSB7XG4gICAgICAgIGlmIChlID4gMHhmZmZmZmZmZiB8fCBlIDwgMSkge1xuICAgICAgICAgICAgcmV0dXJuIEJpZ0ludGVnZXIuT05FO1xuICAgICAgICB9XG4gICAgICAgIHZhciByID0gbmJpKCk7XG4gICAgICAgIHZhciByMiA9IG5iaSgpO1xuICAgICAgICB2YXIgZyA9IHouY29udmVydCh0aGlzKTtcbiAgICAgICAgdmFyIGkgPSBuYml0cyhlKSAtIDE7XG4gICAgICAgIGcuY29weVRvKHIpO1xuICAgICAgICB3aGlsZSAoLS1pID49IDApIHtcbiAgICAgICAgICAgIHouc3FyVG8ociwgcjIpO1xuICAgICAgICAgICAgaWYgKChlICYgKDEgPDwgaSkpID4gMCkge1xuICAgICAgICAgICAgICAgIHoubXVsVG8ocjIsIGcsIHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHQgPSByO1xuICAgICAgICAgICAgICAgIHIgPSByMjtcbiAgICAgICAgICAgICAgICByMiA9IHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHoucmV2ZXJ0KHIpO1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuY2h1bmtTaXplID0gYm5wQ2h1bmtTaXplO1xuICAgIC8vIChwcm90ZWN0ZWQpIHJldHVybiB4IHMudC4gcl54IDwgRFZcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5jaHVua1NpemUgPSBmdW5jdGlvbiAocikge1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLkxOMiAqIHRoaXMuREIgLyBNYXRoLmxvZyhyKSk7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS50b1JhZGl4ID0gYm5wVG9SYWRpeDtcbiAgICAvLyAocHJvdGVjdGVkKSBjb252ZXJ0IHRvIHJhZGl4IHN0cmluZ1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnRvUmFkaXggPSBmdW5jdGlvbiAoYikge1xuICAgICAgICBpZiAoYiA9PSBudWxsKSB7XG4gICAgICAgICAgICBiID0gMTA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc2lnbnVtKCkgPT0gMCB8fCBiIDwgMiB8fCBiID4gMzYpIHtcbiAgICAgICAgICAgIHJldHVybiBcIjBcIjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY3MgPSB0aGlzLmNodW5rU2l6ZShiKTtcbiAgICAgICAgdmFyIGEgPSBNYXRoLnBvdyhiLCBjcyk7XG4gICAgICAgIHZhciBkID0gbmJ2KGEpO1xuICAgICAgICB2YXIgeSA9IG5iaSgpO1xuICAgICAgICB2YXIgeiA9IG5iaSgpO1xuICAgICAgICB2YXIgciA9IFwiXCI7XG4gICAgICAgIHRoaXMuZGl2UmVtVG8oZCwgeSwgeik7XG4gICAgICAgIHdoaWxlICh5LnNpZ251bSgpID4gMCkge1xuICAgICAgICAgICAgciA9IChhICsgei5pbnRWYWx1ZSgpKS50b1N0cmluZyhiKS5zdWJzdHIoMSkgKyByO1xuICAgICAgICAgICAgeS5kaXZSZW1UbyhkLCB5LCB6KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gei5pbnRWYWx1ZSgpLnRvU3RyaW5nKGIpICsgcjtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLmZyb21SYWRpeCA9IGJucEZyb21SYWRpeDtcbiAgICAvLyAocHJvdGVjdGVkKSBjb252ZXJ0IGZyb20gcmFkaXggc3RyaW5nXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuZnJvbVJhZGl4ID0gZnVuY3Rpb24gKHMsIGIpIHtcbiAgICAgICAgdGhpcy5mcm9tSW50KDApO1xuICAgICAgICBpZiAoYiA9PSBudWxsKSB7XG4gICAgICAgICAgICBiID0gMTA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNzID0gdGhpcy5jaHVua1NpemUoYik7XG4gICAgICAgIHZhciBkID0gTWF0aC5wb3coYiwgY3MpO1xuICAgICAgICB2YXIgbWkgPSBmYWxzZTtcbiAgICAgICAgdmFyIGogPSAwO1xuICAgICAgICB2YXIgdyA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIHggPSBpbnRBdChzLCBpKTtcbiAgICAgICAgICAgIGlmICh4IDwgMCkge1xuICAgICAgICAgICAgICAgIGlmIChzLmNoYXJBdChpKSA9PSBcIi1cIiAmJiB0aGlzLnNpZ251bSgpID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbWkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHcgPSBiICogdyArIHg7XG4gICAgICAgICAgICBpZiAoKytqID49IGNzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kTXVsdGlwbHkoZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5kQWRkT2Zmc2V0KHcsIDApO1xuICAgICAgICAgICAgICAgIGogPSAwO1xuICAgICAgICAgICAgICAgIHcgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChqID4gMCkge1xuICAgICAgICAgICAgdGhpcy5kTXVsdGlwbHkoTWF0aC5wb3coYiwgaikpO1xuICAgICAgICAgICAgdGhpcy5kQWRkT2Zmc2V0KHcsIDApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtaSkge1xuICAgICAgICAgICAgQmlnSW50ZWdlci5aRVJPLnN1YlRvKHRoaXMsIHRoaXMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5mcm9tTnVtYmVyID0gYm5wRnJvbU51bWJlcjtcbiAgICAvLyAocHJvdGVjdGVkKSBhbHRlcm5hdGUgY29uc3RydWN0b3JcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5mcm9tTnVtYmVyID0gZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiAgICAgICAgaWYgKFwibnVtYmVyXCIgPT0gdHlwZW9mIGIpIHtcbiAgICAgICAgICAgIC8vIG5ldyBCaWdJbnRlZ2VyKGludCxpbnQsUk5HKVxuICAgICAgICAgICAgaWYgKGEgPCAyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mcm9tSW50KDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mcm9tTnVtYmVyKGEsIGMpO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy50ZXN0Qml0KGEgLSAxKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBmb3JjZSBNU0Igc2V0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYml0d2lzZVRvKEJpZ0ludGVnZXIuT05FLnNoaWZ0TGVmdChhIC0gMSksIG9wX29yLCB0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNFdmVuKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kQWRkT2Zmc2V0KDEsIDApO1xuICAgICAgICAgICAgICAgIH0gLy8gZm9yY2Ugb2RkXG4gICAgICAgICAgICAgICAgd2hpbGUgKCF0aGlzLmlzUHJvYmFibGVQcmltZShiKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRBZGRPZmZzZXQoMiwgMCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmJpdExlbmd0aCgpID4gYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdWJUbyhCaWdJbnRlZ2VyLk9ORS5zaGlmdExlZnQoYSAtIDEpLCB0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIG5ldyBCaWdJbnRlZ2VyKGludCxSTkcpXG4gICAgICAgICAgICB2YXIgeCA9IFtdO1xuICAgICAgICAgICAgdmFyIHQgPSBhICYgNztcbiAgICAgICAgICAgIHgubGVuZ3RoID0gKGEgPj4gMykgKyAxO1xuICAgICAgICAgICAgYi5uZXh0Qnl0ZXMoeCk7XG4gICAgICAgICAgICBpZiAodCA+IDApIHtcbiAgICAgICAgICAgICAgICB4WzBdICY9ICgoMSA8PCB0KSAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgeFswXSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmZyb21TdHJpbmcoeCwgMjU2KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuYml0d2lzZVRvID0gYm5wQml0d2lzZVRvO1xuICAgIC8vIChwcm90ZWN0ZWQpIHIgPSB0aGlzIG9wIGEgKGJpdHdpc2UpXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuYml0d2lzZVRvID0gZnVuY3Rpb24gKGEsIG9wLCByKSB7XG4gICAgICAgIHZhciBpO1xuICAgICAgICB2YXIgZjtcbiAgICAgICAgdmFyIG0gPSBNYXRoLm1pbihhLnQsIHRoaXMudCk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBtOyArK2kpIHtcbiAgICAgICAgICAgIHJbaV0gPSBvcCh0aGlzW2ldLCBhW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYS50IDwgdGhpcy50KSB7XG4gICAgICAgICAgICBmID0gYS5zICYgdGhpcy5ETTtcbiAgICAgICAgICAgIGZvciAoaSA9IG07IGkgPCB0aGlzLnQ7ICsraSkge1xuICAgICAgICAgICAgICAgIHJbaV0gPSBvcCh0aGlzW2ldLCBmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHIudCA9IHRoaXMudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGYgPSB0aGlzLnMgJiB0aGlzLkRNO1xuICAgICAgICAgICAgZm9yIChpID0gbTsgaSA8IGEudDsgKytpKSB7XG4gICAgICAgICAgICAgICAgcltpXSA9IG9wKGYsIGFbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgci50ID0gYS50O1xuICAgICAgICB9XG4gICAgICAgIHIucyA9IG9wKHRoaXMucywgYS5zKTtcbiAgICAgICAgci5jbGFtcCgpO1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuY2hhbmdlQml0ID0gYm5wQ2hhbmdlQml0O1xuICAgIC8vIChwcm90ZWN0ZWQpIHRoaXMgb3AgKDE8PG4pXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuY2hhbmdlQml0ID0gZnVuY3Rpb24gKG4sIG9wKSB7XG4gICAgICAgIHZhciByID0gQmlnSW50ZWdlci5PTkUuc2hpZnRMZWZ0KG4pO1xuICAgICAgICB0aGlzLmJpdHdpc2VUbyhyLCBvcCwgcik7XG4gICAgICAgIHJldHVybiByO1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuYWRkVG8gPSBibnBBZGRUbztcbiAgICAvLyAocHJvdGVjdGVkKSByID0gdGhpcyArIGFcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5hZGRUbyA9IGZ1bmN0aW9uIChhLCByKSB7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIGMgPSAwO1xuICAgICAgICB2YXIgbSA9IE1hdGgubWluKGEudCwgdGhpcy50KTtcbiAgICAgICAgd2hpbGUgKGkgPCBtKSB7XG4gICAgICAgICAgICBjICs9IHRoaXNbaV0gKyBhW2ldO1xuICAgICAgICAgICAgcltpKytdID0gYyAmIHRoaXMuRE07XG4gICAgICAgICAgICBjID4+PSB0aGlzLkRCO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhLnQgPCB0aGlzLnQpIHtcbiAgICAgICAgICAgIGMgKz0gYS5zO1xuICAgICAgICAgICAgd2hpbGUgKGkgPCB0aGlzLnQpIHtcbiAgICAgICAgICAgICAgICBjICs9IHRoaXNbaV07XG4gICAgICAgICAgICAgICAgcltpKytdID0gYyAmIHRoaXMuRE07XG4gICAgICAgICAgICAgICAgYyA+Pj0gdGhpcy5EQjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGMgKz0gdGhpcy5zO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYyArPSB0aGlzLnM7XG4gICAgICAgICAgICB3aGlsZSAoaSA8IGEudCkge1xuICAgICAgICAgICAgICAgIGMgKz0gYVtpXTtcbiAgICAgICAgICAgICAgICByW2krK10gPSBjICYgdGhpcy5ETTtcbiAgICAgICAgICAgICAgICBjID4+PSB0aGlzLkRCO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYyArPSBhLnM7XG4gICAgICAgIH1cbiAgICAgICAgci5zID0gKGMgPCAwKSA/IC0xIDogMDtcbiAgICAgICAgaWYgKGMgPiAwKSB7XG4gICAgICAgICAgICByW2krK10gPSBjO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgPCAtMSkge1xuICAgICAgICAgICAgcltpKytdID0gdGhpcy5EViArIGM7XG4gICAgICAgIH1cbiAgICAgICAgci50ID0gaTtcbiAgICAgICAgci5jbGFtcCgpO1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuZE11bHRpcGx5ID0gYm5wRE11bHRpcGx5O1xuICAgIC8vIChwcm90ZWN0ZWQpIHRoaXMgKj0gbiwgdGhpcyA+PSAwLCAxIDwgbiA8IERWXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuZE11bHRpcGx5ID0gZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgdGhpc1t0aGlzLnRdID0gdGhpcy5hbSgwLCBuIC0gMSwgdGhpcywgMCwgMCwgdGhpcy50KTtcbiAgICAgICAgKyt0aGlzLnQ7XG4gICAgICAgIHRoaXMuY2xhbXAoKTtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLmRBZGRPZmZzZXQgPSBibnBEQWRkT2Zmc2V0O1xuICAgIC8vIChwcm90ZWN0ZWQpIHRoaXMgKz0gbiA8PCB3IHdvcmRzLCB0aGlzID49IDBcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5kQWRkT2Zmc2V0ID0gZnVuY3Rpb24gKG4sIHcpIHtcbiAgICAgICAgaWYgKG4gPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlICh0aGlzLnQgPD0gdykge1xuICAgICAgICAgICAgdGhpc1t0aGlzLnQrK10gPSAwO1xuICAgICAgICB9XG4gICAgICAgIHRoaXNbd10gKz0gbjtcbiAgICAgICAgd2hpbGUgKHRoaXNbd10gPj0gdGhpcy5EVikge1xuICAgICAgICAgICAgdGhpc1t3XSAtPSB0aGlzLkRWO1xuICAgICAgICAgICAgaWYgKCsrdyA+PSB0aGlzLnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzW3RoaXMudCsrXSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICArK3RoaXNbd107XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLm11bHRpcGx5TG93ZXJUbyA9IGJucE11bHRpcGx5TG93ZXJUbztcbiAgICAvLyAocHJvdGVjdGVkKSByID0gbG93ZXIgbiB3b3JkcyBvZiBcInRoaXMgKiBhXCIsIGEudCA8PSBuXG4gICAgLy8gXCJ0aGlzXCIgc2hvdWxkIGJlIHRoZSBsYXJnZXIgb25lIGlmIGFwcHJvcHJpYXRlLlxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm11bHRpcGx5TG93ZXJUbyA9IGZ1bmN0aW9uIChhLCBuLCByKSB7XG4gICAgICAgIHZhciBpID0gTWF0aC5taW4odGhpcy50ICsgYS50LCBuKTtcbiAgICAgICAgci5zID0gMDsgLy8gYXNzdW1lcyBhLHRoaXMgPj0gMFxuICAgICAgICByLnQgPSBpO1xuICAgICAgICB3aGlsZSAoaSA+IDApIHtcbiAgICAgICAgICAgIHJbLS1pXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaiA9IHIudCAtIHRoaXMudDsgaSA8IGo7ICsraSkge1xuICAgICAgICAgICAgcltpICsgdGhpcy50XSA9IHRoaXMuYW0oMCwgYVtpXSwgciwgaSwgMCwgdGhpcy50KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBqID0gTWF0aC5taW4oYS50LCBuKTsgaSA8IGo7ICsraSkge1xuICAgICAgICAgICAgdGhpcy5hbSgwLCBhW2ldLCByLCBpLCAwLCBuIC0gaSk7XG4gICAgICAgIH1cbiAgICAgICAgci5jbGFtcCgpO1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUubXVsdGlwbHlVcHBlclRvID0gYm5wTXVsdGlwbHlVcHBlclRvO1xuICAgIC8vIChwcm90ZWN0ZWQpIHIgPSBcInRoaXMgKiBhXCIgd2l0aG91dCBsb3dlciBuIHdvcmRzLCBuID4gMFxuICAgIC8vIFwidGhpc1wiIHNob3VsZCBiZSB0aGUgbGFyZ2VyIG9uZSBpZiBhcHByb3ByaWF0ZS5cbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5tdWx0aXBseVVwcGVyVG8gPSBmdW5jdGlvbiAoYSwgbiwgcikge1xuICAgICAgICAtLW47XG4gICAgICAgIHZhciBpID0gci50ID0gdGhpcy50ICsgYS50IC0gbjtcbiAgICAgICAgci5zID0gMDsgLy8gYXNzdW1lcyBhLHRoaXMgPj0gMFxuICAgICAgICB3aGlsZSAoLS1pID49IDApIHtcbiAgICAgICAgICAgIHJbaV0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IE1hdGgubWF4KG4gLSB0aGlzLnQsIDApOyBpIDwgYS50OyArK2kpIHtcbiAgICAgICAgICAgIHJbdGhpcy50ICsgaSAtIG5dID0gdGhpcy5hbShuIC0gaSwgYVtpXSwgciwgMCwgMCwgdGhpcy50ICsgaSAtIG4pO1xuICAgICAgICB9XG4gICAgICAgIHIuY2xhbXAoKTtcbiAgICAgICAgci5kclNoaWZ0VG8oMSwgcik7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5tb2RJbnQgPSBibnBNb2RJbnQ7XG4gICAgLy8gKHByb3RlY3RlZCkgdGhpcyAlIG4sIG4gPCAyXjI2XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUubW9kSW50ID0gZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgaWYgKG4gPD0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGQgPSB0aGlzLkRWICUgbjtcbiAgICAgICAgdmFyIHIgPSAodGhpcy5zIDwgMCkgPyBuIC0gMSA6IDA7XG4gICAgICAgIGlmICh0aGlzLnQgPiAwKSB7XG4gICAgICAgICAgICBpZiAoZCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgciA9IHRoaXNbMF0gJSBuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMudCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICAgICAgICAgIHIgPSAoZCAqIHIgKyB0aGlzW2ldKSAlIG47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByO1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUubWlsbGVyUmFiaW4gPSBibnBNaWxsZXJSYWJpbjtcbiAgICAvLyAocHJvdGVjdGVkKSB0cnVlIGlmIHByb2JhYmx5IHByaW1lIChIQUMgNC4yNCwgTWlsbGVyLVJhYmluKVxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm1pbGxlclJhYmluID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdmFyIG4xID0gdGhpcy5zdWJ0cmFjdChCaWdJbnRlZ2VyLk9ORSk7XG4gICAgICAgIHZhciBrID0gbjEuZ2V0TG93ZXN0U2V0Qml0KCk7XG4gICAgICAgIGlmIChrIDw9IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgciA9IG4xLnNoaWZ0UmlnaHQoayk7XG4gICAgICAgIHQgPSAodCArIDEpID4+IDE7XG4gICAgICAgIGlmICh0ID4gbG93cHJpbWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgdCA9IGxvd3ByaW1lcy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGEgPSBuYmkoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0OyArK2kpIHtcbiAgICAgICAgICAgIC8vIFBpY2sgYmFzZXMgYXQgcmFuZG9tLCBpbnN0ZWFkIG9mIHN0YXJ0aW5nIGF0IDJcbiAgICAgICAgICAgIGEuZnJvbUludChsb3dwcmltZXNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbG93cHJpbWVzLmxlbmd0aCldKTtcbiAgICAgICAgICAgIHZhciB5ID0gYS5tb2RQb3cociwgdGhpcyk7XG4gICAgICAgICAgICBpZiAoeS5jb21wYXJlVG8oQmlnSW50ZWdlci5PTkUpICE9IDAgJiYgeS5jb21wYXJlVG8objEpICE9IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgaiA9IDE7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGorKyA8IGsgJiYgeS5jb21wYXJlVG8objEpICE9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgeSA9IHkubW9kUG93SW50KDIsIHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoeS5jb21wYXJlVG8oQmlnSW50ZWdlci5PTkUpID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoeS5jb21wYXJlVG8objEpICE9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLnNxdWFyZSA9IGJuU3F1YXJlO1xuICAgIC8vIChwdWJsaWMpIHRoaXNeMlxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnNxdWFyZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHIgPSBuYmkoKTtcbiAgICAgICAgdGhpcy5zcXVhcmVUbyhyKTtcbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfTtcbiAgICAvLyNyZWdpb24gQVNZTkNcbiAgICAvLyBQdWJsaWMgQVBJIG1ldGhvZFxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmdjZGEgPSBmdW5jdGlvbiAoYSwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHggPSAodGhpcy5zIDwgMCkgPyB0aGlzLm5lZ2F0ZSgpIDogdGhpcy5jbG9uZSgpO1xuICAgICAgICB2YXIgeSA9IChhLnMgPCAwKSA/IGEubmVnYXRlKCkgOiBhLmNsb25lKCk7XG4gICAgICAgIGlmICh4LmNvbXBhcmVUbyh5KSA8IDApIHtcbiAgICAgICAgICAgIHZhciB0ID0geDtcbiAgICAgICAgICAgIHggPSB5O1xuICAgICAgICAgICAgeSA9IHQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGkgPSB4LmdldExvd2VzdFNldEJpdCgpO1xuICAgICAgICB2YXIgZyA9IHkuZ2V0TG93ZXN0U2V0Qml0KCk7XG4gICAgICAgIGlmIChnIDwgMCkge1xuICAgICAgICAgICAgY2FsbGJhY2soeCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPCBnKSB7XG4gICAgICAgICAgICBnID0gaTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZyA+IDApIHtcbiAgICAgICAgICAgIHguclNoaWZ0VG8oZywgeCk7XG4gICAgICAgICAgICB5LnJTaGlmdFRvKGcsIHkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdvcmtob3JzZSBvZiB0aGUgYWxnb3JpdGhtLCBnZXRzIGNhbGxlZCAyMDAgLSA4MDAgdGltZXMgcGVyIDUxMiBiaXQga2V5Z2VuLlxuICAgICAgICB2YXIgZ2NkYTEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoKGkgPSB4LmdldExvd2VzdFNldEJpdCgpKSA+IDApIHtcbiAgICAgICAgICAgICAgICB4LnJTaGlmdFRvKGksIHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChpID0geS5nZXRMb3dlc3RTZXRCaXQoKSkgPiAwKSB7XG4gICAgICAgICAgICAgICAgeS5yU2hpZnRUbyhpLCB5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh4LmNvbXBhcmVUbyh5KSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgeC5zdWJUbyh5LCB4KTtcbiAgICAgICAgICAgICAgICB4LnJTaGlmdFRvKDEsIHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgeS5zdWJUbyh4LCB5KTtcbiAgICAgICAgICAgICAgICB5LnJTaGlmdFRvKDEsIHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCEoeC5zaWdudW0oKSA+IDApKSB7XG4gICAgICAgICAgICAgICAgaWYgKGcgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHkubFNoaWZ0VG8oZywgeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyBjYWxsYmFjayh5KTsgfSwgMCk7IC8vIGVzY2FwZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChnY2RhMSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHNldFRpbWVvdXQoZ2NkYTEsIDEwKTtcbiAgICB9O1xuICAgIC8vIChwcm90ZWN0ZWQpIGFsdGVybmF0ZSBjb25zdHJ1Y3RvclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmZyb21OdW1iZXJBc3luYyA9IGZ1bmN0aW9uIChhLCBiLCBjLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoXCJudW1iZXJcIiA9PSB0eXBlb2YgYikge1xuICAgICAgICAgICAgaWYgKGEgPCAyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mcm9tSW50KDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mcm9tTnVtYmVyKGEsIGMpO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy50ZXN0Qml0KGEgLSAxKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJpdHdpc2VUbyhCaWdJbnRlZ2VyLk9ORS5zaGlmdExlZnQoYSAtIDEpLCBvcF9vciwgdGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzRXZlbigpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZEFkZE9mZnNldCgxLCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGJucF8xID0gdGhpcztcbiAgICAgICAgICAgICAgICB2YXIgYm5wZm4xXzEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGJucF8xLmRBZGRPZmZzZXQoMiwgMCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChibnBfMS5iaXRMZW5ndGgoKSA+IGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJucF8xLnN1YlRvKEJpZ0ludGVnZXIuT05FLnNoaWZ0TGVmdChhIC0gMSksIGJucF8xKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoYm5wXzEuaXNQcm9iYWJsZVByaW1lKGIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgY2FsbGJhY2soKTsgfSwgMCk7IC8vIGVzY2FwZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChibnBmbjFfMSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoYm5wZm4xXzEsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHggPSBbXTtcbiAgICAgICAgICAgIHZhciB0ID0gYSAmIDc7XG4gICAgICAgICAgICB4Lmxlbmd0aCA9IChhID4+IDMpICsgMTtcbiAgICAgICAgICAgIGIubmV4dEJ5dGVzKHgpO1xuICAgICAgICAgICAgaWYgKHQgPiAwKSB7XG4gICAgICAgICAgICAgICAgeFswXSAmPSAoKDEgPDwgdCkgLSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHhbMF0gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5mcm9tU3RyaW5nKHgsIDI1Nik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBCaWdJbnRlZ2VyO1xufSgpKTtcbmV4cG9ydCB7IEJpZ0ludGVnZXIgfTtcbi8vI3JlZ2lvbiBSRURVQ0VSU1xuLy8jcmVnaW9uIE51bGxFeHBcbnZhciBOdWxsRXhwID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE51bGxFeHAoKSB7XG4gICAgfVxuICAgIC8vIE51bGxFeHAucHJvdG90eXBlLmNvbnZlcnQgPSBuTm9wO1xuICAgIE51bGxFeHAucHJvdG90eXBlLmNvbnZlcnQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4geDtcbiAgICB9O1xuICAgIC8vIE51bGxFeHAucHJvdG90eXBlLnJldmVydCA9IG5Ob3A7XG4gICAgTnVsbEV4cC5wcm90b3R5cGUucmV2ZXJ0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfTtcbiAgICAvLyBOdWxsRXhwLnByb3RvdHlwZS5tdWxUbyA9IG5NdWxUbztcbiAgICBOdWxsRXhwLnByb3RvdHlwZS5tdWxUbyA9IGZ1bmN0aW9uICh4LCB5LCByKSB7XG4gICAgICAgIHgubXVsdGlwbHlUbyh5LCByKTtcbiAgICB9O1xuICAgIC8vIE51bGxFeHAucHJvdG90eXBlLnNxclRvID0gblNxclRvO1xuICAgIE51bGxFeHAucHJvdG90eXBlLnNxclRvID0gZnVuY3Rpb24gKHgsIHIpIHtcbiAgICAgICAgeC5zcXVhcmVUbyhyKTtcbiAgICB9O1xuICAgIHJldHVybiBOdWxsRXhwO1xufSgpKTtcbi8vIE1vZHVsYXIgcmVkdWN0aW9uIHVzaW5nIFwiY2xhc3NpY1wiIGFsZ29yaXRobVxudmFyIENsYXNzaWMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2xhc3NpYyhtKSB7XG4gICAgICAgIHRoaXMubSA9IG07XG4gICAgfVxuICAgIC8vIENsYXNzaWMucHJvdG90eXBlLmNvbnZlcnQgPSBjQ29udmVydDtcbiAgICBDbGFzc2ljLnByb3RvdHlwZS5jb252ZXJ0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgaWYgKHgucyA8IDAgfHwgeC5jb21wYXJlVG8odGhpcy5tKSA+PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4geC5tb2QodGhpcy5tKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB4O1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBDbGFzc2ljLnByb3RvdHlwZS5yZXZlcnQgPSBjUmV2ZXJ0O1xuICAgIENsYXNzaWMucHJvdG90eXBlLnJldmVydCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB4O1xuICAgIH07XG4gICAgLy8gQ2xhc3NpYy5wcm90b3R5cGUucmVkdWNlID0gY1JlZHVjZTtcbiAgICBDbGFzc2ljLnByb3RvdHlwZS5yZWR1Y2UgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB4LmRpdlJlbVRvKHRoaXMubSwgbnVsbCwgeCk7XG4gICAgfTtcbiAgICAvLyBDbGFzc2ljLnByb3RvdHlwZS5tdWxUbyA9IGNNdWxUbztcbiAgICBDbGFzc2ljLnByb3RvdHlwZS5tdWxUbyA9IGZ1bmN0aW9uICh4LCB5LCByKSB7XG4gICAgICAgIHgubXVsdGlwbHlUbyh5LCByKTtcbiAgICAgICAgdGhpcy5yZWR1Y2Uocik7XG4gICAgfTtcbiAgICAvLyBDbGFzc2ljLnByb3RvdHlwZS5zcXJUbyA9IGNTcXJUbztcbiAgICBDbGFzc2ljLnByb3RvdHlwZS5zcXJUbyA9IGZ1bmN0aW9uICh4LCByKSB7XG4gICAgICAgIHguc3F1YXJlVG8ocik7XG4gICAgICAgIHRoaXMucmVkdWNlKHIpO1xuICAgIH07XG4gICAgcmV0dXJuIENsYXNzaWM7XG59KCkpO1xuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gTW9udGdvbWVyeVxuLy8gTW9udGdvbWVyeSByZWR1Y3Rpb25cbnZhciBNb250Z29tZXJ5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1vbnRnb21lcnkobSkge1xuICAgICAgICB0aGlzLm0gPSBtO1xuICAgICAgICB0aGlzLm1wID0gbS5pbnZEaWdpdCgpO1xuICAgICAgICB0aGlzLm1wbCA9IHRoaXMubXAgJiAweDdmZmY7XG4gICAgICAgIHRoaXMubXBoID0gdGhpcy5tcCA+PiAxNTtcbiAgICAgICAgdGhpcy51bSA9ICgxIDw8IChtLkRCIC0gMTUpKSAtIDE7XG4gICAgICAgIHRoaXMubXQyID0gMiAqIG0udDtcbiAgICB9XG4gICAgLy8gTW9udGdvbWVyeS5wcm90b3R5cGUuY29udmVydCA9IG1vbnRDb252ZXJ0O1xuICAgIC8vIHhSIG1vZCBtXG4gICAgTW9udGdvbWVyeS5wcm90b3R5cGUuY29udmVydCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciByID0gbmJpKCk7XG4gICAgICAgIHguYWJzKCkuZGxTaGlmdFRvKHRoaXMubS50LCByKTtcbiAgICAgICAgci5kaXZSZW1Ubyh0aGlzLm0sIG51bGwsIHIpO1xuICAgICAgICBpZiAoeC5zIDwgMCAmJiByLmNvbXBhcmVUbyhCaWdJbnRlZ2VyLlpFUk8pID4gMCkge1xuICAgICAgICAgICAgdGhpcy5tLnN1YlRvKHIsIHIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByO1xuICAgIH07XG4gICAgLy8gTW9udGdvbWVyeS5wcm90b3R5cGUucmV2ZXJ0ID0gbW9udFJldmVydDtcbiAgICAvLyB4L1IgbW9kIG1cbiAgICBNb250Z29tZXJ5LnByb3RvdHlwZS5yZXZlcnQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgciA9IG5iaSgpO1xuICAgICAgICB4LmNvcHlUbyhyKTtcbiAgICAgICAgdGhpcy5yZWR1Y2Uocik7XG4gICAgICAgIHJldHVybiByO1xuICAgIH07XG4gICAgLy8gTW9udGdvbWVyeS5wcm90b3R5cGUucmVkdWNlID0gbW9udFJlZHVjZTtcbiAgICAvLyB4ID0geC9SIG1vZCBtIChIQUMgMTQuMzIpXG4gICAgTW9udGdvbWVyeS5wcm90b3R5cGUucmVkdWNlID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgd2hpbGUgKHgudCA8PSB0aGlzLm10Mikge1xuICAgICAgICAgICAgLy8gcGFkIHggc28gYW0gaGFzIGVub3VnaCByb29tIGxhdGVyXG4gICAgICAgICAgICB4W3gudCsrXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm0udDsgKytpKSB7XG4gICAgICAgICAgICAvLyBmYXN0ZXIgd2F5IG9mIGNhbGN1bGF0aW5nIHUwID0geFtpXSptcCBtb2QgRFZcbiAgICAgICAgICAgIHZhciBqID0geFtpXSAmIDB4N2ZmZjtcbiAgICAgICAgICAgIHZhciB1MCA9IChqICogdGhpcy5tcGwgKyAoKChqICogdGhpcy5tcGggKyAoeFtpXSA+PiAxNSkgKiB0aGlzLm1wbCkgJiB0aGlzLnVtKSA8PCAxNSkpICYgeC5ETTtcbiAgICAgICAgICAgIC8vIHVzZSBhbSB0byBjb21iaW5lIHRoZSBtdWx0aXBseS1zaGlmdC1hZGQgaW50byBvbmUgY2FsbFxuICAgICAgICAgICAgaiA9IGkgKyB0aGlzLm0udDtcbiAgICAgICAgICAgIHhbal0gKz0gdGhpcy5tLmFtKDAsIHUwLCB4LCBpLCAwLCB0aGlzLm0udCk7XG4gICAgICAgICAgICAvLyBwcm9wYWdhdGUgY2FycnlcbiAgICAgICAgICAgIHdoaWxlICh4W2pdID49IHguRFYpIHtcbiAgICAgICAgICAgICAgICB4W2pdIC09IHguRFY7XG4gICAgICAgICAgICAgICAgeFsrK2pdKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgeC5jbGFtcCgpO1xuICAgICAgICB4LmRyU2hpZnRUbyh0aGlzLm0udCwgeCk7XG4gICAgICAgIGlmICh4LmNvbXBhcmVUbyh0aGlzLm0pID49IDApIHtcbiAgICAgICAgICAgIHguc3ViVG8odGhpcy5tLCB4KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gTW9udGdvbWVyeS5wcm90b3R5cGUubXVsVG8gPSBtb250TXVsVG87XG4gICAgLy8gciA9IFwieHkvUiBtb2QgbVwiOyB4LHkgIT0gclxuICAgIE1vbnRnb21lcnkucHJvdG90eXBlLm11bFRvID0gZnVuY3Rpb24gKHgsIHksIHIpIHtcbiAgICAgICAgeC5tdWx0aXBseVRvKHksIHIpO1xuICAgICAgICB0aGlzLnJlZHVjZShyKTtcbiAgICB9O1xuICAgIC8vIE1vbnRnb21lcnkucHJvdG90eXBlLnNxclRvID0gbW9udFNxclRvO1xuICAgIC8vIHIgPSBcInheMi9SIG1vZCBtXCI7IHggIT0gclxuICAgIE1vbnRnb21lcnkucHJvdG90eXBlLnNxclRvID0gZnVuY3Rpb24gKHgsIHIpIHtcbiAgICAgICAgeC5zcXVhcmVUbyhyKTtcbiAgICAgICAgdGhpcy5yZWR1Y2Uocik7XG4gICAgfTtcbiAgICByZXR1cm4gTW9udGdvbWVyeTtcbn0oKSk7XG4vLyNlbmRyZWdpb24gTW9udGdvbWVyeVxuLy8jcmVnaW9uIEJhcnJldHRcbi8vIEJhcnJldHQgbW9kdWxhciByZWR1Y3Rpb25cbnZhciBCYXJyZXR0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJhcnJldHQobSkge1xuICAgICAgICB0aGlzLm0gPSBtO1xuICAgICAgICAvLyBzZXR1cCBCYXJyZXR0XG4gICAgICAgIHRoaXMucjIgPSBuYmkoKTtcbiAgICAgICAgdGhpcy5xMyA9IG5iaSgpO1xuICAgICAgICBCaWdJbnRlZ2VyLk9ORS5kbFNoaWZ0VG8oMiAqIG0udCwgdGhpcy5yMik7XG4gICAgICAgIHRoaXMubXUgPSB0aGlzLnIyLmRpdmlkZShtKTtcbiAgICB9XG4gICAgLy8gQmFycmV0dC5wcm90b3R5cGUuY29udmVydCA9IGJhcnJldHRDb252ZXJ0O1xuICAgIEJhcnJldHQucHJvdG90eXBlLmNvbnZlcnQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICBpZiAoeC5zIDwgMCB8fCB4LnQgPiAyICogdGhpcy5tLnQpIHtcbiAgICAgICAgICAgIHJldHVybiB4Lm1vZCh0aGlzLm0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHguY29tcGFyZVRvKHRoaXMubSkgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciByID0gbmJpKCk7XG4gICAgICAgICAgICB4LmNvcHlUbyhyKTtcbiAgICAgICAgICAgIHRoaXMucmVkdWNlKHIpO1xuICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIEJhcnJldHQucHJvdG90eXBlLnJldmVydCA9IGJhcnJldHRSZXZlcnQ7XG4gICAgQmFycmV0dC5wcm90b3R5cGUucmV2ZXJ0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfTtcbiAgICAvLyBCYXJyZXR0LnByb3RvdHlwZS5yZWR1Y2UgPSBiYXJyZXR0UmVkdWNlO1xuICAgIC8vIHggPSB4IG1vZCBtIChIQUMgMTQuNDIpXG4gICAgQmFycmV0dC5wcm90b3R5cGUucmVkdWNlID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgeC5kclNoaWZ0VG8odGhpcy5tLnQgLSAxLCB0aGlzLnIyKTtcbiAgICAgICAgaWYgKHgudCA+IHRoaXMubS50ICsgMSkge1xuICAgICAgICAgICAgeC50ID0gdGhpcy5tLnQgKyAxO1xuICAgICAgICAgICAgeC5jbGFtcCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubXUubXVsdGlwbHlVcHBlclRvKHRoaXMucjIsIHRoaXMubS50ICsgMSwgdGhpcy5xMyk7XG4gICAgICAgIHRoaXMubS5tdWx0aXBseUxvd2VyVG8odGhpcy5xMywgdGhpcy5tLnQgKyAxLCB0aGlzLnIyKTtcbiAgICAgICAgd2hpbGUgKHguY29tcGFyZVRvKHRoaXMucjIpIDwgMCkge1xuICAgICAgICAgICAgeC5kQWRkT2Zmc2V0KDEsIHRoaXMubS50ICsgMSk7XG4gICAgICAgIH1cbiAgICAgICAgeC5zdWJUbyh0aGlzLnIyLCB4KTtcbiAgICAgICAgd2hpbGUgKHguY29tcGFyZVRvKHRoaXMubSkgPj0gMCkge1xuICAgICAgICAgICAgeC5zdWJUbyh0aGlzLm0sIHgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBCYXJyZXR0LnByb3RvdHlwZS5tdWxUbyA9IGJhcnJldHRNdWxUbztcbiAgICAvLyByID0geCp5IG1vZCBtOyB4LHkgIT0gclxuICAgIEJhcnJldHQucHJvdG90eXBlLm11bFRvID0gZnVuY3Rpb24gKHgsIHksIHIpIHtcbiAgICAgICAgeC5tdWx0aXBseVRvKHksIHIpO1xuICAgICAgICB0aGlzLnJlZHVjZShyKTtcbiAgICB9O1xuICAgIC8vIEJhcnJldHQucHJvdG90eXBlLnNxclRvID0gYmFycmV0dFNxclRvO1xuICAgIC8vIHIgPSB4XjIgbW9kIG07IHggIT0gclxuICAgIEJhcnJldHQucHJvdG90eXBlLnNxclRvID0gZnVuY3Rpb24gKHgsIHIpIHtcbiAgICAgICAgeC5zcXVhcmVUbyhyKTtcbiAgICAgICAgdGhpcy5yZWR1Y2Uocik7XG4gICAgfTtcbiAgICByZXR1cm4gQmFycmV0dDtcbn0oKSk7XG4vLyNlbmRyZWdpb25cbi8vI2VuZHJlZ2lvbiBSRURVQ0VSU1xuLy8gcmV0dXJuIG5ldywgdW5zZXQgQmlnSW50ZWdlclxuZXhwb3J0IGZ1bmN0aW9uIG5iaSgpIHsgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKG51bGwpOyB9XG5leHBvcnQgZnVuY3Rpb24gcGFyc2VCaWdJbnQoc3RyLCByKSB7XG4gICAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKHN0ciwgcik7XG59XG4vLyBhbTogQ29tcHV0ZSB3X2ogKz0gKHgqdGhpc19pKSwgcHJvcGFnYXRlIGNhcnJpZXMsXG4vLyBjIGlzIGluaXRpYWwgY2FycnksIHJldHVybnMgZmluYWwgY2FycnkuXG4vLyBjIDwgMypkdmFsdWUsIHggPCAyKmR2YWx1ZSwgdGhpc19pIDwgZHZhbHVlXG4vLyBXZSBuZWVkIHRvIHNlbGVjdCB0aGUgZmFzdGVzdCBvbmUgdGhhdCB3b3JrcyBpbiB0aGlzIGVudmlyb25tZW50LlxudmFyIGluQnJvd3NlciA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09IFwidW5kZWZpbmVkXCI7XG5pZiAoaW5Ccm93c2VyICYmIGpfbG0gJiYgKG5hdmlnYXRvci5hcHBOYW1lID09IFwiTWljcm9zb2Z0IEludGVybmV0IEV4cGxvcmVyXCIpKSB7XG4gICAgLy8gYW0yIGF2b2lkcyBhIGJpZyBtdWx0LWFuZC1leHRyYWN0IGNvbXBsZXRlbHkuXG4gICAgLy8gTWF4IGRpZ2l0IGJpdHMgc2hvdWxkIGJlIDw9IDMwIGJlY2F1c2Ugd2UgZG8gYml0d2lzZSBvcHNcbiAgICAvLyBvbiB2YWx1ZXMgdXAgdG8gMipoZHZhbHVlXjItaGR2YWx1ZS0xICg8IDJeMzEpXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuYW0gPSBmdW5jdGlvbiBhbTIoaSwgeCwgdywgaiwgYywgbikge1xuICAgICAgICB2YXIgeGwgPSB4ICYgMHg3ZmZmO1xuICAgICAgICB2YXIgeGggPSB4ID4+IDE1O1xuICAgICAgICB3aGlsZSAoLS1uID49IDApIHtcbiAgICAgICAgICAgIHZhciBsID0gdGhpc1tpXSAmIDB4N2ZmZjtcbiAgICAgICAgICAgIHZhciBoID0gdGhpc1tpKytdID4+IDE1O1xuICAgICAgICAgICAgdmFyIG0gPSB4aCAqIGwgKyBoICogeGw7XG4gICAgICAgICAgICBsID0geGwgKiBsICsgKChtICYgMHg3ZmZmKSA8PCAxNSkgKyB3W2pdICsgKGMgJiAweDNmZmZmZmZmKTtcbiAgICAgICAgICAgIGMgPSAobCA+Pj4gMzApICsgKG0gPj4+IDE1KSArIHhoICogaCArIChjID4+PiAzMCk7XG4gICAgICAgICAgICB3W2orK10gPSBsICYgMHgzZmZmZmZmZjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYztcbiAgICB9O1xuICAgIGRiaXRzID0gMzA7XG59XG5lbHNlIGlmIChpbkJyb3dzZXIgJiYgal9sbSAmJiAobmF2aWdhdG9yLmFwcE5hbWUgIT0gXCJOZXRzY2FwZVwiKSkge1xuICAgIC8vIGFtMTogdXNlIGEgc2luZ2xlIG11bHQgYW5kIGRpdmlkZSB0byBnZXQgdGhlIGhpZ2ggYml0cyxcbiAgICAvLyBtYXggZGlnaXQgYml0cyBzaG91bGQgYmUgMjYgYmVjYXVzZVxuICAgIC8vIG1heCBpbnRlcm5hbCB2YWx1ZSA9IDIqZHZhbHVlXjItMipkdmFsdWUgKDwgMl41MylcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5hbSA9IGZ1bmN0aW9uIGFtMShpLCB4LCB3LCBqLCBjLCBuKSB7XG4gICAgICAgIHdoaWxlICgtLW4gPj0gMCkge1xuICAgICAgICAgICAgdmFyIHYgPSB4ICogdGhpc1tpKytdICsgd1tqXSArIGM7XG4gICAgICAgICAgICBjID0gTWF0aC5mbG9vcih2IC8gMHg0MDAwMDAwKTtcbiAgICAgICAgICAgIHdbaisrXSA9IHYgJiAweDNmZmZmZmY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGM7XG4gICAgfTtcbiAgICBkYml0cyA9IDI2O1xufVxuZWxzZSB7IC8vIE1vemlsbGEvTmV0c2NhcGUgc2VlbXMgdG8gcHJlZmVyIGFtM1xuICAgIC8vIEFsdGVybmF0ZWx5LCBzZXQgbWF4IGRpZ2l0IGJpdHMgdG8gMjggc2luY2Ugc29tZVxuICAgIC8vIGJyb3dzZXJzIHNsb3cgZG93biB3aGVuIGRlYWxpbmcgd2l0aCAzMi1iaXQgbnVtYmVycy5cbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5hbSA9IGZ1bmN0aW9uIGFtMyhpLCB4LCB3LCBqLCBjLCBuKSB7XG4gICAgICAgIHZhciB4bCA9IHggJiAweDNmZmY7XG4gICAgICAgIHZhciB4aCA9IHggPj4gMTQ7XG4gICAgICAgIHdoaWxlICgtLW4gPj0gMCkge1xuICAgICAgICAgICAgdmFyIGwgPSB0aGlzW2ldICYgMHgzZmZmO1xuICAgICAgICAgICAgdmFyIGggPSB0aGlzW2krK10gPj4gMTQ7XG4gICAgICAgICAgICB2YXIgbSA9IHhoICogbCArIGggKiB4bDtcbiAgICAgICAgICAgIGwgPSB4bCAqIGwgKyAoKG0gJiAweDNmZmYpIDw8IDE0KSArIHdbal0gKyBjO1xuICAgICAgICAgICAgYyA9IChsID4+IDI4KSArIChtID4+IDE0KSArIHhoICogaDtcbiAgICAgICAgICAgIHdbaisrXSA9IGwgJiAweGZmZmZmZmY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGM7XG4gICAgfTtcbiAgICBkYml0cyA9IDI4O1xufVxuQmlnSW50ZWdlci5wcm90b3R5cGUuREIgPSBkYml0cztcbkJpZ0ludGVnZXIucHJvdG90eXBlLkRNID0gKCgxIDw8IGRiaXRzKSAtIDEpO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuRFYgPSAoMSA8PCBkYml0cyk7XG52YXIgQklfRlAgPSA1MjtcbkJpZ0ludGVnZXIucHJvdG90eXBlLkZWID0gTWF0aC5wb3coMiwgQklfRlApO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuRjEgPSBCSV9GUCAtIGRiaXRzO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuRjIgPSAyICogZGJpdHMgLSBCSV9GUDtcbi8vIERpZ2l0IGNvbnZlcnNpb25zXG52YXIgQklfUkMgPSBbXTtcbnZhciBycjtcbnZhciB2djtcbnJyID0gXCIwXCIuY2hhckNvZGVBdCgwKTtcbmZvciAodnYgPSAwOyB2diA8PSA5OyArK3Z2KSB7XG4gICAgQklfUkNbcnIrK10gPSB2djtcbn1cbnJyID0gXCJhXCIuY2hhckNvZGVBdCgwKTtcbmZvciAodnYgPSAxMDsgdnYgPCAzNjsgKyt2dikge1xuICAgIEJJX1JDW3JyKytdID0gdnY7XG59XG5yciA9IFwiQVwiLmNoYXJDb2RlQXQoMCk7XG5mb3IgKHZ2ID0gMTA7IHZ2IDwgMzY7ICsrdnYpIHtcbiAgICBCSV9SQ1tycisrXSA9IHZ2O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGludEF0KHMsIGkpIHtcbiAgICB2YXIgYyA9IEJJX1JDW3MuY2hhckNvZGVBdChpKV07XG4gICAgcmV0dXJuIChjID09IG51bGwpID8gLTEgOiBjO1xufVxuLy8gcmV0dXJuIGJpZ2ludCBpbml0aWFsaXplZCB0byB2YWx1ZVxuZXhwb3J0IGZ1bmN0aW9uIG5idihpKSB7XG4gICAgdmFyIHIgPSBuYmkoKTtcbiAgICByLmZyb21JbnQoaSk7XG4gICAgcmV0dXJuIHI7XG59XG4vLyByZXR1cm5zIGJpdCBsZW5ndGggb2YgdGhlIGludGVnZXIgeFxuZXhwb3J0IGZ1bmN0aW9uIG5iaXRzKHgpIHtcbiAgICB2YXIgciA9IDE7XG4gICAgdmFyIHQ7XG4gICAgaWYgKCh0ID0geCA+Pj4gMTYpICE9IDApIHtcbiAgICAgICAgeCA9IHQ7XG4gICAgICAgIHIgKz0gMTY7XG4gICAgfVxuICAgIGlmICgodCA9IHggPj4gOCkgIT0gMCkge1xuICAgICAgICB4ID0gdDtcbiAgICAgICAgciArPSA4O1xuICAgIH1cbiAgICBpZiAoKHQgPSB4ID4+IDQpICE9IDApIHtcbiAgICAgICAgeCA9IHQ7XG4gICAgICAgIHIgKz0gNDtcbiAgICB9XG4gICAgaWYgKCh0ID0geCA+PiAyKSAhPSAwKSB7XG4gICAgICAgIHggPSB0O1xuICAgICAgICByICs9IDI7XG4gICAgfVxuICAgIGlmICgodCA9IHggPj4gMSkgIT0gMCkge1xuICAgICAgICB4ID0gdDtcbiAgICAgICAgciArPSAxO1xuICAgIH1cbiAgICByZXR1cm4gcjtcbn1cbi8vIFwiY29uc3RhbnRzXCJcbkJpZ0ludGVnZXIuWkVSTyA9IG5idigwKTtcbkJpZ0ludGVnZXIuT05FID0gbmJ2KDEpO1xuIiwiLy8gcHJuZzQuanMgLSB1c2VzIEFyY2ZvdXIgYXMgYSBQUk5HXG52YXIgQXJjZm91ciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBcmNmb3VyKCkge1xuICAgICAgICB0aGlzLmkgPSAwO1xuICAgICAgICB0aGlzLmogPSAwO1xuICAgICAgICB0aGlzLlMgPSBbXTtcbiAgICB9XG4gICAgLy8gQXJjZm91ci5wcm90b3R5cGUuaW5pdCA9IEFSQzRpbml0O1xuICAgIC8vIEluaXRpYWxpemUgYXJjZm91ciBjb250ZXh0IGZyb20ga2V5LCBhbiBhcnJheSBvZiBpbnRzLCBlYWNoIGZyb20gWzAuLjI1NV1cbiAgICBBcmNmb3VyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIGo7XG4gICAgICAgIHZhciB0O1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMjU2OyArK2kpIHtcbiAgICAgICAgICAgIHRoaXMuU1tpXSA9IGk7XG4gICAgICAgIH1cbiAgICAgICAgaiA9IDA7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAyNTY7ICsraSkge1xuICAgICAgICAgICAgaiA9IChqICsgdGhpcy5TW2ldICsga2V5W2kgJSBrZXkubGVuZ3RoXSkgJiAyNTU7XG4gICAgICAgICAgICB0ID0gdGhpcy5TW2ldO1xuICAgICAgICAgICAgdGhpcy5TW2ldID0gdGhpcy5TW2pdO1xuICAgICAgICAgICAgdGhpcy5TW2pdID0gdDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmkgPSAwO1xuICAgICAgICB0aGlzLmogPSAwO1xuICAgIH07XG4gICAgLy8gQXJjZm91ci5wcm90b3R5cGUubmV4dCA9IEFSQzRuZXh0O1xuICAgIEFyY2ZvdXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0O1xuICAgICAgICB0aGlzLmkgPSAodGhpcy5pICsgMSkgJiAyNTU7XG4gICAgICAgIHRoaXMuaiA9ICh0aGlzLmogKyB0aGlzLlNbdGhpcy5pXSkgJiAyNTU7XG4gICAgICAgIHQgPSB0aGlzLlNbdGhpcy5pXTtcbiAgICAgICAgdGhpcy5TW3RoaXMuaV0gPSB0aGlzLlNbdGhpcy5qXTtcbiAgICAgICAgdGhpcy5TW3RoaXMual0gPSB0O1xuICAgICAgICByZXR1cm4gdGhpcy5TWyh0ICsgdGhpcy5TW3RoaXMuaV0pICYgMjU1XTtcbiAgICB9O1xuICAgIHJldHVybiBBcmNmb3VyO1xufSgpKTtcbmV4cG9ydCB7IEFyY2ZvdXIgfTtcbi8vIFBsdWcgaW4geW91ciBSTkcgY29uc3RydWN0b3IgaGVyZVxuZXhwb3J0IGZ1bmN0aW9uIHBybmdfbmV3c3RhdGUoKSB7XG4gICAgcmV0dXJuIG5ldyBBcmNmb3VyKCk7XG59XG4vLyBQb29sIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQgYW5kIGdyZWF0ZXIgdGhhbiAzMi5cbi8vIEFuIGFycmF5IG9mIGJ5dGVzIHRoZSBzaXplIG9mIHRoZSBwb29sIHdpbGwgYmUgcGFzc2VkIHRvIGluaXQoKVxuZXhwb3J0IHZhciBybmdfcHNpemUgPSAyNTY7XG4iLCIvLyBSYW5kb20gbnVtYmVyIGdlbmVyYXRvciAtIHJlcXVpcmVzIGEgUFJORyBiYWNrZW5kLCBlLmcuIHBybmc0LmpzXG5pbXBvcnQgeyBwcm5nX25ld3N0YXRlLCBybmdfcHNpemUgfSBmcm9tIFwiLi9wcm5nNFwiO1xudmFyIHJuZ19zdGF0ZTtcbnZhciBybmdfcG9vbCA9IG51bGw7XG52YXIgcm5nX3BwdHI7XG4vLyBJbml0aWFsaXplIHRoZSBwb29sIHdpdGgganVuayBpZiBuZWVkZWQuXG5pZiAocm5nX3Bvb2wgPT0gbnVsbCkge1xuICAgIHJuZ19wb29sID0gW107XG4gICAgcm5nX3BwdHIgPSAwO1xuICAgIHZhciB0ID0gdm9pZCAwO1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuY3J5cHRvICYmIHdpbmRvdy5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgICAgIC8vIEV4dHJhY3QgZW50cm9weSAoMjA0OCBiaXRzKSBmcm9tIFJORyBpZiBhdmFpbGFibGVcbiAgICAgICAgdmFyIHogPSBuZXcgVWludDMyQXJyYXkoMjU2KTtcbiAgICAgICAgd2luZG93LmNyeXB0by5nZXRSYW5kb21WYWx1ZXMoeik7XG4gICAgICAgIGZvciAodCA9IDA7IHQgPCB6Lmxlbmd0aDsgKyt0KSB7XG4gICAgICAgICAgICBybmdfcG9vbFtybmdfcHB0cisrXSA9IHpbdF0gJiAyNTU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVXNlIG1vdXNlIGV2ZW50cyBmb3IgZW50cm9weSwgaWYgd2UgZG8gbm90IGhhdmUgZW5vdWdoIGVudHJvcHkgYnkgdGhlIHRpbWVcbiAgICAvLyB3ZSBuZWVkIGl0LCBlbnRyb3B5IHdpbGwgYmUgZ2VuZXJhdGVkIGJ5IE1hdGgucmFuZG9tLlxuICAgIHZhciBjb3VudCA9IDA7XG4gICAgdmFyIG9uTW91c2VNb3ZlTGlzdGVuZXJfMSA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICBjb3VudCA9IGNvdW50IHx8IDA7XG4gICAgICAgIGlmIChjb3VudCA+PSAyNTYgfHwgcm5nX3BwdHIgPj0gcm5nX3BzaXplKSB7XG4gICAgICAgICAgICBpZiAod2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBvbk1vdXNlTW92ZUxpc3RlbmVyXzEsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHdpbmRvdy5kZXRhY2hFdmVudCkge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5kZXRhY2hFdmVudChcIm9ubW91c2Vtb3ZlXCIsIG9uTW91c2VNb3ZlTGlzdGVuZXJfMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBtb3VzZUNvb3JkaW5hdGVzID0gZXYueCArIGV2Lnk7XG4gICAgICAgICAgICBybmdfcG9vbFtybmdfcHB0cisrXSA9IG1vdXNlQ29vcmRpbmF0ZXMgJiAyNTU7XG4gICAgICAgICAgICBjb3VudCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBTb21ldGltZXMgRmlyZWZveCB3aWxsIGRlbnkgcGVybWlzc2lvbiB0byBhY2Nlc3MgZXZlbnQgcHJvcGVydGllcyBmb3Igc29tZSByZWFzb24uIElnbm9yZS5cbiAgICAgICAgfVxuICAgIH07XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGlmICh3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgb25Nb3VzZU1vdmVMaXN0ZW5lcl8xLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAod2luZG93LmF0dGFjaEV2ZW50KSB7XG4gICAgICAgICAgICB3aW5kb3cuYXR0YWNoRXZlbnQoXCJvbm1vdXNlbW92ZVwiLCBvbk1vdXNlTW92ZUxpc3RlbmVyXzEpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gcm5nX2dldF9ieXRlKCkge1xuICAgIGlmIChybmdfc3RhdGUgPT0gbnVsbCkge1xuICAgICAgICBybmdfc3RhdGUgPSBwcm5nX25ld3N0YXRlKCk7XG4gICAgICAgIC8vIEF0IHRoaXMgcG9pbnQsIHdlIG1heSBub3QgaGF2ZSBjb2xsZWN0ZWQgZW5vdWdoIGVudHJvcHkuICBJZiBub3QsIGZhbGwgYmFjayB0byBNYXRoLnJhbmRvbVxuICAgICAgICB3aGlsZSAocm5nX3BwdHIgPCBybmdfcHNpemUpIHtcbiAgICAgICAgICAgIHZhciByYW5kb20gPSBNYXRoLmZsb29yKDY1NTM2ICogTWF0aC5yYW5kb20oKSk7XG4gICAgICAgICAgICBybmdfcG9vbFtybmdfcHB0cisrXSA9IHJhbmRvbSAmIDI1NTtcbiAgICAgICAgfVxuICAgICAgICBybmdfc3RhdGUuaW5pdChybmdfcG9vbCk7XG4gICAgICAgIGZvciAocm5nX3BwdHIgPSAwOyBybmdfcHB0ciA8IHJuZ19wb29sLmxlbmd0aDsgKytybmdfcHB0cikge1xuICAgICAgICAgICAgcm5nX3Bvb2xbcm5nX3BwdHJdID0gMDtcbiAgICAgICAgfVxuICAgICAgICBybmdfcHB0ciA9IDA7XG4gICAgfVxuICAgIC8vIFRPRE86IGFsbG93IHJlc2VlZGluZyBhZnRlciBmaXJzdCByZXF1ZXN0XG4gICAgcmV0dXJuIHJuZ19zdGF0ZS5uZXh0KCk7XG59XG52YXIgU2VjdXJlUmFuZG9tID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNlY3VyZVJhbmRvbSgpIHtcbiAgICB9XG4gICAgU2VjdXJlUmFuZG9tLnByb3RvdHlwZS5uZXh0Qnl0ZXMgPSBmdW5jdGlvbiAoYmEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiYS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgYmFbaV0gPSBybmdfZ2V0X2J5dGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFNlY3VyZVJhbmRvbTtcbn0oKSk7XG5leHBvcnQgeyBTZWN1cmVSYW5kb20gfTtcbiIsIi8vIERlcGVuZHMgb24ganNibi5qcyBhbmQgcm5nLmpzXG4vLyBWZXJzaW9uIDEuMTogc3VwcG9ydCB1dGYtOCBlbmNvZGluZyBpbiBwa2NzMXBhZDJcbi8vIGNvbnZlcnQgYSAoaGV4KSBzdHJpbmcgdG8gYSBiaWdudW0gb2JqZWN0XG5pbXBvcnQgeyBCaWdJbnRlZ2VyLCBuYmksIHBhcnNlQmlnSW50IH0gZnJvbSBcIi4vanNiblwiO1xuaW1wb3J0IHsgU2VjdXJlUmFuZG9tIH0gZnJvbSBcIi4vcm5nXCI7XG4vLyBmdW5jdGlvbiBsaW5lYnJrKHMsbikge1xuLy8gICB2YXIgcmV0ID0gXCJcIjtcbi8vICAgdmFyIGkgPSAwO1xuLy8gICB3aGlsZShpICsgbiA8IHMubGVuZ3RoKSB7XG4vLyAgICAgcmV0ICs9IHMuc3Vic3RyaW5nKGksaStuKSArIFwiXFxuXCI7XG4vLyAgICAgaSArPSBuO1xuLy8gICB9XG4vLyAgIHJldHVybiByZXQgKyBzLnN1YnN0cmluZyhpLHMubGVuZ3RoKTtcbi8vIH1cbi8vIGZ1bmN0aW9uIGJ5dGUySGV4KGIpIHtcbi8vICAgaWYoYiA8IDB4MTApXG4vLyAgICAgcmV0dXJuIFwiMFwiICsgYi50b1N0cmluZygxNik7XG4vLyAgIGVsc2Vcbi8vICAgICByZXR1cm4gYi50b1N0cmluZygxNik7XG4vLyB9XG5mdW5jdGlvbiBwa2NzMXBhZDEocywgbikge1xuICAgIGlmIChuIDwgcy5sZW5ndGggKyAyMikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiTWVzc2FnZSB0b28gbG9uZyBmb3IgUlNBXCIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIGxlbiA9IG4gLSBzLmxlbmd0aCAtIDY7XG4gICAgdmFyIGZpbGxlciA9IFwiXCI7XG4gICAgZm9yICh2YXIgZiA9IDA7IGYgPCBsZW47IGYgKz0gMikge1xuICAgICAgICBmaWxsZXIgKz0gXCJmZlwiO1xuICAgIH1cbiAgICB2YXIgbSA9IFwiMDAwMVwiICsgZmlsbGVyICsgXCIwMFwiICsgcztcbiAgICByZXR1cm4gcGFyc2VCaWdJbnQobSwgMTYpO1xufVxuLy8gUEtDUyMxICh0eXBlIDIsIHJhbmRvbSkgcGFkIGlucHV0IHN0cmluZyBzIHRvIG4gYnl0ZXMsIGFuZCByZXR1cm4gYSBiaWdpbnRcbmZ1bmN0aW9uIHBrY3MxcGFkMihzLCBuKSB7XG4gICAgaWYgKG4gPCBzLmxlbmd0aCArIDExKSB7IC8vIFRPRE86IGZpeCBmb3IgdXRmLThcbiAgICAgICAgY29uc29sZS5lcnJvcihcIk1lc3NhZ2UgdG9vIGxvbmcgZm9yIFJTQVwiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBiYSA9IFtdO1xuICAgIHZhciBpID0gcy5sZW5ndGggLSAxO1xuICAgIHdoaWxlIChpID49IDAgJiYgbiA+IDApIHtcbiAgICAgICAgdmFyIGMgPSBzLmNoYXJDb2RlQXQoaS0tKTtcbiAgICAgICAgaWYgKGMgPCAxMjgpIHsgLy8gZW5jb2RlIHVzaW5nIHV0Zi04XG4gICAgICAgICAgICBiYVstLW5dID0gYztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoYyA+IDEyNykgJiYgKGMgPCAyMDQ4KSkge1xuICAgICAgICAgICAgYmFbLS1uXSA9IChjICYgNjMpIHwgMTI4O1xuICAgICAgICAgICAgYmFbLS1uXSA9IChjID4+IDYpIHwgMTkyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYmFbLS1uXSA9IChjICYgNjMpIHwgMTI4O1xuICAgICAgICAgICAgYmFbLS1uXSA9ICgoYyA+PiA2KSAmIDYzKSB8IDEyODtcbiAgICAgICAgICAgIGJhWy0tbl0gPSAoYyA+PiAxMikgfCAyMjQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYmFbLS1uXSA9IDA7XG4gICAgdmFyIHJuZyA9IG5ldyBTZWN1cmVSYW5kb20oKTtcbiAgICB2YXIgeCA9IFtdO1xuICAgIHdoaWxlIChuID4gMikgeyAvLyByYW5kb20gbm9uLXplcm8gcGFkXG4gICAgICAgIHhbMF0gPSAwO1xuICAgICAgICB3aGlsZSAoeFswXSA9PSAwKSB7XG4gICAgICAgICAgICBybmcubmV4dEJ5dGVzKHgpO1xuICAgICAgICB9XG4gICAgICAgIGJhWy0tbl0gPSB4WzBdO1xuICAgIH1cbiAgICBiYVstLW5dID0gMjtcbiAgICBiYVstLW5dID0gMDtcbiAgICByZXR1cm4gbmV3IEJpZ0ludGVnZXIoYmEpO1xufVxuLy8gXCJlbXB0eVwiIFJTQSBrZXkgY29uc3RydWN0b3JcbnZhciBSU0FLZXkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUlNBS2V5KCkge1xuICAgICAgICB0aGlzLm4gPSBudWxsO1xuICAgICAgICB0aGlzLmUgPSAwO1xuICAgICAgICB0aGlzLmQgPSBudWxsO1xuICAgICAgICB0aGlzLnAgPSBudWxsO1xuICAgICAgICB0aGlzLnEgPSBudWxsO1xuICAgICAgICB0aGlzLmRtcDEgPSBudWxsO1xuICAgICAgICB0aGlzLmRtcTEgPSBudWxsO1xuICAgICAgICB0aGlzLmNvZWZmID0gbnVsbDtcbiAgICB9XG4gICAgLy8jcmVnaW9uIFBST1RFQ1RFRFxuICAgIC8vIHByb3RlY3RlZFxuICAgIC8vIFJTQUtleS5wcm90b3R5cGUuZG9QdWJsaWMgPSBSU0FEb1B1YmxpYztcbiAgICAvLyBQZXJmb3JtIHJhdyBwdWJsaWMgb3BlcmF0aW9uIG9uIFwieFwiOiByZXR1cm4geF5lIChtb2QgbilcbiAgICBSU0FLZXkucHJvdG90eXBlLmRvUHVibGljID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHgubW9kUG93SW50KHRoaXMuZSwgdGhpcy5uKTtcbiAgICB9O1xuICAgIC8vIFJTQUtleS5wcm90b3R5cGUuZG9Qcml2YXRlID0gUlNBRG9Qcml2YXRlO1xuICAgIC8vIFBlcmZvcm0gcmF3IHByaXZhdGUgb3BlcmF0aW9uIG9uIFwieFwiOiByZXR1cm4geF5kIChtb2QgbilcbiAgICBSU0FLZXkucHJvdG90eXBlLmRvUHJpdmF0ZSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIGlmICh0aGlzLnAgPT0gbnVsbCB8fCB0aGlzLnEgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHgubW9kUG93KHRoaXMuZCwgdGhpcy5uKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiByZS1jYWxjdWxhdGUgYW55IG1pc3NpbmcgQ1JUIHBhcmFtc1xuICAgICAgICB2YXIgeHAgPSB4Lm1vZCh0aGlzLnApLm1vZFBvdyh0aGlzLmRtcDEsIHRoaXMucCk7XG4gICAgICAgIHZhciB4cSA9IHgubW9kKHRoaXMucSkubW9kUG93KHRoaXMuZG1xMSwgdGhpcy5xKTtcbiAgICAgICAgd2hpbGUgKHhwLmNvbXBhcmVUbyh4cSkgPCAwKSB7XG4gICAgICAgICAgICB4cCA9IHhwLmFkZCh0aGlzLnApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4cC5zdWJ0cmFjdCh4cSkubXVsdGlwbHkodGhpcy5jb2VmZikubW9kKHRoaXMucCkubXVsdGlwbHkodGhpcy5xKS5hZGQoeHEpO1xuICAgIH07XG4gICAgLy8jZW5kcmVnaW9uIFBST1RFQ1RFRFxuICAgIC8vI3JlZ2lvbiBQVUJMSUNcbiAgICAvLyBSU0FLZXkucHJvdG90eXBlLnNldFB1YmxpYyA9IFJTQVNldFB1YmxpYztcbiAgICAvLyBTZXQgdGhlIHB1YmxpYyBrZXkgZmllbGRzIE4gYW5kIGUgZnJvbSBoZXggc3RyaW5nc1xuICAgIFJTQUtleS5wcm90b3R5cGUuc2V0UHVibGljID0gZnVuY3Rpb24gKE4sIEUpIHtcbiAgICAgICAgaWYgKE4gIT0gbnVsbCAmJiBFICE9IG51bGwgJiYgTi5sZW5ndGggPiAwICYmIEUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5uID0gcGFyc2VCaWdJbnQoTiwgMTYpO1xuICAgICAgICAgICAgdGhpcy5lID0gcGFyc2VJbnQoRSwgMTYpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkludmFsaWQgUlNBIHB1YmxpYyBrZXlcIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIFJTQUtleS5wcm90b3R5cGUuZW5jcnlwdCA9IFJTQUVuY3J5cHQ7XG4gICAgLy8gUmV0dXJuIHRoZSBQS0NTIzEgUlNBIGVuY3J5cHRpb24gb2YgXCJ0ZXh0XCIgYXMgYW4gZXZlbi1sZW5ndGggaGV4IHN0cmluZ1xuICAgIFJTQUtleS5wcm90b3R5cGUuZW5jcnlwdCA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICAgIHZhciBtYXhMZW5ndGggPSAodGhpcy5uLmJpdExlbmd0aCgpICsgNykgPj4gMztcbiAgICAgICAgdmFyIG0gPSBwa2NzMXBhZDIodGV4dCwgbWF4TGVuZ3RoKTtcbiAgICAgICAgaWYgKG0gPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGMgPSB0aGlzLmRvUHVibGljKG0pO1xuICAgICAgICBpZiAoYyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaCA9IGMudG9TdHJpbmcoMTYpO1xuICAgICAgICB2YXIgbGVuZ3RoID0gaC5sZW5ndGg7XG4gICAgICAgIC8vIGZpeCB6ZXJvIGJlZm9yZSByZXN1bHRcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXhMZW5ndGggKiAyIC0gbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGggPSBcIjBcIiArIGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGg7XG4gICAgfTtcbiAgICAvLyBSU0FLZXkucHJvdG90eXBlLnNldFByaXZhdGUgPSBSU0FTZXRQcml2YXRlO1xuICAgIC8vIFNldCB0aGUgcHJpdmF0ZSBrZXkgZmllbGRzIE4sIGUsIGFuZCBkIGZyb20gaGV4IHN0cmluZ3NcbiAgICBSU0FLZXkucHJvdG90eXBlLnNldFByaXZhdGUgPSBmdW5jdGlvbiAoTiwgRSwgRCkge1xuICAgICAgICBpZiAoTiAhPSBudWxsICYmIEUgIT0gbnVsbCAmJiBOLmxlbmd0aCA+IDAgJiYgRS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLm4gPSBwYXJzZUJpZ0ludChOLCAxNik7XG4gICAgICAgICAgICB0aGlzLmUgPSBwYXJzZUludChFLCAxNik7XG4gICAgICAgICAgICB0aGlzLmQgPSBwYXJzZUJpZ0ludChELCAxNik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiSW52YWxpZCBSU0EgcHJpdmF0ZSBrZXlcIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIFJTQUtleS5wcm90b3R5cGUuc2V0UHJpdmF0ZUV4ID0gUlNBU2V0UHJpdmF0ZUV4O1xuICAgIC8vIFNldCB0aGUgcHJpdmF0ZSBrZXkgZmllbGRzIE4sIGUsIGQgYW5kIENSVCBwYXJhbXMgZnJvbSBoZXggc3RyaW5nc1xuICAgIFJTQUtleS5wcm90b3R5cGUuc2V0UHJpdmF0ZUV4ID0gZnVuY3Rpb24gKE4sIEUsIEQsIFAsIFEsIERQLCBEUSwgQykge1xuICAgICAgICBpZiAoTiAhPSBudWxsICYmIEUgIT0gbnVsbCAmJiBOLmxlbmd0aCA+IDAgJiYgRS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLm4gPSBwYXJzZUJpZ0ludChOLCAxNik7XG4gICAgICAgICAgICB0aGlzLmUgPSBwYXJzZUludChFLCAxNik7XG4gICAgICAgICAgICB0aGlzLmQgPSBwYXJzZUJpZ0ludChELCAxNik7XG4gICAgICAgICAgICB0aGlzLnAgPSBwYXJzZUJpZ0ludChQLCAxNik7XG4gICAgICAgICAgICB0aGlzLnEgPSBwYXJzZUJpZ0ludChRLCAxNik7XG4gICAgICAgICAgICB0aGlzLmRtcDEgPSBwYXJzZUJpZ0ludChEUCwgMTYpO1xuICAgICAgICAgICAgdGhpcy5kbXExID0gcGFyc2VCaWdJbnQoRFEsIDE2KTtcbiAgICAgICAgICAgIHRoaXMuY29lZmYgPSBwYXJzZUJpZ0ludChDLCAxNik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiSW52YWxpZCBSU0EgcHJpdmF0ZSBrZXlcIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIFJTQUtleS5wcm90b3R5cGUuZ2VuZXJhdGUgPSBSU0FHZW5lcmF0ZTtcbiAgICAvLyBHZW5lcmF0ZSBhIG5ldyByYW5kb20gcHJpdmF0ZSBrZXkgQiBiaXRzIGxvbmcsIHVzaW5nIHB1YmxpYyBleHB0IEVcbiAgICBSU0FLZXkucHJvdG90eXBlLmdlbmVyYXRlID0gZnVuY3Rpb24gKEIsIEUpIHtcbiAgICAgICAgdmFyIHJuZyA9IG5ldyBTZWN1cmVSYW5kb20oKTtcbiAgICAgICAgdmFyIHFzID0gQiA+PiAxO1xuICAgICAgICB0aGlzLmUgPSBwYXJzZUludChFLCAxNik7XG4gICAgICAgIHZhciBlZSA9IG5ldyBCaWdJbnRlZ2VyKEUsIDE2KTtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgIHRoaXMucCA9IG5ldyBCaWdJbnRlZ2VyKEIgLSBxcywgMSwgcm5nKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wLnN1YnRyYWN0KEJpZ0ludGVnZXIuT05FKS5nY2QoZWUpLmNvbXBhcmVUbyhCaWdJbnRlZ2VyLk9ORSkgPT0gMCAmJiB0aGlzLnAuaXNQcm9iYWJsZVByaW1lKDEwKSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5xID0gbmV3IEJpZ0ludGVnZXIocXMsIDEsIHJuZyk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucS5zdWJ0cmFjdChCaWdJbnRlZ2VyLk9ORSkuZ2NkKGVlKS5jb21wYXJlVG8oQmlnSW50ZWdlci5PTkUpID09IDAgJiYgdGhpcy5xLmlzUHJvYmFibGVQcmltZSgxMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMucC5jb21wYXJlVG8odGhpcy5xKSA8PSAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIHQgPSB0aGlzLnA7XG4gICAgICAgICAgICAgICAgdGhpcy5wID0gdGhpcy5xO1xuICAgICAgICAgICAgICAgIHRoaXMucSA9IHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcDEgPSB0aGlzLnAuc3VidHJhY3QoQmlnSW50ZWdlci5PTkUpO1xuICAgICAgICAgICAgdmFyIHExID0gdGhpcy5xLnN1YnRyYWN0KEJpZ0ludGVnZXIuT05FKTtcbiAgICAgICAgICAgIHZhciBwaGkgPSBwMS5tdWx0aXBseShxMSk7XG4gICAgICAgICAgICBpZiAocGhpLmdjZChlZSkuY29tcGFyZVRvKEJpZ0ludGVnZXIuT05FKSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uID0gdGhpcy5wLm11bHRpcGx5KHRoaXMucSk7XG4gICAgICAgICAgICAgICAgdGhpcy5kID0gZWUubW9kSW52ZXJzZShwaGkpO1xuICAgICAgICAgICAgICAgIHRoaXMuZG1wMSA9IHRoaXMuZC5tb2QocDEpO1xuICAgICAgICAgICAgICAgIHRoaXMuZG1xMSA9IHRoaXMuZC5tb2QocTEpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29lZmYgPSB0aGlzLnEubW9kSW52ZXJzZSh0aGlzLnApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBSU0FLZXkucHJvdG90eXBlLmRlY3J5cHQgPSBSU0FEZWNyeXB0O1xuICAgIC8vIFJldHVybiB0aGUgUEtDUyMxIFJTQSBkZWNyeXB0aW9uIG9mIFwiY3RleHRcIi5cbiAgICAvLyBcImN0ZXh0XCIgaXMgYW4gZXZlbi1sZW5ndGggaGV4IHN0cmluZyBhbmQgdGhlIG91dHB1dCBpcyBhIHBsYWluIHN0cmluZy5cbiAgICBSU0FLZXkucHJvdG90eXBlLmRlY3J5cHQgPSBmdW5jdGlvbiAoY3RleHQpIHtcbiAgICAgICAgdmFyIGMgPSBwYXJzZUJpZ0ludChjdGV4dCwgMTYpO1xuICAgICAgICB2YXIgbSA9IHRoaXMuZG9Qcml2YXRlKGMpO1xuICAgICAgICBpZiAobSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGtjczF1bnBhZDIobSwgKHRoaXMubi5iaXRMZW5ndGgoKSArIDcpID4+IDMpO1xuICAgIH07XG4gICAgLy8gR2VuZXJhdGUgYSBuZXcgcmFuZG9tIHByaXZhdGUga2V5IEIgYml0cyBsb25nLCB1c2luZyBwdWJsaWMgZXhwdCBFXG4gICAgUlNBS2V5LnByb3RvdHlwZS5nZW5lcmF0ZUFzeW5jID0gZnVuY3Rpb24gKEIsIEUsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBybmcgPSBuZXcgU2VjdXJlUmFuZG9tKCk7XG4gICAgICAgIHZhciBxcyA9IEIgPj4gMTtcbiAgICAgICAgdGhpcy5lID0gcGFyc2VJbnQoRSwgMTYpO1xuICAgICAgICB2YXIgZWUgPSBuZXcgQmlnSW50ZWdlcihFLCAxNik7XG4gICAgICAgIHZhciByc2EgPSB0aGlzO1xuICAgICAgICAvLyBUaGVzZSBmdW5jdGlvbnMgaGF2ZSBub24tZGVzY3JpcHQgbmFtZXMgYmVjYXVzZSB0aGV5IHdlcmUgb3JpZ2luYWxseSBmb3IoOzspIGxvb3BzLlxuICAgICAgICAvLyBJIGRvbid0IGtub3cgYWJvdXQgY3J5cHRvZ3JhcGh5IHRvIGdpdmUgdGhlbSBiZXR0ZXIgbmFtZXMgdGhhbiBsb29wMS00LlxuICAgICAgICB2YXIgbG9vcDEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbG9vcDQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJzYS5wLmNvbXBhcmVUbyhyc2EucSkgPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IHJzYS5wO1xuICAgICAgICAgICAgICAgICAgICByc2EucCA9IHJzYS5xO1xuICAgICAgICAgICAgICAgICAgICByc2EucSA9IHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBwMSA9IHJzYS5wLnN1YnRyYWN0KEJpZ0ludGVnZXIuT05FKTtcbiAgICAgICAgICAgICAgICB2YXIgcTEgPSByc2EucS5zdWJ0cmFjdChCaWdJbnRlZ2VyLk9ORSk7XG4gICAgICAgICAgICAgICAgdmFyIHBoaSA9IHAxLm11bHRpcGx5KHExKTtcbiAgICAgICAgICAgICAgICBpZiAocGhpLmdjZChlZSkuY29tcGFyZVRvKEJpZ0ludGVnZXIuT05FKSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJzYS5uID0gcnNhLnAubXVsdGlwbHkocnNhLnEpO1xuICAgICAgICAgICAgICAgICAgICByc2EuZCA9IGVlLm1vZEludmVyc2UocGhpKTtcbiAgICAgICAgICAgICAgICAgICAgcnNhLmRtcDEgPSByc2EuZC5tb2QocDEpO1xuICAgICAgICAgICAgICAgICAgICByc2EuZG1xMSA9IHJzYS5kLm1vZChxMSk7XG4gICAgICAgICAgICAgICAgICAgIHJzYS5jb2VmZiA9IHJzYS5xLm1vZEludmVyc2UocnNhLnApO1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgY2FsbGJhY2soKTsgfSwgMCk7IC8vIGVzY2FwZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChsb29wMSwgMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBsb29wMyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByc2EucSA9IG5iaSgpO1xuICAgICAgICAgICAgICAgIHJzYS5xLmZyb21OdW1iZXJBc3luYyhxcywgMSwgcm5nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJzYS5xLnN1YnRyYWN0KEJpZ0ludGVnZXIuT05FKS5nY2RhKGVlLCBmdW5jdGlvbiAocikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHIuY29tcGFyZVRvKEJpZ0ludGVnZXIuT05FKSA9PSAwICYmIHJzYS5xLmlzUHJvYmFibGVQcmltZSgxMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGxvb3A0LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQobG9vcDMsIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgbG9vcDIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcnNhLnAgPSBuYmkoKTtcbiAgICAgICAgICAgICAgICByc2EucC5mcm9tTnVtYmVyQXN5bmMoQiAtIHFzLCAxLCBybmcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcnNhLnAuc3VidHJhY3QoQmlnSW50ZWdlci5PTkUpLmdjZGEoZWUsIGZ1bmN0aW9uIChyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoci5jb21wYXJlVG8oQmlnSW50ZWdlci5PTkUpID09IDAgJiYgcnNhLnAuaXNQcm9iYWJsZVByaW1lKDEwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQobG9vcDMsIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChsb29wMiwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQobG9vcDIsIDApO1xuICAgICAgICB9O1xuICAgICAgICBzZXRUaW1lb3V0KGxvb3AxLCAwKTtcbiAgICB9O1xuICAgIFJTQUtleS5wcm90b3R5cGUuc2lnbiA9IGZ1bmN0aW9uICh0ZXh0LCBkaWdlc3RNZXRob2QsIGRpZ2VzdE5hbWUpIHtcbiAgICAgICAgdmFyIGhlYWRlciA9IGdldERpZ2VzdEhlYWRlcihkaWdlc3ROYW1lKTtcbiAgICAgICAgdmFyIGRpZ2VzdCA9IGhlYWRlciArIGRpZ2VzdE1ldGhvZCh0ZXh0KS50b1N0cmluZygpO1xuICAgICAgICB2YXIgbSA9IHBrY3MxcGFkMShkaWdlc3QsIHRoaXMubi5iaXRMZW5ndGgoKSAvIDQpO1xuICAgICAgICBpZiAobSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYyA9IHRoaXMuZG9Qcml2YXRlKG0pO1xuICAgICAgICBpZiAoYyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaCA9IGMudG9TdHJpbmcoMTYpO1xuICAgICAgICBpZiAoKGgubGVuZ3RoICYgMSkgPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gXCIwXCIgKyBoO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSU0FLZXkucHJvdG90eXBlLnZlcmlmeSA9IGZ1bmN0aW9uICh0ZXh0LCBzaWduYXR1cmUsIGRpZ2VzdE1ldGhvZCkge1xuICAgICAgICB2YXIgYyA9IHBhcnNlQmlnSW50KHNpZ25hdHVyZSwgMTYpO1xuICAgICAgICB2YXIgbSA9IHRoaXMuZG9QdWJsaWMoYyk7XG4gICAgICAgIGlmIChtID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciB1bnBhZGRlZCA9IG0udG9TdHJpbmcoMTYpLnJlcGxhY2UoL14xZiswMC8sIFwiXCIpO1xuICAgICAgICB2YXIgZGlnZXN0ID0gcmVtb3ZlRGlnZXN0SGVhZGVyKHVucGFkZGVkKTtcbiAgICAgICAgcmV0dXJuIGRpZ2VzdCA9PSBkaWdlc3RNZXRob2QodGV4dCkudG9TdHJpbmcoKTtcbiAgICB9O1xuICAgIHJldHVybiBSU0FLZXk7XG59KCkpO1xuZXhwb3J0IHsgUlNBS2V5IH07XG4vLyBVbmRvIFBLQ1MjMSAodHlwZSAyLCByYW5kb20pIHBhZGRpbmcgYW5kLCBpZiB2YWxpZCwgcmV0dXJuIHRoZSBwbGFpbnRleHRcbmZ1bmN0aW9uIHBrY3MxdW5wYWQyKGQsIG4pIHtcbiAgICB2YXIgYiA9IGQudG9CeXRlQXJyYXkoKTtcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBiLmxlbmd0aCAmJiBiW2ldID09IDApIHtcbiAgICAgICAgKytpO1xuICAgIH1cbiAgICBpZiAoYi5sZW5ndGggLSBpICE9IG4gLSAxIHx8IGJbaV0gIT0gMikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgKytpO1xuICAgIHdoaWxlIChiW2ldICE9IDApIHtcbiAgICAgICAgaWYgKCsraSA+PSBiLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIHJldCA9IFwiXCI7XG4gICAgd2hpbGUgKCsraSA8IGIubGVuZ3RoKSB7XG4gICAgICAgIHZhciBjID0gYltpXSAmIDI1NTtcbiAgICAgICAgaWYgKGMgPCAxMjgpIHsgLy8gdXRmLTggZGVjb2RlXG4gICAgICAgICAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoYyA+IDE5MSkgJiYgKGMgPCAyMjQpKSB7XG4gICAgICAgICAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoKGMgJiAzMSkgPDwgNikgfCAoYltpICsgMV0gJiA2MykpO1xuICAgICAgICAgICAgKytpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKChjICYgMTUpIDw8IDEyKSB8ICgoYltpICsgMV0gJiA2MykgPDwgNikgfCAoYltpICsgMl0gJiA2MykpO1xuICAgICAgICAgICAgaSArPSAyO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59XG4vLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzQ0NyNwYWdlLTQzXG52YXIgRElHRVNUX0hFQURFUlMgPSB7XG4gICAgbWQyOiBcIjMwMjAzMDBjMDYwODJhODY0ODg2ZjcwZDAyMDIwNTAwMDQxMFwiLFxuICAgIG1kNTogXCIzMDIwMzAwYzA2MDgyYTg2NDg4NmY3MGQwMjA1MDUwMDA0MTBcIixcbiAgICBzaGExOiBcIjMwMjEzMDA5MDYwNTJiMGUwMzAyMWEwNTAwMDQxNFwiLFxuICAgIHNoYTIyNDogXCIzMDJkMzAwZDA2MDk2MDg2NDgwMTY1MDMwNDAyMDQwNTAwMDQxY1wiLFxuICAgIHNoYTI1NjogXCIzMDMxMzAwZDA2MDk2MDg2NDgwMTY1MDMwNDAyMDEwNTAwMDQyMFwiLFxuICAgIHNoYTM4NDogXCIzMDQxMzAwZDA2MDk2MDg2NDgwMTY1MDMwNDAyMDIwNTAwMDQzMFwiLFxuICAgIHNoYTUxMjogXCIzMDUxMzAwZDA2MDk2MDg2NDgwMTY1MDMwNDAyMDMwNTAwMDQ0MFwiLFxuICAgIHJpcGVtZDE2MDogXCIzMDIxMzAwOTA2MDUyYjI0MDMwMjAxMDUwMDA0MTRcIlxufTtcbmZ1bmN0aW9uIGdldERpZ2VzdEhlYWRlcihuYW1lKSB7XG4gICAgcmV0dXJuIERJR0VTVF9IRUFERVJTW25hbWVdIHx8IFwiXCI7XG59XG5mdW5jdGlvbiByZW1vdmVEaWdlc3RIZWFkZXIoc3RyKSB7XG4gICAgZm9yICh2YXIgbmFtZV8xIGluIERJR0VTVF9IRUFERVJTKSB7XG4gICAgICAgIGlmIChESUdFU1RfSEVBREVSUy5oYXNPd25Qcm9wZXJ0eShuYW1lXzEpKSB7XG4gICAgICAgICAgICB2YXIgaGVhZGVyID0gRElHRVNUX0hFQURFUlNbbmFtZV8xXTtcbiAgICAgICAgICAgIHZhciBsZW4gPSBoZWFkZXIubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHN0ci5zdWJzdHIoMCwgbGVuKSA9PSBoZWFkZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyLnN1YnN0cihsZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG59XG4vLyBSZXR1cm4gdGhlIFBLQ1MjMSBSU0EgZW5jcnlwdGlvbiBvZiBcInRleHRcIiBhcyBhIEJhc2U2NC1lbmNvZGVkIHN0cmluZ1xuLy8gZnVuY3Rpb24gUlNBRW5jcnlwdEI2NCh0ZXh0KSB7XG4vLyAgdmFyIGggPSB0aGlzLmVuY3J5cHQodGV4dCk7XG4vLyAgaWYoaCkgcmV0dXJuIGhleDJiNjQoaCk7IGVsc2UgcmV0dXJuIG51bGw7XG4vLyB9XG4vLyBwdWJsaWNcbi8vIFJTQUtleS5wcm90b3R5cGUuZW5jcnlwdF9iNjQgPSBSU0FFbmNyeXB0QjY0O1xuIiwiLyohXG5Db3B5cmlnaHQgKGMpIDIwMTEsIFlhaG9vISBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5Db2RlIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0QgTGljZW5zZTpcbmh0dHA6Ly9kZXZlbG9wZXIueWFob28uY29tL3l1aS9saWNlbnNlLmh0bWxcbnZlcnNpb246IDIuOS4wXG4qL1xuZXhwb3J0IHZhciBZQUhPTyA9IHt9O1xuWUFIT08ubGFuZyA9IHtcbiAgICAvKipcbiAgICAgKiBVdGlsaXR5IHRvIHNldCB1cCB0aGUgcHJvdG90eXBlLCBjb25zdHJ1Y3RvciBhbmQgc3VwZXJjbGFzcyBwcm9wZXJ0aWVzIHRvXG4gICAgICogc3VwcG9ydCBhbiBpbmhlcml0YW5jZSBzdHJhdGVneSB0aGF0IGNhbiBjaGFpbiBjb25zdHJ1Y3RvcnMgYW5kIG1ldGhvZHMuXG4gICAgICogU3RhdGljIG1lbWJlcnMgd2lsbCBub3QgYmUgaW5oZXJpdGVkLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBleHRlbmRcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc3ViYyAgIHRoZSBvYmplY3QgdG8gbW9kaWZ5XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc3VwZXJjIHRoZSBvYmplY3QgdG8gaW5oZXJpdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdmVycmlkZXMgIGFkZGl0aW9uYWwgcHJvcGVydGllcy9tZXRob2RzIHRvIGFkZCB0byB0aGVcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YmNsYXNzIHByb3RvdHlwZS4gIFRoZXNlIHdpbGwgb3ZlcnJpZGUgdGhlXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGluZyBpdGVtcyBvYnRhaW5lZCBmcm9tIHRoZSBzdXBlcmNsYXNzXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiBwcmVzZW50LlxuICAgICAqL1xuICAgIGV4dGVuZDogZnVuY3Rpb24gKHN1YmMsIHN1cGVyYywgb3ZlcnJpZGVzKSB7XG4gICAgICAgIGlmICghc3VwZXJjIHx8ICFzdWJjKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJZQUhPTy5sYW5nLmV4dGVuZCBmYWlsZWQsIHBsZWFzZSBjaGVjayB0aGF0IFwiICtcbiAgICAgICAgICAgICAgICBcImFsbCBkZXBlbmRlbmNpZXMgYXJlIGluY2x1ZGVkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgRiA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgRi5wcm90b3R5cGUgPSBzdXBlcmMucHJvdG90eXBlO1xuICAgICAgICBzdWJjLnByb3RvdHlwZSA9IG5ldyBGKCk7XG4gICAgICAgIHN1YmMucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViYztcbiAgICAgICAgc3ViYy5zdXBlcmNsYXNzID0gc3VwZXJjLnByb3RvdHlwZTtcbiAgICAgICAgaWYgKHN1cGVyYy5wcm90b3R5cGUuY29uc3RydWN0b3IgPT0gT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgc3VwZXJjLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1cGVyYztcbiAgICAgICAgfVxuICAgICAgICBpZiAob3ZlcnJpZGVzKSB7XG4gICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgIGZvciAoaSBpbiBvdmVycmlkZXMpIHtcbiAgICAgICAgICAgICAgICBzdWJjLnByb3RvdHlwZVtpXSA9IG92ZXJyaWRlc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBJRSB3aWxsIG5vdCBlbnVtZXJhdGUgbmF0aXZlIGZ1bmN0aW9ucyBpbiBhIGRlcml2ZWQgb2JqZWN0IGV2ZW4gaWYgdGhlXG4gICAgICAgICAgICAgKiBmdW5jdGlvbiB3YXMgb3ZlcnJpZGRlbi4gIFRoaXMgaXMgYSB3b3JrYXJvdW5kIGZvciBzcGVjaWZpYyBmdW5jdGlvbnNcbiAgICAgICAgICAgICAqIHdlIGNhcmUgYWJvdXQgb24gdGhlIE9iamVjdCBwcm90b3R5cGUuXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgX0lFRW51bUZpeFxuICAgICAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gciAgdGhlIG9iamVjdCB0byByZWNlaXZlIHRoZSBhdWdtZW50YXRpb25cbiAgICAgICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHMgIHRoZSBvYmplY3QgdGhhdCBzdXBwbGllcyB0aGUgcHJvcGVydGllcyB0byBhdWdtZW50XG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2YXIgX0lFRW51bUZpeCA9IGZ1bmN0aW9uICgpIHsgfSwgQUREID0gW1widG9TdHJpbmdcIiwgXCJ2YWx1ZU9mXCJdO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoL01TSUUvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgX0lFRW51bUZpeCA9IGZ1bmN0aW9uIChyLCBzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgQURELmxlbmd0aDsgaSA9IGkgKyAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZuYW1lID0gQUREW2ldLCBmID0gc1tmbmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmID09PSAnZnVuY3Rpb24nICYmIGYgIT0gT2JqZWN0LnByb3RvdHlwZVtmbmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcltmbmFtZV0gPSBmO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXgpIHsgfVxuICAgICAgICAgICAgO1xuICAgICAgICAgICAgX0lFRW51bUZpeChzdWJjLnByb3RvdHlwZSwgb3ZlcnJpZGVzKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG4iLCIvKiBhc24xLTEuMC4xMy5qcyAoYykgMjAxMy0yMDE3IEtlbmppIFVydXNoaW1hIHwga2p1ci5naXRodWIuY29tL2pzcnNhc2lnbi9saWNlbnNlXG4gKi9cbi8qXG4gKiBhc24xLmpzIC0gQVNOLjEgREVSIGVuY29kZXIgY2xhc3Nlc1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMy0yMDE3IEtlbmppIFVydXNoaW1hIChrZW5qaS51cnVzaGltYUBnbWFpbC5jb20pXG4gKlxuICogVGhpcyBzb2Z0d2FyZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIE1JVCBMaWNlbnNlLlxuICogaHR0cHM6Ly9ranVyLmdpdGh1Yi5pby9qc3JzYXNpZ24vbGljZW5zZVxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgYW5kIGxpY2Vuc2Ugbm90aWNlIHNoYWxsIGJlXG4gKiBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqL1xuaW1wb3J0IHsgQmlnSW50ZWdlciB9IGZyb20gXCIuLi9qc2JuL2pzYm5cIjtcbmltcG9ydCB7IFlBSE9PIH0gZnJvbSBcIi4veWFob29cIjtcbi8qKlxuICogQGZpbGVPdmVydmlld1xuICogQG5hbWUgYXNuMS0xLjAuanNcbiAqIEBhdXRob3IgS2VuamkgVXJ1c2hpbWEga2VuamkudXJ1c2hpbWFAZ21haWwuY29tXG4gKiBAdmVyc2lvbiBhc24xIDEuMC4xMyAoMjAxNy1KdW4tMDIpXG4gKiBAc2luY2UganNyc2FzaWduIDIuMVxuICogQGxpY2Vuc2UgPGEgaHJlZj1cImh0dHBzOi8va2p1ci5naXRodWIuaW8vanNyc2FzaWduL2xpY2Vuc2UvXCI+TUlUIExpY2Vuc2U8L2E+XG4gKi9cbi8qKlxuICoga2p1cidzIGNsYXNzIGxpYnJhcnkgbmFtZSBzcGFjZVxuICogPHA+XG4gKiBUaGlzIG5hbWUgc3BhY2UgcHJvdmlkZXMgZm9sbG93aW5nIG5hbWUgc3BhY2VzOlxuICogPHVsPlxuICogPGxpPntAbGluayBLSlVSLmFzbjF9IC0gQVNOLjEgcHJpbWl0aXZlIGhleGFkZWNpbWFsIGVuY29kZXI8L2xpPlxuICogPGxpPntAbGluayBLSlVSLmFzbjEueDUwOX0gLSBBU04uMSBzdHJ1Y3R1cmUgZm9yIFguNTA5IGNlcnRpZmljYXRlIGFuZCBDUkw8L2xpPlxuICogPGxpPntAbGluayBLSlVSLmNyeXB0b30gLSBKYXZhIENyeXB0b2dyYXBoaWMgRXh0ZW5zaW9uKEpDRSkgc3R5bGUgTWVzc2FnZURpZ2VzdC9TaWduYXR1cmVcbiAqIGNsYXNzIGFuZCB1dGlsaXRpZXM8L2xpPlxuICogPC91bD5cbiAqIDwvcD5cbiAqIE5PVEU6IFBsZWFzZSBpZ25vcmUgbWV0aG9kIHN1bW1hcnkgYW5kIGRvY3VtZW50IG9mIHRoaXMgbmFtZXNwYWNlLiBUaGlzIGNhdXNlZCBieSBhIGJ1ZyBvZiBqc2RvYzIuXG4gKiBAbmFtZSBLSlVSXG4gKiBAbmFtZXNwYWNlIGtqdXIncyBjbGFzcyBsaWJyYXJ5IG5hbWUgc3BhY2VcbiAqL1xuZXhwb3J0IHZhciBLSlVSID0ge307XG4vKipcbiAqIGtqdXIncyBBU04uMSBjbGFzcyBsaWJyYXJ5IG5hbWUgc3BhY2VcbiAqIDxwPlxuICogVGhpcyBpcyBJVFUtVCBYLjY5MCBBU04uMSBERVIgZW5jb2RlciBjbGFzcyBsaWJyYXJ5IGFuZFxuICogY2xhc3Mgc3RydWN0dXJlIGFuZCBtZXRob2RzIGlzIHZlcnkgc2ltaWxhciB0b1xuICogb3JnLmJvdW5jeWNhc3RsZS5hc24xIHBhY2thZ2Ugb2ZcbiAqIHdlbGwga25vd24gQm91bmN5Q2FzbHRlIENyeXB0b2dyYXBoeSBMaWJyYXJ5LlxuICogPGg0PlBST1ZJRElORyBBU04uMSBQUklNSVRJVkVTPC9oND5cbiAqIEhlcmUgYXJlIEFTTi4xIERFUiBwcmltaXRpdmUgY2xhc3Nlcy5cbiAqIDx1bD5cbiAqIDxsaT4weDAxIHtAbGluayBLSlVSLmFzbjEuREVSQm9vbGVhbn08L2xpPlxuICogPGxpPjB4MDIge0BsaW5rIEtKVVIuYXNuMS5ERVJJbnRlZ2VyfTwvbGk+XG4gKiA8bGk+MHgwMyB7QGxpbmsgS0pVUi5hc24xLkRFUkJpdFN0cmluZ308L2xpPlxuICogPGxpPjB4MDQge0BsaW5rIEtKVVIuYXNuMS5ERVJPY3RldFN0cmluZ308L2xpPlxuICogPGxpPjB4MDUge0BsaW5rIEtKVVIuYXNuMS5ERVJOdWxsfTwvbGk+XG4gKiA8bGk+MHgwNiB7QGxpbmsgS0pVUi5hc24xLkRFUk9iamVjdElkZW50aWZpZXJ9PC9saT5cbiAqIDxsaT4weDBhIHtAbGluayBLSlVSLmFzbjEuREVSRW51bWVyYXRlZH08L2xpPlxuICogPGxpPjB4MGMge0BsaW5rIEtKVVIuYXNuMS5ERVJVVEY4U3RyaW5nfTwvbGk+XG4gKiA8bGk+MHgxMiB7QGxpbmsgS0pVUi5hc24xLkRFUk51bWVyaWNTdHJpbmd9PC9saT5cbiAqIDxsaT4weDEzIHtAbGluayBLSlVSLmFzbjEuREVSUHJpbnRhYmxlU3RyaW5nfTwvbGk+XG4gKiA8bGk+MHgxNCB7QGxpbmsgS0pVUi5hc24xLkRFUlRlbGV0ZXhTdHJpbmd9PC9saT5cbiAqIDxsaT4weDE2IHtAbGluayBLSlVSLmFzbjEuREVSSUE1U3RyaW5nfTwvbGk+XG4gKiA8bGk+MHgxNyB7QGxpbmsgS0pVUi5hc24xLkRFUlVUQ1RpbWV9PC9saT5cbiAqIDxsaT4weDE4IHtAbGluayBLSlVSLmFzbjEuREVSR2VuZXJhbGl6ZWRUaW1lfTwvbGk+XG4gKiA8bGk+MHgzMCB7QGxpbmsgS0pVUi5hc24xLkRFUlNlcXVlbmNlfTwvbGk+XG4gKiA8bGk+MHgzMSB7QGxpbmsgS0pVUi5hc24xLkRFUlNldH08L2xpPlxuICogPC91bD5cbiAqIDxoND5PVEhFUiBBU04uMSBDTEFTU0VTPC9oND5cbiAqIDx1bD5cbiAqIDxsaT57QGxpbmsgS0pVUi5hc24xLkFTTjFPYmplY3R9PC9saT5cbiAqIDxsaT57QGxpbmsgS0pVUi5hc24xLkRFUkFic3RyYWN0U3RyaW5nfTwvbGk+XG4gKiA8bGk+e0BsaW5rIEtKVVIuYXNuMS5ERVJBYnN0cmFjdFRpbWV9PC9saT5cbiAqIDxsaT57QGxpbmsgS0pVUi5hc24xLkRFUkFic3RyYWN0U3RydWN0dXJlZH08L2xpPlxuICogPGxpPntAbGluayBLSlVSLmFzbjEuREVSVGFnZ2VkT2JqZWN0fTwvbGk+XG4gKiA8L3VsPlxuICogPGg0PlNVQiBOQU1FIFNQQUNFUzwvaDQ+XG4gKiA8dWw+XG4gKiA8bGk+e0BsaW5rIEtKVVIuYXNuMS5jYWRlc30gLSBDQWRFUyBsb25nIHRlcm0gc2lnbmF0dXJlIGZvcm1hdDwvbGk+XG4gKiA8bGk+e0BsaW5rIEtKVVIuYXNuMS5jbXN9IC0gQ3J5cHRvZ3JhcGhpYyBNZXNzYWdlIFN5bnRheDwvbGk+XG4gKiA8bGk+e0BsaW5rIEtKVVIuYXNuMS5jc3J9IC0gQ2VydGlmaWNhdGUgU2lnbmluZyBSZXF1ZXN0IChDU1IvUEtDUyMxMCk8L2xpPlxuICogPGxpPntAbGluayBLSlVSLmFzbjEudHNwfSAtIFJGQyAzMTYxIFRpbWVzdGFtcGluZyBQcm90b2NvbCBGb3JtYXQ8L2xpPlxuICogPGxpPntAbGluayBLSlVSLmFzbjEueDUwOX0gLSBSRkMgNTI4MCBYLjUwOSBjZXJ0aWZpY2F0ZSBhbmQgQ1JMPC9saT5cbiAqIDwvdWw+XG4gKiA8L3A+XG4gKiBOT1RFOiBQbGVhc2UgaWdub3JlIG1ldGhvZCBzdW1tYXJ5IGFuZCBkb2N1bWVudCBvZiB0aGlzIG5hbWVzcGFjZS5cbiAqIFRoaXMgY2F1c2VkIGJ5IGEgYnVnIG9mIGpzZG9jMi5cbiAqIEBuYW1lIEtKVVIuYXNuMVxuICogQG5hbWVzcGFjZVxuICovXG5pZiAodHlwZW9mIEtKVVIuYXNuMSA9PSBcInVuZGVmaW5lZFwiIHx8ICFLSlVSLmFzbjEpXG4gICAgS0pVUi5hc24xID0ge307XG4vKipcbiAqIEFTTjEgdXRpbGl0aWVzIGNsYXNzXG4gKiBAbmFtZSBLSlVSLmFzbjEuQVNOMVV0aWxcbiAqIEBjbGFzcyBBU04xIHV0aWxpdGllcyBjbGFzc1xuICogQHNpbmNlIGFzbjEgMS4wLjJcbiAqL1xuS0pVUi5hc24xLkFTTjFVdGlsID0gbmV3IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmludGVnZXJUb0J5dGVIZXggPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICB2YXIgaCA9IGkudG9TdHJpbmcoMTYpO1xuICAgICAgICBpZiAoKGgubGVuZ3RoICUgMikgPT0gMSlcbiAgICAgICAgICAgIGggPSAnMCcgKyBoO1xuICAgICAgICByZXR1cm4gaDtcbiAgICB9O1xuICAgIHRoaXMuYmlnSW50VG9NaW5Ud29zQ29tcGxlbWVudHNIZXggPSBmdW5jdGlvbiAoYmlnSW50ZWdlclZhbHVlKSB7XG4gICAgICAgIHZhciBoID0gYmlnSW50ZWdlclZhbHVlLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgaWYgKGguc3Vic3RyKDAsIDEpICE9ICctJykge1xuICAgICAgICAgICAgaWYgKGgubGVuZ3RoICUgMiA9PSAxKSB7XG4gICAgICAgICAgICAgICAgaCA9ICcwJyArIGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIWgubWF0Y2goL15bMC03XS8pKSB7XG4gICAgICAgICAgICAgICAgICAgIGggPSAnMDAnICsgaDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgaFBvcyA9IGguc3Vic3RyKDEpO1xuICAgICAgICAgICAgdmFyIHhvckxlbiA9IGhQb3MubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHhvckxlbiAlIDIgPT0gMSkge1xuICAgICAgICAgICAgICAgIHhvckxlbiArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCFoLm1hdGNoKC9eWzAtN10vKSkge1xuICAgICAgICAgICAgICAgICAgICB4b3JMZW4gKz0gMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaE1hc2sgPSAnJztcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeG9yTGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBoTWFzayArPSAnZic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYmlNYXNrID0gbmV3IEJpZ0ludGVnZXIoaE1hc2ssIDE2KTtcbiAgICAgICAgICAgIHZhciBiaU5lZyA9IGJpTWFzay54b3IoYmlnSW50ZWdlclZhbHVlKS5hZGQoQmlnSW50ZWdlci5PTkUpO1xuICAgICAgICAgICAgaCA9IGJpTmVnLnRvU3RyaW5nKDE2KS5yZXBsYWNlKC9eLS8sICcnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGdldCBQRU0gc3RyaW5nIGZyb20gaGV4YWRlY2ltYWwgZGF0YSBhbmQgaGVhZGVyIHN0cmluZ1xuICAgICAqIEBuYW1lIGdldFBFTVN0cmluZ0Zyb21IZXhcbiAgICAgKiBAbWVtYmVyT2YgS0pVUi5hc24xLkFTTjFVdGlsXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGFIZXggaGV4YWRlY2ltYWwgc3RyaW5nIG9mIFBFTSBib2R5XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBlbUhlYWRlciBQRU0gaGVhZGVyIHN0cmluZyAoZXguICdSU0EgUFJJVkFURSBLRVknKVxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gUEVNIGZvcm1hdHRlZCBzdHJpbmcgb2YgaW5wdXQgZGF0YVxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFRoaXMgbWV0aG9kIGNvbnZlcnRzIGEgaGV4YWRlY2ltYWwgc3RyaW5nIHRvIGEgUEVNIHN0cmluZyB3aXRoXG4gICAgICogYSBzcGVjaWZpZWQgaGVhZGVyLiBJdHMgbGluZSBicmVhayB3aWxsIGJlIENSTEYoXCJcXHJcXG5cIikuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgcGVtICA9IEtKVVIuYXNuMS5BU04xVXRpbC5nZXRQRU1TdHJpbmdGcm9tSGV4KCc2MTYxNjEnLCAnUlNBIFBSSVZBVEUgS0VZJyk7XG4gICAgICogLy8gdmFsdWUgb2YgcGVtIHdpbGwgYmU6XG4gICAgICogLS0tLS1CRUdJTiBQUklWQVRFIEtFWS0tLS0tXG4gICAgICogWVdGaFxuICAgICAqIC0tLS0tRU5EIFBSSVZBVEUgS0VZLS0tLS1cbiAgICAgKi9cbiAgICB0aGlzLmdldFBFTVN0cmluZ0Zyb21IZXggPSBmdW5jdGlvbiAoZGF0YUhleCwgcGVtSGVhZGVyKSB7XG4gICAgICAgIHJldHVybiBoZXh0b3BlbShkYXRhSGV4LCBwZW1IZWFkZXIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogZ2VuZXJhdGUgQVNOMU9iamVjdCBzcGVjaWZlZCBieSBKU09OIHBhcmFtZXRlcnNcbiAgICAgKiBAbmFtZSBuZXdPYmplY3RcbiAgICAgKiBAbWVtYmVyT2YgS0pVUi5hc24xLkFTTjFVdGlsXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGFyYW0gSlNPTiBwYXJhbWV0ZXIgdG8gZ2VuZXJhdGUgQVNOMU9iamVjdFxuICAgICAqIEByZXR1cm4ge0tKVVIuYXNuMS5BU04xT2JqZWN0fSBnZW5lcmF0ZWQgb2JqZWN0XG4gICAgICogQHNpbmNlIGFzbjEgMS4wLjNcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBnZW5lcmF0ZSBhbnkgQVNOMU9iamVjdCBzcGVjaWZpZWQgYnkgSlNPTiBwYXJhbVxuICAgICAqIGluY2x1ZGluZyBBU04uMSBwcmltaXRpdmUgb3Igc3RydWN0dXJlZC5cbiAgICAgKiBHZW5lcmFsbHkgJ3BhcmFtJyBjYW4gYmUgZGVzY3JpYmVkIGFzIGZvbGxvd3M6XG4gICAgICogPGJsb2NrcXVvdGU+XG4gICAgICoge1RZUEUtT0YtQVNOT0JKOiBBU04xT0JKLVBBUkFNRVRFUn1cbiAgICAgKiA8L2Jsb2NrcXVvdGU+XG4gICAgICogJ1RZUEUtT0YtQVNOMU9CSicgY2FuIGJlIG9uZSBvZiBmb2xsb3dpbmcgc3ltYm9sczpcbiAgICAgKiA8dWw+XG4gICAgICogPGxpPidib29sJyAtIERFUkJvb2xlYW48L2xpPlxuICAgICAqIDxsaT4naW50JyAtIERFUkludGVnZXI8L2xpPlxuICAgICAqIDxsaT4nYml0c3RyJyAtIERFUkJpdFN0cmluZzwvbGk+XG4gICAgICogPGxpPidvY3RzdHInIC0gREVST2N0ZXRTdHJpbmc8L2xpPlxuICAgICAqIDxsaT4nbnVsbCcgLSBERVJOdWxsPC9saT5cbiAgICAgKiA8bGk+J29pZCcgLSBERVJPYmplY3RJZGVudGlmaWVyPC9saT5cbiAgICAgKiA8bGk+J2VudW0nIC0gREVSRW51bWVyYXRlZDwvbGk+XG4gICAgICogPGxpPid1dGY4c3RyJyAtIERFUlVURjhTdHJpbmc8L2xpPlxuICAgICAqIDxsaT4nbnVtc3RyJyAtIERFUk51bWVyaWNTdHJpbmc8L2xpPlxuICAgICAqIDxsaT4ncHJuc3RyJyAtIERFUlByaW50YWJsZVN0cmluZzwvbGk+XG4gICAgICogPGxpPid0ZWxzdHInIC0gREVSVGVsZXRleFN0cmluZzwvbGk+XG4gICAgICogPGxpPidpYTVzdHInIC0gREVSSUE1U3RyaW5nPC9saT5cbiAgICAgKiA8bGk+J3V0Y3RpbWUnIC0gREVSVVRDVGltZTwvbGk+XG4gICAgICogPGxpPidnZW50aW1lJyAtIERFUkdlbmVyYWxpemVkVGltZTwvbGk+XG4gICAgICogPGxpPidzZXEnIC0gREVSU2VxdWVuY2U8L2xpPlxuICAgICAqIDxsaT4nc2V0JyAtIERFUlNldDwvbGk+XG4gICAgICogPGxpPid0YWcnIC0gREVSVGFnZ2VkT2JqZWN0PC9saT5cbiAgICAgKiA8L3VsPlxuICAgICAqIEBleGFtcGxlXG4gICAgICogbmV3T2JqZWN0KHsncHJuc3RyJzogJ2FhYSd9KTtcbiAgICAgKiBuZXdPYmplY3QoeydzZXEnOiBbeydpbnQnOiAzfSwgeydwcm5zdHInOiAnYWFhJ31dfSlcbiAgICAgKiAvLyBBU04uMSBUYWdnZWQgT2JqZWN0XG4gICAgICogbmV3T2JqZWN0KHsndGFnJzogeyd0YWcnOiAnYTEnLFxuICAgICAqICAgICAgICAgICAgICAgICAgICAnZXhwbGljaXQnOiB0cnVlLFxuICAgICAqICAgICAgICAgICAgICAgICAgICAnb2JqJzogeydzZXEnOiBbeydpbnQnOiAzfSwgeydwcm5zdHInOiAnYWFhJ31dfX19KTtcbiAgICAgKiAvLyBtb3JlIHNpbXBsZSByZXByZXNlbnRhdGlvbiBvZiBBU04uMSBUYWdnZWQgT2JqZWN0XG4gICAgICogbmV3T2JqZWN0KHsndGFnJzogWydhMScsXG4gICAgICogICAgICAgICAgICAgICAgICAgIHRydWUsXG4gICAgICogICAgICAgICAgICAgICAgICAgIHsnc2VxJzogW1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgIHsnaW50JzogM30sXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgeydwcm5zdHInOiAnYWFhJ31dfVxuICAgICAqICAgICAgICAgICAgICAgICAgIF19KTtcbiAgICAgKi9cbiAgICB0aGlzLm5ld09iamVjdCA9IGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgICB2YXIgX0tKVVIgPSBLSlVSLCBfS0pVUl9hc24xID0gX0tKVVIuYXNuMSwgX0RFUkJvb2xlYW4gPSBfS0pVUl9hc24xLkRFUkJvb2xlYW4sIF9ERVJJbnRlZ2VyID0gX0tKVVJfYXNuMS5ERVJJbnRlZ2VyLCBfREVSQml0U3RyaW5nID0gX0tKVVJfYXNuMS5ERVJCaXRTdHJpbmcsIF9ERVJPY3RldFN0cmluZyA9IF9LSlVSX2FzbjEuREVST2N0ZXRTdHJpbmcsIF9ERVJOdWxsID0gX0tKVVJfYXNuMS5ERVJOdWxsLCBfREVST2JqZWN0SWRlbnRpZmllciA9IF9LSlVSX2FzbjEuREVST2JqZWN0SWRlbnRpZmllciwgX0RFUkVudW1lcmF0ZWQgPSBfS0pVUl9hc24xLkRFUkVudW1lcmF0ZWQsIF9ERVJVVEY4U3RyaW5nID0gX0tKVVJfYXNuMS5ERVJVVEY4U3RyaW5nLCBfREVSTnVtZXJpY1N0cmluZyA9IF9LSlVSX2FzbjEuREVSTnVtZXJpY1N0cmluZywgX0RFUlByaW50YWJsZVN0cmluZyA9IF9LSlVSX2FzbjEuREVSUHJpbnRhYmxlU3RyaW5nLCBfREVSVGVsZXRleFN0cmluZyA9IF9LSlVSX2FzbjEuREVSVGVsZXRleFN0cmluZywgX0RFUklBNVN0cmluZyA9IF9LSlVSX2FzbjEuREVSSUE1U3RyaW5nLCBfREVSVVRDVGltZSA9IF9LSlVSX2FzbjEuREVSVVRDVGltZSwgX0RFUkdlbmVyYWxpemVkVGltZSA9IF9LSlVSX2FzbjEuREVSR2VuZXJhbGl6ZWRUaW1lLCBfREVSU2VxdWVuY2UgPSBfS0pVUl9hc24xLkRFUlNlcXVlbmNlLCBfREVSU2V0ID0gX0tKVVJfYXNuMS5ERVJTZXQsIF9ERVJUYWdnZWRPYmplY3QgPSBfS0pVUl9hc24xLkRFUlRhZ2dlZE9iamVjdCwgX25ld09iamVjdCA9IF9LSlVSX2FzbjEuQVNOMVV0aWwubmV3T2JqZWN0O1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHBhcmFtKTtcbiAgICAgICAgaWYgKGtleXMubGVuZ3RoICE9IDEpXG4gICAgICAgICAgICB0aHJvdyBcImtleSBvZiBwYXJhbSBzaGFsbCBiZSBvbmx5IG9uZS5cIjtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbMF07XG4gICAgICAgIGlmIChcIjpib29sOmludDpiaXRzdHI6b2N0c3RyOm51bGw6b2lkOmVudW06dXRmOHN0cjpudW1zdHI6cHJuc3RyOnRlbHN0cjppYTVzdHI6dXRjdGltZTpnZW50aW1lOnNlcTpzZXQ6dGFnOlwiLmluZGV4T2YoXCI6XCIgKyBrZXkgKyBcIjpcIikgPT0gLTEpXG4gICAgICAgICAgICB0aHJvdyBcInVuZGVmaW5lZCBrZXk6IFwiICsga2V5O1xuICAgICAgICBpZiAoa2V5ID09IFwiYm9vbFwiKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBfREVSQm9vbGVhbihwYXJhbVtrZXldKTtcbiAgICAgICAgaWYgKGtleSA9PSBcImludFwiKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBfREVSSW50ZWdlcihwYXJhbVtrZXldKTtcbiAgICAgICAgaWYgKGtleSA9PSBcImJpdHN0clwiKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBfREVSQml0U3RyaW5nKHBhcmFtW2tleV0pO1xuICAgICAgICBpZiAoa2V5ID09IFwib2N0c3RyXCIpXG4gICAgICAgICAgICByZXR1cm4gbmV3IF9ERVJPY3RldFN0cmluZyhwYXJhbVtrZXldKTtcbiAgICAgICAgaWYgKGtleSA9PSBcIm51bGxcIilcbiAgICAgICAgICAgIHJldHVybiBuZXcgX0RFUk51bGwocGFyYW1ba2V5XSk7XG4gICAgICAgIGlmIChrZXkgPT0gXCJvaWRcIilcbiAgICAgICAgICAgIHJldHVybiBuZXcgX0RFUk9iamVjdElkZW50aWZpZXIocGFyYW1ba2V5XSk7XG4gICAgICAgIGlmIChrZXkgPT0gXCJlbnVtXCIpXG4gICAgICAgICAgICByZXR1cm4gbmV3IF9ERVJFbnVtZXJhdGVkKHBhcmFtW2tleV0pO1xuICAgICAgICBpZiAoa2V5ID09IFwidXRmOHN0clwiKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBfREVSVVRGOFN0cmluZyhwYXJhbVtrZXldKTtcbiAgICAgICAgaWYgKGtleSA9PSBcIm51bXN0clwiKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBfREVSTnVtZXJpY1N0cmluZyhwYXJhbVtrZXldKTtcbiAgICAgICAgaWYgKGtleSA9PSBcInBybnN0clwiKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBfREVSUHJpbnRhYmxlU3RyaW5nKHBhcmFtW2tleV0pO1xuICAgICAgICBpZiAoa2V5ID09IFwidGVsc3RyXCIpXG4gICAgICAgICAgICByZXR1cm4gbmV3IF9ERVJUZWxldGV4U3RyaW5nKHBhcmFtW2tleV0pO1xuICAgICAgICBpZiAoa2V5ID09IFwiaWE1c3RyXCIpXG4gICAgICAgICAgICByZXR1cm4gbmV3IF9ERVJJQTVTdHJpbmcocGFyYW1ba2V5XSk7XG4gICAgICAgIGlmIChrZXkgPT0gXCJ1dGN0aW1lXCIpXG4gICAgICAgICAgICByZXR1cm4gbmV3IF9ERVJVVENUaW1lKHBhcmFtW2tleV0pO1xuICAgICAgICBpZiAoa2V5ID09IFwiZ2VudGltZVwiKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBfREVSR2VuZXJhbGl6ZWRUaW1lKHBhcmFtW2tleV0pO1xuICAgICAgICBpZiAoa2V5ID09IFwic2VxXCIpIHtcbiAgICAgICAgICAgIHZhciBwYXJhbUxpc3QgPSBwYXJhbVtrZXldO1xuICAgICAgICAgICAgdmFyIGEgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyYW1MaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFzbjFPYmogPSBfbmV3T2JqZWN0KHBhcmFtTGlzdFtpXSk7XG4gICAgICAgICAgICAgICAgYS5wdXNoKGFzbjFPYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBfREVSU2VxdWVuY2UoeyAnYXJyYXknOiBhIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChrZXkgPT0gXCJzZXRcIikge1xuICAgICAgICAgICAgdmFyIHBhcmFtTGlzdCA9IHBhcmFtW2tleV07XG4gICAgICAgICAgICB2YXIgYSA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJhbUxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgYXNuMU9iaiA9IF9uZXdPYmplY3QocGFyYW1MaXN0W2ldKTtcbiAgICAgICAgICAgICAgICBhLnB1c2goYXNuMU9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IF9ERVJTZXQoeyAnYXJyYXknOiBhIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChrZXkgPT0gXCJ0YWdcIikge1xuICAgICAgICAgICAgdmFyIHRhZ1BhcmFtID0gcGFyYW1ba2V5XTtcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodGFnUGFyYW0pID09PSAnW29iamVjdCBBcnJheV0nICYmXG4gICAgICAgICAgICAgICAgdGFnUGFyYW0ubGVuZ3RoID09IDMpIHtcbiAgICAgICAgICAgICAgICB2YXIgb2JqID0gX25ld09iamVjdCh0YWdQYXJhbVsyXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBfREVSVGFnZ2VkT2JqZWN0KHsgdGFnOiB0YWdQYXJhbVswXSxcbiAgICAgICAgICAgICAgICAgICAgZXhwbGljaXQ6IHRhZ1BhcmFtWzFdLFxuICAgICAgICAgICAgICAgICAgICBvYmo6IG9iaiB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBuZXdQYXJhbSA9IHt9O1xuICAgICAgICAgICAgICAgIGlmICh0YWdQYXJhbS5leHBsaWNpdCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICBuZXdQYXJhbS5leHBsaWNpdCA9IHRhZ1BhcmFtLmV4cGxpY2l0O1xuICAgICAgICAgICAgICAgIGlmICh0YWdQYXJhbS50YWcgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgbmV3UGFyYW0udGFnID0gdGFnUGFyYW0udGFnO1xuICAgICAgICAgICAgICAgIGlmICh0YWdQYXJhbS5vYmogPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgXCJvYmogc2hhbGwgYmUgc3BlY2lmaWVkIGZvciAndGFnJy5cIjtcbiAgICAgICAgICAgICAgICBuZXdQYXJhbS5vYmogPSBfbmV3T2JqZWN0KHRhZ1BhcmFtLm9iaik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBfREVSVGFnZ2VkT2JqZWN0KG5ld1BhcmFtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogZ2V0IGVuY29kZWQgaGV4YWRlY2ltYWwgc3RyaW5nIG9mIEFTTjFPYmplY3Qgc3BlY2lmZWQgYnkgSlNPTiBwYXJhbWV0ZXJzXG4gICAgICogQG5hbWUganNvblRvQVNOMUhFWFxuICAgICAqIEBtZW1iZXJPZiBLSlVSLmFzbjEuQVNOMVV0aWxcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXJhbSBKU09OIHBhcmFtZXRlciB0byBnZW5lcmF0ZSBBU04xT2JqZWN0XG4gICAgICogQHJldHVybiBoZXhhZGVjaW1hbCBzdHJpbmcgb2YgQVNOMU9iamVjdFxuICAgICAqIEBzaW5jZSBhc24xIDEuMC40XG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogQXMgZm9yIEFTTi4xIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBKU09OIG9iamVjdCxcbiAgICAgKiBwbGVhc2Ugc2VlIHtAbGluayBuZXdPYmplY3R9LlxuICAgICAqIEBleGFtcGxlXG4gICAgICoganNvblRvQVNOMUhFWCh7J3BybnN0cic6ICdhYWEnfSk7XG4gICAgICovXG4gICAgdGhpcy5qc29uVG9BU04xSEVYID0gZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgICAgIHZhciBhc24xT2JqID0gdGhpcy5uZXdPYmplY3QocGFyYW0pO1xuICAgICAgICByZXR1cm4gYXNuMU9iai5nZXRFbmNvZGVkSGV4KCk7XG4gICAgfTtcbn07XG4vKipcbiAqIGdldCBkb3Qgbm90ZWQgb2lkIG51bWJlciBzdHJpbmcgZnJvbSBoZXhhZGVjaW1hbCB2YWx1ZSBvZiBPSURcbiAqIEBuYW1lIG9pZEhleFRvSW50XG4gKiBAbWVtYmVyT2YgS0pVUi5hc24xLkFTTjFVdGlsXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7U3RyaW5nfSBoZXggaGV4YWRlY2ltYWwgdmFsdWUgb2Ygb2JqZWN0IGlkZW50aWZpZXJcbiAqIEByZXR1cm4ge1N0cmluZ30gZG90IG5vdGVkIHN0cmluZyBvZiBvYmplY3QgaWRlbnRpZmllclxuICogQHNpbmNlIGpzcnNhc2lnbiA0LjguMyBhc24xIDEuMC43XG4gKiBAZGVzY3JpcHRpb25cbiAqIFRoaXMgc3RhdGljIG1ldGhvZCBjb252ZXJ0cyBmcm9tIGhleGFkZWNpbWFsIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZlxuICogQVNOLjEgdmFsdWUgb2Ygb2JqZWN0IGlkZW50aWZpZXIgdG8gb2lkIG51bWJlciBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICogS0pVUi5hc24xLkFTTjFVdGlsLm9pZEhleFRvSW50KCc1NTA0MDYnKSAmcmFycjsgXCIyLjUuNC42XCJcbiAqL1xuS0pVUi5hc24xLkFTTjFVdGlsLm9pZEhleFRvSW50ID0gZnVuY3Rpb24gKGhleCkge1xuICAgIHZhciBzID0gXCJcIjtcbiAgICB2YXIgaTAxID0gcGFyc2VJbnQoaGV4LnN1YnN0cigwLCAyKSwgMTYpO1xuICAgIHZhciBpMCA9IE1hdGguZmxvb3IoaTAxIC8gNDApO1xuICAgIHZhciBpMSA9IGkwMSAlIDQwO1xuICAgIHZhciBzID0gaTAgKyBcIi5cIiArIGkxO1xuICAgIHZhciBiaW5idWYgPSBcIlwiO1xuICAgIGZvciAodmFyIGkgPSAyOyBpIDwgaGV4Lmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHBhcnNlSW50KGhleC5zdWJzdHIoaSwgMiksIDE2KTtcbiAgICAgICAgdmFyIGJpbiA9IChcIjAwMDAwMDAwXCIgKyB2YWx1ZS50b1N0cmluZygyKSkuc2xpY2UoLTgpO1xuICAgICAgICBiaW5idWYgPSBiaW5idWYgKyBiaW4uc3Vic3RyKDEsIDcpO1xuICAgICAgICBpZiAoYmluLnN1YnN0cigwLCAxKSA9PSBcIjBcIikge1xuICAgICAgICAgICAgdmFyIGJpID0gbmV3IEJpZ0ludGVnZXIoYmluYnVmLCAyKTtcbiAgICAgICAgICAgIHMgPSBzICsgXCIuXCIgKyBiaS50b1N0cmluZygxMCk7XG4gICAgICAgICAgICBiaW5idWYgPSBcIlwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICByZXR1cm4gcztcbn07XG4vKipcbiAqIGdldCBoZXhhZGVjaW1hbCB2YWx1ZSBvZiBvYmplY3QgaWRlbnRpZmllciBmcm9tIGRvdCBub3RlZCBvaWQgdmFsdWVcbiAqIEBuYW1lIG9pZEludFRvSGV4XG4gKiBAbWVtYmVyT2YgS0pVUi5hc24xLkFTTjFVdGlsXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7U3RyaW5nfSBvaWRTdHJpbmcgZG90IG5vdGVkIHN0cmluZyBvZiBvYmplY3QgaWRlbnRpZmllclxuICogQHJldHVybiB7U3RyaW5nfSBoZXhhZGVjaW1hbCB2YWx1ZSBvZiBvYmplY3QgaWRlbnRpZmllclxuICogQHNpbmNlIGpzcnNhc2lnbiA0LjguMyBhc24xIDEuMC43XG4gKiBAZGVzY3JpcHRpb25cbiAqIFRoaXMgc3RhdGljIG1ldGhvZCBjb252ZXJ0cyBmcm9tIG9iamVjdCBpZGVudGlmaWVyIHZhbHVlIHN0cmluZy5cbiAqIHRvIGhleGFkZWNpbWFsIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBpdC5cbiAqIEBleGFtcGxlXG4gKiBLSlVSLmFzbjEuQVNOMVV0aWwub2lkSW50VG9IZXgoXCIyLjUuNC42XCIpICZyYXJyOyBcIjU1MDQwNlwiXG4gKi9cbktKVVIuYXNuMS5BU04xVXRpbC5vaWRJbnRUb0hleCA9IGZ1bmN0aW9uIChvaWRTdHJpbmcpIHtcbiAgICB2YXIgaXRveCA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHZhciBoID0gaS50b1N0cmluZygxNik7XG4gICAgICAgIGlmIChoLmxlbmd0aCA9PSAxKVxuICAgICAgICAgICAgaCA9ICcwJyArIGg7XG4gICAgICAgIHJldHVybiBoO1xuICAgIH07XG4gICAgdmFyIHJvaWR0b3ggPSBmdW5jdGlvbiAocm9pZCkge1xuICAgICAgICB2YXIgaCA9ICcnO1xuICAgICAgICB2YXIgYmkgPSBuZXcgQmlnSW50ZWdlcihyb2lkLCAxMCk7XG4gICAgICAgIHZhciBiID0gYmkudG9TdHJpbmcoMik7XG4gICAgICAgIHZhciBwYWRMZW4gPSA3IC0gYi5sZW5ndGggJSA3O1xuICAgICAgICBpZiAocGFkTGVuID09IDcpXG4gICAgICAgICAgICBwYWRMZW4gPSAwO1xuICAgICAgICB2YXIgYlBhZCA9ICcnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhZExlbjsgaSsrKVxuICAgICAgICAgICAgYlBhZCArPSAnMCc7XG4gICAgICAgIGIgPSBiUGFkICsgYjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiLmxlbmd0aCAtIDE7IGkgKz0gNykge1xuICAgICAgICAgICAgdmFyIGI4ID0gYi5zdWJzdHIoaSwgNyk7XG4gICAgICAgICAgICBpZiAoaSAhPSBiLmxlbmd0aCAtIDcpXG4gICAgICAgICAgICAgICAgYjggPSAnMScgKyBiODtcbiAgICAgICAgICAgIGggKz0gaXRveChwYXJzZUludChiOCwgMikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoO1xuICAgIH07XG4gICAgaWYgKCFvaWRTdHJpbmcubWF0Y2goL15bMC05Ll0rJC8pKSB7XG4gICAgICAgIHRocm93IFwibWFsZm9ybWVkIG9pZCBzdHJpbmc6IFwiICsgb2lkU3RyaW5nO1xuICAgIH1cbiAgICB2YXIgaCA9ICcnO1xuICAgIHZhciBhID0gb2lkU3RyaW5nLnNwbGl0KCcuJyk7XG4gICAgdmFyIGkwID0gcGFyc2VJbnQoYVswXSkgKiA0MCArIHBhcnNlSW50KGFbMV0pO1xuICAgIGggKz0gaXRveChpMCk7XG4gICAgYS5zcGxpY2UoMCwgMik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGggKz0gcm9pZHRveChhW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIGg7XG59O1xuLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbi8vICBBYnN0cmFjdCBBU04uMSBDbGFzc2VzXG4vLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbi8qKlxuICogYmFzZSBjbGFzcyBmb3IgQVNOLjEgREVSIGVuY29kZXIgb2JqZWN0XG4gKiBAbmFtZSBLSlVSLmFzbjEuQVNOMU9iamVjdFxuICogQGNsYXNzIGJhc2UgY2xhc3MgZm9yIEFTTi4xIERFUiBlbmNvZGVyIG9iamVjdFxuICogQHByb3BlcnR5IHtCb29sZWFufSBpc01vZGlmaWVkIGZsYWcgd2hldGhlciBpbnRlcm5hbCBkYXRhIHdhcyBjaGFuZ2VkXG4gKiBAcHJvcGVydHkge1N0cmluZ30gaFRMViBoZXhhZGVjaW1hbCBzdHJpbmcgb2YgQVNOLjEgVExWXG4gKiBAcHJvcGVydHkge1N0cmluZ30gaFQgaGV4YWRlY2ltYWwgc3RyaW5nIG9mIEFTTi4xIFRMViB0YWcoVClcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBoTCBoZXhhZGVjaW1hbCBzdHJpbmcgb2YgQVNOLjEgVExWIGxlbmd0aChMKVxuICogQHByb3BlcnR5IHtTdHJpbmd9IGhWIGhleGFkZWNpbWFsIHN0cmluZyBvZiBBU04uMSBUTFYgdmFsdWUoVilcbiAqIEBkZXNjcmlwdGlvblxuICovXG5LSlVSLmFzbjEuQVNOMU9iamVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaXNNb2RpZmllZCA9IHRydWU7XG4gICAgdmFyIGhUTFYgPSBudWxsO1xuICAgIHZhciBoVCA9ICcwMCc7XG4gICAgdmFyIGhMID0gJzAwJztcbiAgICB2YXIgaFYgPSAnJztcbiAgICAvKipcbiAgICAgKiBnZXQgaGV4YWRlY2ltYWwgQVNOLjEgVExWIGxlbmd0aChMKSBieXRlcyBmcm9tIFRMViB2YWx1ZShWKVxuICAgICAqIEBuYW1lIGdldExlbmd0aEhleEZyb21WYWx1ZVxuICAgICAqIEBtZW1iZXJPZiBLSlVSLmFzbjEuQVNOMU9iamVjdCNcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IGhleGFkZWNpbWFsIHN0cmluZyBvZiBBU04uMSBUTFYgbGVuZ3RoKEwpXG4gICAgICovXG4gICAgdGhpcy5nZXRMZW5ndGhIZXhGcm9tVmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5oViA9PSBcInVuZGVmaW5lZFwiIHx8IHRoaXMuaFYgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgXCJ0aGlzLmhWIGlzIG51bGwgb3IgdW5kZWZpbmVkLlwiO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmhWLmxlbmd0aCAlIDIgPT0gMSkge1xuICAgICAgICAgICAgdGhyb3cgXCJ2YWx1ZSBoZXggbXVzdCBiZSBldmVuIGxlbmd0aDogbj1cIiArIGhWLmxlbmd0aCArIFwiLHY9XCIgKyB0aGlzLmhWO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuID0gdGhpcy5oVi5sZW5ndGggLyAyO1xuICAgICAgICB2YXIgaE4gPSBuLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgaWYgKGhOLmxlbmd0aCAlIDIgPT0gMSkge1xuICAgICAgICAgICAgaE4gPSBcIjBcIiArIGhOO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuIDwgMTI4KSB7XG4gICAgICAgICAgICByZXR1cm4gaE47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgaE5sZW4gPSBoTi5sZW5ndGggLyAyO1xuICAgICAgICAgICAgaWYgKGhObGVuID4gMTUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBcIkFTTi4xIGxlbmd0aCB0b28gbG9uZyB0byByZXByZXNlbnQgYnkgOHg6IG4gPSBcIiArIG4udG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGhlYWQgPSAxMjggKyBoTmxlbjtcbiAgICAgICAgICAgIHJldHVybiBoZWFkLnRvU3RyaW5nKDE2KSArIGhOO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBnZXQgaGV4YWRlY2ltYWwgc3RyaW5nIG9mIEFTTi4xIFRMViBieXRlc1xuICAgICAqIEBuYW1lIGdldEVuY29kZWRIZXhcbiAgICAgKiBAbWVtYmVyT2YgS0pVUi5hc24xLkFTTjFPYmplY3QjXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBoZXhhZGVjaW1hbCBzdHJpbmcgb2YgQVNOLjEgVExWXG4gICAgICovXG4gICAgdGhpcy5nZXRFbmNvZGVkSGV4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5oVExWID09IG51bGwgfHwgdGhpcy5pc01vZGlmaWVkKSB7XG4gICAgICAgICAgICB0aGlzLmhWID0gdGhpcy5nZXRGcmVzaFZhbHVlSGV4KCk7XG4gICAgICAgICAgICB0aGlzLmhMID0gdGhpcy5nZXRMZW5ndGhIZXhGcm9tVmFsdWUoKTtcbiAgICAgICAgICAgIHRoaXMuaFRMViA9IHRoaXMuaFQgKyB0aGlzLmhMICsgdGhpcy5oVjtcbiAgICAgICAgICAgIHRoaXMuaXNNb2RpZmllZCA9IGZhbHNlO1xuICAgICAgICAgICAgLy9hbGVydChcImZpcnN0IHRpbWU6IFwiICsgdGhpcy5oVExWKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5oVExWO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogZ2V0IGhleGFkZWNpbWFsIHN0cmluZyBvZiBBU04uMSBUTFYgdmFsdWUoVikgYnl0ZXNcbiAgICAgKiBAbmFtZSBnZXRWYWx1ZUhleFxuICAgICAqIEBtZW1iZXJPZiBLSlVSLmFzbjEuQVNOMU9iamVjdCNcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IGhleGFkZWNpbWFsIHN0cmluZyBvZiBBU04uMSBUTFYgdmFsdWUoVikgYnl0ZXNcbiAgICAgKi9cbiAgICB0aGlzLmdldFZhbHVlSGV4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmdldEVuY29kZWRIZXgoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaFY7XG4gICAgfTtcbiAgICB0aGlzLmdldEZyZXNoVmFsdWVIZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9O1xufTtcbi8vID09IEJFR0lOIERFUkFic3RyYWN0U3RyaW5nID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLyoqXG4gKiBiYXNlIGNsYXNzIGZvciBBU04uMSBERVIgc3RyaW5nIGNsYXNzZXNcbiAqIEBuYW1lIEtKVVIuYXNuMS5ERVJBYnN0cmFjdFN0cmluZ1xuICogQGNsYXNzIGJhc2UgY2xhc3MgZm9yIEFTTi4xIERFUiBzdHJpbmcgY2xhc3Nlc1xuICogQHBhcmFtIHtBcnJheX0gcGFyYW1zIGFzc29jaWF0aXZlIGFycmF5IG9mIHBhcmFtZXRlcnMgKGV4LiB7J3N0cic6ICdhYWEnfSlcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBzIGludGVybmFsIHN0cmluZyBvZiB2YWx1ZVxuICogQGV4dGVuZHMgS0pVUi5hc24xLkFTTjFPYmplY3RcbiAqIEBkZXNjcmlwdGlvblxuICogPGJyLz5cbiAqIEFzIGZvciBhcmd1bWVudCAncGFyYW1zJyBmb3IgY29uc3RydWN0b3IsIHlvdSBjYW4gc3BlY2lmeSBvbmUgb2ZcbiAqIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICogPHVsPlxuICogPGxpPnN0ciAtIHNwZWNpZnkgaW5pdGlhbCBBU04uMSB2YWx1ZShWKSBieSBhIHN0cmluZzwvbGk+XG4gKiA8bGk+aGV4IC0gc3BlY2lmeSBpbml0aWFsIEFTTi4xIHZhbHVlKFYpIGJ5IGEgaGV4YWRlY2ltYWwgc3RyaW5nPC9saT5cbiAqIDwvdWw+XG4gKiBOT1RFOiAncGFyYW1zJyBjYW4gYmUgb21pdHRlZC5cbiAqL1xuS0pVUi5hc24xLkRFUkFic3RyYWN0U3RyaW5nID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgIEtKVVIuYXNuMS5ERVJBYnN0cmFjdFN0cmluZy5zdXBlcmNsYXNzLmNvbnN0cnVjdG9yLmNhbGwodGhpcyk7XG4gICAgdmFyIHMgPSBudWxsO1xuICAgIHZhciBoViA9IG51bGw7XG4gICAgLyoqXG4gICAgICogZ2V0IHN0cmluZyB2YWx1ZSBvZiB0aGlzIHN0cmluZyBvYmplY3RcbiAgICAgKiBAbmFtZSBnZXRTdHJpbmdcbiAgICAgKiBAbWVtYmVyT2YgS0pVUi5hc24xLkRFUkFic3RyYWN0U3RyaW5nI1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gc3RyaW5nIHZhbHVlIG9mIHRoaXMgc3RyaW5nIG9iamVjdFxuICAgICAqL1xuICAgIHRoaXMuZ2V0U3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogc2V0IHZhbHVlIGJ5IGEgc3RyaW5nXG4gICAgICogQG5hbWUgc2V0U3RyaW5nXG4gICAgICogQG1lbWJlck9mIEtKVVIuYXNuMS5ERVJBYnN0cmFjdFN0cmluZyNcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmV3UyB2YWx1ZSBieSBhIHN0cmluZyB0byBzZXRcbiAgICAgKi9cbiAgICB0aGlzLnNldFN0cmluZyA9IGZ1bmN0aW9uIChuZXdTKSB7XG4gICAgICAgIHRoaXMuaFRMViA9IG51bGw7XG4gICAgICAgIHRoaXMuaXNNb2RpZmllZCA9IHRydWU7XG4gICAgICAgIHRoaXMucyA9IG5ld1M7XG4gICAgICAgIHRoaXMuaFYgPSBzdG9oZXgodGhpcy5zKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIHNldCB2YWx1ZSBieSBhIGhleGFkZWNpbWFsIHN0cmluZ1xuICAgICAqIEBuYW1lIHNldFN0cmluZ0hleFxuICAgICAqIEBtZW1iZXJPZiBLSlVSLmFzbjEuREVSQWJzdHJhY3RTdHJpbmcjXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5ld0hleFN0cmluZyB2YWx1ZSBieSBhIGhleGFkZWNpbWFsIHN0cmluZyB0byBzZXRcbiAgICAgKi9cbiAgICB0aGlzLnNldFN0cmluZ0hleCA9IGZ1bmN0aW9uIChuZXdIZXhTdHJpbmcpIHtcbiAgICAgICAgdGhpcy5oVExWID0gbnVsbDtcbiAgICAgICAgdGhpcy5pc01vZGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zID0gbnVsbDtcbiAgICAgICAgdGhpcy5oViA9IG5ld0hleFN0cmluZztcbiAgICB9O1xuICAgIHRoaXMuZ2V0RnJlc2hWYWx1ZUhleCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaFY7XG4gICAgfTtcbiAgICBpZiAodHlwZW9mIHBhcmFtcyAhPSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcGFyYW1zID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RyaW5nKHBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHBhcmFtc1snc3RyJ10gIT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgdGhpcy5zZXRTdHJpbmcocGFyYW1zWydzdHInXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHBhcmFtc1snaGV4J10gIT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgdGhpcy5zZXRTdHJpbmdIZXgocGFyYW1zWydoZXgnXSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuWUFIT08ubGFuZy5leHRlbmQoS0pVUi5hc24xLkRFUkFic3RyYWN0U3RyaW5nLCBLSlVSLmFzbjEuQVNOMU9iamVjdCk7XG4vLyA9PSBFTkQgICBERVJBYnN0cmFjdFN0cmluZyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vID09IEJFR0lOIERFUkFic3RyYWN0VGltZSA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLyoqXG4gKiBiYXNlIGNsYXNzIGZvciBBU04uMSBERVIgR2VuZXJhbGl6ZWQvVVRDVGltZSBjbGFzc1xuICogQG5hbWUgS0pVUi5hc24xLkRFUkFic3RyYWN0VGltZVxuICogQGNsYXNzIGJhc2UgY2xhc3MgZm9yIEFTTi4xIERFUiBHZW5lcmFsaXplZC9VVENUaW1lIGNsYXNzXG4gKiBAcGFyYW0ge0FycmF5fSBwYXJhbXMgYXNzb2NpYXRpdmUgYXJyYXkgb2YgcGFyYW1ldGVycyAoZXguIHsnc3RyJzogJzEzMDQzMDIzNTk1OVonfSlcbiAqIEBleHRlbmRzIEtKVVIuYXNuMS5BU04xT2JqZWN0XG4gKiBAZGVzY3JpcHRpb25cbiAqIEBzZWUgS0pVUi5hc24xLkFTTjFPYmplY3QgLSBzdXBlcmNsYXNzXG4gKi9cbktKVVIuYXNuMS5ERVJBYnN0cmFjdFRpbWUgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgS0pVUi5hc24xLkRFUkFic3RyYWN0VGltZS5zdXBlcmNsYXNzLmNvbnN0cnVjdG9yLmNhbGwodGhpcyk7XG4gICAgdmFyIHMgPSBudWxsO1xuICAgIHZhciBkYXRlID0gbnVsbDtcbiAgICAvLyAtLS0gUFJJVkFURSBNRVRIT0RTIC0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgdGhpcy5sb2NhbERhdGVUb1VUQyA9IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHV0YyA9IGQuZ2V0VGltZSgpICsgKGQuZ2V0VGltZXpvbmVPZmZzZXQoKSAqIDYwMDAwKTtcbiAgICAgICAgdmFyIHV0Y0RhdGUgPSBuZXcgRGF0ZSh1dGMpO1xuICAgICAgICByZXR1cm4gdXRjRGF0ZTtcbiAgICB9O1xuICAgIC8qXG4gICAgICogZm9ybWF0IGRhdGUgc3RyaW5nIGJ5IERhdGEgb2JqZWN0XG4gICAgICogQG5hbWUgZm9ybWF0RGF0ZVxuICAgICAqIEBtZW1iZXJPZiBLSlVSLmFzbjEuQWJzdHJhY3RUaW1lO1xuICAgICAqIEBwYXJhbSB7RGF0ZX0gZGF0ZU9iamVjdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlICd1dGMnIG9yICdnZW4nXG4gICAgICogQHBhcmFtIHtib29sZWFufSB3aXRoTWlsbGlzIGZsYWcgZm9yIHdpdGggbWlsbGlzZWN0aW9ucyBvciBub3RcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiAnd2l0aE1pbGxpcycgZmxhZyBpcyBzdXBwb3J0ZWQgZnJvbSBhc24xIDEuMC42LlxuICAgICAqL1xuICAgIHRoaXMuZm9ybWF0RGF0ZSA9IGZ1bmN0aW9uIChkYXRlT2JqZWN0LCB0eXBlLCB3aXRoTWlsbGlzKSB7XG4gICAgICAgIHZhciBwYWQgPSB0aGlzLnplcm9QYWRkaW5nO1xuICAgICAgICB2YXIgZCA9IHRoaXMubG9jYWxEYXRlVG9VVEMoZGF0ZU9iamVjdCk7XG4gICAgICAgIHZhciB5ZWFyID0gU3RyaW5nKGQuZ2V0RnVsbFllYXIoKSk7XG4gICAgICAgIGlmICh0eXBlID09ICd1dGMnKVxuICAgICAgICAgICAgeWVhciA9IHllYXIuc3Vic3RyKDIsIDIpO1xuICAgICAgICB2YXIgbW9udGggPSBwYWQoU3RyaW5nKGQuZ2V0TW9udGgoKSArIDEpLCAyKTtcbiAgICAgICAgdmFyIGRheSA9IHBhZChTdHJpbmcoZC5nZXREYXRlKCkpLCAyKTtcbiAgICAgICAgdmFyIGhvdXIgPSBwYWQoU3RyaW5nKGQuZ2V0SG91cnMoKSksIDIpO1xuICAgICAgICB2YXIgbWluID0gcGFkKFN0cmluZyhkLmdldE1pbnV0ZXMoKSksIDIpO1xuICAgICAgICB2YXIgc2VjID0gcGFkKFN0cmluZyhkLmdldFNlY29uZHMoKSksIDIpO1xuICAgICAgICB2YXIgcyA9IHllYXIgKyBtb250aCArIGRheSArIGhvdXIgKyBtaW4gKyBzZWM7XG4gICAgICAgIGlmICh3aXRoTWlsbGlzID09PSB0cnVlKSB7XG4gICAgICAgICAgICB2YXIgbWlsbGlzID0gZC5nZXRNaWxsaXNlY29uZHMoKTtcbiAgICAgICAgICAgIGlmIChtaWxsaXMgIT0gMCkge1xuICAgICAgICAgICAgICAgIHZhciBzTWlsbGlzID0gcGFkKFN0cmluZyhtaWxsaXMpLCAzKTtcbiAgICAgICAgICAgICAgICBzTWlsbGlzID0gc01pbGxpcy5yZXBsYWNlKC9bMF0rJC8sIFwiXCIpO1xuICAgICAgICAgICAgICAgIHMgPSBzICsgXCIuXCIgKyBzTWlsbGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzICsgXCJaXCI7XG4gICAgfTtcbiAgICB0aGlzLnplcm9QYWRkaW5nID0gZnVuY3Rpb24gKHMsIGxlbikge1xuICAgICAgICBpZiAocy5sZW5ndGggPj0gbGVuKVxuICAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgIHJldHVybiBuZXcgQXJyYXkobGVuIC0gcy5sZW5ndGggKyAxKS5qb2luKCcwJykgKyBzO1xuICAgIH07XG4gICAgLy8gLS0tIFBVQkxJQyBNRVRIT0RTIC0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLyoqXG4gICAgICogZ2V0IHN0cmluZyB2YWx1ZSBvZiB0aGlzIHN0cmluZyBvYmplY3RcbiAgICAgKiBAbmFtZSBnZXRTdHJpbmdcbiAgICAgKiBAbWVtYmVyT2YgS0pVUi5hc24xLkRFUkFic3RyYWN0VGltZSNcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHN0cmluZyB2YWx1ZSBvZiB0aGlzIHRpbWUgb2JqZWN0XG4gICAgICovXG4gICAgdGhpcy5nZXRTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBzZXQgdmFsdWUgYnkgYSBzdHJpbmdcbiAgICAgKiBAbmFtZSBzZXRTdHJpbmdcbiAgICAgKiBAbWVtYmVyT2YgS0pVUi5hc24xLkRFUkFic3RyYWN0VGltZSNcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmV3UyB2YWx1ZSBieSBhIHN0cmluZyB0byBzZXQgc3VjaCBsaWtlIFwiMTMwNDMwMjM1OTU5WlwiXG4gICAgICovXG4gICAgdGhpcy5zZXRTdHJpbmcgPSBmdW5jdGlvbiAobmV3Uykge1xuICAgICAgICB0aGlzLmhUTFYgPSBudWxsO1xuICAgICAgICB0aGlzLmlzTW9kaWZpZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnMgPSBuZXdTO1xuICAgICAgICB0aGlzLmhWID0gc3RvaGV4KG5ld1MpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogc2V0IHZhbHVlIGJ5IGEgRGF0ZSBvYmplY3RcbiAgICAgKiBAbmFtZSBzZXRCeURhdGVWYWx1ZVxuICAgICAqIEBtZW1iZXJPZiBLSlVSLmFzbjEuREVSQWJzdHJhY3RUaW1lI1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7SW50ZWdlcn0geWVhciB5ZWFyIG9mIGRhdGUgKGV4LiAyMDEzKVxuICAgICAqIEBwYXJhbSB7SW50ZWdlcn0gbW9udGggbW9udGggb2YgZGF0ZSBiZXR3ZWVuIDEgYW5kIDEyIChleC4gMTIpXG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSBkYXkgZGF5IG9mIG1vbnRoXG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSBob3VyIGhvdXJzIG9mIGRhdGVcbiAgICAgKiBAcGFyYW0ge0ludGVnZXJ9IG1pbiBtaW51dGVzIG9mIGRhdGVcbiAgICAgKiBAcGFyYW0ge0ludGVnZXJ9IHNlYyBzZWNvbmRzIG9mIGRhdGVcbiAgICAgKi9cbiAgICB0aGlzLnNldEJ5RGF0ZVZhbHVlID0gZnVuY3Rpb24gKHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbiwgc2VjKSB7XG4gICAgICAgIHZhciBkYXRlT2JqZWN0ID0gbmV3IERhdGUoRGF0ZS5VVEMoeWVhciwgbW9udGggLSAxLCBkYXksIGhvdXIsIG1pbiwgc2VjLCAwKSk7XG4gICAgICAgIHRoaXMuc2V0QnlEYXRlKGRhdGVPYmplY3QpO1xuICAgIH07XG4gICAgdGhpcy5nZXRGcmVzaFZhbHVlSGV4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oVjtcbiAgICB9O1xufTtcbllBSE9PLmxhbmcuZXh0ZW5kKEtKVVIuYXNuMS5ERVJBYnN0cmFjdFRpbWUsIEtKVVIuYXNuMS5BU04xT2JqZWN0KTtcbi8vID09IEVORCAgIERFUkFic3RyYWN0VGltZSA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gPT0gQkVHSU4gREVSQWJzdHJhY3RTdHJ1Y3R1cmVkID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vKipcbiAqIGJhc2UgY2xhc3MgZm9yIEFTTi4xIERFUiBzdHJ1Y3R1cmVkIGNsYXNzXG4gKiBAbmFtZSBLSlVSLmFzbjEuREVSQWJzdHJhY3RTdHJ1Y3R1cmVkXG4gKiBAY2xhc3MgYmFzZSBjbGFzcyBmb3IgQVNOLjEgREVSIHN0cnVjdHVyZWQgY2xhc3NcbiAqIEBwcm9wZXJ0eSB7QXJyYXl9IGFzbjFBcnJheSBpbnRlcm5hbCBhcnJheSBvZiBBU04xT2JqZWN0XG4gKiBAZXh0ZW5kcyBLSlVSLmFzbjEuQVNOMU9iamVjdFxuICogQGRlc2NyaXB0aW9uXG4gKiBAc2VlIEtKVVIuYXNuMS5BU04xT2JqZWN0IC0gc3VwZXJjbGFzc1xuICovXG5LSlVSLmFzbjEuREVSQWJzdHJhY3RTdHJ1Y3R1cmVkID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgIEtKVVIuYXNuMS5ERVJBYnN0cmFjdFN0cmluZy5zdXBlcmNsYXNzLmNvbnN0cnVjdG9yLmNhbGwodGhpcyk7XG4gICAgdmFyIGFzbjFBcnJheSA9IG51bGw7XG4gICAgLyoqXG4gICAgICogc2V0IHZhbHVlIGJ5IGFycmF5IG9mIEFTTjFPYmplY3RcbiAgICAgKiBAbmFtZSBzZXRCeUFTTjFPYmplY3RBcnJheVxuICAgICAqIEBtZW1iZXJPZiBLSlVSLmFzbjEuREVSQWJzdHJhY3RTdHJ1Y3R1cmVkI1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7YXJyYXl9IGFzbjFPYmplY3RBcnJheSBhcnJheSBvZiBBU04xT2JqZWN0IHRvIHNldFxuICAgICAqL1xuICAgIHRoaXMuc2V0QnlBU04xT2JqZWN0QXJyYXkgPSBmdW5jdGlvbiAoYXNuMU9iamVjdEFycmF5KSB7XG4gICAgICAgIHRoaXMuaFRMViA9IG51bGw7XG4gICAgICAgIHRoaXMuaXNNb2RpZmllZCA9IHRydWU7XG4gICAgICAgIHRoaXMuYXNuMUFycmF5ID0gYXNuMU9iamVjdEFycmF5O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogYXBwZW5kIGFuIEFTTjFPYmplY3QgdG8gaW50ZXJuYWwgYXJyYXlcbiAgICAgKiBAbmFtZSBhcHBlbmRBU04xT2JqZWN0XG4gICAgICogQG1lbWJlck9mIEtKVVIuYXNuMS5ERVJBYnN0cmFjdFN0cnVjdHVyZWQjXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtBU04xT2JqZWN0fSBhc24xT2JqZWN0IHRvIGFkZFxuICAgICAqL1xuICAgIHRoaXMuYXBwZW5kQVNOMU9iamVjdCA9IGZ1bmN0aW9uIChhc24xT2JqZWN0KSB7XG4gICAgICAgIHRoaXMuaFRMViA9IG51bGw7XG4gICAgICAgIHRoaXMuaXNNb2RpZmllZCA9IHRydWU7XG4gICAgICAgIHRoaXMuYXNuMUFycmF5LnB1c2goYXNuMU9iamVjdCk7XG4gICAgfTtcbiAgICB0aGlzLmFzbjFBcnJheSA9IG5ldyBBcnJheSgpO1xuICAgIGlmICh0eXBlb2YgcGFyYW1zICE9IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwYXJhbXNbJ2FycmF5J10gIT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgdGhpcy5hc24xQXJyYXkgPSBwYXJhbXNbJ2FycmF5J107XG4gICAgICAgIH1cbiAgICB9XG59O1xuWUFIT08ubGFuZy5leHRlbmQoS0pVUi5hc24xLkRFUkFic3RyYWN0U3RydWN0dXJlZCwgS0pVUi5hc24xLkFTTjFPYmplY3QpO1xuLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbi8vICBBU04uMSBPYmplY3QgQ2xhc3Nlc1xuLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbi8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4vKipcbiAqIGNsYXNzIGZvciBBU04uMSBERVIgQm9vbGVhblxuICogQG5hbWUgS0pVUi5hc24xLkRFUkJvb2xlYW5cbiAqIEBjbGFzcyBjbGFzcyBmb3IgQVNOLjEgREVSIEJvb2xlYW5cbiAqIEBleHRlbmRzIEtKVVIuYXNuMS5BU04xT2JqZWN0XG4gKiBAZGVzY3JpcHRpb25cbiAqIEBzZWUgS0pVUi5hc24xLkFTTjFPYmplY3QgLSBzdXBlcmNsYXNzXG4gKi9cbktKVVIuYXNuMS5ERVJCb29sZWFuID0gZnVuY3Rpb24gKCkge1xuICAgIEtKVVIuYXNuMS5ERVJCb29sZWFuLnN1cGVyY2xhc3MuY29uc3RydWN0b3IuY2FsbCh0aGlzKTtcbiAgICB0aGlzLmhUID0gXCIwMVwiO1xuICAgIHRoaXMuaFRMViA9IFwiMDEwMWZmXCI7XG59O1xuWUFIT08ubGFuZy5leHRlbmQoS0pVUi5hc24xLkRFUkJvb2xlYW4sIEtKVVIuYXNuMS5BU04xT2JqZWN0KTtcbi8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4vKipcbiAqIGNsYXNzIGZvciBBU04uMSBERVIgSW50ZWdlclxuICogQG5hbWUgS0pVUi5hc24xLkRFUkludGVnZXJcbiAqIEBjbGFzcyBjbGFzcyBmb3IgQVNOLjEgREVSIEludGVnZXJcbiAqIEBleHRlbmRzIEtKVVIuYXNuMS5BU04xT2JqZWN0XG4gKiBAZGVzY3JpcHRpb25cbiAqIDxici8+XG4gKiBBcyBmb3IgYXJndW1lbnQgJ3BhcmFtcycgZm9yIGNvbnN0cnVjdG9yLCB5b3UgY2FuIHNwZWNpZnkgb25lIG9mXG4gKiBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqIDx1bD5cbiAqIDxsaT5pbnQgLSBzcGVjaWZ5IGluaXRpYWwgQVNOLjEgdmFsdWUoVikgYnkgaW50ZWdlciB2YWx1ZTwvbGk+XG4gKiA8bGk+YmlnaW50IC0gc3BlY2lmeSBpbml0aWFsIEFTTi4xIHZhbHVlKFYpIGJ5IEJpZ0ludGVnZXIgb2JqZWN0PC9saT5cbiAqIDxsaT5oZXggLSBzcGVjaWZ5IGluaXRpYWwgQVNOLjEgdmFsdWUoVikgYnkgYSBoZXhhZGVjaW1hbCBzdHJpbmc8L2xpPlxuICogPC91bD5cbiAqIE5PVEU6ICdwYXJhbXMnIGNhbiBiZSBvbWl0dGVkLlxuICovXG5LSlVSLmFzbjEuREVSSW50ZWdlciA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICBLSlVSLmFzbjEuREVSSW50ZWdlci5zdXBlcmNsYXNzLmNvbnN0cnVjdG9yLmNhbGwodGhpcyk7XG4gICAgdGhpcy5oVCA9IFwiMDJcIjtcbiAgICAvKipcbiAgICAgKiBzZXQgdmFsdWUgYnkgVG9tIFd1J3MgQmlnSW50ZWdlciBvYmplY3RcbiAgICAgKiBAbmFtZSBzZXRCeUJpZ0ludGVnZXJcbiAgICAgKiBAbWVtYmVyT2YgS0pVUi5hc24xLkRFUkludGVnZXIjXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtCaWdJbnRlZ2VyfSBiaWdJbnRlZ2VyVmFsdWUgdG8gc2V0XG4gICAgICovXG4gICAgdGhpcy5zZXRCeUJpZ0ludGVnZXIgPSBmdW5jdGlvbiAoYmlnSW50ZWdlclZhbHVlKSB7XG4gICAgICAgIHRoaXMuaFRMViA9IG51bGw7XG4gICAgICAgIHRoaXMuaXNNb2RpZmllZCA9IHRydWU7XG4gICAgICAgIHRoaXMuaFYgPSBLSlVSLmFzbjEuQVNOMVV0aWwuYmlnSW50VG9NaW5Ud29zQ29tcGxlbWVudHNIZXgoYmlnSW50ZWdlclZhbHVlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIHNldCB2YWx1ZSBieSBpbnRlZ2VyIHZhbHVlXG4gICAgICogQG5hbWUgc2V0QnlJbnRlZ2VyXG4gICAgICogQG1lbWJlck9mIEtKVVIuYXNuMS5ERVJJbnRlZ2VyXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSBpbnRlZ2VyIHZhbHVlIHRvIHNldFxuICAgICAqL1xuICAgIHRoaXMuc2V0QnlJbnRlZ2VyID0gZnVuY3Rpb24gKGludFZhbHVlKSB7XG4gICAgICAgIHZhciBiaSA9IG5ldyBCaWdJbnRlZ2VyKFN0cmluZyhpbnRWYWx1ZSksIDEwKTtcbiAgICAgICAgdGhpcy5zZXRCeUJpZ0ludGVnZXIoYmkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogc2V0IHZhbHVlIGJ5IGludGVnZXIgdmFsdWVcbiAgICAgKiBAbmFtZSBzZXRWYWx1ZUhleFxuICAgICAqIEBtZW1iZXJPZiBLSlVSLmFzbjEuREVSSW50ZWdlciNcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaGV4YWRlY2ltYWwgc3RyaW5nIG9mIGludGVnZXIgdmFsdWVcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiA8YnIvPlxuICAgICAqIE5PVEU6IFZhbHVlIHNoYWxsIGJlIHJlcHJlc2VudGVkIGJ5IG1pbmltdW0gb2N0ZXQgbGVuZ3RoIG9mXG4gICAgICogdHdvJ3MgY29tcGxlbWVudCByZXByZXNlbnRhdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIG5ldyBLSlVSLmFzbjEuREVSSW50ZWdlcigxMjMpO1xuICAgICAqIG5ldyBLSlVSLmFzbjEuREVSSW50ZWdlcih7J2ludCc6IDEyM30pO1xuICAgICAqIG5ldyBLSlVSLmFzbjEuREVSSW50ZWdlcih7J2hleCc6ICcxZmFkJ30pO1xuICAgICAqL1xuICAgIHRoaXMuc2V0VmFsdWVIZXggPSBmdW5jdGlvbiAobmV3SGV4U3RyaW5nKSB7XG4gICAgICAgIHRoaXMuaFYgPSBuZXdIZXhTdHJpbmc7XG4gICAgfTtcbiAgICB0aGlzLmdldEZyZXNoVmFsdWVIZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhWO1xuICAgIH07XG4gICAgaWYgKHR5cGVvZiBwYXJhbXMgIT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBpZiAodHlwZW9mIHBhcmFtc1snYmlnaW50J10gIT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgdGhpcy5zZXRCeUJpZ0ludGVnZXIocGFyYW1zWydiaWdpbnQnXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHBhcmFtc1snaW50J10gIT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgdGhpcy5zZXRCeUludGVnZXIocGFyYW1zWydpbnQnXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHBhcmFtcyA9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICB0aGlzLnNldEJ5SW50ZWdlcihwYXJhbXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBwYXJhbXNbJ2hleCddICE9IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0VmFsdWVIZXgocGFyYW1zWydoZXgnXSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuWUFIT08ubGFuZy5leHRlbmQoS0pVUi5hc24xLkRFUkludGVnZXIsIEtKVVIuYXNuMS5BU04xT2JqZWN0KTtcbi8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4vKipcbiAqIGNsYXNzIGZvciBBU04uMSBERVIgZW5jb2RlZCBCaXRTdHJpbmcgcHJpbWl0aXZlXG4gKiBAbmFtZSBLSlVSLmFzbjEuREVSQml0U3RyaW5nXG4gKiBAY2xhc3MgY2xhc3MgZm9yIEFTTi4xIERFUiBlbmNvZGVkIEJpdFN0cmluZyBwcmltaXRpdmVcbiAqIEBleHRlbmRzIEtKVVIuYXNuMS5BU04xT2JqZWN0XG4gKiBAZGVzY3JpcHRpb25cbiAqIDxici8+XG4gKiBBcyBmb3IgYXJndW1lbnQgJ3BhcmFtcycgZm9yIGNvbnN0cnVjdG9yLCB5b3UgY2FuIHNwZWNpZnkgb25lIG9mXG4gKiBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqIDx1bD5cbiAqIDxsaT5iaW4gLSBzcGVjaWZ5IGJpbmFyeSBzdHJpbmcgKGV4LiAnMTAxMTEnKTwvbGk+XG4gKiA8bGk+YXJyYXkgLSBzcGVjaWZ5IGFycmF5IG9mIGJvb2xlYW4gKGV4LiBbdHJ1ZSxmYWxzZSx0cnVlLHRydWVdKTwvbGk+XG4gKiA8bGk+aGV4IC0gc3BlY2lmeSBoZXhhZGVjaW1hbCBzdHJpbmcgb2YgQVNOLjEgdmFsdWUoVikgaW5jbHVkaW5nIHVudXNlZCBiaXRzPC9saT5cbiAqIDxsaT5vYmogLSBzcGVjaWZ5IHtAbGluayBLSlVSLmFzbjEuQVNOMVV0aWwubmV3T2JqZWN0fVxuICogYXJndW1lbnQgZm9yIFwiQml0U3RyaW5nIGVuY2Fwc3VsYXRlc1wiIHN0cnVjdHVyZS48L2xpPlxuICogPC91bD5cbiAqIE5PVEUxOiAncGFyYW1zJyBjYW4gYmUgb21pdHRlZC48YnIvPlxuICogTk9URTI6ICdvYmonIHBhcmFtZXRlciBoYXZlIGJlZW4gc3VwcG9ydGVkIHNpbmNlXG4gKiBhc24xIDEuMC4xMSwganNyc2FzaWduIDYuMS4xICgyMDE2LVNlcC0yNSkuPGJyLz5cbiAqIEBleGFtcGxlXG4gKiAvLyBkZWZhdWx0IGNvbnN0cnVjdG9yXG4gKiBvID0gbmV3IEtKVVIuYXNuMS5ERVJCaXRTdHJpbmcoKTtcbiAqIC8vIGluaXRpYWxpemUgd2l0aCBiaW5hcnkgc3RyaW5nXG4gKiBvID0gbmV3IEtKVVIuYXNuMS5ERVJCaXRTdHJpbmcoe2JpbjogXCIxMDExXCJ9KTtcbiAqIC8vIGluaXRpYWxpemUgd2l0aCBib29sZWFuIGFycmF5XG4gKiBvID0gbmV3IEtKVVIuYXNuMS5ERVJCaXRTdHJpbmcoe2FycmF5OiBbdHJ1ZSxmYWxzZSx0cnVlLHRydWVdfSk7XG4gKiAvLyBpbml0aWFsaXplIHdpdGggaGV4YWRlY2ltYWwgc3RyaW5nICgwNCBpcyB1bnVzZWQgYml0cylcbiAqIG8gPSBuZXcgS0pVUi5hc24xLkRFUk9jdGV0U3RyaW5nKHtoZXg6IFwiMDRiYWMwXCJ9KTtcbiAqIC8vIGluaXRpYWxpemUgd2l0aCBBU04xVXRpbC5uZXdPYmplY3QgYXJndW1lbnQgZm9yIGVuY2Fwc3VsYXRlZFxuICogbyA9IG5ldyBLSlVSLmFzbjEuREVSQml0U3RyaW5nKHtvYmo6IHtzZXE6IFt7aW50OiAzfSwge3BybnN0cjogJ2FhYSd9XX19KTtcbiAqIC8vIGFib3ZlIGdlbmVyYXRlcyBhIEFTTi4xIGRhdGEgbGlrZSB0aGlzOlxuICogLy8gQklUIFNUUklORywgZW5jYXBzdWxhdGVzIHtcbiAqIC8vICAgU0VRVUVOQ0Uge1xuICogLy8gICAgIElOVEVHRVIgM1xuICogLy8gICAgIFByaW50YWJsZVN0cmluZyAnYWFhJ1xuICogLy8gICAgIH1cbiAqIC8vICAgfVxuICovXG5LSlVSLmFzbjEuREVSQml0U3RyaW5nID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgIGlmIChwYXJhbXMgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgcGFyYW1zLm9iaiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB2YXIgbyA9IEtKVVIuYXNuMS5BU04xVXRpbC5uZXdPYmplY3QocGFyYW1zLm9iaik7XG4gICAgICAgIHBhcmFtcy5oZXggPSBcIjAwXCIgKyBvLmdldEVuY29kZWRIZXgoKTtcbiAgICB9XG4gICAgS0pVUi5hc24xLkRFUkJpdFN0cmluZy5zdXBlcmNsYXNzLmNvbnN0cnVjdG9yLmNhbGwodGhpcyk7XG4gICAgdGhpcy5oVCA9IFwiMDNcIjtcbiAgICAvKipcbiAgICAgKiBzZXQgQVNOLjEgdmFsdWUoVikgYnkgYSBoZXhhZGVjaW1hbCBzdHJpbmcgaW5jbHVkaW5nIHVudXNlZCBiaXRzXG4gICAgICogQG5hbWUgc2V0SGV4VmFsdWVJbmNsdWRpbmdVbnVzZWRCaXRzXG4gICAgICogQG1lbWJlck9mIEtKVVIuYXNuMS5ERVJCaXRTdHJpbmcjXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5ld0hleFN0cmluZ0luY2x1ZGluZ1VudXNlZEJpdHNcbiAgICAgKi9cbiAgICB0aGlzLnNldEhleFZhbHVlSW5jbHVkaW5nVW51c2VkQml0cyA9IGZ1bmN0aW9uIChuZXdIZXhTdHJpbmdJbmNsdWRpbmdVbnVzZWRCaXRzKSB7XG4gICAgICAgIHRoaXMuaFRMViA9IG51bGw7XG4gICAgICAgIHRoaXMuaXNNb2RpZmllZCA9IHRydWU7XG4gICAgICAgIHRoaXMuaFYgPSBuZXdIZXhTdHJpbmdJbmNsdWRpbmdVbnVzZWRCaXRzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogc2V0IEFTTi4xIHZhbHVlKFYpIGJ5IHVudXNlZCBiaXQgYW5kIGhleGFkZWNpbWFsIHN0cmluZyBvZiB2YWx1ZVxuICAgICAqIEBuYW1lIHNldFVudXNlZEJpdHNBbmRIZXhWYWx1ZVxuICAgICAqIEBtZW1iZXJPZiBLSlVSLmFzbjEuREVSQml0U3RyaW5nI1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7SW50ZWdlcn0gdW51c2VkQml0c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBoVmFsdWVcbiAgICAgKi9cbiAgICB0aGlzLnNldFVudXNlZEJpdHNBbmRIZXhWYWx1ZSA9IGZ1bmN0aW9uICh1bnVzZWRCaXRzLCBoVmFsdWUpIHtcbiAgICAgICAgaWYgKHVudXNlZEJpdHMgPCAwIHx8IDcgPCB1bnVzZWRCaXRzKSB7XG4gICAgICAgICAgICB0aHJvdyBcInVudXNlZCBiaXRzIHNoYWxsIGJlIGZyb20gMCB0byA3OiB1ID0gXCIgKyB1bnVzZWRCaXRzO1xuICAgICAgICB9XG4gICAgICAgIHZhciBoVW51c2VkQml0cyA9IFwiMFwiICsgdW51c2VkQml0cztcbiAgICAgICAgdGhpcy5oVExWID0gbnVsbDtcbiAgICAgICAgdGhpcy5pc01vZGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5oViA9IGhVbnVzZWRCaXRzICsgaFZhbHVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogc2V0IEFTTi4xIERFUiBCaXRTdHJpbmcgYnkgYmluYXJ5IHN0cmluZzxici8+XG4gICAgICogQG5hbWUgc2V0QnlCaW5hcnlTdHJpbmdcbiAgICAgKiBAbWVtYmVyT2YgS0pVUi5hc24xLkRFUkJpdFN0cmluZyNcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYmluYXJ5U3RyaW5nIGJpbmFyeSB2YWx1ZSBzdHJpbmcgKGkuZS4gJzEwMTExJylcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBJdHMgdW51c2VkIGJpdHMgd2lsbCBiZSBjYWxjdWxhdGVkIGF1dG9tYXRpY2FsbHkgYnkgbGVuZ3RoIG9mXG4gICAgICogJ2JpbmFyeVZhbHVlJy4gPGJyLz5cbiAgICAgKiBOT1RFOiBUcmFpbGluZyB6ZXJvcyAnMCcgd2lsbCBiZSBpZ25vcmVkLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogbyA9IG5ldyBLSlVSLmFzbjEuREVSQml0U3RyaW5nKCk7XG4gICAgICogby5zZXRCeUJvb2xlYW5BcnJheShcIjAxMDExXCIpO1xuICAgICAqL1xuICAgIHRoaXMuc2V0QnlCaW5hcnlTdHJpbmcgPSBmdW5jdGlvbiAoYmluYXJ5U3RyaW5nKSB7XG4gICAgICAgIGJpbmFyeVN0cmluZyA9IGJpbmFyeVN0cmluZy5yZXBsYWNlKC8wKyQvLCAnJyk7XG4gICAgICAgIHZhciB1bnVzZWRCaXRzID0gOCAtIGJpbmFyeVN0cmluZy5sZW5ndGggJSA4O1xuICAgICAgICBpZiAodW51c2VkQml0cyA9PSA4KVxuICAgICAgICAgICAgdW51c2VkQml0cyA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IHVudXNlZEJpdHM7IGkrKykge1xuICAgICAgICAgICAgYmluYXJ5U3RyaW5nICs9ICcwJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgaCA9ICcnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJpbmFyeVN0cmluZy5sZW5ndGggLSAxOyBpICs9IDgpIHtcbiAgICAgICAgICAgIHZhciBiID0gYmluYXJ5U3RyaW5nLnN1YnN0cihpLCA4KTtcbiAgICAgICAgICAgIHZhciB4ID0gcGFyc2VJbnQoYiwgMikudG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgaWYgKHgubGVuZ3RoID09IDEpXG4gICAgICAgICAgICAgICAgeCA9ICcwJyArIHg7XG4gICAgICAgICAgICBoICs9IHg7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oVExWID0gbnVsbDtcbiAgICAgICAgdGhpcy5pc01vZGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5oViA9ICcwJyArIHVudXNlZEJpdHMgKyBoO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogc2V0IEFTTi4xIFRMViB2YWx1ZShWKSBieSBhbiBhcnJheSBvZiBib29sZWFuPGJyLz5cbiAgICAgKiBAbmFtZSBzZXRCeUJvb2xlYW5BcnJheVxuICAgICAqIEBtZW1iZXJPZiBLSlVSLmFzbjEuREVSQml0U3RyaW5nI1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7YXJyYXl9IGJvb2xlYW5BcnJheSBhcnJheSBvZiBib29sZWFuIChleC4gW3RydWUsIGZhbHNlLCB0cnVlXSlcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBOT1RFOiBUcmFpbGluZyBmYWxzZXMgd2lsbCBiZSBpZ25vcmVkIGluIHRoZSBBU04uMSBERVIgT2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICogbyA9IG5ldyBLSlVSLmFzbjEuREVSQml0U3RyaW5nKCk7XG4gICAgICogby5zZXRCeUJvb2xlYW5BcnJheShbZmFsc2UsIHRydWUsIGZhbHNlLCB0cnVlLCB0cnVlXSk7XG4gICAgICovXG4gICAgdGhpcy5zZXRCeUJvb2xlYW5BcnJheSA9IGZ1bmN0aW9uIChib29sZWFuQXJyYXkpIHtcbiAgICAgICAgdmFyIHMgPSAnJztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib29sZWFuQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChib29sZWFuQXJyYXlbaV0gPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHMgKz0gJzEnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcyArPSAnMCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRCeUJpbmFyeVN0cmluZyhzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGdlbmVyYXRlIGFuIGFycmF5IG9mIGZhbHNlcyB3aXRoIHNwZWNpZmllZCBsZW5ndGg8YnIvPlxuICAgICAqIEBuYW1lIG5ld0ZhbHNlQXJyYXlcbiAgICAgKiBAbWVtYmVyT2YgS0pVUi5hc24xLkRFUkJpdFN0cmluZ1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7SW50ZWdlcn0gbkxlbmd0aCBsZW5ndGggb2YgYXJyYXkgdG8gZ2VuZXJhdGVcbiAgICAgKiBAcmV0dXJuIHthcnJheX0gYXJyYXkgb2YgYm9vbGVhbiBmYWxzZXNcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBUaGlzIHN0YXRpYyBtZXRob2QgbWF5IGJlIHVzZWZ1bCB0byBpbml0aWFsaXplIGJvb2xlYW4gYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBvID0gbmV3IEtKVVIuYXNuMS5ERVJCaXRTdHJpbmcoKTtcbiAgICAgKiBvLm5ld0ZhbHNlQXJyYXkoMykgJnJhcnI7IFtmYWxzZSwgZmFsc2UsIGZhbHNlXVxuICAgICAqL1xuICAgIHRoaXMubmV3RmFsc2VBcnJheSA9IGZ1bmN0aW9uIChuTGVuZ3RoKSB7XG4gICAgICAgIHZhciBhID0gbmV3IEFycmF5KG5MZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5MZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYVtpXSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhO1xuICAgIH07XG4gICAgdGhpcy5nZXRGcmVzaFZhbHVlSGV4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oVjtcbiAgICB9O1xuICAgIGlmICh0eXBlb2YgcGFyYW1zICE9IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwYXJhbXMgPT0gXCJzdHJpbmdcIiAmJiBwYXJhbXMudG9Mb3dlckNhc2UoKS5tYXRjaCgvXlswLTlhLWZdKyQvKSkge1xuICAgICAgICAgICAgdGhpcy5zZXRIZXhWYWx1ZUluY2x1ZGluZ1VudXNlZEJpdHMocGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgcGFyYW1zWydoZXgnXSAhPSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB0aGlzLnNldEhleFZhbHVlSW5jbHVkaW5nVW51c2VkQml0cyhwYXJhbXNbJ2hleCddKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgcGFyYW1zWydiaW4nXSAhPSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB0aGlzLnNldEJ5QmluYXJ5U3RyaW5nKHBhcmFtc1snYmluJ10pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBwYXJhbXNbJ2FycmF5J10gIT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgdGhpcy5zZXRCeUJvb2xlYW5BcnJheShwYXJhbXNbJ2FycmF5J10pO1xuICAgICAgICB9XG4gICAgfVxufTtcbllBSE9PLmxhbmcuZXh0ZW5kKEtKVVIuYXNuMS5ERVJCaXRTdHJpbmcsIEtKVVIuYXNuMS5BU04xT2JqZWN0KTtcbi8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4vKipcbiAqIGNsYXNzIGZvciBBU04uMSBERVIgT2N0ZXRTdHJpbmc8YnIvPlxuICogQG5hbWUgS0pVUi5hc24xLkRFUk9jdGV0U3RyaW5nXG4gKiBAY2xhc3MgY2xhc3MgZm9yIEFTTi4xIERFUiBPY3RldFN0cmluZ1xuICogQHBhcmFtIHtBcnJheX0gcGFyYW1zIGFzc29jaWF0aXZlIGFycmF5IG9mIHBhcmFtZXRlcnMgKGV4LiB7J3N0cic6ICdhYWEnfSlcbiAqIEBleHRlbmRzIEtKVVIuYXNuMS5ERVJBYnN0cmFjdFN0cmluZ1xuICogQGRlc2NyaXB0aW9uXG4gKiBUaGlzIGNsYXNzIHByb3ZpZGVzIEFTTi4xIE9jdGV0U3RyaW5nIHNpbXBsZSB0eXBlLjxici8+XG4gKiBTdXBwb3J0ZWQgXCJwYXJhbXNcIiBhdHRyaWJ1dGVzIGFyZTpcbiAqIDx1bD5cbiAqIDxsaT5zdHIgLSB0byBzZXQgYSBzdHJpbmcgYXMgYSB2YWx1ZTwvbGk+XG4gKiA8bGk+aGV4IC0gdG8gc2V0IGEgaGV4YWRlY2ltYWwgc3RyaW5nIGFzIGEgdmFsdWU8L2xpPlxuICogPGxpPm9iaiAtIHRvIHNldCBhIGVuY2Fwc3VsYXRlZCBBU04uMSB2YWx1ZSBieSBKU09OIG9iamVjdFxuICogd2hpY2ggaXMgZGVmaW5lZCBpbiB7QGxpbmsgS0pVUi5hc24xLkFTTjFVdGlsLm5ld09iamVjdH08L2xpPlxuICogPC91bD5cbiAqIE5PVEU6IEEgcGFyYW1ldGVyICdvYmonIGhhdmUgYmVlbiBzdXBwb3J0ZWRcbiAqIGZvciBcIk9DVEVUIFNUUklORywgZW5jYXBzdWxhdGVzXCIgc3RydWN0dXJlLlxuICogc2luY2UgYXNuMSAxLjAuMTEsIGpzcnNhc2lnbiA2LjEuMSAoMjAxNi1TZXAtMjUpLlxuICogQHNlZSBLSlVSLmFzbjEuREVSQWJzdHJhY3RTdHJpbmcgLSBzdXBlcmNsYXNzXG4gKiBAZXhhbXBsZVxuICogLy8gZGVmYXVsdCBjb25zdHJ1Y3RvclxuICogbyA9IG5ldyBLSlVSLmFzbjEuREVST2N0ZXRTdHJpbmcoKTtcbiAqIC8vIGluaXRpYWxpemUgd2l0aCBzdHJpbmdcbiAqIG8gPSBuZXcgS0pVUi5hc24xLkRFUk9jdGV0U3RyaW5nKHtzdHI6IFwiYWFhXCJ9KTtcbiAqIC8vIGluaXRpYWxpemUgd2l0aCBoZXhhZGVjaW1hbCBzdHJpbmdcbiAqIG8gPSBuZXcgS0pVUi5hc24xLkRFUk9jdGV0U3RyaW5nKHtoZXg6IFwiNjE2MTYxXCJ9KTtcbiAqIC8vIGluaXRpYWxpemUgd2l0aCBBU04xVXRpbC5uZXdPYmplY3QgYXJndW1lbnRcbiAqIG8gPSBuZXcgS0pVUi5hc24xLkRFUk9jdGV0U3RyaW5nKHtvYmo6IHtzZXE6IFt7aW50OiAzfSwge3BybnN0cjogJ2FhYSd9XX19KTtcbiAqIC8vIGFib3ZlIGdlbmVyYXRlcyBhIEFTTi4xIGRhdGEgbGlrZSB0aGlzOlxuICogLy8gT0NURVQgU1RSSU5HLCBlbmNhcHN1bGF0ZXMge1xuICogLy8gICBTRVFVRU5DRSB7XG4gKiAvLyAgICAgSU5URUdFUiAzXG4gKiAvLyAgICAgUHJpbnRhYmxlU3RyaW5nICdhYWEnXG4gKiAvLyAgICAgfVxuICogLy8gICB9XG4gKi9cbktKVVIuYXNuMS5ERVJPY3RldFN0cmluZyA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICBpZiAocGFyYW1zICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHBhcmFtcy5vYmogIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdmFyIG8gPSBLSlVSLmFzbjEuQVNOMVV0aWwubmV3T2JqZWN0KHBhcmFtcy5vYmopO1xuICAgICAgICBwYXJhbXMuaGV4ID0gby5nZXRFbmNvZGVkSGV4KCk7XG4gICAgfVxuICAgIEtKVVIuYXNuMS5ERVJPY3RldFN0cmluZy5zdXBlcmNsYXNzLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgcGFyYW1zKTtcbiAgICB0aGlzLmhUID0gXCIwNFwiO1xufTtcbllBSE9PLmxhbmcuZXh0ZW5kKEtKVVIuYXNuMS5ERVJPY3RldFN0cmluZywgS0pVUi5hc24xLkRFUkFic3RyYWN0U3RyaW5nKTtcbi8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4vKipcbiAqIGNsYXNzIGZvciBBU04uMSBERVIgTnVsbFxuICogQG5hbWUgS0pVUi5hc24xLkRFUk51bGxcbiAqIEBjbGFzcyBjbGFzcyBmb3IgQVNOLjEgREVSIE51bGxcbiAqIEBleHRlbmRzIEtKVVIuYXNuMS5BU04xT2JqZWN0XG4gKiBAZGVzY3JpcHRpb25cbiAqIEBzZWUgS0pVUi5hc24xLkFTTjFPYmplY3QgLSBzdXBlcmNsYXNzXG4gKi9cbktKVVIuYXNuMS5ERVJOdWxsID0gZnVuY3Rpb24gKCkge1xuICAgIEtKVVIuYXNuMS5ERVJOdWxsLnN1cGVyY2xhc3MuY29uc3RydWN0b3IuY2FsbCh0aGlzKTtcbiAgICB0aGlzLmhUID0gXCIwNVwiO1xuICAgIHRoaXMuaFRMViA9IFwiMDUwMFwiO1xufTtcbllBSE9PLmxhbmcuZXh0ZW5kKEtKVVIuYXNuMS5ERVJOdWxsLCBLSlVSLmFzbjEuQVNOMU9iamVjdCk7XG4vLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuLyoqXG4gKiBjbGFzcyBmb3IgQVNOLjEgREVSIE9iamVjdElkZW50aWZpZXJcbiAqIEBuYW1lIEtKVVIuYXNuMS5ERVJPYmplY3RJZGVudGlmaWVyXG4gKiBAY2xhc3MgY2xhc3MgZm9yIEFTTi4xIERFUiBPYmplY3RJZGVudGlmaWVyXG4gKiBAcGFyYW0ge0FycmF5fSBwYXJhbXMgYXNzb2NpYXRpdmUgYXJyYXkgb2YgcGFyYW1ldGVycyAoZXguIHsnb2lkJzogJzIuNS40LjUnfSlcbiAqIEBleHRlbmRzIEtKVVIuYXNuMS5BU04xT2JqZWN0XG4gKiBAZGVzY3JpcHRpb25cbiAqIDxici8+XG4gKiBBcyBmb3IgYXJndW1lbnQgJ3BhcmFtcycgZm9yIGNvbnN0cnVjdG9yLCB5b3UgY2FuIHNwZWNpZnkgb25lIG9mXG4gKiBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqIDx1bD5cbiAqIDxsaT5vaWQgLSBzcGVjaWZ5IGluaXRpYWwgQVNOLjEgdmFsdWUoVikgYnkgYSBvaWQgc3RyaW5nIChleC4gMi41LjQuMTMpPC9saT5cbiAqIDxsaT5oZXggLSBzcGVjaWZ5IGluaXRpYWwgQVNOLjEgdmFsdWUoVikgYnkgYSBoZXhhZGVjaW1hbCBzdHJpbmc8L2xpPlxuICogPC91bD5cbiAqIE5PVEU6ICdwYXJhbXMnIGNhbiBiZSBvbWl0dGVkLlxuICovXG5LSlVSLmFzbjEuREVST2JqZWN0SWRlbnRpZmllciA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICB2YXIgaXRveCA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHZhciBoID0gaS50b1N0cmluZygxNik7XG4gICAgICAgIGlmIChoLmxlbmd0aCA9PSAxKVxuICAgICAgICAgICAgaCA9ICcwJyArIGg7XG4gICAgICAgIHJldHVybiBoO1xuICAgIH07XG4gICAgdmFyIHJvaWR0b3ggPSBmdW5jdGlvbiAocm9pZCkge1xuICAgICAgICB2YXIgaCA9ICcnO1xuICAgICAgICB2YXIgYmkgPSBuZXcgQmlnSW50ZWdlcihyb2lkLCAxMCk7XG4gICAgICAgIHZhciBiID0gYmkudG9TdHJpbmcoMik7XG4gICAgICAgIHZhciBwYWRMZW4gPSA3IC0gYi5sZW5ndGggJSA3O1xuICAgICAgICBpZiAocGFkTGVuID09IDcpXG4gICAgICAgICAgICBwYWRMZW4gPSAwO1xuICAgICAgICB2YXIgYlBhZCA9ICcnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhZExlbjsgaSsrKVxuICAgICAgICAgICAgYlBhZCArPSAnMCc7XG4gICAgICAgIGIgPSBiUGFkICsgYjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiLmxlbmd0aCAtIDE7IGkgKz0gNykge1xuICAgICAgICAgICAgdmFyIGI4ID0gYi5zdWJzdHIoaSwgNyk7XG4gICAgICAgICAgICBpZiAoaSAhPSBiLmxlbmd0aCAtIDcpXG4gICAgICAgICAgICAgICAgYjggPSAnMScgKyBiODtcbiAgICAgICAgICAgIGggKz0gaXRveChwYXJzZUludChiOCwgMikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoO1xuICAgIH07XG4gICAgS0pVUi5hc24xLkRFUk9iamVjdElkZW50aWZpZXIuc3VwZXJjbGFzcy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMpO1xuICAgIHRoaXMuaFQgPSBcIjA2XCI7XG4gICAgLyoqXG4gICAgICogc2V0IHZhbHVlIGJ5IGEgaGV4YWRlY2ltYWwgc3RyaW5nXG4gICAgICogQG5hbWUgc2V0VmFsdWVIZXhcbiAgICAgKiBAbWVtYmVyT2YgS0pVUi5hc24xLkRFUk9iamVjdElkZW50aWZpZXIjXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5ld0hleFN0cmluZyBoZXhhZGVjaW1hbCB2YWx1ZSBvZiBPSUQgYnl0ZXNcbiAgICAgKi9cbiAgICB0aGlzLnNldFZhbHVlSGV4ID0gZnVuY3Rpb24gKG5ld0hleFN0cmluZykge1xuICAgICAgICB0aGlzLmhUTFYgPSBudWxsO1xuICAgICAgICB0aGlzLmlzTW9kaWZpZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnMgPSBudWxsO1xuICAgICAgICB0aGlzLmhWID0gbmV3SGV4U3RyaW5nO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogc2V0IHZhbHVlIGJ5IGEgT0lEIHN0cmluZzxici8+XG4gICAgICogQG5hbWUgc2V0VmFsdWVPaWRTdHJpbmdcbiAgICAgKiBAbWVtYmVyT2YgS0pVUi5hc24xLkRFUk9iamVjdElkZW50aWZpZXIjXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9pZFN0cmluZyBPSUQgc3RyaW5nIChleC4gMi41LjQuMTMpXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBvID0gbmV3IEtKVVIuYXNuMS5ERVJPYmplY3RJZGVudGlmaWVyKCk7XG4gICAgICogby5zZXRWYWx1ZU9pZFN0cmluZyhcIjIuNS40LjEzXCIpO1xuICAgICAqL1xuICAgIHRoaXMuc2V0VmFsdWVPaWRTdHJpbmcgPSBmdW5jdGlvbiAob2lkU3RyaW5nKSB7XG4gICAgICAgIGlmICghb2lkU3RyaW5nLm1hdGNoKC9eWzAtOS5dKyQvKSkge1xuICAgICAgICAgICAgdGhyb3cgXCJtYWxmb3JtZWQgb2lkIHN0cmluZzogXCIgKyBvaWRTdHJpbmc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGggPSAnJztcbiAgICAgICAgdmFyIGEgPSBvaWRTdHJpbmcuc3BsaXQoJy4nKTtcbiAgICAgICAgdmFyIGkwID0gcGFyc2VJbnQoYVswXSkgKiA0MCArIHBhcnNlSW50KGFbMV0pO1xuICAgICAgICBoICs9IGl0b3goaTApO1xuICAgICAgICBhLnNwbGljZSgwLCAyKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBoICs9IHJvaWR0b3goYVtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oVExWID0gbnVsbDtcbiAgICAgICAgdGhpcy5pc01vZGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zID0gbnVsbDtcbiAgICAgICAgdGhpcy5oViA9IGg7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBzZXQgdmFsdWUgYnkgYSBPSUQgbmFtZVxuICAgICAqIEBuYW1lIHNldFZhbHVlTmFtZVxuICAgICAqIEBtZW1iZXJPZiBLSlVSLmFzbjEuREVST2JqZWN0SWRlbnRpZmllciNcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2lkTmFtZSBPSUQgbmFtZSAoZXguICdzZXJ2ZXJBdXRoJylcbiAgICAgKiBAc2luY2UgMS4wLjFcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBPSUQgbmFtZSBzaGFsbCBiZSBkZWZpbmVkIGluICdLSlVSLmFzbjEueDUwOS5PSUQubmFtZTJvaWRMaXN0Jy5cbiAgICAgKiBPdGhlcndpc2UgcmFpc2UgZXJyb3IuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBvID0gbmV3IEtKVVIuYXNuMS5ERVJPYmplY3RJZGVudGlmaWVyKCk7XG4gICAgICogby5zZXRWYWx1ZU5hbWUoXCJzZXJ2ZXJBdXRoXCIpO1xuICAgICAqL1xuICAgIHRoaXMuc2V0VmFsdWVOYW1lID0gZnVuY3Rpb24gKG9pZE5hbWUpIHtcbiAgICAgICAgdmFyIG9pZCA9IEtKVVIuYXNuMS54NTA5Lk9JRC5uYW1lMm9pZChvaWROYW1lKTtcbiAgICAgICAgaWYgKG9pZCAhPT0gJycpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0VmFsdWVPaWRTdHJpbmcob2lkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IFwiREVST2JqZWN0SWRlbnRpZmllciBvaWROYW1lIHVuZGVmaW5lZDogXCIgKyBvaWROYW1lO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmdldEZyZXNoVmFsdWVIZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhWO1xuICAgIH07XG4gICAgaWYgKHBhcmFtcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcGFyYW1zID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpZiAocGFyYW1zLm1hdGNoKC9eWzAtMl0uWzAtOS5dKyQvKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0VmFsdWVPaWRTdHJpbmcocGFyYW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0VmFsdWVOYW1lKHBhcmFtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGFyYW1zLm9pZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnNldFZhbHVlT2lkU3RyaW5nKHBhcmFtcy5vaWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBhcmFtcy5oZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZUhleChwYXJhbXMuaGV4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwYXJhbXMubmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnNldFZhbHVlTmFtZShwYXJhbXMubmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuWUFIT08ubGFuZy5leHRlbmQoS0pVUi5hc24xLkRFUk9iamVjdElkZW50aWZpZXIsIEtKVVIuYXNuMS5BU04xT2JqZWN0KTtcbi8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4vKipcbiAqIGNsYXNzIGZvciBBU04uMSBERVIgRW51bWVyYXRlZFxuICogQG5hbWUgS0pVUi5hc24xLkRFUkVudW1lcmF0ZWRcbiAqIEBjbGFzcyBjbGFzcyBmb3IgQVNOLjEgREVSIEVudW1lcmF0ZWRcbiAqIEBleHRlbmRzIEtKVVIuYXNuMS5BU04xT2JqZWN0XG4gKiBAZGVzY3JpcHRpb25cbiAqIDxici8+XG4gKiBBcyBmb3IgYXJndW1lbnQgJ3BhcmFtcycgZm9yIGNvbnN0cnVjdG9yLCB5b3UgY2FuIHNwZWNpZnkgb25lIG9mXG4gKiBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqIDx1bD5cbiAqIDxsaT5pbnQgLSBzcGVjaWZ5IGluaXRpYWwgQVNOLjEgdmFsdWUoVikgYnkgaW50ZWdlciB2YWx1ZTwvbGk+XG4gKiA8bGk+aGV4IC0gc3BlY2lmeSBpbml0aWFsIEFTTi4xIHZhbHVlKFYpIGJ5IGEgaGV4YWRlY2ltYWwgc3RyaW5nPC9saT5cbiAqIDwvdWw+XG4gKiBOT1RFOiAncGFyYW1zJyBjYW4gYmUgb21pdHRlZC5cbiAqIEBleGFtcGxlXG4gKiBuZXcgS0pVUi5hc24xLkRFUkVudW1lcmF0ZWQoMTIzKTtcbiAqIG5ldyBLSlVSLmFzbjEuREVSRW51bWVyYXRlZCh7aW50OiAxMjN9KTtcbiAqIG5ldyBLSlVSLmFzbjEuREVSRW51bWVyYXRlZCh7aGV4OiAnMWZhZCd9KTtcbiAqL1xuS0pVUi5hc24xLkRFUkVudW1lcmF0ZWQgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgS0pVUi5hc24xLkRFUkVudW1lcmF0ZWQuc3VwZXJjbGFzcy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMpO1xuICAgIHRoaXMuaFQgPSBcIjBhXCI7XG4gICAgLyoqXG4gICAgICogc2V0IHZhbHVlIGJ5IFRvbSBXdSdzIEJpZ0ludGVnZXIgb2JqZWN0XG4gICAgICogQG5hbWUgc2V0QnlCaWdJbnRlZ2VyXG4gICAgICogQG1lbWJlck9mIEtKVVIuYXNuMS5ERVJFbnVtZXJhdGVkI1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7QmlnSW50ZWdlcn0gYmlnSW50ZWdlclZhbHVlIHRvIHNldFxuICAgICAqL1xuICAgIHRoaXMuc2V0QnlCaWdJbnRlZ2VyID0gZnVuY3Rpb24gKGJpZ0ludGVnZXJWYWx1ZSkge1xuICAgICAgICB0aGlzLmhUTFYgPSBudWxsO1xuICAgICAgICB0aGlzLmlzTW9kaWZpZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmhWID0gS0pVUi5hc24xLkFTTjFVdGlsLmJpZ0ludFRvTWluVHdvc0NvbXBsZW1lbnRzSGV4KGJpZ0ludGVnZXJWYWx1ZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBzZXQgdmFsdWUgYnkgaW50ZWdlciB2YWx1ZVxuICAgICAqIEBuYW1lIHNldEJ5SW50ZWdlclxuICAgICAqIEBtZW1iZXJPZiBLSlVSLmFzbjEuREVSRW51bWVyYXRlZCNcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0ludGVnZXJ9IGludGVnZXIgdmFsdWUgdG8gc2V0XG4gICAgICovXG4gICAgdGhpcy5zZXRCeUludGVnZXIgPSBmdW5jdGlvbiAoaW50VmFsdWUpIHtcbiAgICAgICAgdmFyIGJpID0gbmV3IEJpZ0ludGVnZXIoU3RyaW5nKGludFZhbHVlKSwgMTApO1xuICAgICAgICB0aGlzLnNldEJ5QmlnSW50ZWdlcihiaSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBzZXQgdmFsdWUgYnkgaW50ZWdlciB2YWx1ZVxuICAgICAqIEBuYW1lIHNldFZhbHVlSGV4XG4gICAgICogQG1lbWJlck9mIEtKVVIuYXNuMS5ERVJFbnVtZXJhdGVkI1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBoZXhhZGVjaW1hbCBzdHJpbmcgb2YgaW50ZWdlciB2YWx1ZVxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIDxici8+XG4gICAgICogTk9URTogVmFsdWUgc2hhbGwgYmUgcmVwcmVzZW50ZWQgYnkgbWluaW11bSBvY3RldCBsZW5ndGggb2ZcbiAgICAgKiB0d28ncyBjb21wbGVtZW50IHJlcHJlc2VudGF0aW9uLlxuICAgICAqL1xuICAgIHRoaXMuc2V0VmFsdWVIZXggPSBmdW5jdGlvbiAobmV3SGV4U3RyaW5nKSB7XG4gICAgICAgIHRoaXMuaFYgPSBuZXdIZXhTdHJpbmc7XG4gICAgfTtcbiAgICB0aGlzLmdldEZyZXNoVmFsdWVIZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhWO1xuICAgIH07XG4gICAgaWYgKHR5cGVvZiBwYXJhbXMgIT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBpZiAodHlwZW9mIHBhcmFtc1snaW50J10gIT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgdGhpcy5zZXRCeUludGVnZXIocGFyYW1zWydpbnQnXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHBhcmFtcyA9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICB0aGlzLnNldEJ5SW50ZWdlcihwYXJhbXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBwYXJhbXNbJ2hleCddICE9IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0VmFsdWVIZXgocGFyYW1zWydoZXgnXSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuWUFIT08ubGFuZy5leHRlbmQoS0pVUi5hc24xLkRFUkVudW1lcmF0ZWQsIEtKVVIuYXNuMS5BU04xT2JqZWN0KTtcbi8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4vKipcbiAqIGNsYXNzIGZvciBBU04uMSBERVIgVVRGOFN0cmluZ1xuICogQG5hbWUgS0pVUi5hc24xLkRFUlVURjhTdHJpbmdcbiAqIEBjbGFzcyBjbGFzcyBmb3IgQVNOLjEgREVSIFVURjhTdHJpbmdcbiAqIEBwYXJhbSB7QXJyYXl9IHBhcmFtcyBhc3NvY2lhdGl2ZSBhcnJheSBvZiBwYXJhbWV0ZXJzIChleC4geydzdHInOiAnYWFhJ30pXG4gKiBAZXh0ZW5kcyBLSlVSLmFzbjEuREVSQWJzdHJhY3RTdHJpbmdcbiAqIEBkZXNjcmlwdGlvblxuICogQHNlZSBLSlVSLmFzbjEuREVSQWJzdHJhY3RTdHJpbmcgLSBzdXBlcmNsYXNzXG4gKi9cbktKVVIuYXNuMS5ERVJVVEY4U3RyaW5nID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgIEtKVVIuYXNuMS5ERVJVVEY4U3RyaW5nLnN1cGVyY2xhc3MuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBwYXJhbXMpO1xuICAgIHRoaXMuaFQgPSBcIjBjXCI7XG59O1xuWUFIT08ubGFuZy5leHRlbmQoS0pVUi5hc24xLkRFUlVURjhTdHJpbmcsIEtKVVIuYXNuMS5ERVJBYnN0cmFjdFN0cmluZyk7XG4vLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuLyoqXG4gKiBjbGFzcyBmb3IgQVNOLjEgREVSIE51bWVyaWNTdHJpbmdcbiAqIEBuYW1lIEtKVVIuYXNuMS5ERVJOdW1lcmljU3RyaW5nXG4gKiBAY2xhc3MgY2xhc3MgZm9yIEFTTi4xIERFUiBOdW1lcmljU3RyaW5nXG4gKiBAcGFyYW0ge0FycmF5fSBwYXJhbXMgYXNzb2NpYXRpdmUgYXJyYXkgb2YgcGFyYW1ldGVycyAoZXguIHsnc3RyJzogJ2FhYSd9KVxuICogQGV4dGVuZHMgS0pVUi5hc24xLkRFUkFic3RyYWN0U3RyaW5nXG4gKiBAZGVzY3JpcHRpb25cbiAqIEBzZWUgS0pVUi5hc24xLkRFUkFic3RyYWN0U3RyaW5nIC0gc3VwZXJjbGFzc1xuICovXG5LSlVSLmFzbjEuREVSTnVtZXJpY1N0cmluZyA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICBLSlVSLmFzbjEuREVSTnVtZXJpY1N0cmluZy5zdXBlcmNsYXNzLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgcGFyYW1zKTtcbiAgICB0aGlzLmhUID0gXCIxMlwiO1xufTtcbllBSE9PLmxhbmcuZXh0ZW5kKEtKVVIuYXNuMS5ERVJOdW1lcmljU3RyaW5nLCBLSlVSLmFzbjEuREVSQWJzdHJhY3RTdHJpbmcpO1xuLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbi8qKlxuICogY2xhc3MgZm9yIEFTTi4xIERFUiBQcmludGFibGVTdHJpbmdcbiAqIEBuYW1lIEtKVVIuYXNuMS5ERVJQcmludGFibGVTdHJpbmdcbiAqIEBjbGFzcyBjbGFzcyBmb3IgQVNOLjEgREVSIFByaW50YWJsZVN0cmluZ1xuICogQHBhcmFtIHtBcnJheX0gcGFyYW1zIGFzc29jaWF0aXZlIGFycmF5IG9mIHBhcmFtZXRlcnMgKGV4LiB7J3N0cic6ICdhYWEnfSlcbiAqIEBleHRlbmRzIEtKVVIuYXNuMS5ERVJBYnN0cmFjdFN0cmluZ1xuICogQGRlc2NyaXB0aW9uXG4gKiBAc2VlIEtKVVIuYXNuMS5ERVJBYnN0cmFjdFN0cmluZyAtIHN1cGVyY2xhc3NcbiAqL1xuS0pVUi5hc24xLkRFUlByaW50YWJsZVN0cmluZyA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICBLSlVSLmFzbjEuREVSUHJpbnRhYmxlU3RyaW5nLnN1cGVyY2xhc3MuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBwYXJhbXMpO1xuICAgIHRoaXMuaFQgPSBcIjEzXCI7XG59O1xuWUFIT08ubGFuZy5leHRlbmQoS0pVUi5hc24xLkRFUlByaW50YWJsZVN0cmluZywgS0pVUi5hc24xLkRFUkFic3RyYWN0U3RyaW5nKTtcbi8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4vKipcbiAqIGNsYXNzIGZvciBBU04uMSBERVIgVGVsZXRleFN0cmluZ1xuICogQG5hbWUgS0pVUi5hc24xLkRFUlRlbGV0ZXhTdHJpbmdcbiAqIEBjbGFzcyBjbGFzcyBmb3IgQVNOLjEgREVSIFRlbGV0ZXhTdHJpbmdcbiAqIEBwYXJhbSB7QXJyYXl9IHBhcmFtcyBhc3NvY2lhdGl2ZSBhcnJheSBvZiBwYXJhbWV0ZXJzIChleC4geydzdHInOiAnYWFhJ30pXG4gKiBAZXh0ZW5kcyBLSlVSLmFzbjEuREVSQWJzdHJhY3RTdHJpbmdcbiAqIEBkZXNjcmlwdGlvblxuICogQHNlZSBLSlVSLmFzbjEuREVSQWJzdHJhY3RTdHJpbmcgLSBzdXBlcmNsYXNzXG4gKi9cbktKVVIuYXNuMS5ERVJUZWxldGV4U3RyaW5nID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgIEtKVVIuYXNuMS5ERVJUZWxldGV4U3RyaW5nLnN1cGVyY2xhc3MuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBwYXJhbXMpO1xuICAgIHRoaXMuaFQgPSBcIjE0XCI7XG59O1xuWUFIT08ubGFuZy5leHRlbmQoS0pVUi5hc24xLkRFUlRlbGV0ZXhTdHJpbmcsIEtKVVIuYXNuMS5ERVJBYnN0cmFjdFN0cmluZyk7XG4vLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuLyoqXG4gKiBjbGFzcyBmb3IgQVNOLjEgREVSIElBNVN0cmluZ1xuICogQG5hbWUgS0pVUi5hc24xLkRFUklBNVN0cmluZ1xuICogQGNsYXNzIGNsYXNzIGZvciBBU04uMSBERVIgSUE1U3RyaW5nXG4gKiBAcGFyYW0ge0FycmF5fSBwYXJhbXMgYXNzb2NpYXRpdmUgYXJyYXkgb2YgcGFyYW1ldGVycyAoZXguIHsnc3RyJzogJ2FhYSd9KVxuICogQGV4dGVuZHMgS0pVUi5hc24xLkRFUkFic3RyYWN0U3RyaW5nXG4gKiBAZGVzY3JpcHRpb25cbiAqIEBzZWUgS0pVUi5hc24xLkRFUkFic3RyYWN0U3RyaW5nIC0gc3VwZXJjbGFzc1xuICovXG5LSlVSLmFzbjEuREVSSUE1U3RyaW5nID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgIEtKVVIuYXNuMS5ERVJJQTVTdHJpbmcuc3VwZXJjbGFzcy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIHBhcmFtcyk7XG4gICAgdGhpcy5oVCA9IFwiMTZcIjtcbn07XG5ZQUhPTy5sYW5nLmV4dGVuZChLSlVSLmFzbjEuREVSSUE1U3RyaW5nLCBLSlVSLmFzbjEuREVSQWJzdHJhY3RTdHJpbmcpO1xuLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbi8qKlxuICogY2xhc3MgZm9yIEFTTi4xIERFUiBVVENUaW1lXG4gKiBAbmFtZSBLSlVSLmFzbjEuREVSVVRDVGltZVxuICogQGNsYXNzIGNsYXNzIGZvciBBU04uMSBERVIgVVRDVGltZVxuICogQHBhcmFtIHtBcnJheX0gcGFyYW1zIGFzc29jaWF0aXZlIGFycmF5IG9mIHBhcmFtZXRlcnMgKGV4LiB7J3N0cic6ICcxMzA0MzAyMzU5NTlaJ30pXG4gKiBAZXh0ZW5kcyBLSlVSLmFzbjEuREVSQWJzdHJhY3RUaW1lXG4gKiBAZGVzY3JpcHRpb25cbiAqIDxici8+XG4gKiBBcyBmb3IgYXJndW1lbnQgJ3BhcmFtcycgZm9yIGNvbnN0cnVjdG9yLCB5b3UgY2FuIHNwZWNpZnkgb25lIG9mXG4gKiBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqIDx1bD5cbiAqIDxsaT5zdHIgLSBzcGVjaWZ5IGluaXRpYWwgQVNOLjEgdmFsdWUoVikgYnkgYSBzdHJpbmcgKGV4LicxMzA0MzAyMzU5NTlaJyk8L2xpPlxuICogPGxpPmhleCAtIHNwZWNpZnkgaW5pdGlhbCBBU04uMSB2YWx1ZShWKSBieSBhIGhleGFkZWNpbWFsIHN0cmluZzwvbGk+XG4gKiA8bGk+ZGF0ZSAtIHNwZWNpZnkgRGF0ZSBvYmplY3QuPC9saT5cbiAqIDwvdWw+XG4gKiBOT1RFOiAncGFyYW1zJyBjYW4gYmUgb21pdHRlZC5cbiAqIDxoND5FWEFNUExFUzwvaDQ+XG4gKiBAZXhhbXBsZVxuICogZDEgPSBuZXcgS0pVUi5hc24xLkRFUlVUQ1RpbWUoKTtcbiAqIGQxLnNldFN0cmluZygnMTMwNDMwMTI1OTU5WicpO1xuICpcbiAqIGQyID0gbmV3IEtKVVIuYXNuMS5ERVJVVENUaW1lKHsnc3RyJzogJzEzMDQzMDEyNTk1OVonfSk7XG4gKiBkMyA9IG5ldyBLSlVSLmFzbjEuREVSVVRDVGltZSh7J2RhdGUnOiBuZXcgRGF0ZShEYXRlLlVUQygyMDE1LCAwLCAzMSwgMCwgMCwgMCwgMCkpfSk7XG4gKiBkNCA9IG5ldyBLSlVSLmFzbjEuREVSVVRDVGltZSgnMTMwNDMwMTI1OTU5WicpO1xuICovXG5LSlVSLmFzbjEuREVSVVRDVGltZSA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICBLSlVSLmFzbjEuREVSVVRDVGltZS5zdXBlcmNsYXNzLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgcGFyYW1zKTtcbiAgICB0aGlzLmhUID0gXCIxN1wiO1xuICAgIC8qKlxuICAgICAqIHNldCB2YWx1ZSBieSBhIERhdGUgb2JqZWN0PGJyLz5cbiAgICAgKiBAbmFtZSBzZXRCeURhdGVcbiAgICAgKiBAbWVtYmVyT2YgS0pVUi5hc24xLkRFUlVUQ1RpbWUjXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtEYXRlfSBkYXRlT2JqZWN0IERhdGUgb2JqZWN0IHRvIHNldCBBU04uMSB2YWx1ZShWKVxuICAgICAqIEBleGFtcGxlXG4gICAgICogbyA9IG5ldyBLSlVSLmFzbjEuREVSVVRDVGltZSgpO1xuICAgICAqIG8uc2V0QnlEYXRlKG5ldyBEYXRlKFwiMjAxNi8xMi8zMVwiKSk7XG4gICAgICovXG4gICAgdGhpcy5zZXRCeURhdGUgPSBmdW5jdGlvbiAoZGF0ZU9iamVjdCkge1xuICAgICAgICB0aGlzLmhUTFYgPSBudWxsO1xuICAgICAgICB0aGlzLmlzTW9kaWZpZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmRhdGUgPSBkYXRlT2JqZWN0O1xuICAgICAgICB0aGlzLnMgPSB0aGlzLmZvcm1hdERhdGUodGhpcy5kYXRlLCAndXRjJyk7XG4gICAgICAgIHRoaXMuaFYgPSBzdG9oZXgodGhpcy5zKTtcbiAgICB9O1xuICAgIHRoaXMuZ2V0RnJlc2hWYWx1ZUhleCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmRhdGUgPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgdGhpcy5zID09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICB0aGlzLnMgPSB0aGlzLmZvcm1hdERhdGUodGhpcy5kYXRlLCAndXRjJyk7XG4gICAgICAgICAgICB0aGlzLmhWID0gc3RvaGV4KHRoaXMucyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaFY7XG4gICAgfTtcbiAgICBpZiAocGFyYW1zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHBhcmFtcy5zdHIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5zZXRTdHJpbmcocGFyYW1zLnN0cik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHBhcmFtcyA9PSBcInN0cmluZ1wiICYmIHBhcmFtcy5tYXRjaCgvXlswLTldezEyfVokLykpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RyaW5nKHBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGFyYW1zLmhleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0cmluZ0hleChwYXJhbXMuaGV4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwYXJhbXMuZGF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnNldEJ5RGF0ZShwYXJhbXMuZGF0ZSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuWUFIT08ubGFuZy5leHRlbmQoS0pVUi5hc24xLkRFUlVUQ1RpbWUsIEtKVVIuYXNuMS5ERVJBYnN0cmFjdFRpbWUpO1xuLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbi8qKlxuICogY2xhc3MgZm9yIEFTTi4xIERFUiBHZW5lcmFsaXplZFRpbWVcbiAqIEBuYW1lIEtKVVIuYXNuMS5ERVJHZW5lcmFsaXplZFRpbWVcbiAqIEBjbGFzcyBjbGFzcyBmb3IgQVNOLjEgREVSIEdlbmVyYWxpemVkVGltZVxuICogQHBhcmFtIHtBcnJheX0gcGFyYW1zIGFzc29jaWF0aXZlIGFycmF5IG9mIHBhcmFtZXRlcnMgKGV4LiB7J3N0cic6ICcyMDEzMDQzMDIzNTk1OVonfSlcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gd2l0aE1pbGxpcyBmbGFnIHRvIHNob3cgbWlsbGlzZWNvbmRzIG9yIG5vdFxuICogQGV4dGVuZHMgS0pVUi5hc24xLkRFUkFic3RyYWN0VGltZVxuICogQGRlc2NyaXB0aW9uXG4gKiA8YnIvPlxuICogQXMgZm9yIGFyZ3VtZW50ICdwYXJhbXMnIGZvciBjb25zdHJ1Y3RvciwgeW91IGNhbiBzcGVjaWZ5IG9uZSBvZlxuICogZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKiA8dWw+XG4gKiA8bGk+c3RyIC0gc3BlY2lmeSBpbml0aWFsIEFTTi4xIHZhbHVlKFYpIGJ5IGEgc3RyaW5nIChleC4nMjAxMzA0MzAyMzU5NTlaJyk8L2xpPlxuICogPGxpPmhleCAtIHNwZWNpZnkgaW5pdGlhbCBBU04uMSB2YWx1ZShWKSBieSBhIGhleGFkZWNpbWFsIHN0cmluZzwvbGk+XG4gKiA8bGk+ZGF0ZSAtIHNwZWNpZnkgRGF0ZSBvYmplY3QuPC9saT5cbiAqIDxsaT5taWxsaXMgLSBzcGVjaWZ5IGZsYWcgdG8gc2hvdyBtaWxsaXNlY29uZHMgKGZyb20gMS4wLjYpPC9saT5cbiAqIDwvdWw+XG4gKiBOT1RFMTogJ3BhcmFtcycgY2FuIGJlIG9taXR0ZWQuXG4gKiBOT1RFMjogJ3dpdGhNaWxsaXMnIHByb3BlcnR5IGlzIHN1cHBvcnRlZCBmcm9tIGFzbjEgMS4wLjYuXG4gKi9cbktKVVIuYXNuMS5ERVJHZW5lcmFsaXplZFRpbWUgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgS0pVUi5hc24xLkRFUkdlbmVyYWxpemVkVGltZS5zdXBlcmNsYXNzLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgcGFyYW1zKTtcbiAgICB0aGlzLmhUID0gXCIxOFwiO1xuICAgIHRoaXMud2l0aE1pbGxpcyA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIHNldCB2YWx1ZSBieSBhIERhdGUgb2JqZWN0XG4gICAgICogQG5hbWUgc2V0QnlEYXRlXG4gICAgICogQG1lbWJlck9mIEtKVVIuYXNuMS5ERVJHZW5lcmFsaXplZFRpbWUjXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtEYXRlfSBkYXRlT2JqZWN0IERhdGUgb2JqZWN0IHRvIHNldCBBU04uMSB2YWx1ZShWKVxuICAgICAqIEBleGFtcGxlXG4gICAgICogV2hlbiB5b3Ugc3BlY2lmeSBVVEMgdGltZSwgdXNlICdEYXRlLlVUQycgbWV0aG9kIGxpa2UgdGhpczo8YnIvPlxuICAgICAqIG8xID0gbmV3IERFUlVUQ1RpbWUoKTtcbiAgICAgKiBvMS5zZXRCeURhdGUoZGF0ZSk7XG4gICAgICpcbiAgICAgKiBkYXRlID0gbmV3IERhdGUoRGF0ZS5VVEMoMjAxNSwgMCwgMzEsIDIzLCA1OSwgNTksIDApKTsgIzIwMTVKQU4zMSAyMzo1OTo1OVxuICAgICAqL1xuICAgIHRoaXMuc2V0QnlEYXRlID0gZnVuY3Rpb24gKGRhdGVPYmplY3QpIHtcbiAgICAgICAgdGhpcy5oVExWID0gbnVsbDtcbiAgICAgICAgdGhpcy5pc01vZGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5kYXRlID0gZGF0ZU9iamVjdDtcbiAgICAgICAgdGhpcy5zID0gdGhpcy5mb3JtYXREYXRlKHRoaXMuZGF0ZSwgJ2dlbicsIHRoaXMud2l0aE1pbGxpcyk7XG4gICAgICAgIHRoaXMuaFYgPSBzdG9oZXgodGhpcy5zKTtcbiAgICB9O1xuICAgIHRoaXMuZ2V0RnJlc2hWYWx1ZUhleCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0ZSA9PT0gdW5kZWZpbmVkICYmIHRoaXMucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgdGhpcy5zID0gdGhpcy5mb3JtYXREYXRlKHRoaXMuZGF0ZSwgJ2dlbicsIHRoaXMud2l0aE1pbGxpcyk7XG4gICAgICAgICAgICB0aGlzLmhWID0gc3RvaGV4KHRoaXMucyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaFY7XG4gICAgfTtcbiAgICBpZiAocGFyYW1zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHBhcmFtcy5zdHIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5zZXRTdHJpbmcocGFyYW1zLnN0cik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHBhcmFtcyA9PSBcInN0cmluZ1wiICYmIHBhcmFtcy5tYXRjaCgvXlswLTldezE0fVokLykpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RyaW5nKHBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGFyYW1zLmhleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0cmluZ0hleChwYXJhbXMuaGV4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwYXJhbXMuZGF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnNldEJ5RGF0ZShwYXJhbXMuZGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmFtcy5taWxsaXMgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMud2l0aE1pbGxpcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG59O1xuWUFIT08ubGFuZy5leHRlbmQoS0pVUi5hc24xLkRFUkdlbmVyYWxpemVkVGltZSwgS0pVUi5hc24xLkRFUkFic3RyYWN0VGltZSk7XG4vLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuLyoqXG4gKiBjbGFzcyBmb3IgQVNOLjEgREVSIFNlcXVlbmNlXG4gKiBAbmFtZSBLSlVSLmFzbjEuREVSU2VxdWVuY2VcbiAqIEBjbGFzcyBjbGFzcyBmb3IgQVNOLjEgREVSIFNlcXVlbmNlXG4gKiBAZXh0ZW5kcyBLSlVSLmFzbjEuREVSQWJzdHJhY3RTdHJ1Y3R1cmVkXG4gKiBAZGVzY3JpcHRpb25cbiAqIDxici8+XG4gKiBBcyBmb3IgYXJndW1lbnQgJ3BhcmFtcycgZm9yIGNvbnN0cnVjdG9yLCB5b3UgY2FuIHNwZWNpZnkgb25lIG9mXG4gKiBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqIDx1bD5cbiAqIDxsaT5hcnJheSAtIHNwZWNpZnkgYXJyYXkgb2YgQVNOMU9iamVjdCB0byBzZXQgZWxlbWVudHMgb2YgY29udGVudDwvbGk+XG4gKiA8L3VsPlxuICogTk9URTogJ3BhcmFtcycgY2FuIGJlIG9taXR0ZWQuXG4gKi9cbktKVVIuYXNuMS5ERVJTZXF1ZW5jZSA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICBLSlVSLmFzbjEuREVSU2VxdWVuY2Uuc3VwZXJjbGFzcy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIHBhcmFtcyk7XG4gICAgdGhpcy5oVCA9IFwiMzBcIjtcbiAgICB0aGlzLmdldEZyZXNoVmFsdWVIZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBoID0gJyc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hc24xQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBhc24xT2JqID0gdGhpcy5hc24xQXJyYXlbaV07XG4gICAgICAgICAgICBoICs9IGFzbjFPYmouZ2V0RW5jb2RlZEhleCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaFYgPSBoO1xuICAgICAgICByZXR1cm4gdGhpcy5oVjtcbiAgICB9O1xufTtcbllBSE9PLmxhbmcuZXh0ZW5kKEtKVVIuYXNuMS5ERVJTZXF1ZW5jZSwgS0pVUi5hc24xLkRFUkFic3RyYWN0U3RydWN0dXJlZCk7XG4vLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuLyoqXG4gKiBjbGFzcyBmb3IgQVNOLjEgREVSIFNldFxuICogQG5hbWUgS0pVUi5hc24xLkRFUlNldFxuICogQGNsYXNzIGNsYXNzIGZvciBBU04uMSBERVIgU2V0XG4gKiBAZXh0ZW5kcyBLSlVSLmFzbjEuREVSQWJzdHJhY3RTdHJ1Y3R1cmVkXG4gKiBAZGVzY3JpcHRpb25cbiAqIDxici8+XG4gKiBBcyBmb3IgYXJndW1lbnQgJ3BhcmFtcycgZm9yIGNvbnN0cnVjdG9yLCB5b3UgY2FuIHNwZWNpZnkgb25lIG9mXG4gKiBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqIDx1bD5cbiAqIDxsaT5hcnJheSAtIHNwZWNpZnkgYXJyYXkgb2YgQVNOMU9iamVjdCB0byBzZXQgZWxlbWVudHMgb2YgY29udGVudDwvbGk+XG4gKiA8bGk+c29ydGZsYWcgLSBmbGFnIGZvciBzb3J0IChkZWZhdWx0OiB0cnVlKS4gQVNOLjEgQkVSIGlzIG5vdCBzb3J0ZWQgaW4gJ1NFVCBPRicuPC9saT5cbiAqIDwvdWw+XG4gKiBOT1RFMTogJ3BhcmFtcycgY2FuIGJlIG9taXR0ZWQuPGJyLz5cbiAqIE5PVEUyOiBzb3J0ZmxhZyBpcyBzdXBwb3J0ZWQgc2luY2UgMS4wLjUuXG4gKi9cbktKVVIuYXNuMS5ERVJTZXQgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgS0pVUi5hc24xLkRFUlNldC5zdXBlcmNsYXNzLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgcGFyYW1zKTtcbiAgICB0aGlzLmhUID0gXCIzMVwiO1xuICAgIHRoaXMuc29ydEZsYWcgPSB0cnVlOyAvLyBpdGVtIHNoYWxsIGJlIHNvcnRlZCBvbmx5IGluIEFTTi4xIERFUlxuICAgIHRoaXMuZ2V0RnJlc2hWYWx1ZUhleCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGEgPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmFzbjFBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGFzbjFPYmogPSB0aGlzLmFzbjFBcnJheVtpXTtcbiAgICAgICAgICAgIGEucHVzaChhc24xT2JqLmdldEVuY29kZWRIZXgoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc29ydEZsYWcgPT0gdHJ1ZSlcbiAgICAgICAgICAgIGEuc29ydCgpO1xuICAgICAgICB0aGlzLmhWID0gYS5qb2luKCcnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaFY7XG4gICAgfTtcbiAgICBpZiAodHlwZW9mIHBhcmFtcyAhPSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcGFyYW1zLnNvcnRmbGFnICE9IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgICAgIHBhcmFtcy5zb3J0ZmxhZyA9PSBmYWxzZSlcbiAgICAgICAgICAgIHRoaXMuc29ydEZsYWcgPSBmYWxzZTtcbiAgICB9XG59O1xuWUFIT08ubGFuZy5leHRlbmQoS0pVUi5hc24xLkRFUlNldCwgS0pVUi5hc24xLkRFUkFic3RyYWN0U3RydWN0dXJlZCk7XG4vLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuLyoqXG4gKiBjbGFzcyBmb3IgQVNOLjEgREVSIFRhZ2dlZE9iamVjdFxuICogQG5hbWUgS0pVUi5hc24xLkRFUlRhZ2dlZE9iamVjdFxuICogQGNsYXNzIGNsYXNzIGZvciBBU04uMSBERVIgVGFnZ2VkT2JqZWN0XG4gKiBAZXh0ZW5kcyBLSlVSLmFzbjEuQVNOMU9iamVjdFxuICogQGRlc2NyaXB0aW9uXG4gKiA8YnIvPlxuICogUGFyYW1ldGVyICd0YWdOb05leCcgaXMgQVNOLjEgdGFnKFQpIHZhbHVlIGZvciB0aGlzIG9iamVjdC5cbiAqIEZvciBleGFtcGxlLCBpZiB5b3UgZmluZCAnWzFdJyB0YWcgaW4gYSBBU04uMSBkdW1wLFxuICogJ3RhZ05vSGV4JyB3aWxsIGJlICdhMScuXG4gKiA8YnIvPlxuICogQXMgZm9yIG9wdGlvbmFsIGFyZ3VtZW50ICdwYXJhbXMnIGZvciBjb25zdHJ1Y3RvciwgeW91IGNhbiBzcGVjaWZ5ICpBTlkqIG9mXG4gKiBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqIDx1bD5cbiAqIDxsaT5leHBsaWNpdCAtIHNwZWNpZnkgdHJ1ZSBpZiB0aGlzIGlzIGV4cGxpY2l0IHRhZyBvdGhlcndpc2UgZmFsc2VcbiAqICAgICAoZGVmYXVsdCBpcyAndHJ1ZScpLjwvbGk+XG4gKiA8bGk+dGFnIC0gc3BlY2lmeSB0YWcgKGRlZmF1bHQgaXMgJ2EwJyB3aGljaCBtZWFucyBbMF0pPC9saT5cbiAqIDxsaT5vYmogLSBzcGVjaWZ5IEFTTjFPYmplY3Qgd2hpY2ggaXMgdGFnZ2VkPC9saT5cbiAqIDwvdWw+XG4gKiBAZXhhbXBsZVxuICogZDEgPSBuZXcgS0pVUi5hc24xLkRFUlVURjhTdHJpbmcoeydzdHInOidhJ30pO1xuICogZDIgPSBuZXcgS0pVUi5hc24xLkRFUlRhZ2dlZE9iamVjdCh7J29iaic6IGQxfSk7XG4gKiBoZXggPSBkMi5nZXRFbmNvZGVkSGV4KCk7XG4gKi9cbktKVVIuYXNuMS5ERVJUYWdnZWRPYmplY3QgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgS0pVUi5hc24xLkRFUlRhZ2dlZE9iamVjdC5zdXBlcmNsYXNzLmNvbnN0cnVjdG9yLmNhbGwodGhpcyk7XG4gICAgdGhpcy5oVCA9IFwiYTBcIjtcbiAgICB0aGlzLmhWID0gJyc7XG4gICAgdGhpcy5pc0V4cGxpY2l0ID0gdHJ1ZTtcbiAgICB0aGlzLmFzbjFPYmplY3QgPSBudWxsO1xuICAgIC8qKlxuICAgICAqIHNldCB2YWx1ZSBieSBhbiBBU04xT2JqZWN0XG4gICAgICogQG5hbWUgc2V0U3RyaW5nXG4gICAgICogQG1lbWJlck9mIEtKVVIuYXNuMS5ERVJUYWdnZWRPYmplY3QjXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBpc0V4cGxpY2l0RmxhZyBmbGFnIGZvciBleHBsaWNpdC9pbXBsaWNpdCB0YWdcbiAgICAgKiBAcGFyYW0ge0ludGVnZXJ9IHRhZ05vSGV4IGhleGFkZWNpbWFsIHN0cmluZyBvZiBBU04uMSB0YWdcbiAgICAgKiBAcGFyYW0ge0FTTjFPYmplY3R9IGFzbjFPYmplY3QgQVNOLjEgdG8gZW5jYXBzdWxhdGVcbiAgICAgKi9cbiAgICB0aGlzLnNldEFTTjFPYmplY3QgPSBmdW5jdGlvbiAoaXNFeHBsaWNpdEZsYWcsIHRhZ05vSGV4LCBhc24xT2JqZWN0KSB7XG4gICAgICAgIHRoaXMuaFQgPSB0YWdOb0hleDtcbiAgICAgICAgdGhpcy5pc0V4cGxpY2l0ID0gaXNFeHBsaWNpdEZsYWc7XG4gICAgICAgIHRoaXMuYXNuMU9iamVjdCA9IGFzbjFPYmplY3Q7XG4gICAgICAgIGlmICh0aGlzLmlzRXhwbGljaXQpIHtcbiAgICAgICAgICAgIHRoaXMuaFYgPSB0aGlzLmFzbjFPYmplY3QuZ2V0RW5jb2RlZEhleCgpO1xuICAgICAgICAgICAgdGhpcy5oVExWID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuaXNNb2RpZmllZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhWID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuaFRMViA9IGFzbjFPYmplY3QuZ2V0RW5jb2RlZEhleCgpO1xuICAgICAgICAgICAgdGhpcy5oVExWID0gdGhpcy5oVExWLnJlcGxhY2UoL14uLi8sIHRhZ05vSGV4KTtcbiAgICAgICAgICAgIHRoaXMuaXNNb2RpZmllZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmdldEZyZXNoVmFsdWVIZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhWO1xuICAgIH07XG4gICAgaWYgKHR5cGVvZiBwYXJhbXMgIT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBpZiAodHlwZW9mIHBhcmFtc1sndGFnJ10gIT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgdGhpcy5oVCA9IHBhcmFtc1sndGFnJ107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBwYXJhbXNbJ2V4cGxpY2l0J10gIT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgdGhpcy5pc0V4cGxpY2l0ID0gcGFyYW1zWydleHBsaWNpdCddO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcGFyYW1zWydvYmonXSAhPSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB0aGlzLmFzbjFPYmplY3QgPSBwYXJhbXNbJ29iaiddO1xuICAgICAgICAgICAgdGhpcy5zZXRBU04xT2JqZWN0KHRoaXMuaXNFeHBsaWNpdCwgdGhpcy5oVCwgdGhpcy5hc24xT2JqZWN0KTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5ZQUhPTy5sYW5nLmV4dGVuZChLSlVSLmFzbjEuREVSVGFnZ2VkT2JqZWN0LCBLSlVSLmFzbjEuQVNOMU9iamVjdCk7XG4iLCJ2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuaW1wb3J0IHsgaGV4MmI2NCB9IGZyb20gXCIuL2xpYi9qc2JuL2Jhc2U2NFwiO1xuaW1wb3J0IHsgSGV4IH0gZnJvbSBcIi4vbGliL2FzbjFqcy9oZXhcIjtcbmltcG9ydCB7IEJhc2U2NCB9IGZyb20gXCIuL2xpYi9hc24xanMvYmFzZTY0XCI7XG5pbXBvcnQgeyBBU04xIH0gZnJvbSBcIi4vbGliL2FzbjFqcy9hc24xXCI7XG5pbXBvcnQgeyBSU0FLZXkgfSBmcm9tIFwiLi9saWIvanNibi9yc2FcIjtcbmltcG9ydCB7IHBhcnNlQmlnSW50IH0gZnJvbSBcIi4vbGliL2pzYm4vanNiblwiO1xuaW1wb3J0IHsgS0pVUiB9IGZyb20gXCIuL2xpYi9qc3JzYXNpZ24vYXNuMS0xLjBcIjtcbi8qKlxuICogQ3JlYXRlIGEgbmV3IEpTRW5jcnlwdFJTQUtleSB0aGF0IGV4dGVuZHMgVG9tIFd1J3MgUlNBIGtleSBvYmplY3QuXG4gKiBUaGlzIG9iamVjdCBpcyBqdXN0IGEgZGVjb3JhdG9yIGZvciBwYXJzaW5nIHRoZSBrZXkgcGFyYW1ldGVyXG4gKiBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IGtleSAtIFRoZSBrZXkgaW4gc3RyaW5nIGZvcm1hdCwgb3IgYW4gb2JqZWN0IGNvbnRhaW5pbmdcbiAqIHRoZSBwYXJhbWV0ZXJzIG5lZWRlZCB0byBidWlsZCBhIFJTQUtleSBvYmplY3QuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIEpTRW5jcnlwdFJTQUtleSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSlNFbmNyeXB0UlNBS2V5LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEpTRW5jcnlwdFJTQUtleShrZXkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgLy8gQ2FsbCB0aGUgc3VwZXIgY29uc3RydWN0b3IuXG4gICAgICAgIC8vICBSU0FLZXkuY2FsbCh0aGlzKTtcbiAgICAgICAgLy8gSWYgYSBrZXkga2V5IHdhcyBwcm92aWRlZC5cbiAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyBhIHN0cmluZy4uLlxuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5wYXJzZUtleShrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoSlNFbmNyeXB0UlNBS2V5Lmhhc1ByaXZhdGVLZXlQcm9wZXJ0eShrZXkpIHx8XG4gICAgICAgICAgICAgICAgSlNFbmNyeXB0UlNBS2V5Lmhhc1B1YmxpY0tleVByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAvLyBTZXQgdGhlIHZhbHVlcyBmb3IgdGhlIGtleS5cbiAgICAgICAgICAgICAgICBfdGhpcy5wYXJzZVByb3BlcnRpZXNGcm9tKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdG8gcGFyc2UgYSBwZW0gZW5jb2RlZCBzdHJpbmcgY29udGFpbmluZyBib3RoIGEgcHVibGljIG9yIHByaXZhdGUga2V5LlxuICAgICAqIFRoZSBtZXRob2Qgd2lsbCB0cmFuc2xhdGUgdGhlIHBlbSBlbmNvZGVkIHN0cmluZyBpbiBhIGRlciBlbmNvZGVkIHN0cmluZyBhbmRcbiAgICAgKiB3aWxsIHBhcnNlIHByaXZhdGUga2V5IGFuZCBwdWJsaWMga2V5IHBhcmFtZXRlcnMuIFRoaXMgbWV0aG9kIGFjY2VwdHMgcHVibGljIGtleVxuICAgICAqIGluIHRoZSByc2FlbmNyeXB0aW9uIHBrY3MgIzEgZm9ybWF0IChvaWQ6IDEuMi44NDAuMTEzNTQ5LjEuMS4xKS5cbiAgICAgKlxuICAgICAqIEB0b2RvIENoZWNrIGhvdyBtYW55IHJzYSBmb3JtYXRzIHVzZSB0aGUgc2FtZSBmb3JtYXQgb2YgcGtjcyAjMS5cbiAgICAgKlxuICAgICAqIFRoZSBmb3JtYXQgaXMgZGVmaW5lZCBhczpcbiAgICAgKiBQdWJsaWNLZXlJbmZvIDo6PSBTRVFVRU5DRSB7XG4gICAgICogICBhbGdvcml0aG0gICAgICAgQWxnb3JpdGhtSWRlbnRpZmllcixcbiAgICAgKiAgIFB1YmxpY0tleSAgICAgICBCSVQgU1RSSU5HXG4gICAgICogfVxuICAgICAqIFdoZXJlIEFsZ29yaXRobUlkZW50aWZpZXIgaXM6XG4gICAgICogQWxnb3JpdGhtSWRlbnRpZmllciA6Oj0gU0VRVUVOQ0Uge1xuICAgICAqICAgYWxnb3JpdGhtICAgICAgIE9CSkVDVCBJREVOVElGSUVSLCAgICAgdGhlIE9JRCBvZiB0aGUgZW5jIGFsZ29yaXRobVxuICAgICAqICAgcGFyYW1ldGVycyAgICAgIEFOWSBERUZJTkVEIEJZIGFsZ29yaXRobSBPUFRJT05BTCAoTlVMTCBmb3IgUEtDUyAjMSlcbiAgICAgKiB9XG4gICAgICogYW5kIFB1YmxpY0tleSBpcyBhIFNFUVVFTkNFIGVuY2Fwc3VsYXRlZCBpbiBhIEJJVCBTVFJJTkdcbiAgICAgKiBSU0FQdWJsaWNLZXkgOjo9IFNFUVVFTkNFIHtcbiAgICAgKiAgIG1vZHVsdXMgICAgICAgICAgIElOVEVHRVIsICAtLSBuXG4gICAgICogICBwdWJsaWNFeHBvbmVudCAgICBJTlRFR0VSICAgLS0gZVxuICAgICAqIH1cbiAgICAgKiBpdCdzIHBvc3NpYmxlIHRvIGV4YW1pbmUgdGhlIHN0cnVjdHVyZSBvZiB0aGUga2V5cyBvYnRhaW5lZCBmcm9tIG9wZW5zc2wgdXNpbmdcbiAgICAgKiBhbiBhc24uMSBkdW1wZXIgYXMgdGhlIG9uZSB1c2VkIGhlcmUgdG8gcGFyc2UgdGhlIGNvbXBvbmVudHM6IGh0dHA6Ly9sYXBvLml0L2FzbjFqcy9cbiAgICAgKiBAYXJndW1lbnQge3N0cmluZ30gcGVtIHRoZSBwZW0gZW5jb2RlZCBzdHJpbmcsIGNhbiBpbmNsdWRlIHRoZSBCRUdJTi9FTkQgaGVhZGVyL2Zvb3RlclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgSlNFbmNyeXB0UlNBS2V5LnByb3RvdHlwZS5wYXJzZUtleSA9IGZ1bmN0aW9uIChwZW0pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBtb2R1bHVzID0gMDtcbiAgICAgICAgICAgIHZhciBwdWJsaWNfZXhwb25lbnQgPSAwO1xuICAgICAgICAgICAgdmFyIHJlSGV4ID0gL15cXHMqKD86WzAtOUEtRmEtZl1bMC05QS1GYS1mXVxccyopKyQvO1xuICAgICAgICAgICAgdmFyIGRlciA9IHJlSGV4LnRlc3QocGVtKSA/IEhleC5kZWNvZGUocGVtKSA6IEJhc2U2NC51bmFybW9yKHBlbSk7XG4gICAgICAgICAgICB2YXIgYXNuMSA9IEFTTjEuZGVjb2RlKGRlcik7XG4gICAgICAgICAgICAvLyBGaXhlcyBhIGJ1ZyB3aXRoIE9wZW5TU0wgMS4wKyBwcml2YXRlIGtleXNcbiAgICAgICAgICAgIGlmIChhc24xLnN1Yi5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgICAgICBhc24xID0gYXNuMS5zdWJbMl0uc3ViWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFzbjEuc3ViLmxlbmd0aCA9PT0gOSkge1xuICAgICAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBwcml2YXRlIGtleS5cbiAgICAgICAgICAgICAgICBtb2R1bHVzID0gYXNuMS5zdWJbMV0uZ2V0SGV4U3RyaW5nVmFsdWUoKTsgLy8gYmlnaW50XG4gICAgICAgICAgICAgICAgdGhpcy5uID0gcGFyc2VCaWdJbnQobW9kdWx1cywgMTYpO1xuICAgICAgICAgICAgICAgIHB1YmxpY19leHBvbmVudCA9IGFzbjEuc3ViWzJdLmdldEhleFN0cmluZ1ZhbHVlKCk7IC8vIGludFxuICAgICAgICAgICAgICAgIHRoaXMuZSA9IHBhcnNlSW50KHB1YmxpY19leHBvbmVudCwgMTYpO1xuICAgICAgICAgICAgICAgIHZhciBwcml2YXRlX2V4cG9uZW50ID0gYXNuMS5zdWJbM10uZ2V0SGV4U3RyaW5nVmFsdWUoKTsgLy8gYmlnaW50XG4gICAgICAgICAgICAgICAgdGhpcy5kID0gcGFyc2VCaWdJbnQocHJpdmF0ZV9leHBvbmVudCwgMTYpO1xuICAgICAgICAgICAgICAgIHZhciBwcmltZTEgPSBhc24xLnN1Yls0XS5nZXRIZXhTdHJpbmdWYWx1ZSgpOyAvLyBiaWdpbnRcbiAgICAgICAgICAgICAgICB0aGlzLnAgPSBwYXJzZUJpZ0ludChwcmltZTEsIDE2KTtcbiAgICAgICAgICAgICAgICB2YXIgcHJpbWUyID0gYXNuMS5zdWJbNV0uZ2V0SGV4U3RyaW5nVmFsdWUoKTsgLy8gYmlnaW50XG4gICAgICAgICAgICAgICAgdGhpcy5xID0gcGFyc2VCaWdJbnQocHJpbWUyLCAxNik7XG4gICAgICAgICAgICAgICAgdmFyIGV4cG9uZW50MSA9IGFzbjEuc3ViWzZdLmdldEhleFN0cmluZ1ZhbHVlKCk7IC8vIGJpZ2ludFxuICAgICAgICAgICAgICAgIHRoaXMuZG1wMSA9IHBhcnNlQmlnSW50KGV4cG9uZW50MSwgMTYpO1xuICAgICAgICAgICAgICAgIHZhciBleHBvbmVudDIgPSBhc24xLnN1Yls3XS5nZXRIZXhTdHJpbmdWYWx1ZSgpOyAvLyBiaWdpbnRcbiAgICAgICAgICAgICAgICB0aGlzLmRtcTEgPSBwYXJzZUJpZ0ludChleHBvbmVudDIsIDE2KTtcbiAgICAgICAgICAgICAgICB2YXIgY29lZmZpY2llbnQgPSBhc24xLnN1Yls4XS5nZXRIZXhTdHJpbmdWYWx1ZSgpOyAvLyBiaWdpbnRcbiAgICAgICAgICAgICAgICB0aGlzLmNvZWZmID0gcGFyc2VCaWdJbnQoY29lZmZpY2llbnQsIDE2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFzbjEuc3ViLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgIGlmIChhc24xLnN1YlswXS5zdWIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgQVNOLjEgU3ViamVjdFB1YmxpY0tleUluZm8gdHlwZSBhcyBkZWZpbmVkIGJ5IFguNTA5XG4gICAgICAgICAgICAgICAgICAgIHZhciBiaXRfc3RyaW5nID0gYXNuMS5zdWJbMV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZXF1ZW5jZSA9IGJpdF9zdHJpbmcuc3ViWzBdO1xuICAgICAgICAgICAgICAgICAgICBtb2R1bHVzID0gc2VxdWVuY2Uuc3ViWzBdLmdldEhleFN0cmluZ1ZhbHVlKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubiA9IHBhcnNlQmlnSW50KG1vZHVsdXMsIDE2KTtcbiAgICAgICAgICAgICAgICAgICAgcHVibGljX2V4cG9uZW50ID0gc2VxdWVuY2Uuc3ViWzFdLmdldEhleFN0cmluZ1ZhbHVlKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZSA9IHBhcnNlSW50KHB1YmxpY19leHBvbmVudCwgMTYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgQVNOLjEgUlNBUHVibGljS2V5IHR5cGUgYXMgZGVmaW5lZCBieSBQS0NTICMxXG4gICAgICAgICAgICAgICAgICAgIG1vZHVsdXMgPSBhc24xLnN1YlswXS5nZXRIZXhTdHJpbmdWYWx1ZSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm4gPSBwYXJzZUJpZ0ludChtb2R1bHVzLCAxNik7XG4gICAgICAgICAgICAgICAgICAgIHB1YmxpY19leHBvbmVudCA9IGFzbjEuc3ViWzFdLmdldEhleFN0cmluZ1ZhbHVlKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZSA9IHBhcnNlSW50KHB1YmxpY19leHBvbmVudCwgMTYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChleCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUcmFuc2xhdGUgcnNhIHBhcmFtZXRlcnMgaW4gYSBoZXggZW5jb2RlZCBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSByc2Ega2V5LlxuICAgICAqXG4gICAgICogVGhlIHRyYW5zbGF0aW9uIGZvbGxvdyB0aGUgQVNOLjEgbm90YXRpb24gOlxuICAgICAqIFJTQVByaXZhdGVLZXkgOjo9IFNFUVVFTkNFIHtcbiAgICAgKiAgIHZlcnNpb24gICAgICAgICAgIFZlcnNpb24sXG4gICAgICogICBtb2R1bHVzICAgICAgICAgICBJTlRFR0VSLCAgLS0gblxuICAgICAqICAgcHVibGljRXhwb25lbnQgICAgSU5URUdFUiwgIC0tIGVcbiAgICAgKiAgIHByaXZhdGVFeHBvbmVudCAgIElOVEVHRVIsICAtLSBkXG4gICAgICogICBwcmltZTEgICAgICAgICAgICBJTlRFR0VSLCAgLS0gcFxuICAgICAqICAgcHJpbWUyICAgICAgICAgICAgSU5URUdFUiwgIC0tIHFcbiAgICAgKiAgIGV4cG9uZW50MSAgICAgICAgIElOVEVHRVIsICAtLSBkIG1vZCAocDEpXG4gICAgICogICBleHBvbmVudDIgICAgICAgICBJTlRFR0VSLCAgLS0gZCBtb2QgKHEtMSlcbiAgICAgKiAgIGNvZWZmaWNpZW50ICAgICAgIElOVEVHRVIsICAtLSAoaW52ZXJzZSBvZiBxKSBtb2QgcFxuICAgICAqIH1cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSAgREVSIEVuY29kZWQgU3RyaW5nIHJlcHJlc2VudGluZyB0aGUgcnNhIHByaXZhdGUga2V5XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBKU0VuY3J5cHRSU0FLZXkucHJvdG90eXBlLmdldFByaXZhdGVCYXNlS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGFycmF5OiBbXG4gICAgICAgICAgICAgICAgbmV3IEtKVVIuYXNuMS5ERVJJbnRlZ2VyKHsgaW50OiAwIH0pLFxuICAgICAgICAgICAgICAgIG5ldyBLSlVSLmFzbjEuREVSSW50ZWdlcih7IGJpZ2ludDogdGhpcy5uIH0pLFxuICAgICAgICAgICAgICAgIG5ldyBLSlVSLmFzbjEuREVSSW50ZWdlcih7IGludDogdGhpcy5lIH0pLFxuICAgICAgICAgICAgICAgIG5ldyBLSlVSLmFzbjEuREVSSW50ZWdlcih7IGJpZ2ludDogdGhpcy5kIH0pLFxuICAgICAgICAgICAgICAgIG5ldyBLSlVSLmFzbjEuREVSSW50ZWdlcih7IGJpZ2ludDogdGhpcy5wIH0pLFxuICAgICAgICAgICAgICAgIG5ldyBLSlVSLmFzbjEuREVSSW50ZWdlcih7IGJpZ2ludDogdGhpcy5xIH0pLFxuICAgICAgICAgICAgICAgIG5ldyBLSlVSLmFzbjEuREVSSW50ZWdlcih7IGJpZ2ludDogdGhpcy5kbXAxIH0pLFxuICAgICAgICAgICAgICAgIG5ldyBLSlVSLmFzbjEuREVSSW50ZWdlcih7IGJpZ2ludDogdGhpcy5kbXExIH0pLFxuICAgICAgICAgICAgICAgIG5ldyBLSlVSLmFzbjEuREVSSW50ZWdlcih7IGJpZ2ludDogdGhpcy5jb2VmZiB9KSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH07XG4gICAgICAgIHZhciBzZXEgPSBuZXcgS0pVUi5hc24xLkRFUlNlcXVlbmNlKG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gc2VxLmdldEVuY29kZWRIZXgoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGJhc2U2NCAocGVtKSBlbmNvZGVkIHZlcnNpb24gb2YgdGhlIERFUiBlbmNvZGVkIHJlcHJlc2VudGF0aW9uXG4gICAgICogQHJldHVybnMge3N0cmluZ30gcGVtIGVuY29kZWQgcmVwcmVzZW50YXRpb24gd2l0aG91dCBoZWFkZXIgYW5kIGZvb3RlclxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBKU0VuY3J5cHRSU0FLZXkucHJvdG90eXBlLmdldFByaXZhdGVCYXNlS2V5QjY0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gaGV4MmI2NCh0aGlzLmdldFByaXZhdGVCYXNlS2V5KCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVHJhbnNsYXRlIHJzYSBwYXJhbWV0ZXJzIGluIGEgaGV4IGVuY29kZWQgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgcnNhIHB1YmxpYyBrZXkuXG4gICAgICogVGhlIHJlcHJlc2VudGF0aW9uIGZvbGxvdyB0aGUgQVNOLjEgbm90YXRpb24gOlxuICAgICAqIFB1YmxpY0tleUluZm8gOjo9IFNFUVVFTkNFIHtcbiAgICAgKiAgIGFsZ29yaXRobSAgICAgICBBbGdvcml0aG1JZGVudGlmaWVyLFxuICAgICAqICAgUHVibGljS2V5ICAgICAgIEJJVCBTVFJJTkdcbiAgICAgKiB9XG4gICAgICogV2hlcmUgQWxnb3JpdGhtSWRlbnRpZmllciBpczpcbiAgICAgKiBBbGdvcml0aG1JZGVudGlmaWVyIDo6PSBTRVFVRU5DRSB7XG4gICAgICogICBhbGdvcml0aG0gICAgICAgT0JKRUNUIElERU5USUZJRVIsICAgICB0aGUgT0lEIG9mIHRoZSBlbmMgYWxnb3JpdGhtXG4gICAgICogICBwYXJhbWV0ZXJzICAgICAgQU5ZIERFRklORUQgQlkgYWxnb3JpdGhtIE9QVElPTkFMIChOVUxMIGZvciBQS0NTICMxKVxuICAgICAqIH1cbiAgICAgKiBhbmQgUHVibGljS2V5IGlzIGEgU0VRVUVOQ0UgZW5jYXBzdWxhdGVkIGluIGEgQklUIFNUUklOR1xuICAgICAqIFJTQVB1YmxpY0tleSA6Oj0gU0VRVUVOQ0Uge1xuICAgICAqICAgbW9kdWx1cyAgICAgICAgICAgSU5URUdFUiwgIC0tIG5cbiAgICAgKiAgIHB1YmxpY0V4cG9uZW50ICAgIElOVEVHRVIgICAtLSBlXG4gICAgICogfVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IERFUiBFbmNvZGVkIFN0cmluZyByZXByZXNlbnRpbmcgdGhlIHJzYSBwdWJsaWMga2V5XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBKU0VuY3J5cHRSU0FLZXkucHJvdG90eXBlLmdldFB1YmxpY0Jhc2VLZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBmaXJzdF9zZXF1ZW5jZSA9IG5ldyBLSlVSLmFzbjEuREVSU2VxdWVuY2Uoe1xuICAgICAgICAgICAgYXJyYXk6IFtcbiAgICAgICAgICAgICAgICBuZXcgS0pVUi5hc24xLkRFUk9iamVjdElkZW50aWZpZXIoeyBvaWQ6IFwiMS4yLjg0MC4xMTM1NDkuMS4xLjFcIiB9KSxcbiAgICAgICAgICAgICAgICBuZXcgS0pVUi5hc24xLkRFUk51bGwoKSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgc2Vjb25kX3NlcXVlbmNlID0gbmV3IEtKVVIuYXNuMS5ERVJTZXF1ZW5jZSh7XG4gICAgICAgICAgICBhcnJheTogW1xuICAgICAgICAgICAgICAgIG5ldyBLSlVSLmFzbjEuREVSSW50ZWdlcih7IGJpZ2ludDogdGhpcy5uIH0pLFxuICAgICAgICAgICAgICAgIG5ldyBLSlVSLmFzbjEuREVSSW50ZWdlcih7IGludDogdGhpcy5lIH0pLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBiaXRfc3RyaW5nID0gbmV3IEtKVVIuYXNuMS5ERVJCaXRTdHJpbmcoe1xuICAgICAgICAgICAgaGV4OiBcIjAwXCIgKyBzZWNvbmRfc2VxdWVuY2UuZ2V0RW5jb2RlZEhleCgpLFxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHNlcSA9IG5ldyBLSlVSLmFzbjEuREVSU2VxdWVuY2Uoe1xuICAgICAgICAgICAgYXJyYXk6IFtmaXJzdF9zZXF1ZW5jZSwgYml0X3N0cmluZ10sXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc2VxLmdldEVuY29kZWRIZXgoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGJhc2U2NCAocGVtKSBlbmNvZGVkIHZlcnNpb24gb2YgdGhlIERFUiBlbmNvZGVkIHJlcHJlc2VudGF0aW9uXG4gICAgICogQHJldHVybnMge3N0cmluZ30gcGVtIGVuY29kZWQgcmVwcmVzZW50YXRpb24gd2l0aG91dCBoZWFkZXIgYW5kIGZvb3RlclxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBKU0VuY3J5cHRSU0FLZXkucHJvdG90eXBlLmdldFB1YmxpY0Jhc2VLZXlCNjQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBoZXgyYjY0KHRoaXMuZ2V0UHVibGljQmFzZUtleSgpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIHdyYXAgdGhlIHN0cmluZyBpbiBibG9jayBvZiB3aWR0aCBjaGFycy4gVGhlIGRlZmF1bHQgdmFsdWUgZm9yIHJzYSBrZXlzIGlzIDY0XG4gICAgICogY2hhcmFjdGVycy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIHRoZSBwZW0gZW5jb2RlZCBzdHJpbmcgd2l0aG91dCBoZWFkZXIgYW5kIGZvb3RlclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbd2lkdGg9NjRdIC0gdGhlIGxlbmd0aCB0aGUgc3RyaW5nIGhhcyB0byBiZSB3cmFwcGVkIGF0XG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIEpTRW5jcnlwdFJTQUtleS53b3Jkd3JhcCA9IGZ1bmN0aW9uIChzdHIsIHdpZHRoKSB7XG4gICAgICAgIHdpZHRoID0gd2lkdGggfHwgNjQ7XG4gICAgICAgIGlmICghc3RyKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZWdleCA9IFwiKC57MSxcIiArIHdpZHRoICsgXCJ9KSggK3wkXFxuPyl8KC57MSxcIiArIHdpZHRoICsgXCJ9KVwiO1xuICAgICAgICByZXR1cm4gc3RyLm1hdGNoKFJlZ0V4cChyZWdleCwgXCJnXCIpKS5qb2luKFwiXFxuXCIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgdGhlIHBlbSBlbmNvZGVkIHByaXZhdGUga2V5XG4gICAgICogQHJldHVybnMge3N0cmluZ30gdGhlIHBlbSBlbmNvZGVkIHByaXZhdGUga2V5IHdpdGggaGVhZGVyL2Zvb3RlclxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBKU0VuY3J5cHRSU0FLZXkucHJvdG90eXBlLmdldFByaXZhdGVLZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBrZXkgPSBcIi0tLS0tQkVHSU4gUlNBIFBSSVZBVEUgS0VZLS0tLS1cXG5cIjtcbiAgICAgICAga2V5ICs9IEpTRW5jcnlwdFJTQUtleS53b3Jkd3JhcCh0aGlzLmdldFByaXZhdGVCYXNlS2V5QjY0KCkpICsgXCJcXG5cIjtcbiAgICAgICAga2V5ICs9IFwiLS0tLS1FTkQgUlNBIFBSSVZBVEUgS0VZLS0tLS1cIjtcbiAgICAgICAgcmV0dXJuIGtleTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIHRoZSBwZW0gZW5jb2RlZCBwdWJsaWMga2V5XG4gICAgICogQHJldHVybnMge3N0cmluZ30gdGhlIHBlbSBlbmNvZGVkIHB1YmxpYyBrZXkgd2l0aCBoZWFkZXIvZm9vdGVyXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIEpTRW5jcnlwdFJTQUtleS5wcm90b3R5cGUuZ2V0UHVibGljS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIga2V5ID0gXCItLS0tLUJFR0lOIFBVQkxJQyBLRVktLS0tLVxcblwiO1xuICAgICAgICBrZXkgKz0gSlNFbmNyeXB0UlNBS2V5LndvcmR3cmFwKHRoaXMuZ2V0UHVibGljQmFzZUtleUI2NCgpKSArIFwiXFxuXCI7XG4gICAgICAgIGtleSArPSBcIi0tLS0tRU5EIFBVQkxJQyBLRVktLS0tLVwiO1xuICAgICAgICByZXR1cm4ga2V5O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhlIG9iamVjdCBjb250YWlucyB0aGUgbmVjZXNzYXJ5IHBhcmFtZXRlcnMgdG8gcG9wdWxhdGUgdGhlIHJzYSBtb2R1bHVzXG4gICAgICogYW5kIHB1YmxpYyBleHBvbmVudCBwYXJhbWV0ZXJzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqPXt9XSAtIEFuIG9iamVjdCB0aGF0IG1heSBjb250YWluIHRoZSB0d28gcHVibGljIGtleVxuICAgICAqIHBhcmFtZXRlcnNcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgb2JqZWN0IGNvbnRhaW5zIGJvdGggdGhlIG1vZHVsdXMgYW5kIHRoZSBwdWJsaWMgZXhwb25lbnRcbiAgICAgKiBwcm9wZXJ0aWVzIChuIGFuZCBlKVxuICAgICAqIEB0b2RvIGNoZWNrIGZvciB0eXBlcyBvZiBuIGFuZCBlLiBOIHNob3VsZCBiZSBhIHBhcnNlYWJsZSBiaWdJbnQgb2JqZWN0LCBFIHNob3VsZFxuICAgICAqIGJlIGEgcGFyc2VhYmxlIGludGVnZXIgbnVtYmVyXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBKU0VuY3J5cHRSU0FLZXkuaGFzUHVibGljS2V5UHJvcGVydHkgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIG9iaiA9IG9iaiB8fCB7fTtcbiAgICAgICAgcmV0dXJuIG9iai5oYXNPd25Qcm9wZXJ0eShcIm5cIikgJiYgb2JqLmhhc093blByb3BlcnR5KFwiZVwiKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZSBvYmplY3QgY29udGFpbnMgQUxMIHRoZSBwYXJhbWV0ZXJzIG9mIGFuIFJTQSBrZXkuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmo9e31dIC0gQW4gb2JqZWN0IHRoYXQgbWF5IGNvbnRhaW4gbmluZSByc2Ega2V5XG4gICAgICogcGFyYW1ldGVyc1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSBvYmplY3QgY29udGFpbnMgYWxsIHRoZSBwYXJhbWV0ZXJzIG5lZWRlZFxuICAgICAqIEB0b2RvIGNoZWNrIGZvciB0eXBlcyBvZiB0aGUgcGFyYW1ldGVycyBhbGwgdGhlIHBhcmFtZXRlcnMgYnV0IHRoZSBwdWJsaWMgZXhwb25lbnRcbiAgICAgKiBzaG91bGQgYmUgcGFyc2VhYmxlIGJpZ2ludCBvYmplY3RzLCB0aGUgcHVibGljIGV4cG9uZW50IHNob3VsZCBiZSBhIHBhcnNlYWJsZSBpbnRlZ2VyIG51bWJlclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgSlNFbmNyeXB0UlNBS2V5Lmhhc1ByaXZhdGVLZXlQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgb2JqID0gb2JqIHx8IHt9O1xuICAgICAgICByZXR1cm4gKG9iai5oYXNPd25Qcm9wZXJ0eShcIm5cIikgJiZcbiAgICAgICAgICAgIG9iai5oYXNPd25Qcm9wZXJ0eShcImVcIikgJiZcbiAgICAgICAgICAgIG9iai5oYXNPd25Qcm9wZXJ0eShcImRcIikgJiZcbiAgICAgICAgICAgIG9iai5oYXNPd25Qcm9wZXJ0eShcInBcIikgJiZcbiAgICAgICAgICAgIG9iai5oYXNPd25Qcm9wZXJ0eShcInFcIikgJiZcbiAgICAgICAgICAgIG9iai5oYXNPd25Qcm9wZXJ0eShcImRtcDFcIikgJiZcbiAgICAgICAgICAgIG9iai5oYXNPd25Qcm9wZXJ0eShcImRtcTFcIikgJiZcbiAgICAgICAgICAgIG9iai5oYXNPd25Qcm9wZXJ0eShcImNvZWZmXCIpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFBhcnNlIHRoZSBwcm9wZXJ0aWVzIG9mIG9iaiBpbiB0aGUgY3VycmVudCByc2Egb2JqZWN0LiBPYmogc2hvdWxkIEFUIExFQVNUXG4gICAgICogaW5jbHVkZSB0aGUgbW9kdWx1cyBhbmQgcHVibGljIGV4cG9uZW50IChuLCBlKSBwYXJhbWV0ZXJzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogLSB0aGUgb2JqZWN0IGNvbnRhaW5pbmcgcnNhIHBhcmFtZXRlcnNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIEpTRW5jcnlwdFJTQUtleS5wcm90b3R5cGUucGFyc2VQcm9wZXJ0aWVzRnJvbSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgdGhpcy5uID0gb2JqLm47XG4gICAgICAgIHRoaXMuZSA9IG9iai5lO1xuICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KFwiZFwiKSkge1xuICAgICAgICAgICAgdGhpcy5kID0gb2JqLmQ7XG4gICAgICAgICAgICB0aGlzLnAgPSBvYmoucDtcbiAgICAgICAgICAgIHRoaXMucSA9IG9iai5xO1xuICAgICAgICAgICAgdGhpcy5kbXAxID0gb2JqLmRtcDE7XG4gICAgICAgICAgICB0aGlzLmRtcTEgPSBvYmouZG1xMTtcbiAgICAgICAgICAgIHRoaXMuY29lZmYgPSBvYmouY29lZmY7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBKU0VuY3J5cHRSU0FLZXk7XG59KFJTQUtleSkpO1xuZXhwb3J0IHsgSlNFbmNyeXB0UlNBS2V5IH07XG4iLCJ2YXIgX2E7XG5pbXBvcnQgeyBiNjR0b2hleCwgaGV4MmI2NCB9IGZyb20gXCIuL2xpYi9qc2JuL2Jhc2U2NFwiO1xuaW1wb3J0IHsgSlNFbmNyeXB0UlNBS2V5IH0gZnJvbSBcIi4vSlNFbmNyeXB0UlNBS2V5XCI7XG52YXIgdmVyc2lvbiA9IHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJ1xuICAgID8gKF9hID0gcHJvY2Vzcy5lbnYpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5ucG1fcGFja2FnZV92ZXJzaW9uXG4gICAgOiB1bmRlZmluZWQ7XG4vKipcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMgPSB7fV0gLSBBbiBvYmplY3QgdG8gY3VzdG9taXplIEpTRW5jcnlwdCBiZWhhdmlvdXJcbiAqIHBvc3NpYmxlIHBhcmFtZXRlcnMgYXJlOlxuICogLSBkZWZhdWx0X2tleV9zaXplICAgICAgICB7bnVtYmVyfSAgZGVmYXVsdDogMTAyNCB0aGUga2V5IHNpemUgaW4gYml0XG4gKiAtIGRlZmF1bHRfcHVibGljX2V4cG9uZW50IHtzdHJpbmd9ICBkZWZhdWx0OiAnMDEwMDAxJyB0aGUgaGV4YWRlY2ltYWwgcmVwcmVzZW50YXRpb24gb2YgdGhlIHB1YmxpYyBleHBvbmVudFxuICogLSBsb2cgICAgICAgICAgICAgICAgICAgICB7Ym9vbGVhbn0gZGVmYXVsdDogZmFsc2Ugd2hldGhlciBsb2cgd2Fybi9lcnJvciBvciBub3RcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgSlNFbmNyeXB0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEpTRW5jcnlwdChvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICB0aGlzLmRlZmF1bHRfa2V5X3NpemUgPSBvcHRpb25zLmRlZmF1bHRfa2V5X3NpemVcbiAgICAgICAgICAgID8gcGFyc2VJbnQob3B0aW9ucy5kZWZhdWx0X2tleV9zaXplLCAxMClcbiAgICAgICAgICAgIDogMTAyNDtcbiAgICAgICAgdGhpcy5kZWZhdWx0X3B1YmxpY19leHBvbmVudCA9IG9wdGlvbnMuZGVmYXVsdF9wdWJsaWNfZXhwb25lbnQgfHwgXCIwMTAwMDFcIjsgLy8gNjU1MzcgZGVmYXVsdCBvcGVuc3NsIHB1YmxpYyBleHBvbmVudCBmb3IgcnNhIGtleSB0eXBlXG4gICAgICAgIHRoaXMubG9nID0gb3B0aW9ucy5sb2cgfHwgZmFsc2U7XG4gICAgICAgIC8vIFRoZSBwcml2YXRlIGFuZCBwdWJsaWMga2V5LlxuICAgICAgICB0aGlzLmtleSA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB0byBzZXQgdGhlIHJzYSBrZXkgcGFyYW1ldGVyIChvbmUgbWV0aG9kIGlzIGVub3VnaCB0byBzZXQgYm90aCB0aGUgcHVibGljXG4gICAgICogYW5kIHRoZSBwcml2YXRlIGtleSwgc2luY2UgdGhlIHByaXZhdGUga2V5IGNvbnRhaW5zIHRoZSBwdWJsaWMga2V5IHBhcmFtZW50ZXJzKVxuICAgICAqIExvZyBhIHdhcm5pbmcgaWYgbG9ncyBhcmUgZW5hYmxlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fHN0cmluZ30ga2V5IHRoZSBwZW0gZW5jb2RlZCBzdHJpbmcgb3IgYW4gb2JqZWN0ICh3aXRoIG9yIHdpdGhvdXQgaGVhZGVyL2Zvb3RlcilcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgSlNFbmNyeXB0LnByb3RvdHlwZS5zZXRLZXkgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmICh0aGlzLmxvZyAmJiB0aGlzLmtleSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiQSBrZXkgd2FzIGFscmVhZHkgc2V0LCBvdmVycmlkaW5nIGV4aXN0aW5nLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmtleSA9IG5ldyBKU0VuY3J5cHRSU0FLZXkoa2V5KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFByb3h5IG1ldGhvZCBmb3Igc2V0S2V5LCBmb3IgYXBpIGNvbXBhdGliaWxpdHlcbiAgICAgKiBAc2VlIHNldEtleVxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBKU0VuY3J5cHQucHJvdG90eXBlLnNldFByaXZhdGVLZXkgPSBmdW5jdGlvbiAocHJpdmtleSkge1xuICAgICAgICAvLyBDcmVhdGUgdGhlIGtleS5cbiAgICAgICAgdGhpcy5zZXRLZXkocHJpdmtleSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQcm94eSBtZXRob2QgZm9yIHNldEtleSwgZm9yIGFwaSBjb21wYXRpYmlsaXR5XG4gICAgICogQHNlZSBzZXRLZXlcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgSlNFbmNyeXB0LnByb3RvdHlwZS5zZXRQdWJsaWNLZXkgPSBmdW5jdGlvbiAocHVia2V5KSB7XG4gICAgICAgIC8vIFNldHMgdGhlIHB1YmxpYyBrZXkuXG4gICAgICAgIHRoaXMuc2V0S2V5KHB1YmtleSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQcm94eSBtZXRob2QgZm9yIFJTQUtleSBvYmplY3QncyBkZWNyeXB0LCBkZWNyeXB0IHRoZSBzdHJpbmcgdXNpbmcgdGhlIHByaXZhdGVcbiAgICAgKiBjb21wb25lbnRzIG9mIHRoZSByc2Ega2V5IG9iamVjdC4gTm90ZSB0aGF0IGlmIHRoZSBvYmplY3Qgd2FzIG5vdCBzZXQgd2lsbCBiZSBjcmVhdGVkXG4gICAgICogb24gdGhlIGZseSAoYnkgdGhlIGdldEtleSBtZXRob2QpIHVzaW5nIHRoZSBwYXJhbWV0ZXJzIHBhc3NlZCBpbiB0aGUgSlNFbmNyeXB0IGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBiYXNlNjQgZW5jb2RlZCBjcnlwdGVkIHN0cmluZyB0byBkZWNyeXB0XG4gICAgICogQHJldHVybiB7c3RyaW5nfSB0aGUgZGVjcnlwdGVkIHN0cmluZ1xuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBKU0VuY3J5cHQucHJvdG90eXBlLmRlY3J5cHQgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIC8vIFJldHVybiB0aGUgZGVjcnlwdGVkIHN0cmluZy5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEtleSgpLmRlY3J5cHQoYjY0dG9oZXgoc3RyKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFByb3h5IG1ldGhvZCBmb3IgUlNBS2V5IG9iamVjdCdzIGVuY3J5cHQsIGVuY3J5cHQgdGhlIHN0cmluZyB1c2luZyB0aGUgcHVibGljXG4gICAgICogY29tcG9uZW50cyBvZiB0aGUgcnNhIGtleSBvYmplY3QuIE5vdGUgdGhhdCBpZiB0aGUgb2JqZWN0IHdhcyBub3Qgc2V0IHdpbGwgYmUgY3JlYXRlZFxuICAgICAqIG9uIHRoZSBmbHkgKGJ5IHRoZSBnZXRLZXkgbWV0aG9kKSB1c2luZyB0aGUgcGFyYW1ldGVycyBwYXNzZWQgaW4gdGhlIEpTRW5jcnlwdCBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgdGhlIHN0cmluZyB0byBlbmNyeXB0XG4gICAgICogQHJldHVybiB7c3RyaW5nfSB0aGUgZW5jcnlwdGVkIHN0cmluZyBlbmNvZGVkIGluIGJhc2U2NFxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBKU0VuY3J5cHQucHJvdG90eXBlLmVuY3J5cHQgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIC8vIFJldHVybiB0aGUgZW5jcnlwdGVkIHN0cmluZy5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBoZXgyYjY0KHRoaXMuZ2V0S2V5KCkuZW5jcnlwdChzdHIpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUHJveHkgbWV0aG9kIGZvciBSU0FLZXkgb2JqZWN0J3Mgc2lnbi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIHRoZSBzdHJpbmcgdG8gc2lnblxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGRpZ2VzdE1ldGhvZCBoYXNoIG1ldGhvZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkaWdlc3ROYW1lIHRoZSBuYW1lIG9mIHRoZSBoYXNoIGFsZ29yaXRobVxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gdGhlIHNpZ25hdHVyZSBlbmNvZGVkIGluIGJhc2U2NFxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBKU0VuY3J5cHQucHJvdG90eXBlLnNpZ24gPSBmdW5jdGlvbiAoc3RyLCBkaWdlc3RNZXRob2QsIGRpZ2VzdE5hbWUpIHtcbiAgICAgICAgLy8gcmV0dXJuIHRoZSBSU0Egc2lnbmF0dXJlIG9mICdzdHInIGluICdoZXgnIGZvcm1hdC5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBoZXgyYjY0KHRoaXMuZ2V0S2V5KCkuc2lnbihzdHIsIGRpZ2VzdE1ldGhvZCwgZGlnZXN0TmFtZSkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChleCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQcm94eSBtZXRob2QgZm9yIFJTQUtleSBvYmplY3QncyB2ZXJpZnkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciB0aGUgc3RyaW5nIHRvIHZlcmlmeVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzaWduYXR1cmUgdGhlIHNpZ25hdHVyZSBlbmNvZGVkIGluIGJhc2U2NCB0byBjb21wYXJlIHRoZSBzdHJpbmcgdG9cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBkaWdlc3RNZXRob2QgaGFzaCBtZXRob2RcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSB3aGV0aGVyIHRoZSBkYXRhIGFuZCBzaWduYXR1cmUgbWF0Y2hcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgSlNFbmNyeXB0LnByb3RvdHlwZS52ZXJpZnkgPSBmdW5jdGlvbiAoc3RyLCBzaWduYXR1cmUsIGRpZ2VzdE1ldGhvZCkge1xuICAgICAgICAvLyBSZXR1cm4gdGhlIGRlY3J5cHRlZCAnZGlnZXN0JyBvZiB0aGUgc2lnbmF0dXJlLlxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0S2V5KCkudmVyaWZ5KHN0ciwgYjY0dG9oZXgoc2lnbmF0dXJlKSwgZGlnZXN0TWV0aG9kKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0dGVyIGZvciB0aGUgY3VycmVudCBKU0VuY3J5cHRSU0FLZXkgb2JqZWN0LiBJZiBpdCBkb2Vzbid0IGV4aXN0cyBhIG5ldyBvYmplY3RcbiAgICAgKiB3aWxsIGJlIGNyZWF0ZWQgYW5kIHJldHVybmVkXG4gICAgICogQHBhcmFtIHtjYWxsYmFja30gW2NiXSB0aGUgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIGlmIHdlIHdhbnQgdGhlIGtleSB0byBiZSBnZW5lcmF0ZWRcbiAgICAgKiBpbiBhbiBhc3luYyBmYXNoaW9uXG4gICAgICogQHJldHVybnMge0pTRW5jcnlwdFJTQUtleX0gdGhlIEpTRW5jcnlwdFJTQUtleSBvYmplY3RcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgSlNFbmNyeXB0LnByb3RvdHlwZS5nZXRLZXkgPSBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgLy8gT25seSBjcmVhdGUgbmV3IGlmIGl0IGRvZXMgbm90IGV4aXN0LlxuICAgICAgICBpZiAoIXRoaXMua2V5KSB7XG4gICAgICAgICAgICAvLyBHZXQgYSBuZXcgcHJpdmF0ZSBrZXkuXG4gICAgICAgICAgICB0aGlzLmtleSA9IG5ldyBKU0VuY3J5cHRSU0FLZXkoKTtcbiAgICAgICAgICAgIGlmIChjYiAmJiB7fS50b1N0cmluZy5jYWxsKGNiKSA9PT0gXCJbb2JqZWN0IEZ1bmN0aW9uXVwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5rZXkuZ2VuZXJhdGVBc3luYyh0aGlzLmRlZmF1bHRfa2V5X3NpemUsIHRoaXMuZGVmYXVsdF9wdWJsaWNfZXhwb25lbnQsIGNiKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBHZW5lcmF0ZSB0aGUga2V5LlxuICAgICAgICAgICAgdGhpcy5rZXkuZ2VuZXJhdGUodGhpcy5kZWZhdWx0X2tleV9zaXplLCB0aGlzLmRlZmF1bHRfcHVibGljX2V4cG9uZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5rZXk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwZW0gZW5jb2RlZCByZXByZXNlbnRhdGlvbiBvZiB0aGUgcHJpdmF0ZSBrZXlcbiAgICAgKiBJZiB0aGUga2V5IGRvZXNuJ3QgZXhpc3RzIGEgbmV3IGtleSB3aWxsIGJlIGNyZWF0ZWRcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBwZW0gZW5jb2RlZCByZXByZXNlbnRhdGlvbiBvZiB0aGUgcHJpdmF0ZSBrZXkgV0lUSCBoZWFkZXIgYW5kIGZvb3RlclxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBKU0VuY3J5cHQucHJvdG90eXBlLmdldFByaXZhdGVLZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFJldHVybiB0aGUgcHJpdmF0ZSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGtleS5cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0S2V5KCkuZ2V0UHJpdmF0ZUtleSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcGVtIGVuY29kZWQgcmVwcmVzZW50YXRpb24gb2YgdGhlIHByaXZhdGUga2V5XG4gICAgICogSWYgdGhlIGtleSBkb2Vzbid0IGV4aXN0cyBhIG5ldyBrZXkgd2lsbCBiZSBjcmVhdGVkXG4gICAgICogQHJldHVybnMge3N0cmluZ30gcGVtIGVuY29kZWQgcmVwcmVzZW50YXRpb24gb2YgdGhlIHByaXZhdGUga2V5IFdJVEhPVVQgaGVhZGVyIGFuZCBmb290ZXJcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgSlNFbmNyeXB0LnByb3RvdHlwZS5nZXRQcml2YXRlS2V5QjY0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBSZXR1cm4gdGhlIHByaXZhdGUgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBrZXkuXG4gICAgICAgIHJldHVybiB0aGlzLmdldEtleSgpLmdldFByaXZhdGVCYXNlS2V5QjY0KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwZW0gZW5jb2RlZCByZXByZXNlbnRhdGlvbiBvZiB0aGUgcHVibGljIGtleVxuICAgICAqIElmIHRoZSBrZXkgZG9lc24ndCBleGlzdHMgYSBuZXcga2V5IHdpbGwgYmUgY3JlYXRlZFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IHBlbSBlbmNvZGVkIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwdWJsaWMga2V5IFdJVEggaGVhZGVyIGFuZCBmb290ZXJcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgSlNFbmNyeXB0LnByb3RvdHlwZS5nZXRQdWJsaWNLZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFJldHVybiB0aGUgcHJpdmF0ZSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGtleS5cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0S2V5KCkuZ2V0UHVibGljS2V5KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwZW0gZW5jb2RlZCByZXByZXNlbnRhdGlvbiBvZiB0aGUgcHVibGljIGtleVxuICAgICAqIElmIHRoZSBrZXkgZG9lc24ndCBleGlzdHMgYSBuZXcga2V5IHdpbGwgYmUgY3JlYXRlZFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IHBlbSBlbmNvZGVkIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwdWJsaWMga2V5IFdJVEhPVVQgaGVhZGVyIGFuZCBmb290ZXJcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgSlNFbmNyeXB0LnByb3RvdHlwZS5nZXRQdWJsaWNLZXlCNjQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFJldHVybiB0aGUgcHJpdmF0ZSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGtleS5cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0S2V5KCkuZ2V0UHVibGljQmFzZUtleUI2NCgpO1xuICAgIH07XG4gICAgSlNFbmNyeXB0LnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIHJldHVybiBKU0VuY3J5cHQ7XG59KCkpO1xuZXhwb3J0IHsgSlNFbmNyeXB0IH07XG4iLCJpbXBvcnQgeyBKU0VuY3J5cHQgfSBmcm9tICcuL0pTRW5jcnlwdCc7XG5leHBvcnQgeyBKU0VuY3J5cHQgfTtcbmV4cG9ydCBkZWZhdWx0IEpTRW5jcnlwdDtcbiIsImltcG9ydCB7IEpTRW5jcnlwdCB9IGZyb20gJ2pzZW5jcnlwdCc7XG5pbXBvcnQgeyBwYXJzZUJpZ0ludCB9IGZyb20gJ2pzZW5jcnlwdC9saWIvbGliL2pzYm4vanNibic7XG5pbXBvcnQgeyBpc0V4dGVuc2lvbiB9IGZyb20gJy4vZ2xvYmFscyc7XG5pbXBvcnQgeyBlcnJvciB9IGZyb20gJy4vbG9nJztcbmV4cG9ydCBjbGFzcyBSU0FFbmNyeXB0IHtcbiAgICBjb25zdHJ1Y3Rvcihtb2R1bHVzLCBleHBvbmVudCkge1xuICAgICAgICBpZiAoaXNFeHRlbnNpb24oKSkge1xuICAgICAgICAgICAgdGhpcy5lbmNyeXB0b3IgPSBuZXcgSlNFbmNyeXB0KHsgbG9nOiB0cnVlIH0pO1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5lbmNyeXB0b3IuZ2V0S2V5KCk7XG4gICAgICAgICAgICBjb25zdCBuID0gcGFyc2VCaWdJbnQobW9kdWx1cywgMTYpO1xuICAgICAgICAgICAgY29uc3QgZSA9IHBhcnNlSW50KGV4cG9uZW50LCAxNik7XG4gICAgICAgICAgICBrZXkucGFyc2VQcm9wZXJ0aWVzRnJvbSh7IG4sIGUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBuZXcgUlNBS2V5KCk7XG4gICAgICAgICAgICBrZXkuc2V0UHVibGljKG1vZHVsdXMsIGV4cG9uZW50KTtcbiAgICAgICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVuY3J5cHQoZGF0YSkge1xuICAgICAgICBpZiAoaXNFeHRlbnNpb24oKSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNyeXB0b3IuZ2V0S2V5KCkuZW5jcnlwdChkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IoYEZhaWxlZCB0byBlbmNyeXB0ICR7ZGF0YS5sZW5ndGh9IGNoYXJhY3RlcnNgLCBlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmtleS5lbmNyeXB0KGRhdGEpO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgaXNFeHRlbnNpb24gfSBmcm9tICcuL2dsb2JhbHMnO1xuaW1wb3J0IHsgZ2V0UmVzcG9uc2VCb2R5IH0gZnJvbSAnLi9odHRwJztcbmltcG9ydCB7IGVycm9yLCBsb2cgfSBmcm9tICcuL2xvZyc7XG5pbXBvcnQgeyBnZXRTZXJ2ZXJJbmZvUlRDIH0gZnJvbSAnLi9vZmZuZXR3b3JrJztcbmltcG9ydCB7IGdldFNlcnZlcklkRm9yUHJpbnRlciwgZ2V0U2VydmVySWRUb1NlcnZlckluZm9DYWNoZSB9IGZyb20gJy4vb2ZmbmV0d29yay9vZmZuZXR3b3JrY2FjaGUnO1xuaW1wb3J0IHsgZ2V0VXJsQmFzZU9mUHJpbnRlclVybCB9IGZyb20gJy4vcHJpbnRlcic7XG5pbXBvcnQgeyBSU0FFbmNyeXB0IH0gZnJvbSAnLi9yc2EnO1xuY29uc3QgR29vZ2xlVXNlckluZm9VUkwgPSAnaHR0cHM6Ly93d3cuZ29vZ2xlYXBpcy5jb20vb2F1dGgyL3YyL3VzZXJpbmZvJztcbmNvbnN0IEdTdWl0ZVRva2VuUmV2b2tlVXJsID0gJ2h0dHBzOi8vYWNjb3VudHMuZ29vZ2xlLmNvbS9vL29hdXRoMi9yZXZva2UnO1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGF1dGhlbnRpY2F0ZVdpdGhHU3VpdGVIVFRQKHNlcnZlckJhc2VVUkwsIGlzSW50ZXJhY3RpdmUpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoW2dldFJzYVB1YmxpY0tleShzZXJ2ZXJCYXNlVVJMKSwgZ2V0R29vZ2xlQXV0aEluZm8oaXNJbnRlcmFjdGl2ZSldKVxuICAgICAgICAudGhlbigoW3JzYUtleSwgYXV0aEluZm9dKSA9PiB7XG4gICAgICAgIHJldHVybiBlbmNyeXB0Q3JlZGVudGlhbHNXaXRoS2V5KGAke2F1dGhJbmZvLmVtYWlsfWAsIGAke2F1dGhJbmZvLnRva2VufWAsIHJzYUtleSk7XG4gICAgfSk7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYXV0aGVudGljYXRlV2l0aEdTdWl0ZShwcmludEpvYiwgaXNJbnRlcmFjdGl2ZSwgZW5jcnlwdEZvck1vYmlsaXR5ID0gdHJ1ZSkge1xuICAgIGxvZyhgQXV0aGVudGljYXRpbmcgd2l0aCBHLVN1aXRlOiBcblx0XHRwcmludEpvYklkPSR7cHJpbnRKb2IucHJpbnRlcklkfSwgaXNJbnRlcmFjdGl2ZT0ke2lzSW50ZXJhY3RpdmV9LCBlbmNyeXB0Rm9yTW9iaWxpdHk9JHtlbmNyeXB0Rm9yTW9iaWxpdHl9YCk7XG4gICAgaWYgKGVuY3J5cHRGb3JNb2JpbGl0eSkge1xuICAgICAgICBjb25zdCBzZXJ2ZXJCYXNlVVJMID0gZ2V0VXJsQmFzZU9mUHJpbnRlclVybChwcmludEpvYi5wcmludGVySWQpO1xuICAgICAgICByZXR1cm4gYXV0aGVudGljYXRlV2l0aEdTdWl0ZUhUVFAoc2VydmVyQmFzZVVSTCwgaXNJbnRlcmFjdGl2ZSk7XG4gICAgfVxuICAgIHJldHVybiBnZXRHb29nbGVBdXRoSW5mbyhpc0ludGVyYWN0aXZlKVxuICAgICAgICAudGhlbigoZ29vZ2xlQXV0aCkgPT4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmUoeyBwcm92aWRlcjogJ2dvb2dsZScsIHVzZXJpZDogZ29vZ2xlQXV0aC5lbWFpbCwgdG9rZW46IGdvb2dsZUF1dGgudG9rZW4gfSk7XG4gICAgfSkpO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEdvb2dsZUF1dGhJbmZvKGlzSW50ZXJhY3RpdmUpIHtcbiAgICBsb2coYEdldHRpbmcgYXV0aCBpbmZvIGZyb20gRy1TdWl0ZTogaXNJbnRlcmFjdGl2ZT0ke2lzSW50ZXJhY3RpdmV9YCk7XG4gICAgY29uc3QgcmV0cnlXaXRoUmVmcmVzaGVkVG9rZW4gPSBhc3luYyAoZSwgb2xkVG9rZW4pID0+IHtcbiAgICAgICAgZXJyb3IoJ2ZhaWxlZCB0byBnZXQgR29vZ2xlIHVzZXIgaW5mby4gcmVmcmVzaGluZyB0b2tlbi4uLicsIGUpO1xuICAgICAgICBjb25zdCBkZXRhaWxzID0geyBpbnRlcmFjdGl2ZTogaXNJbnRlcmFjdGl2ZSB9O1xuICAgICAgICByZXR1cm4gcmVmcmVzaFRva2VuKG9sZFRva2VuLCBkZXRhaWxzKS50aGVuKG5ld1Rva2VuID0+IGdldEdTdWl0ZVVzZXJJbmZvKG5ld1Rva2VuKSk7XG4gICAgfTtcbiAgICByZXR1cm4gZ2V0R1N1aXRlVG9rZW4oaXNJbnRlcmFjdGl2ZSlcbiAgICAgICAgLnRoZW4oKHRva2VuKSA9PiBnZXRHU3VpdGVVc2VySW5mbyh0b2tlbikuY2F0Y2goZSA9PiByZXRyeVdpdGhSZWZyZXNoZWRUb2tlbihlLCB0b2tlbikpKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldEdTdWl0ZVRva2VuKGlzSW50ZXJhY3RpdmUpIHtcbiAgICBjb25zdCBkZXRhaWxzID0geyBpbnRlcmFjdGl2ZTogaXNJbnRlcmFjdGl2ZSB9O1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNocm9tZS5pZGVudGl0eS5nZXRBdXRoVG9rZW4oZGV0YWlscywgKHRva2VuKSA9PiB7XG4gICAgICAgICAgICBpZiAoY2hyb21lLnJ1bnRpbWUubGFzdEVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGNocm9tZS5ydW50aW1lLmxhc3RFcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNvbHZlKHRva2VuKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5hc3luYyBmdW5jdGlvbiByZWZyZXNoVG9rZW4oZXhwaXJlZFRva2VuLCBkZXRhaWxzKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgbG9nKGBSZWZyZXNoaW5nIHVzZXIgdG9rZW4gZm9yOiAnJHtkZXRhaWxzLmFjY291bnR9Jy4uLmApO1xuICAgICAgICBjaHJvbWUuaWRlbnRpdHkucmVtb3ZlQ2FjaGVkQXV0aFRva2VuKHsgdG9rZW46IGV4cGlyZWRUb2tlbiB9LCAoKSA9PiB7XG4gICAgICAgICAgICBjaHJvbWUuaWRlbnRpdHkuZ2V0QXV0aFRva2VuKGRldGFpbHMsICh0b2tlbikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChjaHJvbWUucnVudGltZS5sYXN0RXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IoYEZhaWxlZCB0byByZWZyZXNoIHRva2VuOiAke2Nocm9tZS5ydW50aW1lLmxhc3RFcnJvci5tZXNzYWdlfWApO1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoY2hyb21lLnJ1bnRpbWUubGFzdEVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc29sdmUodG9rZW4pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEdTdWl0ZVVzZXJJbmZvKGFjY2Vzc1Rva2VuKSB7XG4gICAgbG9nKCdbZ2V0R1N1aXRlVXNlckluZm9dIEZldGNoaW5nIHVzZXIgaW5mbyBmcm9tIEctU3VpdGUuLi4nKTtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0dvb2dsZVVzZXJJbmZvVVJMfT9hY2Nlc3NfdG9rZW49JHthY2Nlc3NUb2tlbn1gKTtcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byByZXNvbHZlIEctU3VpdGUgdXNlcjogJHthd2FpdCByZXNwb25zZS50ZXh0KCl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgbG9nKGBbZ2V0R1N1aXRlVXNlckluZm9dIFJlc29sdmVkIHVzZXI6ICR7cmVzcC5lbWFpbH1gKTtcbiAgICAgICAgcmV0dXJuIHsgdG9rZW46IGFjY2Vzc1Rva2VuLCBlbWFpbDogcmVzcC5lbWFpbCB9O1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGVycm9yKCdbZ2V0R1N1aXRlVXNlckluZm9dIEVycm9yOicsIGVycik7XG4gICAgICAgIHRocm93IGVycjtcbiAgICB9XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0UnNhUHVibGljS2V5KHVybEJhc2UpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybEJhc2UgKyAnL3B1YmxpYy1rZXknLCB7XG4gICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICdjbGllbnQtdHlwZSc6IGNsaWVudFZlcnNpb25JRCgpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSkudGhlbihyZXNwb25zZSA9PiBnZXRSZXNwb25zZUJvZHkocmVzcG9uc2UpKTtcbiAgICAgICAgcmV0dXJuIHBhcnNlUnNhS2V5KHJlc3BvbnNlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBlcnJvcignW2dldFJzYVB1YmxpY0tleV0gRXJyb3I6JywgZXJyKTtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZVJzYUtleShyZXNwKSB7XG4gICAgICAgIGlmICghcmVzcC5tb2R1bHVzIHx8ICFyZXNwLmV4cG9uZW50KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZW5jcnlwdGlvbiBrZXkgaW5mbyByZXR1cm5lZCBieSB0aGUgc2VydmVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBrZXlMZW5ndGggPSByZXNwLm1vZHVsdXMubGVuZ3RoICogOCAvIDI7XG4gICAgICAgICAgICBsb2coYFtnZXRSc2FQdWJsaWNLZXldIE1vYmlsaXR5IFByaW50IGlzIHVzaW5nICR7a2V5TGVuZ3RofWJpdCBSU0Ega2V5Li4uYCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJTQUVuY3J5cHQocmVzcC5tb2R1bHVzLCByZXNwLmV4cG9uZW50KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGlzR1N1aXRlRW5hYmxlZEhUVFAodXJsQmFzZSkge1xuICAgIGxvZyhgW2lzR1N1aXRlRW5hYmxlZEhUVFBdIENoZWNraW5nIGlmIEdTdWl0ZSBpcyBlbmFibGVkIG9uIHNlcnZlcjogJHt1cmxCYXNlfS4uLmApO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsQmFzZSArICcvYXV0aC1vcHRpb25zJywge1xuICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAnY2xpZW50LXR5cGUnOiBjbGllbnRWZXJzaW9uSUQoKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pLnRoZW4ocmVzcCA9PiBnZXRSZXNwb25zZUJvZHkocmVzcCkpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2Uuc2lnbkluV2l0aEdvb2dsZTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBlcnJvcignW2lzR1N1aXRlRW5hYmxlZEhUVFBdIEVycm9yOicsIGVycik7XG4gICAgICAgIHRocm93IGVycjtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBpc0dTdWl0ZUVuYWJsZWRSVEMocHJpbnRlcklkKSB7XG4gICAgY29uc3Qgc2VydmVySWQgPSBhd2FpdCBnZXRTZXJ2ZXJJZEZvclByaW50ZXIocHJpbnRlcklkKTtcbiAgICBpZiAoIXNlcnZlcklkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5rbm93biBzZXJ2ZXIgaWQgZm9yIHByaW50ZXI6ICR7cHJpbnRlcklkfWApO1xuICAgIH1cbiAgICBjb25zdCBzZXJ2ZXJJbmZvID0gZ2V0U2VydmVySWRUb1NlcnZlckluZm9DYWNoZSgpLmdldChzZXJ2ZXJJZCk7XG4gICAgaWYgKHNlcnZlckluZm8pIHtcbiAgICAgICAgcmV0dXJuIHNlcnZlckluZm8uc2lnbkluV2l0aEdvb2dsZTtcbiAgICB9XG4gICAgbG9nKGBJbmZvcm1hdGlvbiBmb3Igc2VydmVyICcke3NlcnZlcklkfScgaXMgbm90IGNhY2hlZCwgZmV0Y2hpbmcuLi5gKTtcbiAgICByZXR1cm4gZ2V0U2VydmVySW5mb1JUQyhzZXJ2ZXJJZCkudGhlbihpbmZvID0+IGluZm8uc2lnbkluV2l0aEdvb2dsZSkuY2F0Y2goZSA9PiB7XG4gICAgICAgIGVycm9yKCdVbmFibGUgdG8gZGV0ZXJtaW5lIGlmIEdvb2dsZSBzaWduLWluIGlzIGVuYWJsZWQuJywgZSk7XG4gICAgICAgIHRocm93IGU7XG4gICAgfSk7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaXNHU3VpdGVFbmFibGVkKHByaW50Sm9iLCBjbG91ZFByaW50Sm9iID0gZmFsc2UpIHtcbiAgICBsb2coYGlzR1N1aXRlRW5hYmxlZDogcHJpbnRlcklkPSR7cHJpbnRKb2IucHJpbnRlcklkfSAoJHtjbG91ZFByaW50Sm9iID8gJ0Nsb3VkIEpvYicgOiAnTG9jYWwgSm9iJ30pYCk7XG4gICAgaWYgKGNsb3VkUHJpbnRKb2IpIHtcbiAgICAgICAgcmV0dXJuIGlzR1N1aXRlRW5hYmxlZFJUQyhwcmludEpvYi5wcmludGVySWQpO1xuICAgIH1cbiAgICBjb25zdCB1cmxCYXNlID0gZ2V0VXJsQmFzZU9mUHJpbnRlclVybChwcmludEpvYi5wcmludGVySWQpO1xuICAgIHJldHVybiBpc0dTdWl0ZUVuYWJsZWRIVFRQKHVybEJhc2UpO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJldm9rZUNhY2hlZEdTdWl0ZUF1dGhUb2tlbihtc0J1ZmZlclRpbWUgPSAwKSB7XG4gICAgbG9nKCdSZXZva2luZyBhdXRoIHRva2VuIHdpdGggRy1TdWl0ZS4uLicpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB0b2tlbiA9IGF3YWl0IG5ldyBQcm9taXNlKChpbm5lclJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgICBjaHJvbWUuaWRlbnRpdHkuZ2V0QXV0aFRva2VuKHsgaW50ZXJhY3RpdmU6IGZhbHNlIH0sIChpbm5lclRva2VuKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlubmVyUmVzb2x2ZShpbm5lclRva2VuKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHRva2VuID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRva2VuUGFyYW0gPSAndG9rZW49JyArIHRva2VuO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtHU3VpdGVUb2tlblJldm9rZVVybH0/JHt0b2tlblBhcmFtfWAsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgJ0NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfSwgbXNCdWZmZXJUaW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlamVjdChhd2FpdCByZXNwb25zZS50ZXh0KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGVycm9yKCdbcmV2b2tlQ2FjaGVkR1N1aXRlQXV0aFRva2VuXSBFcnJvcjonLCBlcnIpO1xuICAgICAgICAgICAgcmVqZWN0KCdDb25uZWN0aW9uIGZhaWxlZCcpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5hc3luYyBmdW5jdGlvbiBlbmNyeXB0Q3JlZGVudGlhbHNXaXRoS2V5KHVzZXJuYW1lLCBwYXNzd29yZCwgcnNhS2V5KSB7XG4gICAgbG9nKCdFbmNyeXB0aW5nIGNyZWRlbnRpYWxzLi4uJyk7XG4gICAgY29uc3QgcGxhaW5DcmVkZW50aWFscyA9IHVzZXJuYW1lICsgJzonICsgcGFzc3dvcmQ7XG4gICAgY29uc3QgZW5jcnlwdGVkID0gcnNhS2V5LmVuY3J5cHQocGxhaW5DcmVkZW50aWFscyk7XG4gICAgaWYgKCFlbmNyeXB0ZWQpIHtcbiAgICAgICAgZXJyb3IoJ0NyZWRlbnRpYWwgZW5jcnlwdGlvbiBmYWlsZWQhJywgJ2xlbmd0aCcsIHBsYWluQ3JlZGVudGlhbHMubGVuZ3RoKTtcbiAgICB9XG4gICAgcmV0dXJuIGVuY3J5cHRlZDtcbn1cbmZ1bmN0aW9uIGNsaWVudFZlcnNpb25JRCgpIHtcbiAgICBpZiAoaXNFeHRlbnNpb24oKSkge1xuICAgICAgICByZXR1cm4gJ0Nocm9tZUFwcEV4dC0nICsgY2hyb21lLnJ1bnRpbWUuZ2V0TWFuaWZlc3QoKS52ZXJzaW9uO1xuICAgIH1cbiAgICByZXR1cm4gJ0Nocm9tZUFwcC0nICsgY2hyb21lLnJ1bnRpbWUuZ2V0TWFuaWZlc3QoKS52ZXJzaW9uO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGVuY3J5cHRDcmVkZW50aWFscyhtcFNlcnZlckJhc2VVcmwsIHVzZXJuYW1lLCBwYXNzd29yZCkge1xuICAgIGxvZyhgRW5jcnlwdGluZyBjcmVkZW50aWFscyBmb3IgJHttcFNlcnZlckJhc2VVcmx9Li4uYCk7XG4gICAgcmV0dXJuIGdldFJzYVB1YmxpY0tleShtcFNlcnZlckJhc2VVcmwpLnRoZW4oKHJzYUtleSkgPT4ge1xuICAgICAgICByZXR1cm4gZW5jcnlwdENyZWRlbnRpYWxzV2l0aEtleSh1c2VybmFtZSwgcGFzc3dvcmQsIHJzYUtleSk7XG4gICAgfSk7XG59XG5leHBvcnQgY29uc3QgaW5NZW1vcnlDcmVkcyA9IHtcbiAgICByZW1lbWJlck1lOiBmYWxzZSxcbn07XG5leHBvcnQgZnVuY3Rpb24gcmVtZW1iZXJDcmVkc0luTWVtb3J5KGNyZWRlbnRpYWxzKSB7XG4gICAgaW5NZW1vcnlDcmVkcy51c2VybmFtZSA9IGNyZWRlbnRpYWxzLnVzZXJuYW1lO1xuICAgIGluTWVtb3J5Q3JlZHMucGFzc3dvcmQgPSBjcmVkZW50aWFscy5wYXNzd29yZDtcbiAgICBpbk1lbW9yeUNyZWRzLnJlbWVtYmVyTWUgPSBjcmVkZW50aWFscy5yZW1lbWJlck1lO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNsZWFySW5NZW1vcnlDcmVkcygpIHtcbiAgICBpbk1lbW9yeUNyZWRzLnVzZXJuYW1lID0gdW5kZWZpbmVkO1xuICAgIGluTWVtb3J5Q3JlZHMucGFzc3dvcmQgPSB1bmRlZmluZWQ7XG59XG5leHBvcnQgZnVuY3Rpb24gaW5NZW1vcnlDcmVkc0F2YWlsYWJsZSgpIHtcbiAgICByZXR1cm4gaW5NZW1vcnlDcmVkcy51c2VybmFtZSAhPSBudWxsICYmIGluTWVtb3J5Q3JlZHMucGFzc3dvcmQgIT0gbnVsbDtcbn1cbiIsImV4cG9ydCBhc3luYyBmdW5jdGlvbiBzZW5kUGFnZU1lc3NhZ2UobXNnLCBvcHRzID0ge30pIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCB0YWJNZXNzYWdlID0gb3B0cy50YWJJZCAhPT0gdW5kZWZpbmVkO1xuICAgICAgICBjb25zb2xlLmluZm8oYHNlbmRQYWdlTWVzc2FnZSgke3RhYk1lc3NhZ2UgPyAndGFiJyA6ICdleHQnfSk6IGAgK1xuICAgICAgICAgICAgYCR7SlNPTi5zdHJpbmdpZnkobXNnKX0sIG9wdHM6ICR7SlNPTi5zdHJpbmdpZnkob3B0cyl9Li4uYCk7XG4gICAgICAgIGNvbnN0IHNlbmQgPSB0YWJNZXNzYWdlID8gY2hyb21lLnRhYnMuc2VuZE1lc3NhZ2UuYmluZCh0aGlzLCBvcHRzLnRhYklkKSA6IGNocm9tZS5ydW50aW1lLnNlbmRNZXNzYWdlO1xuICAgICAgICBzZW5kKG1zZywgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGNocm9tZS5ydW50aW1lLmxhc3RFcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoY2hyb21lLnJ1bnRpbWUubGFzdEVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG4iLCJpbXBvcnQgeyBsb2cgfSBmcm9tICcuLi9sb2cnO1xuaW1wb3J0IHsgc2VuZFBhZ2VNZXNzYWdlIH0gZnJvbSAnLi9tZXNzYWdlJztcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzZW5kUGFnZU1lc3NhZ2VXaXRoUmV0cnkobXNnLCBvcHRzID0ge30pIHtcbiAgICBpZiAobXNnID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCBpdGVyID0gKGRlbGF5ID0gMTAsIGVsYXBzZWQgPSAwLCBhdHRlbXB0ID0gMCkgPT4ge1xuICAgICAgICAgICAgc2V0VGltZW91dChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgZWxhcHNlZCArPSBkZWxheTtcbiAgICAgICAgICAgICAgICBhdHRlbXB0ICs9IDE7XG4gICAgICAgICAgICAgICAgbG9nKCdbc2VuZFBhZ2VNZXNzYWdlV2l0aFJldHJ5XSBBdHRlbXB0aW5nIHRvIHNlbmQgcGFnZSBtZXNzYWdlLicsIHsgYXR0ZW1wdCwgbXNnLCBkZWxheSwgZWxhcHNlZCB9KTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGF3YWl0IHNlbmRQYWdlTWVzc2FnZShtc2csIG9wdHMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsYXBzZWQgPCA1MDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZygnW3NlbmRQYWdlTWVzc2FnZVdpdGhSZXRyeV0gVW5oYW5kbGVkIHBhZ2UgbWVzc2FnZSBzZW5kIGVycm9yIHdpdGhpbiA1MDBtcywgd2lsbCB0cnkgYWdhaW4uJywgZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVyKGRlbGF5ICogMiwgZWxhcHNlZCwgYXR0ZW1wdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZWxhcHNlZCA8IDMwMDBcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIGVcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIGVbJ21lc3NhZ2UnXSA9PSAnQ291bGQgbm90IGVzdGFibGlzaCBjb25uZWN0aW9uLiBSZWNlaXZpbmcgZW5kIGRvZXMgbm90IGV4aXN0LicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZXIoZGVsYXkgKiAyLCBlbGFwc2VkLCBhdHRlbXB0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGRlbGF5KTtcbiAgICAgICAgfTtcbiAgICAgICAgaXRlcigpO1xuICAgIH0pO1xufVxuIiwiZXhwb3J0ICogZnJvbSAnLi9jaHJvbWUnO1xuZXhwb3J0ICogZnJvbSAnLi9jaHJvbWUudHlwZXMnO1xuZXhwb3J0ICogZnJvbSAnLi9tZXNzYWdlJztcbiIsImltcG9ydCB7IGdldEdvb2dsZUF1dGhJbmZvLCBnZXRHU3VpdGVVc2VySW5mbyB9IGZyb20gJy4uL2F1dGgnO1xuZXhwb3J0IGNsYXNzIEdvb2dsZU9wZW5JRE9BdXRoUHJvdmlkZXIge1xuICAgIGdldEFjY2Vzc1Rva2VuKCkge1xuICAgICAgICByZXR1cm4gZ2V0R29vZ2xlQXV0aEluZm8odHJ1ZSkudGhlbihhdXRoSW5mbyA9PiB7XG4gICAgICAgICAgICByZXR1cm4geyBhY2Nlc3NUb2tlbjogYXV0aEluZm8udG9rZW4gfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldFVzZXJJbmZvKG9hdXRoVG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIGdldEdTdWl0ZVVzZXJJbmZvKG9hdXRoVG9rZW4uYWNjZXNzVG9rZW4pLnRoZW4odXNlckluZm8gPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHsgZW1haWw6IHVzZXJJbmZvLmVtYWlsIH07XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IEdvb2dsZU9wZW5JRE9BdXRoUHJvdmlkZXIgfSBmcm9tICcuL2dvb2dsZWF1dGgnO1xuZXhwb3J0IGNvbnN0IE9BdXRoUHJvdmlkZXJJRHMgPSB7XG4gICAgR29vZ2xlOiAnZ29vZ2xlJyxcbn07XG5leHBvcnQgZnVuY3Rpb24gdG9QcmludERlcGxveVRva2VuSW5mbyhzZXNzaW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYXV0aE1ldGhvZDogc2Vzc2lvbi5wcm92aWRlcklELFxuICAgICAgICB0b2tlbjogc2Vzc2lvbi5zZXNzaW9uVG9rZW4sXG4gICAgfTtcbn1cbmV4cG9ydCBjb25zdCBwcmludERlcGxveU9hdXRoUHJvdmlkZXJzID0gbmV3IE1hcCgpO1xucHJpbnREZXBsb3lPYXV0aFByb3ZpZGVycy5zZXQoT0F1dGhQcm92aWRlcklEcy5Hb29nbGUsIG5ldyBHb29nbGVPcGVuSURPQXV0aFByb3ZpZGVyKCkpO1xuIiwiaW1wb3J0IHsgc2VuZFBhZ2VNZXNzYWdlV2l0aFJldHJ5IH0gZnJvbSAnLi4vY2hyb21lJztcbmltcG9ydCB7IGVycm9yLCBsb2csIHdhcm4gfSBmcm9tICcuLi9sb2cnO1xuaW1wb3J0IHsgZ2V0TG9jYWxTdG9yYWdlRGF0YSwgc2V0TG9jYWxTdG9yYWdlRGF0YSB9IGZyb20gJy4uL3N0b3JhZ2UnO1xuY29uc3QgbWF4V2luZG93RGltZW5zaW9ucyA9IHsgd2lkdGg6IDEwMjQsIGhlaWdodDogNzY4IH07XG5jb25zdCBtaW5XaW5kb3dEaW1lbnNpb25zID0geyB3aWR0aDogMTAwLCBoZWlnaHQ6IDEwMCB9O1xuY29uc3QgZGVmYXVsdEZyYW1lU2l6ZSA9IHsgd2lkdGg6IDMwLCBoZWlnaHQ6IDMwIH07XG5sZXQgZnJhbWVTaXplO1xubGV0IGRpc3BsYXlCb3VuZHM7XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2hvd1BvcHVwKHsgcGFnZSwgd2lkdGggPSA0OTQsIGhlaWdodCA9IDYxMCwgbWVzc2FnZSwgfSkge1xuICAgIGxvZygnW3BvcHVwXSBEaXNwbGF5aW5nIHBvcHVwLicsIHsgcGFnZSwgd2lkdGgsIGhlaWdodCB9KTtcbiAgICBhd2FpdCBjYWxjdWxhdGVGcmFtZVNpemUoKTtcbiAgICBjb25zdCB0YWIgPSBhd2FpdCBjcmVhdGVUYWIoe1xuICAgICAgICBwYWdlLFxuICAgICAgICB3aW5kb3dJZDogKGF3YWl0IGNyZWF0ZVBvcHVwV2luZG93KHdpZHRoLCBoZWlnaHQpKS5pZCxcbiAgICB9KTtcbiAgICBsb2coJ1twb3B1cF0gc2VuZGluZyBwYWdlIE1lc3NhZ2UnLCB7IG1lc3NhZ2UgfSk7XG4gICAgYXdhaXQgc2VuZFBhZ2VNZXNzYWdlV2l0aFJldHJ5KG1lc3NhZ2UsIHtcbiAgICAgICAgdGFiSWQ6IHRhYi5pZCxcbiAgICB9KTtcbiAgICBsb2coYFtwb3B1cF0gUG9wdXAgZGlzcGxheWVkICh0YWIgJHt0YWIuaWR9KS5gLCB7IHBhZ2UgfSk7XG59XG5hc3luYyBmdW5jdGlvbiBjYWxjdWxhdGVGcmFtZVNpemUoKSB7XG4gICAgaWYgKGZyYW1lU2l6ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCBzYXZlRnJhbWVTaXplID0gZmFsc2U7XG4gICAgICAgIGZyYW1lU2l6ZSA9IGF3YWl0IGdldExvY2FsU3RvcmFnZURhdGEoJ2ZyYW1lc2l6ZScpO1xuICAgICAgICBpZiAoIWZyYW1lU2l6ZSB8fCAhZnJhbWVTaXplLndpZHRoIHx8ICFmcmFtZVNpemUuaGVpZ2h0KSB7XG4gICAgICAgICAgICBsb2coJ1dpbmRvdyBmcmFtZSBzaXplIG5vdCBrbm93biwgY2FsY3VsYXRpbmcuLi4nKTtcbiAgICAgICAgICAgIGZyYW1lU2l6ZSA9IGF3YWl0IGdldEZyYW1lU2l6ZSgpO1xuICAgICAgICAgICAgc2F2ZUZyYW1lU2l6ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZyYW1lU2l6ZSAmJiBmcmFtZVNpemUud2lkdGggPj0gMCAmJiBmcmFtZVNpemUuaGVpZ2h0ID49IDApIHtcbiAgICAgICAgICAgIGxvZyhgVXNpbmcgd2luZG93IGZyYW1lIHNpemU6ICR7SlNPTi5zdHJpbmdpZnkoZnJhbWVTaXplKX1gKTtcbiAgICAgICAgICAgIE9iamVjdC5mcmVlemUoZnJhbWVTaXplKTtcbiAgICAgICAgICAgIGlmIChzYXZlRnJhbWVTaXplKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgc2V0TG9jYWxTdG9yYWdlRGF0YSgnZnJhbWVzaXplJywgZnJhbWVTaXplKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdhcm4oYEludmFsaWQgd2luZG93IGZyYW1lIHNpemUsIHdpbGwgdXNlIGRlZmF1bHQ6ICR7SlNPTi5zdHJpbmdpZnkoZnJhbWVTaXplKX1gKTtcbiAgICAgICAgICAgIGZyYW1lU2l6ZSA9IGRlZmF1bHRGcmFtZVNpemU7XG4gICAgICAgIH1cbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBjcmVhdGVUYWIoeyBwYWdlLCB3aW5kb3dJZCwgfSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNocm9tZS50YWJzLmNyZWF0ZSh7XG4gICAgICAgICAgICB1cmw6IGNocm9tZS5ydW50aW1lLmdldFVSTChwYWdlKSxcbiAgICAgICAgICAgIHdpbmRvd0lkLFxuICAgICAgICB9LCAodGFiKSA9PiB7XG4gICAgICAgICAgICBpZiAoY2hyb21lLnJ1bnRpbWUubGFzdEVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChjaHJvbWUucnVudGltZS5sYXN0RXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nKGBbcG9wdXBdIFRhYiAnJHtwYWdlfScgKGlkOiR7dGFiLmlkfSwgd2luZG93OiR7dGFiLndpbmRvd0lkfSkgY3JlYXRlZC5gKTtcbiAgICAgICAgICAgIHJlc29sdmUodGFiKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRGcmFtZVNpemUoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsb2coJ1twb3B1cF0gQ3JlYXRpbmcgcGFnZSB0byBtZWFzdXJlIGZyYW1lIHNpemUuJyk7XG4gICAgICAgICAgICBsZXQgdGltZW91dElkID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgY29uc3QgZnJhbWVTaXplQ2FsbGJhY2sgPSAoZnJhbWUsIF9zLCByZXNwb25zZUNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGZyYW1lLnR5cGUgIT09ICdmcmFtZS1zaXplLXJlc3BvbnNlJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aW1lb3V0SWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3BvbnNlQ2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICBjaHJvbWUucnVudGltZS5vbk1lc3NhZ2UucmVtb3ZlTGlzdGVuZXIoZnJhbWVTaXplQ2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZzID0geyB3aWR0aDogZnJhbWUud2lkdGgsIGhlaWdodDogZnJhbWUuaGVpZ2h0IH07XG4gICAgICAgICAgICAgICAgZnMud2lkdGggPSBmcy53aWR0aCA/PyBkZWZhdWx0RnJhbWVTaXplLndpZHRoO1xuICAgICAgICAgICAgICAgIGZzLmhlaWdodCA9IGZzLmhlaWdodCA/PyBkZWZhdWx0RnJhbWVTaXplLmhlaWdodDtcbiAgICAgICAgICAgICAgICBsb2coJ1twb3B1cF0gRnJhbWUgc2l6ZSBtZWFzdXJlZC4nLCBmcyk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShmcyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgY2hyb21lLnJ1bnRpbWUub25NZXNzYWdlLnJlbW92ZUxpc3RlbmVyKGZyYW1lU2l6ZUNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICBsb2coJ1twb3B1cF0gVGltZWQgb3V0IG1lYXN1cmluZyBmcmFtZSBzaXplLCB1c2luZyBkZWZhdWx0LicpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoZGVmYXVsdEZyYW1lU2l6ZSk7XG4gICAgICAgICAgICB9LCAzMDAwKTtcbiAgICAgICAgICAgIGNocm9tZS5ydW50aW1lLm9uTWVzc2FnZS5hZGRMaXN0ZW5lcihmcmFtZVNpemVDYWxsYmFjayk7XG4gICAgICAgICAgICBhd2FpdCBjcmVhdGVUYWIoe1xuICAgICAgICAgICAgICAgIHBhZ2U6ICdmcmFtZXNpemUuaHRtbCcsXG4gICAgICAgICAgICAgICAgd2luZG93SWQ6IChhd2FpdCBjcmVhdGVXaW5kb3coe1xuICAgICAgICAgICAgICAgICAgICB3aWR0aDogbWluV2luZG93RGltZW5zaW9ucy53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBtaW5XaW5kb3dEaW1lbnNpb25zLmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgZm9jdXNlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgfSkpLmlkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGxvZygnW3BvcHVwXSBGYWlsZWQgdG8gbWVhc3VyZSBmcmFtZSBzaXplLCB1c2luZyBkZWZhdWx0LicsIGUpO1xuICAgICAgICAgICAgcmVzb2x2ZShkZWZhdWx0RnJhbWVTaXplKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gY3JlYXRlUG9wdXBXaW5kb3cod2lkdGgsIGhlaWdodCkge1xuICAgIGlmICghZGlzcGxheUJvdW5kcykge1xuICAgICAgICBkaXNwbGF5Qm91bmRzID0gYXdhaXQgZ2V0RGlzcGxheUJvdW5kcyh0cnVlKTtcbiAgICAgICAgT2JqZWN0LmZyZWV6ZShkaXNwbGF5Qm91bmRzKTtcbiAgICB9XG4gICAgbG9nKCdbcG9wdXBdIERpc3BsYXkgd29yayBhcmVhIGRpbWVuc2lvbnMnLCBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIGRpc3BsYXlXaWR0aDogZGlzcGxheUJvdW5kcy53aWR0aCxcbiAgICAgICAgZGlzcGxheUhlaWdodDogZGlzcGxheUJvdW5kcy5oZWlnaHQsXG4gICAgICAgIG1heFdpbmRvd1dpZHRoOiBtYXhXaW5kb3dEaW1lbnNpb25zLndpZHRoLFxuICAgICAgICBtYXhXaW5kb3dIZWlnaHQ6IG1heFdpbmRvd0RpbWVuc2lvbnMuaGVpZ2h0LFxuICAgIH0pKTtcbiAgICB0cnkge1xuICAgICAgICBsb2coJ1twb3B1cF0gQ3JlYXRpbmcgd2luZG93IHVzaW5nIHNjcmVlbiBpbmZvOicsIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIGF2YWlsV2lkdGg6IGRpc3BsYXlCb3VuZHMud2lkdGgsXG4gICAgICAgICAgICBhdmFpbEhlaWdodDogZGlzcGxheUJvdW5kcy5oZWlnaHQsXG4gICAgICAgICAgICBmcmFtZVdpZHRoOiBmcmFtZVNpemUud2lkdGgsXG4gICAgICAgICAgICBmcmFtZUhlaWdodDogZnJhbWVTaXplLmhlaWdodCxcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gYXdhaXQgY3JlYXRlV2luZG93KHtcbiAgICAgICAgICAgIHdpZHRoOiB3aWR0aCArIGZyYW1lU2l6ZS53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0ICsgZnJhbWVTaXplLmhlaWdodCxcbiAgICAgICAgICAgIGxlZnQ6IE1hdGgucm91bmQoKGRpc3BsYXlCb3VuZHMud2lkdGggLSB3aWR0aCkgLyAyKSxcbiAgICAgICAgICAgIHRvcDogTWF0aC5yb3VuZCgoZGlzcGxheUJvdW5kcy5oZWlnaHQgLSBoZWlnaHQpIC8gMiksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBlcnJvcignW3BvcHVwXSBXaW5kb3cgY3JlYXRpb24gZmFpbGVkOicsIGUpO1xuICAgICAgICBsb2coJ1twb3B1cF0gTGFzdCBjaGFuY2UgcmV0cnkgd2l0aG91dCBjZW50ZXJpbmcuJyk7XG4gICAgICAgIHJldHVybiBhd2FpdCBjcmVhdGVXaW5kb3coe1xuICAgICAgICAgICAgd2lkdGg6IHdpZHRoICsgZnJhbWVTaXplLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQgKyBmcmFtZVNpemUuaGVpZ2h0LFxuICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gY3JlYXRlV2luZG93KHsgd2lkdGgsIGhlaWdodCwgbGVmdCwgdG9wLCBmb2N1c2VkID0gdHJ1ZSwgfSkge1xuICAgIGlmIChkaXNwbGF5Qm91bmRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGlzcGxheUJvdW5kcyA9IGF3YWl0IGdldERpc3BsYXlCb3VuZHModHJ1ZSk7XG4gICAgICAgIE9iamVjdC5mcmVlemUoZGlzcGxheUJvdW5kcyk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGxvZyhgW3BvcHVwXSBSZXF1ZXN0ZWQgd2luZG93LCB3aWR0aDoke3dpZHRofSwgaGVpZ2h0OiR7aGVpZ2h0fSwgbGVmdDoke2xlZnR9LCB0b3A6JHt0b3B9YCk7XG4gICAgICAgICh7IGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCB9ID0gbm9ybWFsaXplV2luZG93Qm91bmRzKHsgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0IH0pKTtcbiAgICAgICAgY2hyb21lLndpbmRvd3MuY3JlYXRlKHtcbiAgICAgICAgICAgIHR5cGU6ICdwb3B1cCcsXG4gICAgICAgICAgICBmb2N1c2VkLFxuICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgICBsZWZ0LFxuICAgICAgICAgICAgdG9wLFxuICAgICAgICB9LCBhc3luYyAodykgPT4ge1xuICAgICAgICAgICAgaWYgKGNocm9tZS5ydW50aW1lLmxhc3RFcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoYGZhaWxlZCB0byBkaXNwbGF5IHBvcHVwOiAke2Nocm9tZS5ydW50aW1lLmxhc3RFcnJvci5tZXNzYWdlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIXcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KCdmYWlsZWQgdG8gZGlzcGxheSBwb3B1cCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb2x2ZSh3KTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVXaW5kb3dCb3VuZHMod0JvdW5kcykge1xuICAgIGNvbnN0IG1heFdpZHRoID0gbnVtUmFuZ2UoZGlzcGxheUJvdW5kcy53aWR0aCwgbWF4V2luZG93RGltZW5zaW9ucy53aWR0aCwgZGlzcGxheUJvdW5kcy53aWR0aCk7XG4gICAgY29uc3QgbWF4SGVpZ2h0ID0gbnVtUmFuZ2UoZGlzcGxheUJvdW5kcy5oZWlnaHQsIG1heFdpbmRvd0RpbWVuc2lvbnMuaGVpZ2h0LCBkaXNwbGF5Qm91bmRzLmhlaWdodCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6IG51bVJhbmdlKHdCb3VuZHMud2lkdGgsIG1pbldpbmRvd0RpbWVuc2lvbnMud2lkdGgsIG1heFdpZHRoKSxcbiAgICAgICAgaGVpZ2h0OiBudW1SYW5nZSh3Qm91bmRzLmhlaWdodCwgbWluV2luZG93RGltZW5zaW9ucy5oZWlnaHQsIG1heEhlaWdodCksXG4gICAgICAgIGxlZnQ6IHdCb3VuZHMubGVmdCA/IG51bVJhbmdlKHdCb3VuZHMubGVmdCwgMCwgTWF0aC5yb3VuZCgobWF4V2lkdGggLSB3Qm91bmRzLndpZHRoKSAvIDIpKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgdG9wOiB3Qm91bmRzLnRvcCA/IG51bVJhbmdlKHdCb3VuZHMudG9wLCAwLCBNYXRoLnJvdW5kKChtYXhIZWlnaHQgLSB3Qm91bmRzLmhlaWdodCkgLyAyKSkgOiB1bmRlZmluZWQsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIG51bVJhbmdlKHZhbHVlLCBtaW4sIG1heCkge1xuICAgIHJldHVybiBNYXRoLm1heChNYXRoLm1pbih2YWx1ZSwgbWF4KSwgbWluKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldERpc3BsYXlCb3VuZHMoaXNQcmltYXJ5KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIGNocm9tZS5zeXN0ZW0uZGlzcGxheS5nZXRJbmZvKChkaXNwbGF5cykgPT4ge1xuICAgICAgICAgICAgbGV0IGRpc3BsYXk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGRpc3Agb2YgZGlzcGxheXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGlzcC5pc1ByaW1hcnkgPT09IGlzUHJpbWFyeSkge1xuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5ID0gZGlzcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBib3VuZHMgPSBkaXNwbGF5LndvcmtBcmVhO1xuICAgICAgICAgICAgaWYgKGJvdW5kcy53aWR0aCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgd2FybignSW52YWxpZCBkaXNwbGF5IGJvdW5kcyB3aWR0aCByZXR1cm5lZDonLCBib3VuZHMud2lkdGgpO1xuICAgICAgICAgICAgICAgIGJvdW5kcy53aWR0aCA9IG1heFdpbmRvd0RpbWVuc2lvbnMud2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYm91bmRzLmhlaWdodCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgd2FybignSW52YWxpZCBkaXNwbGF5IGJvdW5kcyBoZWlnaHQgcmV0dXJuZWQ6JywgYm91bmRzLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgYm91bmRzLmhlaWdodCA9IG1heFdpbmRvd0RpbWVuc2lvbnMuaGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb2x2ZShib3VuZHMpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbiIsImltcG9ydCB7IHNlbmRQYWdlTWVzc2FnZSwgc2VuZFBhZ2VNZXNzYWdlV2l0aFJldHJ5IH0gZnJvbSAnLi4vY2hyb21lJztcbmltcG9ydCB7IGxvZyB9IGZyb20gJy4uL2xvZyc7XG5pbXBvcnQgeyBzaG93UG9wdXAgfSBmcm9tICcuLi9wb3B1cCc7XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGlzcGxheUxvZ2luV2luZG93KHsgcHJpbnRKb2IgPSB1bmRlZmluZWQsIHVybEJhc2UgPSB1bmRlZmluZWQsIHNob3dSZW1lbWJlck1lLCBzaG93VXNlcm5hbWVMb2dpbiA9IGZhbHNlLCBzaG93R29vZ2xlTG9naW4gPSBmYWxzZSwgdXNlQ2xvdWRQcmludCA9IGZhbHNlLCB1c2VQcmludERlcGxveSA9IGZhbHNlLCB9KSB7XG4gICAgbG9nKCdbZGlzcGxheUxvZ2luV2luZG93XTogRGlzcGxheWluZyBzaWduLWluIHBvcC11cC4nLCB7IHNob3dSZW1lbWJlck1lLCBzaG93VXNlcm5hbWVMb2dpbiwgc2hvd0dvb2dsZUxvZ2luLCB1c2VDbG91ZFByaW50LCB1c2VQcmludERlcGxveSB9KTtcbiAgICBhd2FpdCBzaG93UG9wdXAoe1xuICAgICAgICBwYWdlOiAnbG9naW4uaHRtbCcsXG4gICAgICAgIGhlaWdodDogNjc1LFxuICAgICAgICBtZXNzYWdlOiB7XG4gICAgICAgICAgICB0eXBlOiAnbG9naW4td2luZG93LWluaXQnLFxuICAgICAgICAgICAgcHJpbnRKb2IsXG4gICAgICAgICAgICBzaG93VXNlcm5hbWVMb2dpbixcbiAgICAgICAgICAgIHNob3dHb29nbGVMb2dpbixcbiAgICAgICAgICAgIHNob3dSZW1lbWJlck1lLFxuICAgICAgICAgICAgdXJsQmFzZSxcbiAgICAgICAgICAgIHVzZUNsb3VkUHJpbnQsXG4gICAgICAgICAgICB1c2VQcmludERlcGxveSxcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjbG9zZUxvZ2luRGlhbG9nKCkge1xuICAgIGxvZygnW2Nsb3NlTG9naW5EaWFsb2ddIHNlbmRpbmcgbWVzc2FnZSB0byBjbG9zZSBsb2dpbiB3aW5kb3cnKTtcbiAgICBjb25zdCBjbG9zZUxvZ2luV2luZG93TWVzc2FnZSA9IHtcbiAgICAgICAgdHlwZTogJ2Nsb3NlLWxvZ2luLXdpbmRvdycsXG4gICAgICAgIG1zZzogJ2Nsb3NlIHdpbmRvdycsXG4gICAgfTtcbiAgICBhd2FpdCBzZW5kUGFnZU1lc3NhZ2UoY2xvc2VMb2dpbldpbmRvd01lc3NhZ2UpO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNlbmREaXNwbGF5RXJyb3JNZXNzYWdlKGVyck1zZykge1xuICAgIGxvZygnW3NlbmREaXNwbGF5RXJyb3JNZXNzYWdlXTogc2VuZGluZyBlcnJvciB0byBsb2dpbiB3aW5kb3cnLCB7IGVyck1zZyB9KTtcbiAgICBjb25zdCBkaXNwbGF5RXJyb3JNZXNzYWdlID0ge1xuICAgICAgICB0eXBlOiAnZGlzcGxheS1lcnJvcicsXG4gICAgICAgIGVyck1zZzogZXJyTXNnLFxuICAgIH07XG4gICAgYXdhaXQgc2VuZFBhZ2VNZXNzYWdlV2l0aFJldHJ5KGRpc3BsYXlFcnJvck1lc3NhZ2UpO1xufVxuIiwiZXhwb3J0ICogZnJvbSAnLi9sb2dpbic7XG4iLCJleHBvcnQgY29uc3QgUHJpbnREZXBsb3lBdXRoTWV0aG9kcyA9IHtcbiAgICBVc2VybmFtZTogJ3VzZXJuYW1lJyxcbiAgICBHb29nbGU6ICdnb29nbGUnLFxufTtcbiIsImNvbnN0IFJTQV9TVFJJTkdfTUFYTEVOID0gMjQ1O1xuZXhwb3J0IGNsYXNzIENsaWVudEVuY3J5cHRpb25TZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3Rvcihyc2FLZXksIHVzZUF1dGhIZWFkZXJFbmNyeXB0aW9uID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5yc2FLZXkgPSByc2FLZXk7XG4gICAgICAgIHRoaXMudXNlQXV0aEhlYWRlckVuY3J5cHRpb24gPSB1c2VBdXRoSGVhZGVyRW5jcnlwdGlvbjtcbiAgICB9XG4gICAgZW5jcnlwdFJlcXVlc3RCb2R5KGJvZHkpIHtcbiAgICAgICAgY29uc3QganNvbkJvZHlTdHIgPSBKU09OLnN0cmluZ2lmeShib2R5KTtcbiAgICAgICAgaWYgKHRoaXMucnNhS2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNyeXB0TG9uZ1N0cmluZyh0aGlzLnJzYUtleSwganNvbkJvZHlTdHIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBqc29uQm9keVN0cjtcbiAgICB9XG4gICAgZW5jcnlwdEF1dGhIZWFkZXJWYWx1ZShoZWFkZXJWYWx1ZSkge1xuICAgICAgICBpZiAodGhpcy51c2VBdXRoSGVhZGVyRW5jcnlwdGlvbiAmJiB0aGlzLnJzYUtleSkge1xuICAgICAgICAgICAgY29uc3QgZW5jcnlwdGVkSGVhZGVyID0gdGhpcy5lbmNyeXB0TG9uZ1N0cmluZyh0aGlzLnJzYUtleSwgaGVhZGVyVmFsdWUpO1xuICAgICAgICAgICAgaWYgKGVuY3J5cHRlZEhlYWRlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbmNyeXB0ZWRIZWFkZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhlYWRlclZhbHVlO1xuICAgIH1cbiAgICBlbmNyeXB0TG9uZ1N0cmluZyhyc2FLZXksIHN0cikge1xuICAgICAgICBpZiAoc3RyLmxlbmd0aCA8PSBSU0FfU1RSSU5HX01BWExFTikge1xuICAgICAgICAgICAgcmV0dXJuIHJzYUtleS5lbmNyeXB0KHN0cik7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHBhdHRlcm4gPSBgLnsxLCR7UlNBX1NUUklOR19NQVhMRU59fWA7XG4gICAgICAgICAgICByZXR1cm4gc3RyLm1hdGNoKG5ldyBSZWdFeHAocGF0dGVybiwgJ2cnKSlcbiAgICAgICAgICAgICAgICAubWFwKHMgPT4gcnNhS2V5LmVuY3J5cHQocykpXG4gICAgICAgICAgICAgICAgLnJlZHVjZSgoYWNjLCBlbmNyeXB0ZWRDaHVuaykgPT4gYWNjICsgJywnICsgZW5jcnlwdGVkQ2h1bmspO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdlbmNyeXB0aW9uIGZhaWxlZCcsIGUpO1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsImltcG9ydCB7IGdldFJzYVB1YmxpY0tleSB9IGZyb20gJy4uLy4uL2F1dGgnO1xuaW1wb3J0IHsgZ2V0UmVzcG9uc2VCb2R5IH0gZnJvbSAnLi4vLi4vaHR0cCc7XG5pbXBvcnQgeyBQcmludERlcGxveUF1dGhNZXRob2RzLCB9IGZyb20gJy4uL3ByaW50ZGVwbG95LnR5cGVzJztcbmltcG9ydCB7IENsaWVudEVuY3J5cHRpb25TZXJ2aWNlIH0gZnJvbSAnLi9lbmNyeXB0aW9uJztcbmNvbnN0IERFRkFVTFRfUFJJTlRfREVQTE9ZX0hUVFBTX1BPUlQgPSA5MTc0O1xuY29uc3QgREVGQVVMVF9QUklOVF9ERVBMT1lfSFRUUF9QT1JUID0gOTE3MztcbmV4cG9ydCBjbGFzcyBQcmludERlcGxveUNsaWVudEJ1aWxkZXIge1xuICAgIGNvbnN0cnVjdG9yKGhvc3QpIHtcbiAgICAgICAgdGhpcy51c2VIVFRQU0VuY3J5cHRpb24gPSAoKSA9PiBuZXcgQ2xpZW50RW5jcnlwdGlvblNlcnZpY2UoKTtcbiAgICAgICAgdGhpcy5ob3N0ID0gaG9zdDtcbiAgICB9XG4gICAgd2l0aEFjY2Vzc2libGVUTFNQb3J0KHBvcnQpIHtcbiAgICAgICAgdGhpcy5hY2Nlc3NpYmxlVExTUG9ydCA9IHBvcnQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB3aXRoU3RyaWN0U1NMKHN0cmljdFNTTCkge1xuICAgICAgICB0aGlzLnN0cmljdFNTTCA9IHN0cmljdFNTTDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHdpdGhPQXV0aFByb3ZpZGVycyhvYXV0aFByb3ZpZGVycykge1xuICAgICAgICB0aGlzLm9hdXRoUHJvdmlkZXJzID0gb2F1dGhQcm92aWRlcnM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBhc3luYyBidWlsZCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLm9hdXRoUHJvdmlkZXJzKSB7XG4gICAgICAgICAgICB0aGlzLm9hdXRoUHJvdmlkZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmhhc0N1c3RvbUFjY2Vzc2libGVUTFNQb3J0KCkgfHwgdGhpcy5zdHJpY3RTU0wpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvcnQgPSB0aGlzLmFjY2Vzc2libGVUTFNQb3J0IHx8IERFRkFVTFRfUFJJTlRfREVQTE9ZX0hUVFBTX1BPUlQ7XG4gICAgICAgICAgICBjb25zdCBzZXJ2ZXJCYXNlVVJMID0gYGh0dHBzOi8vJHt0aGlzLmhvc3R9OiR7cG9ydH1gO1xuICAgICAgICAgICAgY29uc3QgY2xpZW50ID0gbmV3IFBEQ2xpZW50KHNlcnZlckJhc2VVUkwsIHRoaXMub2F1dGhQcm92aWRlcnMsIHRoaXMudXNlSFRUUFNFbmNyeXB0aW9uKCkpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjbGllbnQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGh0dHBzU2VydmVyQmFzZVVSTCA9IGBodHRwczovLyR7dGhpcy5ob3N0fToke0RFRkFVTFRfUFJJTlRfREVQTE9ZX0hUVFBTX1BPUlR9YDtcbiAgICAgICAgcmV0dXJuIGZldGNoKGh0dHBzU2VydmVyQmFzZVVSTClcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNsaWVudCA9IG5ldyBQRENsaWVudChodHRwc1NlcnZlckJhc2VVUkwsIHRoaXMub2F1dGhQcm92aWRlcnMsIHRoaXMudXNlSFRUUFNFbmNyeXB0aW9uKCkpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjbGllbnQpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKF8gPT4ge1xuICAgICAgICAgICAgY29uc3QgaHR0cEJhc2VVcmwgPSBgaHR0cDovLyR7dGhpcy5ob3N0fToke0RFRkFVTFRfUFJJTlRfREVQTE9ZX0hUVFBfUE9SVH1gO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudXNlRW5jcnlwdGVkSFRUUChodHRwQmFzZVVybCkudGhlbihlbmNyeXB0aW9uU2VydmljZSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQRENsaWVudChodHRwQmFzZVVybCwgdGhpcy5vYXV0aFByb3ZpZGVycywgZW5jcnlwdGlvblNlcnZpY2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyB1c2VFbmNyeXB0ZWRIVFRQKGh0dHBCYXNlVXJsKSB7XG4gICAgICAgIGlmIChodHRwQmFzZVVybC5zdGFydHNXaXRoKCdodHRwczovLycpKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ29ubHkgdXNlIGVuY3J5cHRlZCBIVFRQIGlmIHRoZSB0YXJnZXQgaG9zdCBkb2VzblxcJ3Qgc3VwcG9ydCBIVFRQUycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnZXRSc2FQdWJsaWNLZXkoaHR0cEJhc2VVcmwpLnRoZW4oYXN5bmMgKHJzYUtleSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdXNlQXV0aEhlYWRlckVuY3J5cHRpb24gPSBhd2FpdCB0aGlzLmlzQXV0aEhlYWRlckVuY3J5cHRpb25TdXBwb3J0ZWQoaHR0cEJhc2VVcmwpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDbGllbnRFbmNyeXB0aW9uU2VydmljZShyc2FLZXksIHVzZUF1dGhIZWFkZXJFbmNyeXB0aW9uKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIGlzQXV0aEhlYWRlckVuY3J5cHRpb25TdXBwb3J0ZWQoaHR0cEJhc2VVcmwpIHtcbiAgICAgICAgcmV0dXJuIGZldGNoKGAke2h0dHBCYXNlVXJsfS8ke1ByaW50RGVwbG95UGF0aHMuR0VUX0NPTkZJR31gKS50aGVuKHJlc3AgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3Auc3RhdHVzID09PSAyMDA7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBoYXNDdXN0b21BY2Nlc3NpYmxlVExTUG9ydCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWNjZXNzaWJsZVRMU1BvcnRcbiAgICAgICAgICAgICYmIHRoaXMuYWNjZXNzaWJsZVRMU1BvcnQgIT09IDBcbiAgICAgICAgICAgICYmIHRoaXMuYWNjZXNzaWJsZVRMU1BvcnQgIT09IERFRkFVTFRfUFJJTlRfREVQTE9ZX0hUVFBTX1BPUlQ7XG4gICAgfVxufVxudmFyIFByaW50RGVwbG95UGF0aHM7XG4oZnVuY3Rpb24gKFByaW50RGVwbG95UGF0aHMpIHtcbiAgICBQcmludERlcGxveVBhdGhzW1wiTE9HSU5cIl0gPSBcImRlcGxveS9sb2dpblwiO1xuICAgIFByaW50RGVwbG95UGF0aHNbXCJHRVRfUFJJTlRFUlNcIl0gPSBcImRlcGxveS9wcmludGVyc1wiO1xuICAgIFByaW50RGVwbG95UGF0aHNbXCJHRVRfQ09ORklHXCJdID0gXCJkZXBsb3kvY29uZmlnXCI7XG4gICAgUHJpbnREZXBsb3lQYXRoc1tcIkNSRUFURV9PQVVUSF9TRVNTSU9OXCJdID0gXCJkZXBsb3kvb2F1dGgvc2Vzc2lvblwiO1xufSkoUHJpbnREZXBsb3lQYXRocyB8fCAoUHJpbnREZXBsb3lQYXRocyA9IHt9KSk7XG5leHBvcnQgY29uc3QgUHJpbnREZXBsb3lVbmF1dGhvcml6ZWRFcnJvciA9ICdVbmF1dGhvcml6ZWQnO1xuY2xhc3MgUERDbGllbnQge1xuICAgIGNvbnN0cnVjdG9yKHNlcnZlckJhc2VVUkwsIG9hdXRoUHJvdmlkZXJzLCBlbmNyeXB0aW9uU2VydmljZSkge1xuICAgICAgICB0aGlzLmVuY3J5cHRpb25TZXJ2aWNlID0gZW5jcnlwdGlvblNlcnZpY2U7XG4gICAgICAgIHRoaXMucHJvdmlkZXJzID0gb2F1dGhQcm92aWRlcnM7XG4gICAgICAgIHRoaXMuc2VydmVyQmFzZVVSTCA9IHNlcnZlckJhc2VVUkw7XG4gICAgfVxuICAgIGFzeW5jIGxvZ2luKGNyZWRlbnRpYWxzKSB7XG4gICAgICAgIGNvbnN0IHVzZXJuYW1lID0gY3JlZGVudGlhbHMudXNlcm5hbWU7XG4gICAgICAgIGNvbnN0IHBhc3N3b3JkID0gY3JlZGVudGlhbHMucGFzc3dvcmQ7XG4gICAgICAgIGlmICghdXNlcm5hbWUgfHwgIXBhc3N3b3JkKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ21pc3NpbmcgcmVxdWlyZWQgdXNlcm5hbWUvcGFzc3dvcmQgdG8gZ2V0IFBhcGVyQ3V0IHRva2VuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuZ2VuZXJhdGVIZWFkZXJzKCksXG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIGJvZHk6IHRoaXMuZW5jcnlwdGlvblNlcnZpY2UuZW5jcnlwdFJlcXVlc3RCb2R5KHsgdXNlcm5hbWUsIHBhc3N3b3JkIH0pLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZmV0Y2goYCR7dGhpcy5zZXJ2ZXJCYXNlVVJMfS8ke1ByaW50RGVwbG95UGF0aHMuTE9HSU59YCwgcmVxdWVzdClcbiAgICAgICAgICAgIC50aGVuKHIgPT4gZ2V0UmVzcG9uc2VCb2R5KHIpKVxuICAgICAgICAgICAgLnRoZW4oKGJvZHkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYXV0aE1ldGhvZDogUHJpbnREZXBsb3lBdXRoTWV0aG9kcy5Vc2VybmFtZSxcbiAgICAgICAgICAgICAgICB0b2tlbjogYm9keS5Ub2tlbixcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBnZXRDb25maWcoKSB7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB0aGlzLmdlbmVyYXRlSGVhZGVycygpO1xuICAgICAgICByZXR1cm4gZmV0Y2goYCR7dGhpcy5zZXJ2ZXJCYXNlVVJMfS8ke1ByaW50RGVwbG95UGF0aHMuR0VUX0NPTkZJR31gLCB7IGhlYWRlcnMgfSlcbiAgICAgICAgICAgIC50aGVuKHIgPT4gZ2V0UmVzcG9uc2VCb2R5KHIpKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0UHJpbnRlcnModG9rZW5JbmZvLCBjbGllbnRJbmZvKSB7XG4gICAgICAgIGNvbnN0IGZldGNoUHJpbnRlcnMgPSAoY2xpZW50SW5mbykgPT4ge1xuICAgICAgICAgICAgY29uc3QgaGVhZGVycyA9IHRoaXMuZ2VuZXJhdGVIZWFkZXJzKHRva2VuSW5mbyk7XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgYm9keTogdGhpcy5lbmNyeXB0aW9uU2VydmljZS5lbmNyeXB0UmVxdWVzdEJvZHkoY2xpZW50SW5mbyksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGZldGNoKGAke3RoaXMuc2VydmVyQmFzZVVSTH0vJHtQcmludERlcGxveVBhdGhzLkdFVF9QUklOVEVSU31gLCByZXF1ZXN0KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGZldGNoUHJpbnRlcnMoY2xpZW50SW5mbylcbiAgICAgICAgICAgIC50aGVuKGhhbmRsZUludmFsaWRUb2tlbilcbiAgICAgICAgICAgIC50aGVuKHJlc3AgPT4gZ2V0UmVzcG9uc2VCb2R5KHJlc3ApKVxuICAgICAgICAgICAgLnRoZW4oKGJvZHkpID0+IGJvZHkucHJpbnRlcnMpO1xuICAgICAgICBmdW5jdGlvbiBoYW5kbGVJbnZhbGlkVG9rZW4ocmVzcCkge1xuICAgICAgICAgICAgaWYgKHJlc3Auc3RhdHVzID09PSA0MDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoUHJpbnREZXBsb3lVbmF1dGhvcml6ZWRFcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3ApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGNyZWF0ZU9BdXRoU2Vzc2lvbihwcm92aWRlcklEKSB7XG4gICAgICAgIGNvbnN0IG9BdXRoUHJvdmlkZXIgPSB0aGlzLnByb3ZpZGVycy5nZXQocHJvdmlkZXJJRCk7XG4gICAgICAgIGlmICghb0F1dGhQcm92aWRlcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignbm8gc3VjaCBwcm92aWRlcicpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGBubyByZWdpc3RlcmVkIHByb3ZpZGVyIGZvciBwcm92aWRlcklEPSR7cHJvdmlkZXJJRH1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvQXV0aFRva2VuID0gYXdhaXQgb0F1dGhQcm92aWRlci5nZXRBY2Nlc3NUb2tlbigpO1xuICAgICAgICBjb25zdCB1cmwgPSBgJHt0aGlzLnNlcnZlckJhc2VVUkx9LyR7UHJpbnREZXBsb3lQYXRocy5DUkVBVEVfT0FVVEhfU0VTU0lPTn1gO1xuICAgICAgICBjb25zdCByZXFCb2R5ID0ge1xuICAgICAgICAgICAgcHJvdmlkZXJJZDogcHJvdmlkZXJJRCxcbiAgICAgICAgICAgIGFjY2Vzc1Rva2VuOiBvQXV0aFRva2VuLmFjY2Vzc1Rva2VuLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZmV0Y2godXJsLCB7XG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuZ2VuZXJhdGVIZWFkZXJzKCksXG4gICAgICAgICAgICBib2R5OiB0aGlzLmVuY3J5cHRpb25TZXJ2aWNlLmVuY3J5cHRSZXF1ZXN0Qm9keShyZXFCb2R5KSxcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKChyZXNwKSA9PiB7XG4gICAgICAgICAgICBpZiAocmVzcC5zdGF0dXMgPT09IDQwMykge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgnVW5rbm93biB1c2VyJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZ2V0UmVzcG9uc2VCb2R5KHJlc3ApO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oYXN5bmMgKGJvZHkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNlc3Npb25JbmZvID0ge1xuICAgICAgICAgICAgICAgIHByb3ZpZGVySUQ6IHByb3ZpZGVySUQsXG4gICAgICAgICAgICAgICAgdXNlcm5hbWU6IGJvZHkudXNlcm5hbWUsXG4gICAgICAgICAgICAgICAgc2Vzc2lvblRva2VuOiBib2R5LnNlc3Npb25Ub2tlbixcbiAgICAgICAgICAgICAgICBvYXV0aFRva2VuOiBvQXV0aFRva2VuLFxuICAgICAgICAgICAgICAgIGVtYWlsOiBib2R5LmVtYWlsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoc2Vzc2lvbkluZm8pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0U2VydmVyQmFzZVVSTCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VydmVyQmFzZVVSTDtcbiAgICB9XG4gICAgZ2VuZXJhdGVIZWFkZXJzKHRva2VuSW5mbykge1xuICAgICAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgICAgICAgQWNjZXB0OiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICBpZiAodG9rZW5JbmZvKSB7XG4gICAgICAgICAgICBjb25zdCBoZWFkZXIgPSBgQmVhcmVyICR7dG9rZW5JbmZvLnRva2VufWA7XG4gICAgICAgICAgICBoZWFkZXJzWydBdXRob3JpemF0aW9uJ10gPSB0aGlzLmVuY3J5cHRpb25TZXJ2aWNlLmVuY3J5cHRBdXRoSGVhZGVyVmFsdWUoaGVhZGVyKTtcbiAgICAgICAgICAgIGlmICh0b2tlbkluZm8uYXV0aE1ldGhvZCAhPT0gUHJpbnREZXBsb3lBdXRoTWV0aG9kcy5Vc2VybmFtZSkge1xuICAgICAgICAgICAgICAgIGhlYWRlcnNbJ1ByaW50RGVwbG95QXV0aGVudGljYXRpb25UeXBlJ10gPSB0b2tlbkluZm8uYXV0aE1ldGhvZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGVhZGVycztcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBsb2cgfSBmcm9tIFwiLi4vbG9nXCI7XG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2hyb21lT1NWZXJzaW9uKCkge1xuICAgIGNvbnN0IHZlcnNpb25TdHJpbmcgPSBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9DaHJvbWVcXC8oXFxTKykvKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2ZXJzaW9uU3RyaW5nKSAmJiB2ZXJzaW9uU3RyaW5nLmxlbmd0aCA9PT0gMikge1xuICAgICAgICByZXR1cm4gdmVyc2lvblN0cmluZ1sxXTtcbiAgICB9XG4gICAgcmV0dXJuICd1bmtub3duJztcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRDaHJvbWVPU1ZlcnNpb25NYWpvcigpIHtcbiAgICBjb25zdCBjaHJvbWVPU1ZlcnNpb24gPSBnZXRDaHJvbWVPU1ZlcnNpb24oKTtcbiAgICBjb25zdCBtVmVyID0gY2hyb21lT1NWZXJzaW9uLmluZGV4T2YoJy4nKTtcbiAgICByZXR1cm4gcGFyc2VJbnQoY2hyb21lT1NWZXJzaW9uLnN1YnN0cmluZygwLCBtVmVyICE9IC0xID8gbVZlciA6IGNocm9tZU9TVmVyc2lvbi5sZW5ndGgpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRQbGF0Zm9ybUluZm8oKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIGNocm9tZS5ydW50aW1lLmdldFBsYXRmb3JtSW5mbygocGxhdGZvcm1JbmZvKSA9PiB7XG4gICAgICAgICAgICByZXNvbHZlKHBsYXRmb3JtSW5mbyk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldEluc3RhbmNlSWQoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIGNocm9tZS5pbnN0YW5jZUlELmdldElEKChpZCkgPT4ge1xuICAgICAgICAgICAgcmVzb2x2ZShpZCk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldEFzc2V0SWQoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIGlmIChjaHJvbWUuZW50ZXJwcmlzZSAmJiBjaHJvbWUuZW50ZXJwcmlzZS5kZXZpY2VBdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICBjaHJvbWUuZW50ZXJwcmlzZS5kZXZpY2VBdHRyaWJ1dGVzLmdldERldmljZUFzc2V0SWQoKGFzc2V0SWQpID0+IHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKGFzc2V0SWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2coJ1tnZXRBc3NldElkXSBlbnRlcnByaXNlLmRldmljZUF0dHJpYnV0ZXMgbm90IGF2YWlsYWJsZScpO1xuICAgICAgICAgICAgcmVzb2x2ZSh1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4iLCJpbXBvcnQgeyBlcnJvciwgbG9nLCB3YXJuIH0gZnJvbSAnLi4vLi4vbG9nJztcbmltcG9ydCB7IGlzSVB2NCB9IGZyb20gJy4uLy4uL25ldHdvcmsnO1xuaW1wb3J0IHsgZ2V0Q2hyb21lT1NWZXJzaW9uLCBnZXRDaHJvbWVPU1ZlcnNpb25NYWpvciB9IGZyb20gJy4uL3J1bnRpbWUnO1xuY29uc3Qgc2VydmljZVR5cGUgPSAnX2JhbmtzaWEuX3RjcC5sb2NhbCc7XG5jb25zdCBtaW5DaHJvbWVWZXJzaW9uID0gMTE0O1xuY29uc3QgcmVxdWlyZWRDaHJvbWVNZXNzYWdlID0gYENocm9tZSAke21pbkNocm9tZVZlcnNpb259KyByZXF1aXJlZC4gQ2hyb21lIHZlcnNpb246ICR7Z2V0Q2hyb21lT1NWZXJzaW9uKCl9YDtcbmZ1bmN0aW9uIGlzU3VwcG9ydGVkQ2hyb21lVmVyc2lvbigpIHtcbiAgICByZXR1cm4gZ2V0Q2hyb21lT1NWZXJzaW9uTWFqb3IoKSA+PSBtaW5DaHJvbWVWZXJzaW9uO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldExvY2FsSVBBZGRyZXNzZXMoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoaXNTdXBwb3J0ZWRDaHJvbWVWZXJzaW9uKCkpIHtcbiAgICAgICAgICAgICAgICBjaHJvbWUuc3lzdGVtLm5ldHdvcmsuZ2V0TmV0d29ya0ludGVyZmFjZXMoKGludGVyZmFjZXMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9jYWxJUEFkZHJlc3NlcyA9IGludGVyZmFjZXMubWFwKChpKSA9PiBpLmFkZHJlc3MpLmZpbHRlcihpc0lQdjQpO1xuICAgICAgICAgICAgICAgICAgICBsb2coJ1tsb2NhbElQQWRkcmVzc2VzXSBkZXRlY3RlZDogJywgbG9jYWxJUEFkZHJlc3Nlcyk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUobG9jYWxJUEFkZHJlc3Nlcyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9nKCdbbG9jYWxJUEFkZHJlc3Nlc10gQ2hyb21lIHZlcnNpb24gbm90IHN1cHBvcnRlZC4nLCByZXF1aXJlZENocm9tZU1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBlcnJvcignW2xvY2FsSVBBZGRyZXNzZXNdIGNocm9tZS5zeXN0ZW0ubmV0d29yay5nZXROZXR3b3JrSW50ZXJmYWNlcyBmYWlsZWQuJywgZS5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICB3YXJuKCdbbG9jYWxJUEFkZHJlc3Nlc10gTG9jYWwgSVAgYWRkcmVzcyB1bmtub3duIGZhbGxpbmcgYmFjayB0byBbMC4wLjAuMF0uJyk7XG4gICAgICAgIHJlc29sdmUoWycwLjAuMC4wJ10pO1xuICAgIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHN0YXJ0TUROU0xpc3RlbmVyKG9uU2VydmljZUxpc3QpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAoaXNTdXBwb3J0ZWRDaHJvbWVWZXJzaW9uKCkpIHtcbiAgICAgICAgICAgIGNocm9tZS5tZG5zLm9uU2VydmljZUxpc3QuYWRkTGlzdGVuZXIob25TZXJ2aWNlTGlzdCwgeyBzZXJ2aWNlVHlwZSB9KTtcbiAgICAgICAgICAgIHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICAgICAgICBjaHJvbWUubWRucy5vblNlcnZpY2VMaXN0LnJlbW92ZUxpc3RlbmVyKG9uU2VydmljZUxpc3QpO1xuICAgICAgICAgICAgICAgIGNocm9tZS5tZG5zLm9uU2VydmljZUxpc3QuYWRkTGlzdGVuZXIob25TZXJ2aWNlTGlzdCwgeyBzZXJ2aWNlVHlwZSB9KTtcbiAgICAgICAgICAgICAgICBjaHJvbWUubWRucy5mb3JjZURpc2NvdmVyeSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxvZygnW01ETlM6bWRuc0xpc3RlbmVyXSByYW4gcmUtZGlzY292ZXJ5Li4uJyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCA2MDAwICogMTAwMCk7XG4gICAgICAgICAgICBsb2coJ1tNRE5TOm1kbnNMaXN0ZW5lcl0gcmVnaXN0ZXJlZC4uLicpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9nKCdbTUROUzptZG5zTGlzdGVuZXJdIENocm9tZSB2ZXJzaW9uIG5vdCBzdXBwb3J0ZWQuJywgcmVxdWlyZWRDaHJvbWVNZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBlcnJvcignY2hyb21lLm1kbnMub25TZXJ2aWNlTGlzdCBmYWlsZWQuJywgZS5tZXNzYWdlKTtcbiAgICB9XG4gICAgd2FybignbUROUyBkaXNjb3Zlcnkgd2lsbCBub3Qgd29yayBvbiB0aGlzIGNsaWVudC4nKTtcbn1cbiIsImltcG9ydCB7IGdldExvY2FsSVBBZGRyZXNzZXMgfSBmcm9tICcuLi8uLi9jaHJvbWUvbmV0d29yayc7XG5pbXBvcnQgeyBnZXRDaHJvbWVPU1ZlcnNpb24sIGdldFBsYXRmb3JtSW5mbywgZ2V0QXNzZXRJZCB9IGZyb20gJy4uLy4uL2Nocm9tZS9ydW50aW1lJztcbmltcG9ydCB7IEdldENsaWVudFZlcnNpb25JRCB9IGZyb20gJy4uLy4uL2dsb2JhbHMnO1xuaW1wb3J0IHsgZ2V0Q2xpZW50SWQgfSBmcm9tICcuLi8uLi9pZGVudGl0eSc7XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q2xpZW50SW5mbygpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoW2dldENsaWVudElkKCksIGdldFBsYXRmb3JtSW5mbygpLCBnZXRMb2NhbElQQWRkcmVzc2VzKCksIGdldEFzc2V0SWQoKV0pXG4gICAgICAgIC50aGVuKChbY2xpZW50SWQsIHBsYXRmb3JtSW5mbywgaXBBZGRyZXNzZXMsIGFzc2V0SURdKSA9PiB7XG4gICAgICAgIGNvbnN0IGNocm9tZUFwcEV4dFZlcnNpb24gPSBHZXRDbGllbnRWZXJzaW9uSUQoKTtcbiAgICAgICAgY29uc3QgY2hyb21lT1NWZXJzaW9uID0gZ2V0Q2hyb21lT1NWZXJzaW9uKCk7XG4gICAgICAgIGNvbnN0IGNsaWVudEluZm8gPSB7XG4gICAgICAgICAgICBtYWNoaW5lOiB7XG4gICAgICAgICAgICAgICAgaG9zdG5hbWU6IGNsaWVudElkLFxuICAgICAgICAgICAgICAgIG9zOiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdjaHJvbWUnLFxuICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uOiBjaHJvbWVPU1ZlcnNpb24sXG4gICAgICAgICAgICAgICAgICAgIGFyY2g6IHBsYXRmb3JtSW5mby5hcmNoLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaXBBZGRyZXNzZXM6IGlwQWRkcmVzc2VzLFxuICAgICAgICAgICAgICAgIGFjdGl2ZURpcmVjdG9yeURvbWFpbk5hbWU6ICcnLFxuICAgICAgICAgICAgICAgIGNocm9tZUFwcEV4dFZlcnNpb246IGNocm9tZUFwcEV4dFZlcnNpb24sXG4gICAgICAgICAgICAgICAgYXNzZXRJRDogYXNzZXRJRCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBjbGllbnRJbmZvO1xuICAgIH0pO1xufVxuIiwiZXhwb3J0ICogZnJvbSAnLi9jbGllbnQnO1xuZXhwb3J0ICogZnJvbSAnLi9jbGllbnRpbmZvJztcbmV4cG9ydCAqIGZyb20gJy4vZW5jcnlwdGlvbic7XG4iLCJpbXBvcnQgeyBnZXRMb2NhbFN0b3JhZ2VEYXRhLCBzZXRMb2NhbFN0b3JhZ2VEYXRhIH0gZnJvbSAnLi4vc3RvcmFnZSc7XG5jb25zdCBPQVVUSF9TRVNTSU9OX1RPS0VOX0tFWSA9ICdPYXV0aFNlc3Npb24nO1xuY29uc3QgUFJJTlRfREVQTE9ZX0FVVEhfUkVQTyA9ICdwcmludERlcGxveUF1dGhSZXBvJztcbmNvbnN0IFBSSU5UX0RFUExPWV9DT05GSUdfS0VZID0gJ3ByaW50RGVwbG95Q29uZmlnJztcbmNvbnN0IFBBUEVSQ1VUX0FVVEhfS0VZID0gJ3BhcGVyY3V0QXV0aENvb2tpZSc7XG5jbGFzcyBQcmludERlcGxveUxvY2FsU3RvcmFnZSB7XG4gICAgYXN5bmMgZ2V0Q2FjaGVkQ29uZmlnKCkge1xuICAgICAgICByZXR1cm4gZ2V0TG9jYWxTdG9yYWdlRGF0YShQUklOVF9ERVBMT1lfQ09ORklHX0tFWSk7XG4gICAgfVxuICAgIGdldENhY2hlZE9BdXRoU2Vzc2lvblRva2VuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDYWNoZWRBdXRoVG9rZW4oT0FVVEhfU0VTU0lPTl9UT0tFTl9LRVkpO1xuICAgIH1cbiAgICBnZXRDYWNoZWRQcmludERlcGxveVRva2VuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDYWNoZWRBdXRoVG9rZW4oUEFQRVJDVVRfQVVUSF9LRVkpO1xuICAgIH1cbiAgICBhc3luYyBnZXRDYWNoZWRNb2JpbGl0eVByaW50U2VydmVyVG9rZW4oc2VydmVyQmFzZVVybCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDYWNoZWRBdXRoVG9rZW4oc2VydmVyQmFzZVVybCk7XG4gICAgfVxuICAgIGFzeW5jIGNhY2hlQ29uZmlnKGNvbmZpZykge1xuICAgICAgICByZXR1cm4gc2V0TG9jYWxTdG9yYWdlRGF0YShQUklOVF9ERVBMT1lfQ09ORklHX0tFWSwgY29uZmlnKTtcbiAgICB9XG4gICAgYXN5bmMgY2FjaGVNb2JpbGl0eVByaW50U2VydmVyVG9rZW4oc2VydmVyQmFzZVVybCwgdG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVBdXRoVG9rZW4oc2VydmVyQmFzZVVybCwgdG9rZW4pO1xuICAgIH1cbiAgICBhc3luYyBjYWNoZVBhcGVyQ3V0VG9rZW4odG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVBdXRoVG9rZW4oUEFQRVJDVVRfQVVUSF9LRVksIHRva2VuKTtcbiAgICB9XG4gICAgYXN5bmMgY2FjaGVPQXV0aFNlc3Npb25Ub2tlbihzZXNzaW9uVG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVBdXRoVG9rZW4oT0FVVEhfU0VTU0lPTl9UT0tFTl9LRVksIHNlc3Npb25Ub2tlbik7XG4gICAgfVxuICAgIGFzeW5jIHJlbW92ZU1vYmlsaXR5UHJpbnRTZXJ2ZXJUb2tlbihzZXJ2ZXIpIHtcbiAgICAgICAgY29uc3QgYXV0aFJlcG8gPSBhd2FpdCBnZXRMb2NhbFN0b3JhZ2VEYXRhKFBSSU5UX0RFUExPWV9BVVRIX1JFUE8pO1xuICAgICAgICBpZiAoIWF1dGhSZXBvKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHt9KTtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgYXV0aFJlcG9bc2VydmVyXTtcbiAgICAgICAgcmV0dXJuIHNldExvY2FsU3RvcmFnZURhdGEoUFJJTlRfREVQTE9ZX0FVVEhfUkVQTywgYXV0aFJlcG8pO1xuICAgIH1cbiAgICBhc3luYyBjYWNoZUF1dGhUb2tlbihrZXksIHZhbHVlKSB7XG4gICAgICAgIGxldCBhdXRoUmVwbyA9IGF3YWl0IGdldExvY2FsU3RvcmFnZURhdGEoUFJJTlRfREVQTE9ZX0FVVEhfUkVQTyk7XG4gICAgICAgIGlmICghYXV0aFJlcG8pIHtcbiAgICAgICAgICAgIGF1dGhSZXBvID0ge307XG4gICAgICAgIH1cbiAgICAgICAgYXV0aFJlcG9ba2V5XSA9IHZhbHVlO1xuICAgICAgICBhd2FpdCBzZXRMb2NhbFN0b3JhZ2VEYXRhKFBSSU5UX0RFUExPWV9BVVRIX1JFUE8sIGF1dGhSZXBvKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZSk7XG4gICAgfVxuICAgIGFzeW5jIGdldENhY2hlZEF1dGhUb2tlbihrZXkpIHtcbiAgICAgICAgcmV0dXJuIGdldExvY2FsU3RvcmFnZURhdGEoUFJJTlRfREVQTE9ZX0FVVEhfUkVQTykudGhlbigoYXV0aFJlcG8pID0+IHtcbiAgICAgICAgICAgIGlmICghYXV0aFJlcG8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGF1dGhSZXBvW2tleV07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpbnZhbGlkYXRlQWxsQ2FjaGVkVG9rZW5zKCkge1xuICAgICAgICByZXR1cm4gc2V0TG9jYWxTdG9yYWdlRGF0YShQUklOVF9ERVBMT1lfQVVUSF9SRVBPLCB7fSk7XG4gICAgfVxufVxuZXhwb3J0IGNvbnN0IHByaW50RGVwbG95U3RvcmFnZSA9IG5ldyBQcmludERlcGxveUxvY2FsU3RvcmFnZSgpO1xuIiwiaW1wb3J0IHsgYXV0aGVudGljYXRlV2l0aEdTdWl0ZUhUVFAsIGVuY3J5cHRDcmVkZW50aWFscywgaW5NZW1vcnlDcmVkcywgaW5NZW1vcnlDcmVkc0F2YWlsYWJsZSwgcmVtZW1iZXJDcmVkc0luTWVtb3J5LCB9IGZyb20gJy4uL2F1dGgnO1xuaW1wb3J0IHsgY2xvc2VMb2dpbkRpYWxvZywgZGlzcGxheUxvZ2luV2luZG93LCBzZW5kRGlzcGxheUVycm9yTWVzc2FnZSB9IGZyb20gJy4uL2NvbnRyb2wnO1xuaW1wb3J0IHsgZ2V0UmVzcG9uc2VCb2R5IH0gZnJvbSAnLi4vaHR0cCc7XG5pbXBvcnQgeyBsb2cgfSBmcm9tICcuLi9sb2cnO1xuaW1wb3J0IHsgZ2V0VXJsQmFzZU9mUHJpbnRlclVybCB9IGZyb20gJy4uL3ByaW50ZXInO1xuaW1wb3J0IHsgZ2V0TWFuYWdlZFN0b3JhZ2VEYXRhIH0gZnJvbSAnLi4vc3RvcmFnZSc7XG5pbXBvcnQgeyBnZXRDbGllbnRJbmZvLCBQcmludERlcGxveUNsaWVudEJ1aWxkZXIsIFByaW50RGVwbG95VW5hdXRob3JpemVkRXJyb3IgfSBmcm9tICcuL2NsaWVudCc7XG5pbXBvcnQgeyBPQXV0aFByb3ZpZGVySURzLCBwcmludERlcGxveU9hdXRoUHJvdmlkZXJzLCB0b1ByaW50RGVwbG95VG9rZW5JbmZvLCB9IGZyb20gJy4vb2F1dGgnO1xuaW1wb3J0IHsgUHJpbnREZXBsb3lBdXRoTWV0aG9kcywgfSBmcm9tICcuL3ByaW50ZGVwbG95LnR5cGVzJztcbmltcG9ydCB7IHByaW50RGVwbG95U3RvcmFnZSB9IGZyb20gJy4vc3RvcmFnZSc7XG5leHBvcnQgdmFyIE1hbmFnZWRTdG9yYWdlS2V5cztcbihmdW5jdGlvbiAoTWFuYWdlZFN0b3JhZ2VLZXlzKSB7XG4gICAgTWFuYWdlZFN0b3JhZ2VLZXlzW1wiUHJpbnREZXBsb3lTZXJ2ZXJIb3N0c1wiXSA9IFwiUHJpbnREZXBsb3lTZXJ2ZXJIb3N0c1wiO1xuICAgIE1hbmFnZWRTdG9yYWdlS2V5c1tcIkFjY2Vzc2libGVQcmludERlcGxveVRMU1BvcnRcIl0gPSBcIkFjY2Vzc2libGVQcmludERlcGxveVRMU1BvcnRcIjtcbiAgICBNYW5hZ2VkU3RvcmFnZUtleXNbXCJTdHJpY3RTU0xDaGVja2luZ0VuYWJsZWRcIl0gPSBcIlN0cmljdFNTTENoZWNraW5nRW5hYmxlZFwiO1xufSkoTWFuYWdlZFN0b3JhZ2VLZXlzIHx8IChNYW5hZ2VkU3RvcmFnZUtleXMgPSB7fSkpO1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFByaW50ZXJzRnJvbVByaW50RGVwbG95KCkge1xuICAgIGNvbnN0IHBkSG9zdCA9IGF3YWl0IGdldFByZWNvbmZpZ3VyZWRQcmludERlcGxveVNlcnZlcigpO1xuICAgIGlmICghcGRIb3N0KSB7XG4gICAgICAgIGxvZygnW2dldFByZWNvbmZpZ3VyZWRQcmludERlcGxveVNlcnZlcl0gbm8gUHJpbnQgRGVwbG95IHNlcnZlcnMgcHJlY29uZmlndXJlZCcpO1xuICAgICAgICByZXR1cm4gW1tdLCBmYWxzZV07XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGxvZygnW2dldFByaW50ZXJzRnJvbVByaW50RGVwbG95XSBmb3VuZCBQcmludCBEZXBsb3kgc2VydmVyOicsIHBkSG9zdCk7XG4gICAgICAgIGNvbnN0IHByaW50ZXJzID0gYXdhaXQgZ2V0UHJpbnRlcnNGcm9tUHJpbnREZXBsb3lIb3N0KHBkSG9zdCk7XG4gICAgICAgIHJldHVybiBbcHJpbnRlcnMsIHRydWVdO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBsb2coJ1tnZXRQcmludGVyc0Zyb21QcmludERlcGxveUhvc3RdIGZhaWxlZCB0byBnZXQgcHJpbnRlcnM6JywgZSk7XG4gICAgICAgIHJldHVybiBbW10sIHRydWVdO1xuICAgIH1cbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRQcmVjb25maWd1cmVkUHJpbnREZXBsb3lTZXJ2ZXIoKSB7XG4gICAgcmV0dXJuIGdldE1hbmFnZWRTdG9yYWdlRGF0YShNYW5hZ2VkU3RvcmFnZUtleXMuUHJpbnREZXBsb3lTZXJ2ZXJIb3N0cykudGhlbihob3N0cyA9PiB7XG4gICAgICAgIGlmICghaG9zdHMgfHwgaG9zdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaG9zdHNbMF07XG4gICAgfSk7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0UHJpbnREZXBsb3lDbGllbnQocGRIb3N0KSB7XG4gICAgY29uc3Qgc3RyaWN0U1NMQ2hlY2tpbmdFbmFibGVkID0gYXdhaXQgZ2V0TWFuYWdlZFN0b3JhZ2VEYXRhKE1hbmFnZWRTdG9yYWdlS2V5cy5TdHJpY3RTU0xDaGVja2luZ0VuYWJsZWQpO1xuICAgIGNvbnN0IGFjY2Vzc2libGVUTFNQb3J0ID0gYXdhaXQgZ2V0TWFuYWdlZFN0b3JhZ2VEYXRhKE1hbmFnZWRTdG9yYWdlS2V5cy5BY2Nlc3NpYmxlUHJpbnREZXBsb3lUTFNQb3J0KTtcbiAgICBjb25zdCBwZENsaWVudCA9IGF3YWl0IG5ldyBQcmludERlcGxveUNsaWVudEJ1aWxkZXIocGRIb3N0KVxuICAgICAgICAud2l0aEFjY2Vzc2libGVUTFNQb3J0KGFjY2Vzc2libGVUTFNQb3J0KVxuICAgICAgICAud2l0aFN0cmljdFNTTChzdHJpY3RTU0xDaGVja2luZ0VuYWJsZWQpXG4gICAgICAgIC53aXRoT0F1dGhQcm92aWRlcnMocHJpbnREZXBsb3lPYXV0aFByb3ZpZGVycylcbiAgICAgICAgLmJ1aWxkKCk7XG4gICAgbG9nKGBbcHJpbnREZXBsb3lDbGllbnRCdWlsZGVyXSBidWlsdCBQRENsaWVudCB3aXRoIHNlcnZlckJhc2VVUkw9JHtwZENsaWVudC5nZXRTZXJ2ZXJCYXNlVVJMKCl9YCk7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShwZENsaWVudCk7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRQcmludGVyc0Zyb21QcmludERlcGxveUhvc3QocGRIb3N0KSB7XG4gICAgY29uc3QgcGRDbGllbnQgPSBhd2FpdCBnZXRQcmludERlcGxveUNsaWVudChwZEhvc3QpO1xuICAgIGxldCBjbGllbnRDb25maWc7XG4gICAgdHJ5IHtcbiAgICAgICAgY2xpZW50Q29uZmlnID0gYXdhaXQgcGRDbGllbnQuZ2V0Q29uZmlnKCk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGxvZygnW3BkQ2xpZW50LmdldENvbmZpZ10gZmFpbGVkIHRvIGZldGNoIGNvbmZpZycsIGUpO1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGxvZygnW3BkQ2xpZW50LmdldENvbmZpZ10gcmVjZWl2ZWQgY29uZmlnIGZyb20gc2VydmVyOicsIGNsaWVudENvbmZpZyk7XG4gICAgYXdhaXQgcHJpbnREZXBsb3lTdG9yYWdlLmNhY2hlQ29uZmlnKGNsaWVudENvbmZpZyk7XG4gICAgcmV0dXJuIGdldFByaW50ZXJzRm9yQ2xpZW50KHBkQ2xpZW50KVxuICAgICAgICAudGhlbihnZXRBbmRTYXZlVG9rZW5zRm9yUHJpbnRlcnMpXG4gICAgICAgIC50aGVuKG1hcFByaW50ZXJzRm9yUHJpbnRQcm92aWRlcik7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRBbmRTYXZlVG9rZW5zRm9yUHJpbnRlcnMocHJpbnRlcnMpIHtcbiAgICBsb2coJ1tnZXRBbmRTYXZlVG9rZW5zRm9yUHJpbnRlcnNdJywgcHJpbnRlcnMpO1xuICAgIGNvbnN0IGNsaWVudENvbmZpZyA9IGF3YWl0IHByaW50RGVwbG95U3RvcmFnZS5nZXRDYWNoZWRDb25maWcoKTtcbiAgICBjb25zdCBtcFNlcnZlcnMgPSBwcmludGVycy5tYXAoKHByaW50ZXIpID0+IHtcbiAgICAgICAgcmV0dXJuIGdldFNlY3VyZVVSTEZvck1QU2VydmVyKGdldFVybEJhc2VPZlByaW50ZXJVcmwocHJpbnRlci5jb25uZWN0aW9uLm5hbWUpLCBjbGllbnRDb25maWcpO1xuICAgIH0pO1xuICAgIGNvbnN0IHVuaXF1ZU1QU2VydmVycyA9IEFycmF5LmZyb20obmV3IFNldChtcFNlcnZlcnMpKTtcbiAgICBsb2coYFtwcmludGRlcGxveS51bmlxdWVNUFNlcnZlcnNdIGZvdW5kICR7dW5pcXVlTVBTZXJ2ZXJzLmxlbmd0aH0gdW5pcXVlIE1QIHNlcnZlcnMgZnJvbSB0aGUgZGlzY292ZXJlZCBxdWV1ZXNgLCB1bmlxdWVNUFNlcnZlcnMpO1xuICAgIHJldHVybiBQcm9taXNlLmFsbCh1bmlxdWVNUFNlcnZlcnMubWFwKGdldE1vYmlsaXR5UHJpbnRUb2tlbklmTWlzc2luZykpLnRoZW4oKCkgPT4gcHJpbnRlcnMpO1xuICAgIGFzeW5jIGZ1bmN0aW9uIGdldE1vYmlsaXR5UHJpbnRUb2tlbklmTWlzc2luZyhtcFNlcnZlclVSTCkge1xuICAgICAgICByZXR1cm4gcHJpbnREZXBsb3lTdG9yYWdlLmdldENhY2hlZE1vYmlsaXR5UHJpbnRTZXJ2ZXJUb2tlbihtcFNlcnZlclVSTClcbiAgICAgICAgICAgIC50aGVuKCh0b2tlbikgPT4gKHRva2VuID8gdG9rZW4gOiBmZXRjaFRva2VuRnJvbU1vYmlsaXR5UHJpbnRTZXJ2ZXIobXBTZXJ2ZXJVUkwsIGluTWVtb3J5Q3JlZHMpKSlcbiAgICAgICAgICAgIC50aGVuKCh0b2tlbikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGluTWVtb3J5Q3JlZHMucmVtZW1iZXJNZSA/IHByaW50RGVwbG95U3RvcmFnZS5jYWNoZU1vYmlsaXR5UHJpbnRTZXJ2ZXJUb2tlbihtcFNlcnZlclVSTCwgdG9rZW4pIDogdG9rZW47XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgIGxvZyhgW2dldE1vYmlsaXR5UHJpbnRUb2tlbl0gZmFpbGVkIHRvIGdldCB0b2tlbiBmb3IgTVAgc2VydmVyICR7bXBTZXJ2ZXJVUkx9IHZpYSBIVFRQUy4gVGhpcyBtYXkgaGFwcGVuIGAgK1xuICAgICAgICAgICAgICAgICdpZiB0aGUgTVAgc2VydmVyIGlzblxcJ3QgdXNpbmcgYSBub24temVybyBsZW5ndGggQ0Etc2lnbmVkIGNlcnRpZmljYXRlLiBXZSB3aWxsIHVzZSBlbmNyeXB0ZWQgSFRUUCAnICtcbiAgICAgICAgICAgICAgICAnaW5zdGVhZC4gZXJyb3I6JywgZS5tZXNzYWdlIHx8IGUpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFNlY3VyZVVSTEZvck1QU2VydmVyKG1wU2VydmVyVVJMLCBjb25maWcpIHtcbiAgICBjb25zdCBzZXJ2ZXIgPSBtcFNlcnZlclVSTC5yZXBsYWNlKC9odHRwOi9naSwgJ2h0dHBzOicpO1xuICAgIGxldCB0bHNQb3J0ID0gY29uZmlnPy5BY2Nlc3NpYmxlTW9iaWxpdHlQcmludFRMU1BvcnQ7XG4gICAgaWYgKCF0bHNQb3J0IHx8IHRsc1BvcnQgPT0gMCkge1xuICAgICAgICB0bHNQb3J0ID0gOTE2NDtcbiAgICB9XG4gICAgcmV0dXJuIHNlcnZlci5yZXBsYWNlKC86OTE2My9naSwgYDoke3Rsc1BvcnR9YCk7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRQcmludGVyc0ZvckNsaWVudChwZENsaWVudCkge1xuICAgIGNvbnN0IGZldGNoUHJpbnRlcnMgPSAoKSA9PiB7XG4gICAgICAgIGxvZygnW2ZldGNoUHJpbnRlcnNdIGdldHRpbmcgcHJpbnQgZGVwbG95IHRva2VuJyk7XG4gICAgICAgIHJldHVybiBnZXRQcmludERlcGxveVRva2VuKHBkQ2xpZW50KS50aGVuKCh0b2tlbkluZm8pID0+IHtcbiAgICAgICAgICAgIHJldHVybiBnZXRDbGllbnRJbmZvKCkudGhlbihjbGllbnRJbmZvID0+IHtcbiAgICAgICAgICAgICAgICBsb2coYFtnZXRQcmludGVyc10gZ2V0dGluZyBwcmludGVycyB3aXRoIHRoZSBmb2xsb3dpbmcgdXNlciBkZXRhaWxzOiAke0pTT04uc3RyaW5naWZ5KGNsaWVudEluZm8pfWApO1xuICAgICAgICAgICAgICAgIHJldHVybiBwZENsaWVudC5nZXRQcmludGVycyh0b2tlbkluZm8sIGNsaWVudEluZm8pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIGZldGNoUHJpbnRlcnMoKS5jYXRjaChlID0+IHtcbiAgICAgICAgaWYgKGUgPT09IFByaW50RGVwbG95VW5hdXRob3JpemVkRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBwcmludERlcGxveVN0b3JhZ2UuaW52YWxpZGF0ZUFsbENhY2hlZFRva2VucygpLnRoZW4oKCkgPT4gZmV0Y2hQcmludGVycygpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZSk7XG4gICAgfSk7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRQcmludERlcGxveVRva2VuKHBkQ2xpZW50KSB7XG4gICAgY29uc3QgdXNlcm5hbWVUb2tlbiA9IGF3YWl0IHByaW50RGVwbG95U3RvcmFnZS5nZXRDYWNoZWRQcmludERlcGxveVRva2VuKCk7XG4gICAgaWYgKHVzZXJuYW1lVG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGF1dGhNZXRob2Q6IFByaW50RGVwbG95QXV0aE1ldGhvZHMuVXNlcm5hbWUsXG4gICAgICAgICAgICB0b2tlbjogdXNlcm5hbWVUb2tlbixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3Qgb2F1dGhTZXNzaW9uQ3JlZHMgPSBhd2FpdCBwcmludERlcGxveVN0b3JhZ2UuZ2V0Q2FjaGVkT0F1dGhTZXNzaW9uVG9rZW4oKTtcbiAgICBpZiAob2F1dGhTZXNzaW9uQ3JlZHMpIHtcbiAgICAgICAgcmV0dXJuIHRvUHJpbnREZXBsb3lUb2tlbkluZm8ob2F1dGhTZXNzaW9uQ3JlZHMpO1xuICAgIH1cbiAgICBsb2coJ1toYW5kbGVNaXNzaW5nUGFwZXJDdXRUb2tlbl0gY2hlY2tpbmcgaW4gbWVtb3J5IGNyZWRzJyk7XG4gICAgaWYgKGluTWVtb3J5Q3JlZHNBdmFpbGFibGUoKSkge1xuICAgICAgICByZXR1cm4gcGRDbGllbnQubG9naW4oaW5NZW1vcnlDcmVkcykuY2F0Y2goKCkgPT4gYXNrVXNlclRvQXV0aGVudGljYXRlRm9yUHJpbnREZXBsb3kocGRDbGllbnQpKTtcbiAgICB9XG4gICAgbG9nKCdbaGFuZGxlTWlzc2luZ1BhcGVyQ3V0VG9rZW5dIGluIG1lbW9yeSBjcmVkcyB1bmF2YWlsYWJsZScpO1xuICAgIHJldHVybiBhc2tVc2VyVG9BdXRoZW50aWNhdGVGb3JQcmludERlcGxveShwZENsaWVudCk7XG59XG5hc3luYyBmdW5jdGlvbiBmZXRjaFRva2VuRnJvbU1vYmlsaXR5UHJpbnRTZXJ2ZXIobXBTZXJ2ZXJCYXNlVXJsLCBjcmVkZW50aWFscykge1xuICAgIGNvbnN0IHsgdXNlcm5hbWUsIHBhc3N3b3JkIH0gPSBjcmVkZW50aWFscztcbiAgICBpZiAoIXVzZXJuYW1lIHx8ICFwYXNzd29yZCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ21pc3NpbmcgcmVxdWlyZWQgdXNlcm5hbWUvcGFzc3dvcmQgdG8gZ2V0IHRva2VuIGZyb20gTW9iaWxpdHkgUHJpbnQgc2VydmVyJyk7XG4gICAgfVxuICAgIGlmIChtcFNlcnZlckJhc2VVcmwuc3RhcnRzV2l0aCgnaHR0cDonKSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ2Nhbm5vdCBnZXQgdG9rZW4gZnJvbSBNUCBzZXJ2ZXIgdXNpbmcgbm9uLUhUVFBTIFVSTCcpO1xuICAgIH1cbiAgICBjb25zdCBhdXRoVXJsID0gYCR7bXBTZXJ2ZXJCYXNlVXJsfS90b2tlbj9wcmludGVyTmFtZT1ub25lYDtcbiAgICBjb25zdCByZXF1ZXN0UGFyYW1zID0ge1xuICAgICAgICBoZWFkZXJzOiB7IEF1dGhvcml6YXRpb246IGBCYXNpYyAke2J0b2EodXNlcm5hbWUgKyAnOicgKyBwYXNzd29yZCl9YCB9LFxuICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgIH07XG4gICAgcmV0dXJuIGZldGNoKGF1dGhVcmwsIHJlcXVlc3RQYXJhbXMpXG4gICAgICAgIC50aGVuKHJlc3AgPT4gZ2V0UmVzcG9uc2VCb2R5KHJlc3ApKVxuICAgICAgICAudGhlbigoYm9keSkgPT4gYm9keS50b2tlbik7XG59XG5hc3luYyBmdW5jdGlvbiBhc2tVc2VyVG9BdXRoZW50aWNhdGVGb3JQcmludERlcGxveShwZENsaWVudCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSwgX3JlamVjdCkgPT4ge1xuICAgICAgICBjaHJvbWUucnVudGltZS5vbk1lc3NhZ2UuYWRkTGlzdGVuZXIob25DcmVkZW50aWFsc0VudGVyZWRGb3JQcmludERlcGxveUhhbmRsZXIocGRDbGllbnQsIHJlc29sdmUpKTtcbiAgICAgICAgY2hyb21lLnJ1bnRpbWUub25NZXNzYWdlLmFkZExpc3RlbmVyKG9uT2F1dGhTZXNzaW9uQ3JlYXRlZEZvclByaW50RGVwbG95SGFuZGxlcihyZXNvbHZlKSk7XG4gICAgICAgIGF3YWl0IHNob3dMb2dpbldpbmRvdygpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gb25DcmVkZW50aWFsc0VudGVyZWRGb3JQcmludERlcGxveUhhbmRsZXIocGRDbGllbnQsIHJlc29sdmUpIHtcbiAgICByZXR1cm4gKG1lc3NhZ2UsIHNlbmRlcikgPT4ge1xuICAgICAgICBpZiAobWVzc2FnZS50eXBlID09PSAnb24tY3JlZGVudGlhbHMtZW50ZXJlZCcpIHtcbiAgICAgICAgICAgIGxvZygnW29uQ3JlZGVudGlhbHNFbnRlcmVkRm9yUHJpbnREZXBsb3lIYW5kbGVyXSBtZXNzYWdlIHJlY2VpdmVkJywgeyBtZXNzYWdlLCBzZW5kZXIgfSk7XG4gICAgICAgICAgICBjb25zdCBjcmVkZW50aWFsc0VudGVyZWQgPSBtZXNzYWdlO1xuICAgICAgICAgICAgb25DcmVkZW50aWFsc0VudGVyZWRGb3JQcmludERlcGxveShjcmVkZW50aWFsc0VudGVyZWQuY3JlZGVudGlhbHMsIHBkQ2xpZW50KS50aGVuKCh0b2tlbkluZm8pID0+IHtcbiAgICAgICAgICAgICAgICBsb2coJ1tvbkNyZWRlbnRpYWxzRW50ZXJlZEZvclByaW50RGVwbG95SGFuZGxlcl0gc3VjY2VlZGVkJywgeyB0b2tlbkluZm8gfSk7XG4gICAgICAgICAgICAgICAgY2hyb21lLnJ1bnRpbWUub25NZXNzYWdlLnJlbW92ZUxpc3RlbmVyKG9uQ3JlZGVudGlhbHNFbnRlcmVkRm9yUHJpbnREZXBsb3lIYW5kbGVyKHBkQ2xpZW50LCByZXNvbHZlKSk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh0b2tlbkluZm8pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSkuY2F0Y2goZSA9PiB7XG4gICAgICAgICAgICAgICAgbG9nKCdlcnJvcicsIHsgZSB9KTtcbiAgICAgICAgICAgICAgICBpZiAoZSA9PT0gUHJpbnREZXBsb3lVbmF1dGhvcml6ZWRFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBwcmludERlcGxveVN0b3JhZ2UuaW52YWxpZGF0ZUFsbENhY2hlZFRva2VucygpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nKCdbb25DcmVkZW50aWFsc0VudGVyZWRGb3JQcmludERlcGxveUhhbmRsZXJdIGNsZWFyZWQgY2FjaGVkIHByaW50IGRlcGxveSB0b2tlbnMnKTtcbiAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZygnW29uQ3JlZGVudGlhbHNFbnRlcmVkRm9yUHJpbnREZXBsb3lIYW5kbGVyXSBlcnJvciBjbGVhcmluZyBwcmludCBkZXBsb3kgdG9rZW5zJywgeyBlIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gcmVzb2x2ZUVycm9yVG9EaXNwbGF5KGUpO1xuICAgICAgICAgICAgICAgIHNlbmREaXNwbGF5RXJyb3JNZXNzYWdlKGVycm9yTWVzc2FnZSkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxvZygnW29uQ3JlZGVudGlhbHNFbnRlcmVkRm9yUHJpbnREZXBsb3lIYW5kbGVyXSBzZW5kRGlzcGxheUVycm9yTWVzc2FnZScpO1xuICAgICAgICAgICAgICAgIH0pLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxvZygnW29uQ3JlZGVudGlhbHNFbnRlcmVkRm9yUHJpbnREZXBsb3lIYW5kbGVyXSAgc2VuZERpc3BsYXlFcnJvck1lc3NhZ2UgZXJyb3I6JywgeyBlIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuYXN5bmMgZnVuY3Rpb24gb25DcmVkZW50aWFsc0VudGVyZWRGb3JQcmludERlcGxveShjcmVkZW50aWFscywgcGRDbGllbnQpIHtcbiAgICByZW1lbWJlckNyZWRzSW5NZW1vcnkoY3JlZGVudGlhbHMpO1xuICAgIHJldHVybiBwZENsaWVudC5sb2dpbihjcmVkZW50aWFscylcbiAgICAgICAgLnRoZW4oYXN5bmMgKHRva2VuSW5mbykgPT4ge1xuICAgICAgICBpZiAoY3JlZGVudGlhbHMucmVtZW1iZXJNZSkge1xuICAgICAgICAgICAgYXdhaXQgcHJpbnREZXBsb3lTdG9yYWdlLmNhY2hlUGFwZXJDdXRUb2tlbih0b2tlbkluZm8udG9rZW4pO1xuICAgICAgICB9XG4gICAgICAgIGNsb3NlTG9naW5EaWFsb2coKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGxvZygnW29uQ3JlZGVudGlhbHNFbnRlcmVkRm9yUHJpbnREZXBsb3ldIGNsb3NlZCBsb2dpbiBkaWFsb2cnKTtcbiAgICAgICAgfSkuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgIGxvZygnW29uQ3JlZGVudGlhbHNFbnRlcmVkRm9yUHJpbnREZXBsb3ldICBlcnJvcjonLCB7IGUgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdG9rZW5JbmZvO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gb25PYXV0aFNlc3Npb25DcmVhdGVkRm9yUHJpbnREZXBsb3lIYW5kbGVyKHJlc29sdmUpIHtcbiAgICByZXR1cm4gKG1lc3NhZ2UsIHNlbmRlcikgPT4ge1xuICAgICAgICBpZiAobWVzc2FnZS50eXBlID09PSAnb2F1dGgtc2Vzc2lvbi1jcmVhdGVkJykge1xuICAgICAgICAgICAgbG9nKCdbb25PYXV0aFNlc3Npb25DcmVhdGVkRm9yUHJpbnREZXBsb3lIYW5kbGVyXSBtZXNzYWdlIHJlY2VpdmVkIGZyb20nLCB7IG1lc3NhZ2UsIHNlbmRlciB9KTtcbiAgICAgICAgICAgIGNvbnN0IG9hdXRoU2Vzc2lvbkNyZWF0ZWQgPSBtZXNzYWdlO1xuICAgICAgICAgICAgbG9nKCdbb25PYXV0aFNlc3Npb25DcmVhdGVkRm9yUHJpbnREZXBsb3lIYW5kbGVyXVJlY2VpdmVkIG1lc3NhZ2Ugb2F1dGhTZXNzaW9uQ3JlYXRlZCcpO1xuICAgICAgICAgICAgb25PQXV0aFNlc3Npb25DcmVhdGVkRm9yUHJpbnREZXBsb3kob2F1dGhTZXNzaW9uQ3JlYXRlZC5yZW1lbWJlck1lLCBvYXV0aFNlc3Npb25DcmVhdGVkLnNlc3Npb25DcmVkZW50aWFscykudGhlbigodG9rZW5JbmZvKSA9PiB7XG4gICAgICAgICAgICAgICAgbG9nKCdvbk9hdXRoU2Vzc2lvbkNyZWF0ZWRGb3JQcmludERlcGxveUhhbmRsZXIgc3VjY2VlZGVkJywgeyB0b2tlbkluZm8gfSk7XG4gICAgICAgICAgICAgICAgY2hyb21lLnJ1bnRpbWUub25NZXNzYWdlLnJlbW92ZUxpc3RlbmVyKG9uT2F1dGhTZXNzaW9uQ3JlYXRlZEZvclByaW50RGVwbG95SGFuZGxlcihyZXNvbHZlKSk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh0b2tlbkluZm8pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSkuY2F0Y2goZSA9PiB7XG4gICAgICAgICAgICAgICAgbG9nKCdlcnJvcicsIHsgZSB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9O1xufVxuYXN5bmMgZnVuY3Rpb24gb25PQXV0aFNlc3Npb25DcmVhdGVkRm9yUHJpbnREZXBsb3kocmVtZW1iZXJNZSwgc2Vzc2lvbkNyZWRlbnRpYWxzKSB7XG4gICAgbG9nKCdbb25PQXV0aFNlc3Npb25DcmVhdGVkRm9yUHJpbnREZXBsb3ldIG9uT0F1dGhTZXNzaW9uQ3JlYXRlZCcpO1xuICAgIHJlbWVtYmVyQ3JlZHNJbk1lbW9yeSh7IC4uLmluTWVtb3J5Q3JlZHMsIHJlbWVtYmVyTWUgfSk7XG4gICAgaWYgKHJlbWVtYmVyTWUpIHtcbiAgICAgICAgYXdhaXQgcHJpbnREZXBsb3lTdG9yYWdlLmNhY2hlT0F1dGhTZXNzaW9uVG9rZW4oc2Vzc2lvbkNyZWRlbnRpYWxzKTtcbiAgICB9XG4gICAgY2xvc2VMb2dpbkRpYWxvZygpLnRoZW4oKCkgPT4ge1xuICAgICAgICBsb2coJ1tvbk9BdXRoU2Vzc2lvbkNyZWF0ZWRGb3JQcmludERlcGxveV0gY2xvc2VkIGxvZ2luIGRpYWxvZycpO1xuICAgIH0pLmNhdGNoKChlKSA9PiB7XG4gICAgICAgIGxvZygnW29uT0F1dGhTZXNzaW9uQ3JlYXRlZEZvclByaW50RGVwbG95XSAgZXJyb3I6JywgeyBlIH0pO1xuICAgIH0pO1xuICAgIGxvZygnW29uT0F1dGhTZXNzaW9uQ3JlYXRlZEZvclByaW50RGVwbG95XSAgZ2V0dGluZyB0b2tlbiBpbmZvJyk7XG4gICAgY29uc3QgcHJpbnREZXBsb3lUb2tlbkluZm8gPSB0b1ByaW50RGVwbG95VG9rZW5JbmZvKHNlc3Npb25DcmVkZW50aWFscyk7XG4gICAgbG9nKCdbb25PQXV0aFNlc3Npb25DcmVhdGVkRm9yUHJpbnREZXBsb3ldIHRva2VuIGluZm8nLCB7IHByaW50RGVwbG95VG9rZW5JbmZvIH0pO1xuICAgIHJldHVybiBwcmludERlcGxveVRva2VuSW5mbztcbn1cbmFzeW5jIGZ1bmN0aW9uIHNob3dMb2dpbldpbmRvdyhvbkNyZWRlbnRpYWxzRW50ZXJlZCkge1xuICAgIGxvZygnW3Nob3dMb2dpbldpbmRvd10gY2FsbGVkJywgeyBvbkNyZWRlbnRpYWxzRW50ZXJlZCB9KTtcbiAgICBjb25zdCBjb25maWcgPSBhd2FpdCBwcmludERlcGxveVN0b3JhZ2UuZ2V0Q2FjaGVkQ29uZmlnKCk7XG4gICAgY29uc3Qgc2hvd1VzZXJuYW1lTG9naW4gPSBjb25maWcgJiYgY29uZmlnLkF1dGhNZXRob2RzLmluY2x1ZGVzKFByaW50RGVwbG95QXV0aE1ldGhvZHMuVXNlcm5hbWUpO1xuICAgIGNvbnN0IHNob3dHb29nbGVMb2dpbiA9IGNvbmZpZyAmJiBjb25maWcuQXV0aE1ldGhvZHMuaW5jbHVkZXMoUHJpbnREZXBsb3lBdXRoTWV0aG9kcy5Hb29nbGUpO1xuICAgIGF3YWl0IGRpc3BsYXlMb2dpbldpbmRvdyh7XG4gICAgICAgIHNob3dSZW1lbWJlck1lOiB0cnVlLFxuICAgICAgICBzaG93VXNlcm5hbWVMb2dpbixcbiAgICAgICAgc2hvd0dvb2dsZUxvZ2luLFxuICAgICAgICB1c2VQcmludERlcGxveTogdHJ1ZSxcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIG1hcFByaW50ZXJzRm9yUHJpbnRQcm92aWRlcihwcmludGVycykge1xuICAgIHJldHVybiBwcmludGVycy5tYXAoKHsgbmFtZSwgY29ubmVjdGlvbiB9KSA9PiB7XG4gICAgICAgIGNvbnN0IGRpc3BsYXlOYW1lID0gZ2V0Tm9ybWFsaXNlZE5hbWUobmFtZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpZDogYCR7Y29ubmVjdGlvbi5uYW1lfS9wcmludGVycy8ke2VuY29kZVVSSUNvbXBvbmVudChkaXNwbGF5TmFtZSl9YCxcbiAgICAgICAgICAgIG5hbWU6IGRpc3BsYXlOYW1lLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IG5hbWUsXG4gICAgICAgICAgICBhdXRoTW9kZTogJ3Blci1zZXJ2ZXInLFxuICAgICAgICAgICAgY2FwYWJpbGl0aWVzOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfSk7XG59XG5mdW5jdGlvbiBnZXROb3JtYWxpc2VkTmFtZShtcFByaW50ZXJOYW1lKSB7XG4gICAgY29uc3QgcmVnZXggPSAvKC4qKVxcWy4qXFxdXFwoTW9iaWxpdHlcXCkkL2dtO1xuICAgIGlmICghcmVnZXgudGVzdChtcFByaW50ZXJOYW1lKSkge1xuICAgICAgICByZXR1cm4gbXBQcmludGVyTmFtZTtcbiAgICB9XG4gICAgcmV0dXJuIG1wUHJpbnRlck5hbWUuc3Vic3RyaW5nKDAsIG1wUHJpbnRlck5hbWUubGFzdEluZGV4T2YoJ1snKSkudHJpbSgpO1xufVxuZnVuY3Rpb24gcmVzb2x2ZUVycm9yVG9EaXNwbGF5KGUpIHtcbiAgICBpZiAoZS5tZXNzYWdlKSB7XG4gICAgICAgIGlmIChlLm1lc3NhZ2UuaW5jbHVkZXMoJ0hUVFAgNDAxJykpIHtcbiAgICAgICAgICAgIHJldHVybiAnSW52YWxpZCB1c2VybmFtZSBhbmQgcGFzc3dvcmQnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGUubWVzc2FnZS5pbmNsdWRlcygnSFRUUCA1MDAnKSkge1xuICAgICAgICAgICAgcmV0dXJuICdBbiBpbnRlcm5hbCBzZXJ2ZXIgZXJyb3Igb2NjdXJyZWQnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGUubWVzc2FnZS5pbmNsdWRlcygnRmFpbGVkIHRvIGZldGNoJykpIHtcbiAgICAgICAgICAgIHJldHVybiAnQ29ubmVjdGlvbiBmYWlsZWQnO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAnVW5rbm93biBlcnJvci4nO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFBEQXV0aEZvck1vYmlsaXR5U2VydmVyKG1wU2VydmVyKSB7XG4gICAgY29uc3QgY2FjaGVkVG9rZW4gPSBhd2FpdCBwcmludERlcGxveVN0b3JhZ2UuZ2V0Q2FjaGVkTW9iaWxpdHlQcmludFNlcnZlclRva2VuKG1wU2VydmVyKTtcbiAgICBpZiAoY2FjaGVkVG9rZW4pIHtcbiAgICAgICAgbG9nKGBbZ2V0UHJpbnREZXBsb3lBdXRoXSBmb3VuZCBjYWNoZWQgdG9rZW4gZm9yICR7bXBTZXJ2ZXJ9YCk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoeyB0b2tlbjogY2FjaGVkVG9rZW4gfSk7XG4gICAgfVxuICAgIHJldHVybiBoYW5kbGVNaXNzaW5nVG9rZW4oKS5jYXRjaChfZSA9PiB7XG4gICAgICAgIGxvZyhgW2dldFByaW50RGVwbG95QXV0aF0gZGlkIG5vdCBmaW5kIGFueSBjYWNoZWQgdG9rZW5zIG9yIGNyZWRlbnRpYWxzIGZvciBNUCBzZXJ2ZXIgXCIke21wU2VydmVyfS4gYXNraW5nIGAgK1xuICAgICAgICAgICAgJ3VzZXIgdG8gYXV0aGVudGljYXRlLi4uXCInKTtcbiAgICAgICAgcmV0dXJuIGFza1VzZXJUb0F1dGhlbnRpY2F0ZUZvck1QU2VydmVyKG1wU2VydmVyKTtcbiAgICB9KTtcbiAgICBhc3luYyBmdW5jdGlvbiBoYW5kbGVNaXNzaW5nVG9rZW4oKSB7XG4gICAgICAgIGNvbnN0IG9hdXRoU2Vzc2lvbiA9IGF3YWl0IHByaW50RGVwbG95U3RvcmFnZS5nZXRDYWNoZWRPQXV0aFNlc3Npb25Ub2tlbigpO1xuICAgICAgICBpZiAob2F1dGhTZXNzaW9uICYmIG9hdXRoU2Vzc2lvbi5wcm92aWRlcklEID09PSBPQXV0aFByb3ZpZGVySURzLkdvb2dsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGF1dGhlbnRpY2F0ZVdpdGhHU3VpdGVIVFRQKG1wU2VydmVyLCBmYWxzZSkudGhlbihlbmNyeXB0ZWRDcmVkcyA9PiB7XG4gICAgICAgICAgICAgICAgbG9nKGBbZ2V0UHJpbnREZXBsb3lBdXRoXSBnZW5lcmF0ZWQgZW5jcnlwdGVkIG9hdXRoIGNyZWRlbnRpYWxzIGZvciAke29hdXRoU2Vzc2lvbi5wcm92aWRlcklEfWApO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGVuY3J5cHRlZENyZWRzLCBhdXRoT3B0aW9uOiBPQXV0aFByb3ZpZGVySURzLkdvb2dsZSB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluTWVtb3J5Q3JlZHNBdmFpbGFibGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGVuY3J5cHRDcmVkZW50aWFscyhtcFNlcnZlciwgaW5NZW1vcnlDcmVkcy51c2VybmFtZSwgaW5NZW1vcnlDcmVkcy5wYXNzd29yZCkudGhlbigoZW5jcnlwdGVkQ3JlZHMgPT4ge1xuICAgICAgICAgICAgICAgIGxvZygnW2dldFByaW50RGVwbG95QXV0aF0gZ2VuZXJhdGVkIGVuY3J5cHRlZCBiYXNpYyBjcmVkZW50aWFscycpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGVuY3J5cHRlZENyZWRzIH07XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KFByaW50RGVwbG95VW5hdXRob3JpemVkRXJyb3IpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFza1VzZXJUb0F1dGhlbnRpY2F0ZUZvck1QU2VydmVyKG1wU2VydmVyKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlLCBfcmVqZWN0KSA9PiB7XG4gICAgICAgIGNocm9tZS5ydW50aW1lLm9uTWVzc2FnZS5hZGRMaXN0ZW5lcihvbkNyZWRlbnRpYWxzRW50ZXJlZEZvck1QU2VydmVySGFuZGxlcihtcFNlcnZlciwgcmVzb2x2ZSkpO1xuICAgICAgICBhd2FpdCBzaG93TG9naW5XaW5kb3coKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIG9uQ3JlZGVudGlhbHNFbnRlcmVkRm9yTVBTZXJ2ZXJIYW5kbGVyKG1wU2VydmVyLCByZXNvbHZlKSB7XG4gICAgcmV0dXJuIChtZXNzYWdlLCBzZW5kZXIpID0+IHtcbiAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSA9PT0gJ29uLWNyZWRlbnRpYWxzLWVudGVyZWQnKSB7XG4gICAgICAgICAgICBjb25zdCBjcmVkZW50aWFsc0VudGVyZWQgPSBtZXNzYWdlO1xuICAgICAgICAgICAgbG9nKCdbb25DcmVkZW50aWFsc0VudGVyZWRGb3JNUFNlcnZlckhhbmRsZXJdIG1lc3NhZ2UgcmVjZWl2ZWQnLCB7IG1lc3NhZ2UsIHNlbmRlciB9KTtcbiAgICAgICAgICAgIG9uQ3JlZGVudGlhbHNFbnRlcmVkRm9yTVBTZXJ2ZXIoY3JlZGVudGlhbHNFbnRlcmVkLmNyZWRlbnRpYWxzLCBtcFNlcnZlcikudGhlbigoZW5jcnlwdGVkQ3JlZGVudGlhbHMpID0+IHtcbiAgICAgICAgICAgICAgICBjaHJvbWUucnVudGltZS5vbk1lc3NhZ2UucmVtb3ZlTGlzdGVuZXIob25DcmVkZW50aWFsc0VudGVyZWRGb3JNUFNlcnZlckhhbmRsZXIobXBTZXJ2ZXIsIHJlc29sdmUpKTtcbiAgICAgICAgICAgICAgICBsb2coJ1tvbkNyZWRlbnRpYWxzRW50ZXJlZEZvck1QU2VydmVyXSBzdWNjZWVkZWQnLCB7IGVuY3J5cHRlZENyZWRlbnRpYWxzIH0pO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoUHJvbWlzZS5yZXNvbHZlKGVuY3J5cHRlZENyZWRlbnRpYWxzKSk7XG4gICAgICAgICAgICAgICAgY2xvc2VMb2dpbkRpYWxvZygpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsb2coJ1tvbkNyZWRlbnRpYWxzRW50ZXJlZEZvck1QU2VydmVySGFuZGxlcl0gY2xvc2VkIGxvZ2luIGRpYWxvZycpO1xuICAgICAgICAgICAgICAgIH0pLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxvZygnW29uQ3JlZGVudGlhbHNFbnRlcmVkRm9yTVBTZXJ2ZXJIYW5kbGVyXSAgZXJyb3I6JywgeyBlIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSkuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSByZXNvbHZlRXJyb3JUb0Rpc3BsYXkoZSk7XG4gICAgICAgICAgICAgICAgc2VuZERpc3BsYXlFcnJvck1lc3NhZ2UoZXJyb3JNZXNzYWdlKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbG9nKCdbb25DcmVkZW50aWFsc0VudGVyZWRGb3JNUFNlcnZlckhhbmRsZXJdIHNlbmREaXNwbGF5RXJyb3JNZXNzYWdlJyk7XG4gICAgICAgICAgICAgICAgfSkuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbG9nKCdbb25DcmVkZW50aWFsc0VudGVyZWRGb3JNUFNlcnZlckhhbmRsZXJdICBzZW5kRGlzcGxheUVycm9yTWVzc2FnZSBlcnJvcjonLCB7IGUgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiB3cmFwQ3JlZHMoZW5jcnlwdGVkQ3JlZHMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNyeXB0ZWRDcmVkczogZW5jcnlwdGVkQ3JlZHMsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIG9uQ3JlZGVudGlhbHNFbnRlcmVkRm9yTVBTZXJ2ZXIoY3JlZGVudGlhbHMsIG1wU2VydmVyKSB7XG4gICAgcmVtZW1iZXJDcmVkc0luTWVtb3J5KGNyZWRlbnRpYWxzKTtcbiAgICByZXR1cm4gZW5jcnlwdENyZWRlbnRpYWxzKG1wU2VydmVyLCBpbk1lbW9yeUNyZWRzLnVzZXJuYW1lLCBpbk1lbW9yeUNyZWRzLnBhc3N3b3JkKVxuICAgICAgICAudGhlbihhc3luYyAoZW5jcnlwdGVkQ3JlZHMpID0+IHtcbiAgICAgICAgcmV0dXJuIHdyYXBDcmVkcyhlbmNyeXB0ZWRDcmVkcyk7XG4gICAgfSk7XG59XG4iLCJleHBvcnQgKiBmcm9tICcuL2dvb2dsZWF1dGgnO1xuZXhwb3J0ICogZnJvbSAnLi9vYXV0aCc7XG5leHBvcnQgKiBmcm9tICcuL3ByaW50ZGVwbG95JztcbmV4cG9ydCAqIGZyb20gJy4vcHJpbnRkZXBsb3kudHlwZXMnO1xuZXhwb3J0ICogZnJvbSAnLi9zdG9yYWdlJztcbiIsImV4cG9ydCBmdW5jdGlvbiB3aW5kb3dSZXNpemVUb0lubmVyKHcsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICB3LnJlc2l6ZVRvKHdpZHRoICsgKHcub3V0ZXJXaWR0aCAtIHcuaW5uZXJXaWR0aCksIGhlaWdodCArICh3Lm91dGVySGVpZ2h0IC0gdy5pbm5lckhlaWdodCkpO1xufVxuIiwiLypcbiAqIENvcHlyaWdodCDCqSAyMDE3LTIwMjEgUGFwZXJDdXQgU29mdHdhcmUgSW50ZXJuYXRpb25hbCBQdHkuIEx0ZC5cbiAqL1xuXG5pbXBvcnQgJCBmcm9tICdqcXVlcnknO1xuaW1wb3J0IHsgbG9nIH0gZnJvbSAnLi9sb2cnO1xuXG5mdW5jdGlvbiBsb2NhbGl6ZUh0bWxQYWdlKCkge1xuXHRsb2coYGxvY2FsaXplSHRtbFBhZ2U6ICR7Y2hyb21lLmkxOG4uZ2V0VUlMYW5ndWFnZSgpfWApO1xuXG5cdCQoJy50cmFuc2xhdGVkJykuZWFjaChmdW5jdGlvbigpIHtcblx0XHRsZXQgZWxlbWVudCA9ICQodGhpcyk7XG5cdFx0bGV0IGtleSA9IGVsZW1lbnQuZGF0YSgna2V5Jyk7XG5cdFx0bGV0IG5ld1RleHQgPSBrZXkgPyBjaHJvbWUuaTE4bi5nZXRNZXNzYWdlKGtleSkgOiBrZXk7XG5cblx0XHRlbGVtZW50Lmh0bWwobmV3VGV4dCk7XG5cdH0pO1xufVxuXG5sb2NhbGl6ZUh0bWxQYWdlKCk7XG4iLCJpbXBvcnQgJCBmcm9tICdqcXVlcnknO1xuaW1wb3J0ICdqcXVlcnktdmFsaWRhdGlvbic7XG5pbXBvcnQgeyBhdXRoZW50aWNhdGVXaXRoR1N1aXRlLCBlbmNyeXB0Q3JlZGVudGlhbHMsIHJldm9rZUNhY2hlZEdTdWl0ZUF1dGhUb2tlbiB9IGZyb20gJy4uL2F1dGgnO1xuaW1wb3J0IHsgc2VuZFBhZ2VNZXNzYWdlV2l0aFJldHJ5IH0gZnJvbSAnLi4vY2hyb21lJztcbmltcG9ydCB7IGxvZyB9IGZyb20gJy4uL2xvZyc7XG5pbXBvcnQgeyBpc0Nsb3VkUHJpbnRFcnJvciB9IGZyb20gJy4uL29mZm5ldHdvcmsvb2ZmbmV0d29yay11dGlscyc7XG5pbXBvcnQgeyBnZXRQcmVjb25maWd1cmVkUHJpbnREZXBsb3lTZXJ2ZXIsIGdldFByaW50RGVwbG95Q2xpZW50LCBPQXV0aFByb3ZpZGVySURzIH0gZnJvbSAnLi4vcHJpbnRkZXBsb3knO1xuaW1wb3J0IHsgd2luZG93UmVzaXplVG9Jbm5lciB9IGZyb20gJy4uL3dpbmRvdyc7XG5pbXBvcnQgJy4uL2ludGVybmF0aW9uYWxpemF0aW9uJztcbmNocm9tZS5ydW50aW1lLm9uTWVzc2FnZS5hZGRMaXN0ZW5lcihhc3luYyAobWVzc2FnZSwgc2VuZGVyLCBzZW5kUmVzcG9uc2UpID0+IHtcbiAgICBpZiAobWVzc2FnZS50eXBlID09PSAnbG9naW4td2luZG93LWluaXQnKSB7XG4gICAgICAgIGxvZygnUmVjZWl2ZWQgaW5pdCB3aW5kb3cgbWVzc2FnZS4nLCB7IG1lc3NhZ2UgfSk7XG4gICAgICAgIGluaXRMb2dpbldpbmRvdyhtZXNzYWdlKTtcbiAgICAgICAgc2VuZFJlc3BvbnNlKCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG1lc3NhZ2UudHlwZSA9PT0gJ2Nsb3NlLWxvZ2luLXdpbmRvdycpIHtcbiAgICAgICAgbG9nKCdSZWNlaXZlZCBjbG9zZSB3aW5kb3cgbWVzc2FnZScpO1xuICAgICAgICBleGl0TG9hZGluZ1N0YXRlKCk7XG4gICAgICAgIGhpZGVFcnJvcnMoKTtcbiAgICAgICAgc2VuZFJlc3BvbnNlKCk7XG4gICAgICAgIHdpbmRvdy5jbG9zZSgpO1xuICAgIH1cbiAgICBlbHNlIGlmIChtZXNzYWdlLnR5cGUgPT09ICdkaXNwbGF5LWVycm9yJykge1xuICAgICAgICBsb2coJ2Rpc3BsYXktZXJyb3IgbWVzc2FnZSByZWNlaXZlZCcsIHsgbWVzc2FnZSB9KTtcbiAgICAgICAgY29uc3QgZGlzcGxheUVycm9yTWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIGV4aXRMb2FkaW5nU3RhdGUoKTtcbiAgICAgICAgc2hvd01lc3NhZ2VGb3JFcnJvcihkaXNwbGF5RXJyb3JNZXNzYWdlLmVyck1zZyk7XG4gICAgICAgIHNlbmRSZXNwb25zZSgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbG9nKGB1bmtub3duIG1lc3NhZ2UgZnJvbSAnJHtzZW5kZXIudXJsfTogJHtKU09OLnN0cmluZ2lmeShtZXNzYWdlKX1gKTtcbiAgICAgICAgc2VuZFJlc3BvbnNlKCk7XG4gICAgfVxufSk7XG5jb25zdCBjcmVkZW50aWFsc1Jlc3BvbnNlSGFuZGxlciA9IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgIGxvZygnW2NyZWRlbnRpYWxzUmVzcG9uc2VIYW5kbGVyXScpO1xuICAgIGV4aXRMb2FkaW5nU3RhdGUoKTtcbiAgICB1cGRhdGVVaU9uSm9iU3VibWlzc2lvblJlc3BvbnNlKHJlc3BvbnNlKTtcbn07XG5jb25zdCB1cGRhdGVVaU9uSm9iU3VibWlzc2lvblJlc3BvbnNlID0gZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgZXhpdExvYWRpbmdTdGF0ZSgpO1xuICAgIGlmIChyZXNwb25zZSAmJiByZXNwb25zZS5vaykge1xuICAgICAgICBsb2coJ0F1dGhlbnRpY2F0aW9uIHN1Y2Nlc3NmdWwuIEpvYiBzdWJtaXR0ZWQgc3VjY2Vzc2Z1bGx5LicpO1xuICAgICAgICBoaWRlRXJyb3JzKCk7XG4gICAgICAgIHdpbmRvdy5jbG9zZSgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSByZXNwb25zZSAmJiByZXNwb25zZS5tZXNzYWdlID8gcmVzcG9uc2UubWVzc2FnZSA6ICdGYWlsZWQgdG8gbG9nIGluLiBQbGVhc2UgdHJ5IGFnYWluLic7XG4gICAgICAgIHNob3dNZXNzYWdlRm9yRXJyb3IoZXJyb3IpO1xuICAgIH1cbn07XG5mdW5jdGlvbiBpbml0TG9naW5XaW5kb3cobG9naW5XaW5kb3cpIHtcbiAgICBjb25zdCBsb2dpblVzaW5nUGFwZXJDdXRDcmVkZW50aWFscyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZW50ZXJMb2FkaW5nU3RhdGUoKTtcbiAgICAgICAgY29uc3QgaXNSZW1lbWJlciA9ICQoJyNyZW1lbWJlcicpLmlzKCc6Y2hlY2tlZCcpO1xuICAgICAgICBjb25zdCB1c2VybmFtZSA9ICQoJyN1c2VybmFtZScpLnZhbCgpO1xuICAgICAgICBjb25zdCBwYXNzd29yZCA9ICQoJyNwYXNzd29yZCcpLnZhbCgpO1xuICAgICAgICBsb2coYENyZWRlbnRpYWxzIGVudGVyZWQgZm9yIHVzZXJuYW1lPVwiJHt1c2VybmFtZX1cIiB3aXRoICR7cGFzc3dvcmQubGVuZ3RoID09PSAwID8gJ2FuIGVtcHR5JyA6ICdhIG5vbi1lbXB0eSd9IHBhc3N3b3JkYCk7XG4gICAgICAgIGlmIChsb2dpbldpbmRvdy51c2VDbG91ZFByaW50ID09PSB0cnVlKSB7XG4gICAgICAgICAgICBzZW5kUHJpbnRKb2JNZXNzYWdlKHsgdXNlcm5hbWU6IHVzZXJuYW1lLCBwYXNzd29yZDogcGFzc3dvcmQgfSwgaXNSZW1lbWJlciwgbG9naW5XaW5kb3cudXNlQ2xvdWRQcmludCwgY3JlZGVudGlhbHNSZXNwb25zZUhhbmRsZXIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVuY3J5cHRDcmVkZW50aWFscyhsb2dpbldpbmRvdy51cmxCYXNlLCB1c2VybmFtZSwgcGFzc3dvcmQpXG4gICAgICAgICAgICAudGhlbigoZW5jcnlwdGVkQ3JlZHMpID0+IHtcbiAgICAgICAgICAgIHNlbmRQcmludEpvYk1lc3NhZ2UoZW5jcnlwdGVkQ3JlZHMsIGlzUmVtZW1iZXIsIGxvZ2luV2luZG93LnVzZUNsb3VkUHJpbnQsIGNyZWRlbnRpYWxzUmVzcG9uc2VIYW5kbGVyKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgZXhpdExvYWRpbmdTdGF0ZSgpO1xuICAgICAgICAgICAgZSBpbnN0YW5jZW9mIEVycm9yID9cbiAgICAgICAgICAgICAgICBzaG93TWVzc2FnZUZvckVycm9yKGUubWVzc2FnZSkgOiBzaG93TWVzc2FnZUZvckVycm9yKGUpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGxvZ2luVXNpbmdHU3VpdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGVudGVyTG9hZGluZ1N0YXRlKCk7XG4gICAgICAgIGNvbnN0IGlzUmVtZW1iZXIgPSAkKCcjcmVtZW1iZXInKS5pcygnOmNoZWNrZWQnKTtcbiAgICAgICAgbG9nKGBsb2dpblVzaW5nR1N1aXRlIHNlbGVjdGVkOiBpc1JlbWVtYmVyPSR7aXNSZW1lbWJlcn1gKTtcbiAgICAgICAgaWYgKGxvZ2luV2luZG93LnVzZVByaW50RGVwbG95KSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0UHJlY29uZmlndXJlZFByaW50RGVwbG95U2VydmVyKClcbiAgICAgICAgICAgICAgICAudGhlbihob3N0ID0+IGdldFByaW50RGVwbG95Q2xpZW50KGhvc3QpKVxuICAgICAgICAgICAgICAgIC50aGVuKGNsaWVudCA9PiBjbGllbnQuY3JlYXRlT0F1dGhTZXNzaW9uKE9BdXRoUHJvdmlkZXJJRHMuR29vZ2xlKSlcbiAgICAgICAgICAgICAgICAudGhlbihhc3luYyAoc2Vzc2lvbikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9hdXRoU2Vzc2lvbkNyZWF0ZWRNZXNzYWdlID0ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnb2F1dGgtc2Vzc2lvbi1jcmVhdGVkJyxcbiAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbkNyZWRlbnRpYWxzOiBzZXNzaW9uLFxuICAgICAgICAgICAgICAgICAgICByZW1lbWJlck1lOiBpc1JlbWVtYmVyLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgYXdhaXQgc2VuZFBhZ2VNZXNzYWdlV2l0aFJldHJ5KG9hdXRoU2Vzc2lvbkNyZWF0ZWRNZXNzYWdlKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgZXhpdExvYWRpbmdTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIGUgaW5zdGFuY2VvZiBFcnJvciA/XG4gICAgICAgICAgICAgICAgICAgIHNob3dNZXNzYWdlRm9yRXJyb3IoZS5tZXNzYWdlKSA6IHNob3dNZXNzYWdlRm9yRXJyb3IoZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXV0aGVudGljYXRlV2l0aEdTdWl0ZShsb2dpbldpbmRvdy5wcmludEpvYiwgdHJ1ZSwgIWxvZ2luV2luZG93LnVzZUNsb3VkUHJpbnQpXG4gICAgICAgICAgICAudGhlbigoY3JlZGVudGlhbHMpID0+IHtcbiAgICAgICAgICAgIHNlbmRQcmludEpvYk1lc3NhZ2UoY3JlZGVudGlhbHMsIGlzUmVtZW1iZXIsIGxvZ2luV2luZG93LnVzZUNsb3VkUHJpbnQsIGhhbmRsZVJlc3BvbnNlLCAnZ29vZ2xlJyk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgIHNob3dNZXNzYWdlRm9yRXJyb3IoZSwgdHJ1ZSk7XG4gICAgICAgICAgICBleGl0TG9hZGluZ1N0YXRlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBmdW5jdGlvbiBoYW5kbGVSZXNwb25zZShyZXNwb25zZSkge1xuICAgICAgICAgICAgbG9nKCdoYW5kbGVSZXNwb25zZTonLCByZXNwb25zZSk7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UgJiYgcmVzcG9uc2UubWVzc2FnZSA9PT0gJ0ludmFsaWQgdXNlcm5hbWUgb3IgcGFzc3dvcmQnKSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UubWVzc2FnZSA9ICdVbmtub3duIHVzZXInO1xuICAgICAgICAgICAgICAgIHJldm9rZUNhY2hlZEdTdWl0ZUF1dGhUb2tlbig1MDAwKS5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlVWlPbkpvYlN1Ym1pc3Npb25SZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzUmVtZW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV2b2tlQ2FjaGVkR1N1aXRlQXV0aFRva2VuKCkuZmluYWxseSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVVaU9uSm9iU3VibWlzc2lvblJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVVaU9uSm9iU3VibWlzc2lvblJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IG9uTG9naW5DbGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGxvZ2luV2luZG93LnVzZVByaW50RGVwbG95KSB7XG4gICAgICAgICAgICBjb25zdCByZW1lbWJlck1lID0gJCgnI3JlbWVtYmVyJykuaXMoJzpjaGVja2VkJyk7XG4gICAgICAgICAgICBjb25zdCBjcmVkZW50aWFscyA9IHtcbiAgICAgICAgICAgICAgICB1c2VybmFtZTogKCQoJyN1c2VybmFtZScpLnZhbCgpIHx8ICcnKS50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgIHBhc3N3b3JkOiAoJCgnI3Bhc3N3b3JkJykudmFsKCkgfHwgJycpLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgcmVtZW1iZXJNZTogcmVtZW1iZXJNZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBvbkNyZWRlbnRpYWxzRW50ZXJlZE1lc3NhZ2UgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ29uLWNyZWRlbnRpYWxzLWVudGVyZWQnLFxuICAgICAgICAgICAgICAgIGNyZWRlbnRpYWxzOiBjcmVkZW50aWFscyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBzZW5kUGFnZU1lc3NhZ2VXaXRoUmV0cnkob25DcmVkZW50aWFsc0VudGVyZWRNZXNzYWdlKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBsb2coJ2NyZWRlbnRpYWxzIG1lc3NhZ2Ugc2VudCcpO1xuICAgICAgICAgICAgfSkuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgICAgICBsb2coJ2Vycm9yIHNlbmRpbmcgY3JlZGVudGlhbHMnLCB7IGUgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGVudGVyTG9hZGluZ1N0YXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2dpblVzaW5nUGFwZXJDdXRDcmVkZW50aWFscygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBpbml0aWFsaXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBsb2coJ1NldHRpbmcgdXAgbG9naW4gb3B0aW9ucy4nLCB7IHNob3dVc2VybmFtZUxvZ2luOiBsb2dpbldpbmRvdy5zaG93VXNlcm5hbWVMb2dpbiwgc2hvd0dvb2dsZUxvZ2luOiBsb2dpbldpbmRvdy5zaG93R29vZ2xlTG9naW4gfSk7XG4gICAgICAgIGlmIChsb2dpbldpbmRvdy5zaG93VXNlcm5hbWVMb2dpbiAmJiAhbG9naW5XaW5kb3cuc2hvd0dvb2dsZUxvZ2luKSB7XG4gICAgICAgICAgICBjb25zdCBzaXplID0geyB3aWR0aDogNDk0LCBoZWlnaHQ6IDYxMCB9O1xuICAgICAgICAgICAgbG9nKCdSZXNpemluZyB3aW5kb3cgZm9yIHVzZXIvcGFzcyBvbmx5LicsIHNpemUpO1xuICAgICAgICAgICAgd2luZG93UmVzaXplVG9Jbm5lcih3aW5kb3csIHNpemUud2lkdGgsIHNpemUuaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghbG9naW5XaW5kb3cuc2hvd1VzZXJuYW1lTG9naW4gJiYgbG9naW5XaW5kb3cuc2hvd0dvb2dsZUxvZ2luKSB7XG4gICAgICAgICAgICBjb25zdCBzaXplID0geyB3aWR0aDogNDk0LCBoZWlnaHQ6IDQ2NSB9O1xuICAgICAgICAgICAgbG9nKCdSZXNpemluZyB3aW5kb3cgZm9yIFNpZ24gaW4gd2l0aCBHb29nbGUgb25seS4nLCBzaXplKTtcbiAgICAgICAgICAgIHdpbmRvd1Jlc2l6ZVRvSW5uZXIod2luZG93LCBzaXplLndpZHRoLCBzaXplLmhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgdG9nZ2xlUmVtZW1iZXIobG9naW5XaW5kb3cuc2hvd1JlbWVtYmVyTWUpO1xuICAgICAgICBjb25zdCBsb2dpbkZvcm0gPSAkKCcjbG9naW4tZm9ybScpO1xuICAgICAgICBjb25zdCB1c2VyUGFzc0FyZWEgPSAkKCcjbG9naW4tZm9ybS11c2VybmFtZScpO1xuICAgICAgICBjb25zdCB1c2VyUGFzc0xvZ2luQnV0dG9uID0gJCgnI2xvZ2luJyk7XG4gICAgICAgIGNvbnN0IG9yQXJlYSA9ICQoJyNsb2dpbi1mb3JtLW9yJyk7XG4gICAgICAgIGNvbnN0IGdvb2dsZUFyZWEgPSAkKCcjbG9naW4tZm9ybS1nb29nbGUnKTtcbiAgICAgICAgY29uc3QgZ29vZ2xlTG9naW5CdXR0b24gPSAkKCcjZ29vZ2xlbG9naW4nKTtcbiAgICAgICAgaWYgKGxvZ2luV2luZG93LnNob3dVc2VybmFtZUxvZ2luKSB7XG4gICAgICAgICAgICB1c2VyUGFzc0xvZ2luQnV0dG9uLm9uKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAobG9naW5Gb3JtLnZhbGlkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgb25Mb2dpbkNsaWNrKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB1c2VyUGFzc0FyZWEuaGlkZSgpO1xuICAgICAgICB9XG4gICAgICAgIG9yQXJlYS5jc3MoJ3Zpc2liaWxpdHknLCAobG9naW5XaW5kb3cuc2hvd1VzZXJuYW1lTG9naW4gJiYgbG9naW5XaW5kb3cuc2hvd0dvb2dsZUxvZ2luKSA/ICd2aXNpYmxlJyA6ICdoaWRkZW4nKTtcbiAgICAgICAgaWYgKGxvZ2luV2luZG93LnNob3dHb29nbGVMb2dpbikge1xuICAgICAgICAgICAgZ29vZ2xlTG9naW5CdXR0b24ub24oJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGhpZGVFcnJvcnMoKTtcbiAgICAgICAgICAgICAgICBsb2dpblVzaW5nR1N1aXRlKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxvZygnW2xvZ2luXSBsb2dpblVzaW5nR1N1aXRlIHJldHVybmVkJyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGdvb2dsZUFyZWEuaGlkZSgpO1xuICAgICAgICB9XG4gICAgICAgIGxvZ2luRm9ybS52YWxpZGF0ZSh7XG4gICAgICAgICAgICBlcnJvclBsYWNlbWVudDogZnVuY3Rpb24gKGVycm9yLCBlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgJChlbGVtZW50KVxuICAgICAgICAgICAgICAgICAgICAuY2xvc2VzdCgnZm9ybScpXG4gICAgICAgICAgICAgICAgICAgIC5maW5kKCdsYWJlbFtmb3I9XFwnJyArIGVsZW1lbnQuYXR0cignaWQnKSArICdcXCddJylcbiAgICAgICAgICAgICAgICAgICAgLmFwcGVuZChlcnJvcik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXJyb3JFbGVtZW50OiAnc3BhbicsXG4gICAgICAgICAgICBtZXNzYWdlczoge1xuICAgICAgICAgICAgICAgIHVzZXJuYW1lOiB7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkOiAnIChyZXF1aXJlZCknLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcGFzc3dvcmQ6IHtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQ6ICcgKHJlcXVpcmVkKScsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICAkKCcjY2xvc2UnKS5vbignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25zdCBsb2dpbldpbmRvd0Nsb3NlZE1lc3NhZ2UgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2xvZ2luLXdpbmRvdy1jbG9zZWQnLFxuICAgICAgICAgICAgICAgIG1zZzogJ3dpbmRvdyBjbG9zZWQnLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHNlbmRQYWdlTWVzc2FnZVdpdGhSZXRyeShsb2dpbldpbmRvd0Nsb3NlZE1lc3NhZ2UpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIGxvZygnc2VudCBsb2dpbiB3aW5kb3cgY2xvc2VkIG1lc3NhZ2UnKTtcbiAgICAgICAgICAgIH0pLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgbG9nKCdubyBvbmUgaGVhcmQgYWJvdXQgdGhlIHdpbmRvd3MgY2xvc2luZycsIHsgZSB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgd2luZG93LmNsb3NlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBsb2dpbkZvcm0uZmluZCgnaW5wdXQnKS5rZXlwcmVzcyhmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgaWYgKGUud2hpY2ggPT0gMTAgfHwgZS53aGljaCA9PSAxMykge1xuICAgICAgICAgICAgICAgIGlmIChsb2dpbkZvcm0udmFsaWQoKSkge1xuICAgICAgICAgICAgICAgICAgICBvbkxvZ2luQ2xpY2soKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBsb2dpbkZvcm0uZmluZCgnaW5wdXQnKS5vbignaW5wdXQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBoaWRlRXJyb3JzKCk7XG4gICAgICAgIH0pO1xuICAgICAgICAkKGRvY3VtZW50KS5rZXl1cChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChldmVudC5rZXlDb2RlID09PSAyNykge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGluaXRpYWxpc2UoKTtcbn1cbmZ1bmN0aW9uIGV4aXRMb2FkaW5nU3RhdGUoKSB7XG4gICAgY29uc3QgbG9naW5CdXR0b24gPSAkKCcjbG9naW4nKTtcbiAgICBsb2dpbkJ1dHRvbi5yZW1vdmVBdHRyKCdkaXNhYmxlZCcpLnJlbW92ZUNsYXNzKCdsb2FkaW5nJyk7XG4gICAgY29uc3QgZ29vZ2xlTG9naW5CdG4gPSAkKCcjZ29vZ2xlbG9naW4nKTtcbiAgICBnb29nbGVMb2dpbkJ0bi5yZW1vdmVBdHRyKCdkaXNhYmxlZCcpLnJlbW92ZUNsYXNzKCdsb2FkaW5nJyk7XG59XG5mdW5jdGlvbiB0b2dnbGVSZW1lbWJlcihzaG93UmVtZW1iZXJNZSkge1xuICAgICQoJyNyZW1lbWJlci1tZS1jb250YWluZXInKS50b2dnbGUoc2hvd1JlbWVtYmVyTWUpO1xufVxuZnVuY3Rpb24gZW50ZXJMb2FkaW5nU3RhdGUoKSB7XG4gICAgY29uc3QgbG9naW5CdXR0b24gPSAkKCcjbG9naW4nKTtcbiAgICBsb2dpbkJ1dHRvbi5hdHRyKCdkaXNhYmxlZCcsICdkaXNhYmxlZCcpLmFkZENsYXNzKCdsb2FkaW5nJyk7XG4gICAgY29uc3QgZ29vZ2xlTG9naW5CdG4gPSAkKCcjZ29vZ2xlbG9naW4nKTtcbiAgICBnb29nbGVMb2dpbkJ0bi5hdHRyKCdkaXNhYmxlZCcsICdkaXNhYmxlZCcpLmFkZENsYXNzKCdsb2FkaW5nJyk7XG59XG5mdW5jdGlvbiBoaWRlRXJyb3JzKCkge1xuICAgICQoJ3NwYW4uZXJyb3ItbWVzc2FnZScpLmVhY2goKGlkeCwgZW0pID0+IHtcbiAgICAgICAgJChlbSkuaGlkZSgpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gaXNBdXRoRXJyb3IoZXJyKSB7XG4gICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gZXJyLmluY2x1ZGVzKCd1c2VyIGFuZCBwYXNzd29yZCcpIHx8IGVyci5pbmNsdWRlcygnYXV0aGVudGljYXRpb24nKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNDb25uZWN0aW9uRXJyb3IoZXJyKSB7XG4gICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gZXJyLmluY2x1ZGVzKCdDb25uZWN0aW9uIGZhaWxlZCcpIHx8XG4gICAgICAgICAgICBlcnIuaW5jbHVkZXMoJ0NvdWxkIG5vdCBjb25uZWN0JykgfHxcbiAgICAgICAgICAgIGVyci5pbmNsdWRlcygnRmFpbGVkIHRvIGZldGNoJykgfHxcbiAgICAgICAgICAgIGlzQ2xvdWRQcmludEVycm9yKGVycik7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHNob3dNZXNzYWdlRm9yRXJyb3IoZXJyLCBkaXNwbGF5VmVyYmF0aW0pIHtcbiAgICBsb2coYHNob3dNZXNzYWdlRm9yRXJyb3I6ICR7ZXJyfSwgZGlzcGxheVZlcmJhdGltPSR7ZGlzcGxheVZlcmJhdGltfWApO1xuICAgIGlmIChkaXNwbGF5VmVyYmF0aW0pIHtcbiAgICAgICAgJCgnI2Vycm9yLW1lc3NhZ2Utc2hvdy12ZXJiYXRpbScpLnRleHQoZXJyKS5zaG93KCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzQXV0aEVycm9yKGVycikpIHtcbiAgICAgICAgJCgnI2Vycm9yLW1lc3NhZ2UtaW52YWxpZC1jcmVkcycpLnNob3coKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXJyID09PSAnVGhlIHVzZXIgZGlkIG5vdCBhcHByb3ZlIGFjY2Vzcy4nKSB7XG4gICAgICAgICQoJyNlcnJvci1tZXNzYWdlLWdyYW50LWFjY2VzcycpLnNob3coKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXJyID09PSAnVW5rbm93biB1c2VyJykge1xuICAgICAgICAkKCcjZXJyb3ItbWVzc2FnZS11bmtub3duLWctYWNjb3VudCcpLnNob3coKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXJyID09PSAnR1N1aXRlIG5vdCBzdXBwb3J0ZWQnKSB7XG4gICAgICAgICQoJyNlcnJvci1tZXNzYWdlLWdzdWl0ZS1ub3Qtc3VwcG9ydGVkJykuc2hvdygpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0Nvbm5lY3Rpb25FcnJvcihlcnIpKSB7XG4gICAgICAgICQoJyNlcnJvci1tZXNzYWdlLWNvbm5lY3Rpb24tZmFpbGVkJykuc2hvdygpO1xuICAgIH1cbiAgICBlbHNlIGlmIChlcnIuaW5jbHVkZXMoJ2xldCB0aGlyZC1wYXJ0eSBhcHBzIGFjY2VzcyBEaXJlY3RvcnkgZGF0YScpKSB7XG4gICAgICAgICQoJyNlcnJvci1tZXNzYWdlLWdzdWl0ZS10aGlyZC1wYXJ0eS1hY2Nlc3MnKS5zaG93KCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGVyci5pbmNsdWRlcygnUHJpbnRlciBhY2Nlc3MgZGVuaWVkIGJ5IGdyb3VwIHJlc3RyaWN0aW9uJykpIHtcbiAgICAgICAgJCgnI2Vycm9yLW1lc3NhZ2UtZGVuaWVkLWdyb3VwLXJlc3RyaWN0aW9uJykuc2hvdygpO1xuICAgIH1cbiAgICBlbHNlIGlmIChlcnIuaW5jbHVkZXMoJ2lzIG5vdCByZWdpc3RlcmVkJykpIHtcbiAgICAgICAgJCgnI2Vycm9yLW1lc3NhZ2UtZW1haWwtdW5yZWdpc3RlcmVkJykuc2hvdygpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgJCgnI2Vycm9yLW1lc3NhZ2UtaW52YWxpZC1jcmVkcycpLnNob3coKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzZW5kUHJpbnRKb2JNZXNzYWdlKGNyZWRlbnRpYWxzLCBpc1JlbWVtYmVyLCB1c2VDbG91ZFByaW50ID0gZmFsc2UsIHJlc3BvbnNlSGFuZGxlciwgYXV0aE9wdGlvbiA9ICcnKSB7XG4gICAgbG9nKGBzZW5kUHJpbnRKb2JNZXNzYWdlOiBpc1JlbWVtYmVyPSR7aXNSZW1lbWJlcn0sIHVzZUNsb3VkUHJpbnQ9JHt1c2VDbG91ZFByaW50fSwgYXV0aE9wdGlvbj0ke2F1dGhPcHRpb259YCk7XG4gICAgY29uc3Qgc2VuZFByaW50Sm9iTWVzc2FnZSA9IHtcbiAgICAgICAgdHlwZTogJ3NlbmQtcHJpbnQtam9iLW1lc3NhZ2UnLFxuICAgICAgICBjcmVkZW50aWFsczogY3JlZGVudGlhbHMsXG4gICAgICAgIHJlbWVtYmVyOiBpc1JlbWVtYmVyLFxuICAgICAgICB1c2VDbG91ZFByaW50OiB1c2VDbG91ZFByaW50LFxuICAgICAgICBhdXRoT3B0aW9uOiBhdXRoT3B0aW9uLFxuICAgIH07XG4gICAgY2hyb21lLnJ1bnRpbWUuc2VuZE1lc3NhZ2Uoc2VuZFByaW50Sm9iTWVzc2FnZSwge30sIHJlc3BvbnNlSGFuZGxlcik7XG59XG5jaHJvbWUucnVudGltZS5vblN1c3BlbmQuYWRkTGlzdGVuZXIoKCkgPT4ge1xuICAgIGxvZygnW2xvZ2luXSBTdXNwZW5kaW5nLicpO1xufSk7XG4iXSwibmFtZXMiOlsiX0VYVEVOU0lPTl9JRCIsIkVYVEVOU0lPTl9JRCIsIl9BUFBfSUQiLCJBUFBfSUQiLCJfU0VMRl9JRCIsIlNFTEZfSUQiLCJfVkVSU0lPTiIsIlZFUlNJT04iLCJjb25zb2xlIiwiZXJyb3IiLCJpc0V4dGVuc2lvbiIsImlzQXBwIiwiR2V0Q2xpZW50VmVyc2lvbklEIiwiZ2V0UmVzcG9uc2VCb2R5IiwicmVzcCIsIm9rIiwianNvbiIsInRoZW4iLCJyZXNwQm9keSIsIkVycm9yIiwidXJsIiwic3RhdHVzIiwic3RhdHVzVGV4dCIsImlzbzg2MDFEYXRlVGltZVpvbmUiLCJkIiwib2Zmc2V0IiwiZ2V0VGltZXpvbmVPZmZzZXQiLCJzaWduIiwiZ2V0RnVsbFllYXIiLCJwYWQiLCJnZXRNb250aCIsImdldERhdGUiLCJnZXRIb3VycyIsImdldE1pbnV0ZXMiLCJnZXRTZWNvbmRzIiwibiIsImFicyIsIk1hdGgiLCJmbG9vciIsInJlbW90ZUxvZ2dpbmciLCJ1bmRlZmluZWQiLCJzZWxmIiwiY2hyb21lIiwic3RvcmFnZSIsImxvY2FsIiwiZ2V0IiwicmVtb3RlTG9nZ2luZ1VSTCIsInN0YXJ0c1dpdGgiLCJsb2ciLCJKU09OIiwic3RyaW5naWZ5IiwicmVtb3RlTG9nIiwicmVxdWVzdCIsInRhYnMiLCJxdWVyeSIsImFjdGl2ZSIsImN1cnJlbnRXaW5kb3ciLCJsZW5ndGgiLCJib2R5IiwiaWQiLCJmZXRjaCIsImNhdGNoIiwiZSIsImlzUmVtb3RlTG9nZ2luZyIsImFyZ3MiLCJvZmZzY3JlZW5Db250ZXh0Iiwic2VuZFRvU2VydmljZVdvcmtlciIsImFwcGx5IiwiRGF0ZSIsIm1ldGhvZCIsIndhcm4iLCJydW50aW1lIiwiZ2V0TWFuaWZlc3QiLCJ0eXBlIiwiZGF0YSIsInNlbmRNZXNzYWdlIiwidGFyZ2V0IiwiUkFORE9NX1NUUklOR19DSEFSU0VUIiwiY3J5cHRvUmFuZG9tU3RyaW5nIiwicmVzdWx0IiwidiIsImNyeXB0byIsImdldFJhbmRvbVZhbHVlcyIsIlVpbnQzMkFycmF5IiwiZ2V0TG9jYWxTdG9yYWdlRGF0YSIsInNldExvY2FsU3RvcmFnZURhdGEiLCJDTElFTlRfSURfTEVOR1RIIiwiZ2V0Q2xpZW50SWQiLCJjbGllbnRJZCIsIlByb21pc2UiLCJyZXNvbHZlIiwiY3JlYXRlU2Vzc2lvbiIsImJhc2VVcmwiLCJyZXEiLCJpbml0IiwicHJlcGFyZVJlcXVlc3RJbml0IiwiY2xpZW50VG9rZW4iLCJyZXNwb25zZSIsInNlc3Npb25QYXRoIiwiY3JlYXRlT2ZmZXIiLCJpY2VPZmZlciIsInNlc3Npb25JZCIsIm5vdGlmeUNsaWVudENhbmRpZGF0ZXMiLCJpY2VDYW5kaWRhdGVzIiwiZ2V0QW5zd2VyIiwiZ2V0U2VydmVyQ2FuZGlkYXRlcyIsImRhdGUiLCJzaW5jZSIsImRlbGV0ZVNlc3Npb24iLCJoZWFkZXJzIiwiSGVhZGVycyIsImFwcGVuZCIsIkRFRkFVTFRfQ0hVTktfU0laRSIsIk1JTl9DSFVOS19TSVpFIiwiY2h1bmtCbG9iIiwiYmxvYiIsImNodW5rU2l6ZSIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiZW5kIiwibWluIiwic2l6ZSIsInNsaWNlIiwiYmxvYlRvQXJyYXlCdWZmZXIiLCJyZWplY3QiLCJyZWFkZXIiLCJGaWxlUmVhZGVyIiwib25sb2FkZW5kIiwib25lcnJvciIsInJlYWRBc0FycmF5QnVmZmVyIiwiYmxvYlRvU3RyaW5nIiwicmVhZEFzQmluYXJ5U3RyaW5nIiwiTWVzc2FnZSIsIkRhdGFDaGFubmVsIiwiY29uc3RydWN0b3IiLCJzZXJ2ZXJJZCIsImRhdGFDaGFubmVsIiwiZ2V0Q2h1bmtTaXplIiwibGFiZWwiLCJzZW5kQmxvYiIsImIiLCJ0aHJlc2hvbGRMb3ciLCJ0aHJlc2hvbGRIaWdoIiwibWF4IiwiY2h1bmtlZCIsIm51bUNodW5rcyIsImNlaWwiLCJsb2dFdmVyeU5DaHVua3MiLCJidWZmZXJlZEFtb3VudExvd1RocmVzaG9sZCIsImRlZmVycmVkIiwicmVzb2x2ZWQiLCJwcm9taXNlIiwiY2h1bmtJZHgiLCJmaWxsSW5Qcm9ncmVzcyIsImZpbGxUb0NhcGFjaXR5IiwiYnVmZmVyZWRBbW91bnQiLCJ2YWx1ZSIsImRvbmUiLCJuZXh0IiwiYnVmIiwic2VuZCIsIm9uYnVmZmVyZWRhbW91bnRsb3ciLCJzdGFydCIsIm5vdyIsInNlbmRTdHJpbmciLCJzIiwiaXNDbG9zZWQiLCJyZWFkeVN0YXRlIiwiY2xvc2UiLCJvbk9wZW4iLCJmIiwib25vcGVuIiwiZXYiLCJvbk1lc3NhZ2UiLCJvbm1lc3NhZ2UiLCJtc2ciLCJjbGVhck9uTWVzc2FnZSIsIm9uQ2xvc2UiLCJvbmNsb3NlIiwib25FcnJvciIsImRlY29kZVNlc3Npb25EZXNjcmlwdGlvbiIsIm9mZmVyIiwicGFyc2UiLCJhdG9iIiwiZW5jb2RlU2Vzc2lvbkRlc2NyaXB0aW9uIiwic2QiLCJidG9hIiwiTUFYX0NIVU5LX1NJWkUiLCJQZWVyIiwiaWNlQ29uZmlnIiwiZGF0YUNoYW5uZWxzIiwiTWFwIiwiY29ubmVjdGlvblN0YXRlQ2hhbmdlQ2FsbGJhY2tzIiwiY29ubmVjdGlvbiIsIlJUQ1BlZXJDb25uZWN0aW9uIiwiY3JlYXRlUlRDQ29uZmlnIiwib25jb25uZWN0aW9uc3RhdGVjaGFuZ2UiLCJnZXRTZXJ2ZXJJZCIsImNyZWF0ZURhdGFDaGFubmVsIiwiZGMiLCJjaGFubmVsIiwiYmluZCIsInNldCIsInNjdHAiLCJtYXhNZXNzYWdlU2l6ZSIsIm9uRGF0YUNoYW5uZWwiLCJvbmRhdGFjaGFubmVsIiwib25OZWdvdGlhdGlvbk5lZWRlZCIsIm9ubmVnb3RpYXRpb25uZWVkZWQiLCJvbklDRUNhbmRpZGF0ZSIsIm9uaWNlY2FuZGlkYXRlIiwiaXNQZWVyQ29ubmVjdGVkIiwiaWNlQ29ubmVjdGlvblN0YXRlIiwiY29ubmVjdGlvblN0YXRlIiwiY3JlYXRlQW5zd2VyIiwib2ZmZXJTZXNzaW9uRGVzY3JpcHRpb24iLCJzZXRSZW1vdGVEZXNjcmlwdGlvbiIsImFuc3dlciIsInNldExvY2FsRGVzY3JpcHRpb24iLCJvbkNvbm5lY3Rpb25TdGF0ZUNoYW5nZSIsInB1c2giLCJvbklDRUNvbm5lY3Rpb25TdGF0ZUNoYW5nZSIsIm9uaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlIiwiZ2V0Q29ubmVjdGlvblN0YXRlIiwiZ2V0SUNFQ29ubmVjdGlvblN0YXRlIiwibG9jYWxEZXNjcmlwdGlvbiIsInJlZ2lzdGVyQW5zd2VyIiwiYW5zd2VyU2Vzc2lvbkRlc2NyaXB0aW9uIiwiYWRkSWNlQ2FuZGlkYXRlIiwiY2FuZGlkYXRlIiwiZ2V0RGF0YUNoYW5uZWwiLCJnZXRTZWxlY3RlZENhbmRpZGF0ZVBhaXIiLCJpY2VUcmFuc3BvcnQiLCJnZXRJQ0VUcmFuc3BvcnQiLCJ0cmFuc3BvcnQiLCJ3YWl0Rm9yTGl2ZUNvbm5lY3Rpb24iLCJ3YWl0Rm9yIiwicmVzIiwicmVqIiwidGltZW91dCIsInNldFRpbWVvdXQiLCJjdHgiLCJfIiwiY2xlYXJUaW1lb3V0IiwiaWNlU2VydmVycyIsInNlcnZlcnMiLCJpY2VUcmFuc3BvcnRQb2xpY3kiLCJDQVBBQklMSVRJRVNfQ0hBTk5FTF9MQUJFTCIsIkpPQl9DSEFOTkVMX0xBQkVMIiwiSk9CX0RFVEFJTFNfTEFCRUwiLCJQUklOVEVSX0NIQU5ORUxfTEFCRUwiLCJTRVJWRVJfSU5GT19MQUJFTCIsIlRPS0VOX0NIQU5ORUxfTEFCRUwiLCJNb2JSVENDbGllbnQiLCJwZWVyIiwidmVyc2lvbiIsInNob3J0VGltZW91dCIsImdldElEIiwiZ2V0U2VydmVySW5mbyIsImdldFNlcnZlckluZm9DaGFubmVsIiwicmVhZEpzb25SZXNwb25zZUZyb21DaGFubmVsIiwic2VuZFByaW50Sm9iRGV0YWlscyIsInByaW50VG9rZW4iLCJwcmludGVyVXJsIiwicGFyYW1zIiwiZmlsZVNpemUiLCJjbGllbnRWZXJzaW9uIiwiZ2V0Sm9iRGV0YWlsc0NoYW5uZWwiLCJyZWFkQ2h1bmtlZFJlc3BvbnNlIiwiYnl0ZUFycmF5VG9TdHJpbmciLCJpc0Vycm9yIiwic2VuZFByaW50Sm9iIiwiZmlsZSIsImdldEpvYkNoYW5uZWwiLCJpc1JlYWR5IiwiZ2V0UHJpbnRUb2tlbiIsInNoYXJlVG9rZW4iLCJnZXRUb2tlbkNoYW5uZWwiLCJjaHVua1RpbWVvdXQiLCJzdGFydFRpbWUiLCJwZXJmb3JtYW5jZSIsIm9uVGltZW91dCIsInN0cmluZ0RhdGEiLCJVaW50OEFycmF5IiwicmVkdWNlIiwicHJldiIsImNvbmNhdEJ5dGVBcnJheXMiLCJ0b0ZpeGVkIiwiY2h1bmsiLCJieXRlTGVuZ3RoIiwiZ2V0UHJpbnRlcnMiLCJnZXRQcmludGVyQ2hhbm5lbCIsInByaW50ZXJzIiwiZm9yRWFjaCIsInAiLCJlbmNvZGVVUklDb21wb25lbnQiLCJuYW1lIiwiZGVzY3JpcHRpb24iLCJnZXRDYXBhYmlsaXRpZXMiLCJwcmludGVySWQiLCJnZXRDYXBhYmlsaXRpZXNDaGFubmVsIiwidGFnIiwidXRmOGRlY29kZSIsIlRleHREZWNvZGVyIiwiZGVjb2RlIiwiaGVhZCIsInRhaWwiLCJjb25jYXRSZXN1bHQiLCJDTElFTlRfQVBJX0JBU0VfVVJMX1BST0QiLCJDTElFTlRfQVBJX0JBU0VfVVJMX1RFU1QiLCJNb2JSVENDbGllbnRCdWlsZGVyIiwic2V0Q2xpZW50SWQiLCJzZXRTaGFyZVRva2VuIiwic2V0UHJpbnRUb2tlbiIsInNldEJhc2VVcmwiLCJidWlsZCIsInJlY2VpdmVkQW5zd2VyIiwiY2xpZW50Q2FuZGlkYXRlcyIsInNlc3Npb25EZWxldGVkIiwic2Vzc2lvblBhcmFtcyIsInBlZXJDb25uZWN0aW9uTGl2ZSIsInNldERhdGFDaGFubmVsSGFuZGxlcnMiLCJwb2xsR2V0QW5zd2VyIiwiaW50ZXJ2YWwiLCJpY2VBbnN3ZXIiLCJwb2xsRm9yQ2FuZGlkYXRlcyIsInNlbCIsInJlbW90ZSIsInJhY2UiLCJtYXhDaHVua1NpemUiLCJ0aW1lb3V0TXMiLCJ0aW1lIiwic2hvdWxkQnJlYWsiLCJ1cGRhdGVkIiwiYyIsImRlbGF5Iiwic2V0RGF0YUNoYW5uZWxIYW5kbGVyIiwibWVzc2FnZSIsImVycm9yRGV0YWlsIiwiYWxsIiwibXMiLCJwb2xsT3B0aW9ucyIsImRlZmF1bHRDb2xvck9wdGlvbnMiLCJpc19kZWZhdWx0IiwiZGVmYXVsdER1cGxleE9wdGlvbnMiLCJkZWZhdWx0UGFwZXJTaXplIiwiZGVmYXVsdE1lZGlhU2l6ZXMiLCJ3aWR0aF9taWNyb25zIiwiaGVpZ2h0X21pY3JvbnMiLCJjdXN0b21fZGlzcGxheV9uYW1lIiwidG9VcHBlckNhc2UiLCJjcmVhdGVQcmludGVyQ2FwYWJpbGl0aWVzIiwiY29sb3JPcHRpb25zIiwiZHVwbGV4T3B0aW9ucyIsIm1lZGlhU2l6ZXMiLCJwcmludGVyIiwic3VwcG9ydGVkX2NvbnRlbnRfdHlwZSIsImNvbnRlbnRfdHlwZSIsImNvbG9yIiwib3B0aW9uIiwiZHVwbGV4IiwicGFnZV9vcmllbnRhdGlvbiIsImNvcGllcyIsImRlZmF1bHQiLCJtZWRpYV9zaXplIiwicGFyc2VNb2JpbGl0eVByaW50Q2FwYWJpbGl0aWVzIiwiY2FwYWJpbGl0aWVzIiwibWFwIiwibSIsIndpZHRoTWljcm9ucyIsImhlaWdodE1pY3JvbnMiLCJpc0RlZmF1bHQiLCJjdXN0b21EaXNwbGF5TmFtZSIsImV2ZXJ5IiwiZ2V0TWFuYWdlZFN0b3JhZ2VEYXRhIiwia2V5IiwibWFuYWdlZCIsImxhc3RFcnJvciIsInJlbW92ZUxvY2FsU3RvcmFnZURhdGEiLCJrZXlzIiwicmVtb3ZlIiwic2F2ZU1hcCIsIkFycmF5IiwiZnJvbSIsImVudHJpZXMiLCJsb2FkTWFwIiwiayIsInNsZWVwIiwibWlsbGlzIiwiciIsIndhaXRGb3JDb25kaXRpb24iLCJjb25kVGVzdEZ1bmMiLCJzbGVlcE1pbGxpcyIsInNsZWVwTWF4TWlsbGlzIiwic3RhcnRlZCIsIndvcmtlcldhaXRVbnRpbCIsImtlZXBBbGl2ZSIsInNldEludGVydmFsIiwiZ2V0UGxhdGZvcm1JbmZvIiwiY2xlYXJJbnRlcnZhbCIsInByaW50ZXJDYXBhYmlsaXRpZXNDYWNoZSIsInNlcnZlcklkVG9DbGllbnRDYWNoZSIsInN0b3JhZ2VLZXlTZXJ2ZXJJZFRvSW5mb0NhY2hlIiwic2VydmVySWRUb0luZm9DYWNoZSIsInN0b3JhZ2VLZXlQcmludGVyVGltZVVzZWRNYXAiLCJzdG9yYWdlS2V5UHJpbnRlckNhcGFiaWxpdGllc01hcCIsInN0b3JhZ2VLZXlQcmludGVyU2VydmVyTWFwIiwic3RvcmFnZUtleVByaW50VG9rZW5DYWNoZSIsInByaW50ZXJUaW1lVXNlZE1hcCIsInByaW50ZXJOYW1lVG9TZXJ2ZXJJZENhY2hlIiwicHJpbnRUb2tlbkNhY2hlIiwic3RvcmFnZUtleVJlY2xhaW1TdG9yYWdlTGltaXRLYiIsInN0b3JhZ2VLZXlQcmludGVkT2xkZXJUaGFuRGF5cyIsInJlY2xhaW1TdG9yYWdlTGltaXRLYiIsInByaW50ZWRPbGRlclRoYW5EYXlzIiwiY2FjaGVMb2FkZWQiLCJpbml0Q2FjaGUiLCJzdG9yYWdlTGltaXQiLCJwcmludGVkQWdlIiwicG9wdWxhdGVDYWNoZSIsImdldFNlcnZlcklkVG9DbGllbnRDYWNoZSIsImdldFNlcnZlcklkVG9TZXJ2ZXJJbmZvQ2FjaGUiLCJnZXRQcmludGVyTmFtZVRvU2VydmVySWRDYWNoZSIsImdldFByaW50VG9rZW5DYWNoZSIsInVwZGF0ZVByaW50VG9rZW4iLCJwcmludFRva2VuQ2FjaGVJRCIsInNhdmVNYXBUb1N0b3JhZ2UiLCJ1cGRhdGVTZXJ2ZXJJbmZvIiwic2VydmVySW5mbyIsImlkVG9TZXJ2ZXJJbmZvQ2FjaGUiLCJsb2FkTWFwRnJvbVN0b3JhZ2UiLCJnZXRCeXRlc0luVXNlIiwiYnl0ZXNJblVzZSIsImNsZWFudXBTdG9yYWdlIiwidG9NYXAiLCJjb3B5VG9NYXAiLCJyZWFzb24iLCJ0b0xvd2VyQ2FzZSIsImluY2x1ZGVzIiwic3JjIiwiZHN0IiwiY2xlYXIiLCJkYXlzQWdvIiwidGltZXN0YW1wTWlsbGlzIiwibWlsbGlzUGVyRGF5IiwidXNlZEJ5dGVzIiwicHJpbnRlck5hbWUiLCJwcmludGVyTmFtZUZyb21VcmwiLCJ1bnVzZWRQcmludGVyIiwiZ2V0U2VydmVySWRGb3JQcmludGVyIiwicHJpbnRlZERheXMiLCJkaXNjYXJkIiwiZGVsZXRlIiwidXBkYXRlUHJpbnRlckNhY2hlIiwiZ2V0UHJpbnRlckNhcGFiaWxpdGllcyIsImNhcCIsInVwZGF0ZUxhc3RQcmludGVkVGltZSIsInJlYWR5IiwiY2FjaGVkUHJpbnRlck5hbWUiLCJ1cmxQYXRoIiwiVVJMIiwicGF0aG5hbWUiLCJsYXN0U2xhc2giLCJsYXN0SW5kZXhPZiIsImRlY29kZVVSSUNvbXBvbmVudCIsInN1YnN0cmluZyIsIkNsb3VkUHJpbnRMaW5rIiwiTElOS1NfU1RPUkFHRV9LRVkiLCJDTE9VRF9QUklOVF9FUlIiLCJpbml0Q2xvdWRQcmludCIsImlzQ2xvdWRQcmludEVycm9yIiwic2F2ZUJZT0RMaW5rIiwibGluayIsImxpbmtzIiwiZ2V0QWxsTGlua3MiLCJieW9kTGlua3MiLCJnZXRCWU9ETGlua3MiLCJDbG91ZFByaW50SW52aXRlTGlua3MiLCJnZXRNYW5hZ2VkTGlua3MiLCJzdG9yZWRMaW5rcyIsImNvbmNhdCIsImdldE9mZk5ldHdvcmtMaW5rcyIsImFsbExpbmtzIiwiZmlsdGVyIiwibCIsIm9yZ0lkIiwiZXhwaXJlcyIsImV4cGlyeSIsInRvSVNPU3RyaW5nIiwiZ2V0UHJpbnRUb2tlbkNhY2hlSUQiLCJnZXRTaGFyZVRva2VuIiwiZ2V0TGluayIsImZpbmQiLCJPRkZTQ1JFRU5fRE9DVU1FTlRfUEFUSCIsIm9mZlNjcmVlbkRvY3VtZW50Q2hlY2siLCJnZXRPZmZTY3JlZW5Eb2N1bWVudCIsImhhc0RvY3VtZW50Iiwib2Zmc2NyZWVuIiwiY3JlYXRlRG9jdW1lbnQiLCJyZWFzb25zIiwiUmVhc29uIiwiV0VCX1JUQyIsImp1c3RpZmljYXRpb24iLCJtZXNzYWdlT2ZmU2NyZWVuIiwiY2xpZW50VXJsIiwiZ2V0VVJMIiwibWVzc2FnZUNsaWVudCIsImNsaWVudHMiLCJtYXRjaEFsbCIsImluY2x1ZGVVbmNvbnRyb2xsZWQiLCJtZXNzYWdlQ2hhbm5lbCIsIk1lc3NhZ2VDaGFubmVsIiwicG9zdE1lc3NhZ2UiLCJwb3J0MiIsIm9mZnNjcmVlblJlc3BvbnNlIiwiY2IiLCJwb3J0MSIsIk1zZ1R5cGUiLCJjbGllbnRXaW5kb3dzIiwiY2xpZW50V2luZG93IiwiZW5kc1dpdGgiLCJvblN1c3BlbmQiLCJhZGRMaXN0ZW5lciIsImNsb3NlRG9jdW1lbnQiLCJoYW5kbGVNZXNzYWdlcyIsIlNlcnZlcklEIiwiU2VydmVySW5mbyIsIlNoYXJlVG9rZW4iLCJQcmludFRva2VuIiwiUHJpbnRlckxpc3QiLCJnZXRQcmludGVyc0Zyb21BbGxTZXJ2ZXJzIiwic2VydmVySWRzIiwiU2V0IiwiaGFzIiwicHJpbnRlclJlc3VsdHMiLCJnZXRQcmludGVyc0Zyb21TZXJ2ZXIiLCJmbGF0IiwiSW5maW5pdHkiLCJnZXRTZXJ2ZXJJbmZvUlRDIiwiQ2xpZW50SUQiLCJUZXN0RW52IiwidGVzdEVudiIsIlJlc3BTdGF0ZSIsIlJlc3BEYXRhIiwicHJpbnRlclJlc3VsdCIsImdldFByaW50ZXJJbmZvUlRDIiwiUHJpbnRlcklEIiwic3VibWl0UHJpbnRKb2JSVEMiLCJjcmVkZW50aWFscyIsIkZpbGVEYXRhIiwiUHJpbnRlclVSTCIsIlBhcmFtcyIsImpvYkRldGFpbHMiLCJnZXRVcmxCYXNlT2ZQcmludGVyVXJsIiwicmVwbGFjZSIsImdldFByaW50ZXJOYW1lIiwiSlNFbmNyeXB0IiwicGFyc2VCaWdJbnQiLCJSU0FFbmNyeXB0IiwibW9kdWx1cyIsImV4cG9uZW50IiwiZW5jcnlwdG9yIiwiZ2V0S2V5IiwicGFyc2VJbnQiLCJwYXJzZVByb3BlcnRpZXNGcm9tIiwiUlNBS2V5Iiwic2V0UHVibGljIiwiZW5jcnlwdCIsIkdvb2dsZVVzZXJJbmZvVVJMIiwiR1N1aXRlVG9rZW5SZXZva2VVcmwiLCJhdXRoZW50aWNhdGVXaXRoR1N1aXRlSFRUUCIsInNlcnZlckJhc2VVUkwiLCJpc0ludGVyYWN0aXZlIiwiZ2V0UnNhUHVibGljS2V5IiwiZ2V0R29vZ2xlQXV0aEluZm8iLCJyc2FLZXkiLCJhdXRoSW5mbyIsImVuY3J5cHRDcmVkZW50aWFsc1dpdGhLZXkiLCJlbWFpbCIsInRva2VuIiwiYXV0aGVudGljYXRlV2l0aEdTdWl0ZSIsInByaW50Sm9iIiwiZW5jcnlwdEZvck1vYmlsaXR5IiwiZ29vZ2xlQXV0aCIsInByb3ZpZGVyIiwidXNlcmlkIiwicmV0cnlXaXRoUmVmcmVzaGVkVG9rZW4iLCJvbGRUb2tlbiIsImRldGFpbHMiLCJpbnRlcmFjdGl2ZSIsInJlZnJlc2hUb2tlbiIsIm5ld1Rva2VuIiwiZ2V0R1N1aXRlVXNlckluZm8iLCJnZXRHU3VpdGVUb2tlbiIsImlkZW50aXR5IiwiZ2V0QXV0aFRva2VuIiwiZXhwaXJlZFRva2VuIiwiYWNjb3VudCIsInJlbW92ZUNhY2hlZEF1dGhUb2tlbiIsImFjY2Vzc1Rva2VuIiwidGV4dCIsImVyciIsInVybEJhc2UiLCJjbGllbnRWZXJzaW9uSUQiLCJwYXJzZVJzYUtleSIsImtleUxlbmd0aCIsImlzR1N1aXRlRW5hYmxlZEhUVFAiLCJzaWduSW5XaXRoR29vZ2xlIiwiaXNHU3VpdGVFbmFibGVkUlRDIiwiaW5mbyIsImlzR1N1aXRlRW5hYmxlZCIsImNsb3VkUHJpbnRKb2IiLCJyZXZva2VDYWNoZWRHU3VpdGVBdXRoVG9rZW4iLCJtc0J1ZmZlclRpbWUiLCJpbm5lclJlc29sdmUiLCJpbm5lclRva2VuIiwidG9rZW5QYXJhbSIsInVzZXJuYW1lIiwicGFzc3dvcmQiLCJwbGFpbkNyZWRlbnRpYWxzIiwiZW5jcnlwdGVkIiwiZW5jcnlwdENyZWRlbnRpYWxzIiwibXBTZXJ2ZXJCYXNlVXJsIiwiaW5NZW1vcnlDcmVkcyIsInJlbWVtYmVyTWUiLCJyZW1lbWJlckNyZWRzSW5NZW1vcnkiLCJjbGVhckluTWVtb3J5Q3JlZHMiLCJpbk1lbW9yeUNyZWRzQXZhaWxhYmxlIiwic2VuZFBhZ2VNZXNzYWdlIiwib3B0cyIsInRhYk1lc3NhZ2UiLCJ0YWJJZCIsInNlbmRQYWdlTWVzc2FnZVdpdGhSZXRyeSIsIml0ZXIiLCJlbGFwc2VkIiwiYXR0ZW1wdCIsIkdvb2dsZU9wZW5JRE9BdXRoUHJvdmlkZXIiLCJnZXRBY2Nlc3NUb2tlbiIsImdldFVzZXJJbmZvIiwib2F1dGhUb2tlbiIsInVzZXJJbmZvIiwiT0F1dGhQcm92aWRlcklEcyIsIkdvb2dsZSIsInRvUHJpbnREZXBsb3lUb2tlbkluZm8iLCJzZXNzaW9uIiwiYXV0aE1ldGhvZCIsInByb3ZpZGVySUQiLCJzZXNzaW9uVG9rZW4iLCJwcmludERlcGxveU9hdXRoUHJvdmlkZXJzIiwibWF4V2luZG93RGltZW5zaW9ucyIsIndpZHRoIiwiaGVpZ2h0IiwibWluV2luZG93RGltZW5zaW9ucyIsImRlZmF1bHRGcmFtZVNpemUiLCJmcmFtZVNpemUiLCJkaXNwbGF5Qm91bmRzIiwic2hvd1BvcHVwIiwicGFnZSIsImNhbGN1bGF0ZUZyYW1lU2l6ZSIsInRhYiIsImNyZWF0ZVRhYiIsIndpbmRvd0lkIiwiY3JlYXRlUG9wdXBXaW5kb3ciLCJzYXZlRnJhbWVTaXplIiwiZ2V0RnJhbWVTaXplIiwiT2JqZWN0IiwiZnJlZXplIiwiY3JlYXRlIiwidGltZW91dElkIiwiZnJhbWVTaXplQ2FsbGJhY2siLCJmcmFtZSIsIl9zIiwicmVzcG9uc2VDYWxsYmFjayIsIl9mcyR3aWR0aCIsIl9mcyRoZWlnaHQiLCJyZW1vdmVMaXN0ZW5lciIsImZzIiwiY3JlYXRlV2luZG93IiwiZm9jdXNlZCIsImdldERpc3BsYXlCb3VuZHMiLCJkaXNwbGF5V2lkdGgiLCJkaXNwbGF5SGVpZ2h0IiwibWF4V2luZG93V2lkdGgiLCJtYXhXaW5kb3dIZWlnaHQiLCJhdmFpbFdpZHRoIiwiYXZhaWxIZWlnaHQiLCJmcmFtZVdpZHRoIiwiZnJhbWVIZWlnaHQiLCJsZWZ0Iiwicm91bmQiLCJ0b3AiLCJub3JtYWxpemVXaW5kb3dCb3VuZHMiLCJ3aW5kb3dzIiwidyIsIndCb3VuZHMiLCJtYXhXaWR0aCIsIm51bVJhbmdlIiwibWF4SGVpZ2h0IiwiaXNQcmltYXJ5Iiwic3lzdGVtIiwiZGlzcGxheSIsImdldEluZm8iLCJkaXNwbGF5cyIsImRpc3AiLCJib3VuZHMiLCJ3b3JrQXJlYSIsImRpc3BsYXlMb2dpbldpbmRvdyIsInNob3dSZW1lbWJlck1lIiwic2hvd1VzZXJuYW1lTG9naW4iLCJzaG93R29vZ2xlTG9naW4iLCJ1c2VDbG91ZFByaW50IiwidXNlUHJpbnREZXBsb3kiLCJjbG9zZUxvZ2luRGlhbG9nIiwiY2xvc2VMb2dpbldpbmRvd01lc3NhZ2UiLCJzZW5kRGlzcGxheUVycm9yTWVzc2FnZSIsImVyck1zZyIsImRpc3BsYXlFcnJvck1lc3NhZ2UiLCJQcmludERlcGxveUF1dGhNZXRob2RzIiwiVXNlcm5hbWUiLCJSU0FfU1RSSU5HX01BWExFTiIsIkNsaWVudEVuY3J5cHRpb25TZXJ2aWNlIiwidXNlQXV0aEhlYWRlckVuY3J5cHRpb24iLCJlbmNyeXB0UmVxdWVzdEJvZHkiLCJqc29uQm9keVN0ciIsImVuY3J5cHRMb25nU3RyaW5nIiwiZW5jcnlwdEF1dGhIZWFkZXJWYWx1ZSIsImhlYWRlclZhbHVlIiwiZW5jcnlwdGVkSGVhZGVyIiwic3RyIiwicGF0dGVybiIsIm1hdGNoIiwiUmVnRXhwIiwiYWNjIiwiZW5jcnlwdGVkQ2h1bmsiLCJERUZBVUxUX1BSSU5UX0RFUExPWV9IVFRQU19QT1JUIiwiREVGQVVMVF9QUklOVF9ERVBMT1lfSFRUUF9QT1JUIiwiUHJpbnREZXBsb3lDbGllbnRCdWlsZGVyIiwiaG9zdCIsInVzZUhUVFBTRW5jcnlwdGlvbiIsIndpdGhBY2Nlc3NpYmxlVExTUG9ydCIsInBvcnQiLCJhY2Nlc3NpYmxlVExTUG9ydCIsIndpdGhTdHJpY3RTU0wiLCJzdHJpY3RTU0wiLCJ3aXRoT0F1dGhQcm92aWRlcnMiLCJvYXV0aFByb3ZpZGVycyIsImhhc0N1c3RvbUFjY2Vzc2libGVUTFNQb3J0IiwiY2xpZW50IiwiUERDbGllbnQiLCJodHRwc1NlcnZlckJhc2VVUkwiLCJodHRwQmFzZVVybCIsInVzZUVuY3J5cHRlZEhUVFAiLCJlbmNyeXB0aW9uU2VydmljZSIsImlzQXV0aEhlYWRlckVuY3J5cHRpb25TdXBwb3J0ZWQiLCJQcmludERlcGxveVBhdGhzIiwiR0VUX0NPTkZJRyIsIlByaW50RGVwbG95VW5hdXRob3JpemVkRXJyb3IiLCJwcm92aWRlcnMiLCJsb2dpbiIsImdlbmVyYXRlSGVhZGVycyIsIkxPR0lOIiwiVG9rZW4iLCJnZXRDb25maWciLCJ0b2tlbkluZm8iLCJjbGllbnRJbmZvIiwiZmV0Y2hQcmludGVycyIsIkdFVF9QUklOVEVSUyIsImhhbmRsZUludmFsaWRUb2tlbiIsImNyZWF0ZU9BdXRoU2Vzc2lvbiIsIm9BdXRoUHJvdmlkZXIiLCJvQXV0aFRva2VuIiwiQ1JFQVRFX09BVVRIX1NFU1NJT04iLCJyZXFCb2R5IiwicHJvdmlkZXJJZCIsInNlc3Npb25JbmZvIiwiZ2V0U2VydmVyQmFzZVVSTCIsIkFjY2VwdCIsImhlYWRlciIsImdldENocm9tZU9TVmVyc2lvbiIsInZlcnNpb25TdHJpbmciLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJpc0FycmF5IiwiZ2V0Q2hyb21lT1NWZXJzaW9uTWFqb3IiLCJjaHJvbWVPU1ZlcnNpb24iLCJtVmVyIiwiaW5kZXhPZiIsInBsYXRmb3JtSW5mbyIsImdldEluc3RhbmNlSWQiLCJpbnN0YW5jZUlEIiwiZ2V0QXNzZXRJZCIsImVudGVycHJpc2UiLCJkZXZpY2VBdHRyaWJ1dGVzIiwiZ2V0RGV2aWNlQXNzZXRJZCIsImFzc2V0SWQiLCJpc0lQdjQiLCJzZXJ2aWNlVHlwZSIsIm1pbkNocm9tZVZlcnNpb24iLCJyZXF1aXJlZENocm9tZU1lc3NhZ2UiLCJpc1N1cHBvcnRlZENocm9tZVZlcnNpb24iLCJnZXRMb2NhbElQQWRkcmVzc2VzIiwibmV0d29yayIsImdldE5ldHdvcmtJbnRlcmZhY2VzIiwiaW50ZXJmYWNlcyIsImxvY2FsSVBBZGRyZXNzZXMiLCJpIiwiYWRkcmVzcyIsInN0YXJ0TUROU0xpc3RlbmVyIiwib25TZXJ2aWNlTGlzdCIsIm1kbnMiLCJmb3JjZURpc2NvdmVyeSIsImdldENsaWVudEluZm8iLCJpcEFkZHJlc3NlcyIsImFzc2V0SUQiLCJjaHJvbWVBcHBFeHRWZXJzaW9uIiwibWFjaGluZSIsImhvc3RuYW1lIiwib3MiLCJhcmNoIiwiYWN0aXZlRGlyZWN0b3J5RG9tYWluTmFtZSIsIk9BVVRIX1NFU1NJT05fVE9LRU5fS0VZIiwiUFJJTlRfREVQTE9ZX0FVVEhfUkVQTyIsIlBSSU5UX0RFUExPWV9DT05GSUdfS0VZIiwiUEFQRVJDVVRfQVVUSF9LRVkiLCJQcmludERlcGxveUxvY2FsU3RvcmFnZSIsImdldENhY2hlZENvbmZpZyIsImdldENhY2hlZE9BdXRoU2Vzc2lvblRva2VuIiwiZ2V0Q2FjaGVkQXV0aFRva2VuIiwiZ2V0Q2FjaGVkUHJpbnREZXBsb3lUb2tlbiIsImdldENhY2hlZE1vYmlsaXR5UHJpbnRTZXJ2ZXJUb2tlbiIsInNlcnZlckJhc2VVcmwiLCJjYWNoZUNvbmZpZyIsImNvbmZpZyIsImNhY2hlTW9iaWxpdHlQcmludFNlcnZlclRva2VuIiwiY2FjaGVBdXRoVG9rZW4iLCJjYWNoZVBhcGVyQ3V0VG9rZW4iLCJjYWNoZU9BdXRoU2Vzc2lvblRva2VuIiwicmVtb3ZlTW9iaWxpdHlQcmludFNlcnZlclRva2VuIiwic2VydmVyIiwiYXV0aFJlcG8iLCJpbnZhbGlkYXRlQWxsQ2FjaGVkVG9rZW5zIiwicHJpbnREZXBsb3lTdG9yYWdlIiwiTWFuYWdlZFN0b3JhZ2VLZXlzIiwiZ2V0UHJpbnRlcnNGcm9tUHJpbnREZXBsb3kiLCJwZEhvc3QiLCJnZXRQcmVjb25maWd1cmVkUHJpbnREZXBsb3lTZXJ2ZXIiLCJnZXRQcmludGVyc0Zyb21QcmludERlcGxveUhvc3QiLCJQcmludERlcGxveVNlcnZlckhvc3RzIiwiaG9zdHMiLCJnZXRQcmludERlcGxveUNsaWVudCIsInN0cmljdFNTTENoZWNraW5nRW5hYmxlZCIsIlN0cmljdFNTTENoZWNraW5nRW5hYmxlZCIsIkFjY2Vzc2libGVQcmludERlcGxveVRMU1BvcnQiLCJwZENsaWVudCIsImNsaWVudENvbmZpZyIsImdldFByaW50ZXJzRm9yQ2xpZW50IiwiZ2V0QW5kU2F2ZVRva2Vuc0ZvclByaW50ZXJzIiwibWFwUHJpbnRlcnNGb3JQcmludFByb3ZpZGVyIiwibXBTZXJ2ZXJzIiwiZ2V0U2VjdXJlVVJMRm9yTVBTZXJ2ZXIiLCJ1bmlxdWVNUFNlcnZlcnMiLCJnZXRNb2JpbGl0eVByaW50VG9rZW5JZk1pc3NpbmciLCJtcFNlcnZlclVSTCIsImZldGNoVG9rZW5Gcm9tTW9iaWxpdHlQcmludFNlcnZlciIsInRsc1BvcnQiLCJBY2Nlc3NpYmxlTW9iaWxpdHlQcmludFRMU1BvcnQiLCJnZXRQcmludERlcGxveVRva2VuIiwidXNlcm5hbWVUb2tlbiIsIm9hdXRoU2Vzc2lvbkNyZWRzIiwiYXNrVXNlclRvQXV0aGVudGljYXRlRm9yUHJpbnREZXBsb3kiLCJhdXRoVXJsIiwicmVxdWVzdFBhcmFtcyIsIkF1dGhvcml6YXRpb24iLCJfcmVqZWN0Iiwib25DcmVkZW50aWFsc0VudGVyZWRGb3JQcmludERlcGxveUhhbmRsZXIiLCJvbk9hdXRoU2Vzc2lvbkNyZWF0ZWRGb3JQcmludERlcGxveUhhbmRsZXIiLCJzaG93TG9naW5XaW5kb3ciLCJzZW5kZXIiLCJjcmVkZW50aWFsc0VudGVyZWQiLCJvbkNyZWRlbnRpYWxzRW50ZXJlZEZvclByaW50RGVwbG95IiwiZXJyb3JNZXNzYWdlIiwicmVzb2x2ZUVycm9yVG9EaXNwbGF5Iiwib2F1dGhTZXNzaW9uQ3JlYXRlZCIsIm9uT0F1dGhTZXNzaW9uQ3JlYXRlZEZvclByaW50RGVwbG95Iiwic2Vzc2lvbkNyZWRlbnRpYWxzIiwicHJpbnREZXBsb3lUb2tlbkluZm8iLCJvbkNyZWRlbnRpYWxzRW50ZXJlZCIsIkF1dGhNZXRob2RzIiwiZGlzcGxheU5hbWUiLCJnZXROb3JtYWxpc2VkTmFtZSIsImF1dGhNb2RlIiwibXBQcmludGVyTmFtZSIsInJlZ2V4IiwidGVzdCIsInRyaW0iLCJnZXRQREF1dGhGb3JNb2JpbGl0eVNlcnZlciIsIm1wU2VydmVyIiwiY2FjaGVkVG9rZW4iLCJoYW5kbGVNaXNzaW5nVG9rZW4iLCJfZSIsImFza1VzZXJUb0F1dGhlbnRpY2F0ZUZvck1QU2VydmVyIiwib2F1dGhTZXNzaW9uIiwiZW5jcnlwdGVkQ3JlZHMiLCJhdXRoT3B0aW9uIiwib25DcmVkZW50aWFsc0VudGVyZWRGb3JNUFNlcnZlckhhbmRsZXIiLCJvbkNyZWRlbnRpYWxzRW50ZXJlZEZvck1QU2VydmVyIiwiZW5jcnlwdGVkQ3JlZGVudGlhbHMiLCJ3cmFwQ3JlZHMiLCJ3aW5kb3dSZXNpemVUb0lubmVyIiwicmVzaXplVG8iLCJvdXRlcldpZHRoIiwiaW5uZXJXaWR0aCIsIm91dGVySGVpZ2h0IiwiaW5uZXJIZWlnaHQiLCIkIiwic2VuZFJlc3BvbnNlIiwiaW5pdExvZ2luV2luZG93IiwiZXhpdExvYWRpbmdTdGF0ZSIsImhpZGVFcnJvcnMiLCJ3aW5kb3ciLCJzaG93TWVzc2FnZUZvckVycm9yIiwiY3JlZGVudGlhbHNSZXNwb25zZUhhbmRsZXIiLCJ1cGRhdGVVaU9uSm9iU3VibWlzc2lvblJlc3BvbnNlIiwibG9naW5XaW5kb3ciLCJsb2dpblVzaW5nUGFwZXJDdXRDcmVkZW50aWFscyIsImVudGVyTG9hZGluZ1N0YXRlIiwiaXNSZW1lbWJlciIsImlzIiwidmFsIiwic2VuZFByaW50Sm9iTWVzc2FnZSIsImxvZ2luVXNpbmdHU3VpdGUiLCJvYXV0aFNlc3Npb25DcmVhdGVkTWVzc2FnZSIsImhhbmRsZVJlc3BvbnNlIiwiZmluYWxseSIsIm9uTG9naW5DbGljayIsInRvU3RyaW5nIiwib25DcmVkZW50aWFsc0VudGVyZWRNZXNzYWdlIiwiaW5pdGlhbGlzZSIsInRvZ2dsZVJlbWVtYmVyIiwibG9naW5Gb3JtIiwidXNlclBhc3NBcmVhIiwidXNlclBhc3NMb2dpbkJ1dHRvbiIsIm9yQXJlYSIsImdvb2dsZUFyZWEiLCJnb29nbGVMb2dpbkJ1dHRvbiIsIm9uIiwidmFsaWQiLCJoaWRlIiwiY3NzIiwidmFsaWRhdGUiLCJlcnJvclBsYWNlbWVudCIsImVsZW1lbnQiLCJjbG9zZXN0IiwiYXR0ciIsImVycm9yRWxlbWVudCIsIm1lc3NhZ2VzIiwicmVxdWlyZWQiLCJsb2dpbldpbmRvd0Nsb3NlZE1lc3NhZ2UiLCJrZXlwcmVzcyIsIndoaWNoIiwiZG9jdW1lbnQiLCJrZXl1cCIsImV2ZW50Iiwia2V5Q29kZSIsImxvZ2luQnV0dG9uIiwicmVtb3ZlQXR0ciIsInJlbW92ZUNsYXNzIiwiZ29vZ2xlTG9naW5CdG4iLCJ0b2dnbGUiLCJhZGRDbGFzcyIsImVhY2giLCJpZHgiLCJlbSIsImlzQXV0aEVycm9yIiwiaXNDb25uZWN0aW9uRXJyb3IiLCJkaXNwbGF5VmVyYmF0aW0iLCJzaG93IiwicmVzcG9uc2VIYW5kbGVyIiwicmVtZW1iZXIiXSwic291cmNlUm9vdCI6IiJ9